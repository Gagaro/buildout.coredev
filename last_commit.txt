Repository: Products.ATContentTypes
Branch: refs/heads/master
Date: 2015-04-24T21:06:17+02:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/Products.ATContentTypes/commit/6733e3ed60cb20a2fa5d4cc85cc7a50b63106bae

remove CMFDefault references

Files changed:
M Products/ATContentTypes/setuphandlers.py
M setup.py

diff --git a/Products/ATContentTypes/setuphandlers.py b/Products/ATContentTypes/setuphandlers.py
index c180638..bfc8fbb 100644
--- a/Products/ATContentTypes/setuphandlers.py
+++ b/Products/ATContentTypes/setuphandlers.py
@@ -1,7 +1,7 @@
 from Acquisition import aq_base
 from Products.ATContentTypes.lib import constraintypes
 from Products.CMFCore.utils import getToolByName
-from Products.CMFDefault.utils import bodyfinder
+from Products.CMFPlone.utils import bodyfinder
 from Products.CMFPlone.utils import _createObjectByType
 from plone.i18n.normalizer.interfaces import IURLNormalizer
 from plone.portlets.interfaces import ILocalPortletAssignmentManager
diff --git a/setup.py b/setup.py
index 173b315..2bdc7a3 100644
--- a/setup.py
+++ b/setup.py
@@ -8,6 +8,8 @@
       long_description=open("README.txt").read() + "\n" + \
                        open("CHANGES.txt").read(),
       classifiers=[
+        "Programming Language :: Python",
+        "Programming Language :: Python :: 2.7",
         "Framework :: Plone",
         "Framework :: Plone :: 5.0",
         ],
@@ -46,7 +48,6 @@
           'Products.Archetypes',
           'Products.CMFCore',
           'Products.CMFDynamicViewFTI',
-          'Products.CMFDefault',
           'Products.CMFFormController',
           'Products.GenericSetup',
           'Products.MimetypesRegistry',


Repository: Products.ATContentTypes
Branch: refs/heads/master
Date: 2015-04-24T21:07:41+02:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/Products.ATContentTypes/commit/7fdde49b58c9c5e93e5c2c84d0428f090b507df8

remove unnecessary Plone version switch

Files changed:
M Products/ATContentTypes/setuphandlers.py

diff --git a/Products/ATContentTypes/setuphandlers.py b/Products/ATContentTypes/setuphandlers.py
index bfc8fbb..11e3a73 100644
--- a/Products/ATContentTypes/setuphandlers.py
+++ b/Products/ATContentTypes/setuphandlers.py
@@ -13,11 +13,7 @@
 from plone.registry.interfaces import IRegistry
 from zope.component import getUtility
 
-try:
-    from Products.CMFPlone.interfaces import ILanguageSchema
-    PLONE_5 = True
-except:
-    PLONE_5 = False
+from Products.CMFPlone.interfaces import ILanguageSchema
 
 
 def assignTitles(portal):
@@ -62,23 +58,14 @@ def setupPortalContent(p):
     pprop = getToolByName(p, "portal_properties")
     sheet = pprop.site_properties
 
-    if PLONE_5:
-        registry = getUtility(IRegistry)
-        language_settings = registry.forInterface(
-            ILanguageSchema,
-            prefix='plone'
-        )
-        language_settings.use_combined_language_codes = use_combined
-        language_settings.default_language = language
-        language_settings.available_languages = [language]
-    else:
-        tool = getToolByName(p, "portal_languages")
-        tool.manage_setLanguageSettings(
-            language,
-            [language],
-            setUseCombinedLanguageCodes=use_combined,
-            startNeutral=False
-        )
+    registry = getUtility(IRegistry)
+    language_settings = registry.forInterface(
+        ILanguageSchema,
+        prefix='plone'
+    )
+    language_settings.use_combined_language_codes = use_combined
+    language_settings.default_language = language
+    language_settings.available_languages = [language]
 
     # Enable visible_ids for non-latin scripts
 


Repository: Products.ATContentTypes
Branch: refs/heads/master
Date: 2015-04-24T21:12:22+02:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/Products.ATContentTypes/commit/dd06d745875c716a505233b477dc71ace7d1c887

added MetadataTool from CMFDefault

Files changed:
A Products/ATContentTypes/tool/MetadataTool.py

diff --git a/Products/ATContentTypes/tool/MetadataTool.py b/Products/ATContentTypes/tool/MetadataTool.py
new file mode 100644
index 0000000..83b5720
--- /dev/null
+++ b/Products/ATContentTypes/tool/MetadataTool.py
@@ -0,0 +1,592 @@
+##############################################################################
+#
+# Copyright (c) 2001 Zope Foundation and Contributors.
+#
+# This software is subject to the provisions of the Zope Public License,
+# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
+# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
+# FOR A PARTICULAR PURPOSE.
+#
+##############################################################################
+""" CMFDefault portal_metadata tool. """
+
+from AccessControl.SecurityInfo import ClassSecurityInfo
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from OFS.Folder import Folder
+from OFS.SimpleItem import SimpleItem
+from Persistence import PersistentMapping
+from zope.interface import implements
+
+from Products.CMFCore.interfaces import IMetadataTool
+from Products.CMFCore.utils import registerToolInterface
+from Products.CMFCore.utils import UniqueObject
+from Products.CMFDefault.exceptions import MetadataError
+from Products.CMFDefault.permissions import ManagePortal
+from Products.CMFDefault.permissions import ModifyPortalContent
+from Products.CMFDefault.permissions import View
+from Products.CMFDefault.utils import _dtmldir
+
+
+class MetadataElementPolicy( SimpleItem ):
+
+    """ Represent a type-specific policy about a particular metadata element.
+    """
+
+    security = ClassSecurityInfo()
+    #
+    #   Default values.
+    #
+    is_required         = 0
+    supply_default      = 0
+    default_value       = ''
+    enforce_vocabulary  = 0
+    allowed_vocabulary  = ()
+
+    def __init__(self, is_multi_valued=False):
+        self.is_multi_valued = bool(is_multi_valued)
+
+    #
+    #   Mutator.
+    #
+    security.declareProtected(ManagePortal , 'edit')
+    def edit( self
+            , is_required
+            , supply_default
+            , default_value
+            , enforce_vocabulary
+            , allowed_vocabulary
+            ):
+        self.is_required        = bool(is_required)
+        self.supply_default     = bool(supply_default)
+        self.default_value      = default_value
+        self.enforce_vocabulary = bool(enforce_vocabulary)
+        self.allowed_vocabulary = tuple(allowed_vocabulary)
+
+    #
+    #   Query interface
+    #
+    security.declareProtected(View , 'isMultiValued')
+    def isMultiValued( self ):
+        """ Can this element hold multiple values?
+        """
+        return self.is_multi_valued
+
+    security.declareProtected(View , 'isRequired')
+    def isRequired( self ):
+        """ Must this element be supplied?
+        """
+        return self.is_required
+
+    security.declareProtected(View , 'supplyDefault')
+    def supplyDefault( self ):
+        """ Should the tool supply a default?
+        """
+        return self.supply_default
+
+    security.declareProtected(View , 'defaultValue')
+    def defaultValue( self ):
+        """ If so, what is the default?
+        """
+        return self.default_value
+
+    security.declareProtected(View , 'enforceVocabulary')
+    def enforceVocabulary( self ):
+        """ Should the tool enforce the policy's vocabulary?
+        """
+        return self.enforce_vocabulary
+
+    security.declareProtected(View , 'allowedVocabulary')
+    def allowedVocabulary( self ):
+        """ What are the allowed values?
+        """
+        return self.allowed_vocabulary
+
+InitializeClass( MetadataElementPolicy )
+
+
+
+class ElementSpec( SimpleItem ):
+
+    """ Represent all the tool knows about a single metadata element.
+    """
+
+    security = ClassSecurityInfo()
+
+    #
+    #   Default values.
+    #
+    is_multi_valued = 0
+
+    def __init__( self, is_multi_valued ):
+        self.is_multi_valued  = is_multi_valued
+        self.policies         = PersistentMapping()
+        self.policies[ None ] = self._makePolicy()  # set default policy
+
+    security.declarePrivate( '_makePolicy' )
+    def _makePolicy( self ):
+        return MetadataElementPolicy( self.is_multi_valued )
+
+    security.declareProtected(View , 'isMultiValued')
+    def isMultiValued( self ):
+        """
+            Is this element multi-valued?
+        """
+        return self.is_multi_valued
+
+    security.declareProtected(View , 'getPolicy')
+    def getPolicy( self, typ=None ):
+        """ Find the policy for this element for objects of the given type.
+
+        o Return a default, if none found.
+        """
+        try:
+            return self.policies[ typ ].__of__(self)
+        except KeyError:
+            return self.policies[ None ].__of__(self)
+
+    security.declareProtected(View , 'listPolicies')
+    def listPolicies( self ):
+        """ Return a list of all policies for this element.
+        """
+        res = []
+        for k, v in self.policies.items():
+            res.append((k, v.__of__(self)))
+        return res
+
+    security.declareProtected(ManagePortal , 'addPolicy')
+    def addPolicy( self, typ ):
+        """ Add a policy to this element for objects of the given type.
+        """
+        if typ is None:
+            raise MetadataError, "Can't replace default policy."
+
+        if self.policies.has_key( typ ):
+            raise MetadataError, "Existing policy for content type:" + typ
+
+        self.policies[ typ ] = self._makePolicy()
+
+    security.declareProtected(ManagePortal, 'removePolicy')
+    def removePolicy( self, typ ):
+        """ Remove the policy from this element for objects of the given type.
+
+        o Do *not* remvoe the default, however.
+        """
+        if typ is None:
+            raise MetadataError, "Can't remove default policy."
+        del self.policies[ typ ]
+
+InitializeClass( ElementSpec )
+
+
+class MetadataSchema( SimpleItem ):
+
+    """ Describe a metadata schema.
+    """
+
+    security = ClassSecurityInfo()
+
+    meta_type = 'Metadata Schema'
+    publisher = ''
+
+    def __init__( self, id, element_specs=() ):
+        self._setId( id )
+        self.element_specs = PersistentMapping()
+        for name, is_multi_valued in element_specs:
+            self.element_specs[ name ] = ElementSpec( is_multi_valued )
+
+
+    #
+    #   ZMI methods
+    #
+    manage_options = ( ( { 'label'      : 'Elements'
+                         , 'action'     : 'elementPoliciesForm'
+                         }
+                       ,
+                       )
+                     + SimpleItem.manage_options
+                     )
+
+    security.declareProtected(ManagePortal, 'elementPoliciesForm')
+    elementPoliciesForm = DTMLFile( 'metadataElementPolicies', _dtmldir )
+
+    security.declareProtected(ManagePortal, 'addElementPolicy')
+    def addElementPolicy( self
+                        , element
+                        , content_type
+                        , is_required
+                        , supply_default
+                        , default_value
+                        , enforce_vocabulary
+                        , allowed_vocabulary
+                        , REQUEST=None
+                        ):
+        """ Add a type-specific policy for one of our elements.
+        """
+        if content_type == '<default>':
+            content_type = None
+
+        spec = self.getElementSpec( element )
+        spec.addPolicy( content_type )
+        policy = spec.getPolicy( content_type )
+        policy.edit( is_required
+                   , supply_default
+                   , default_value
+                   , enforce_vocabulary
+                   , allowed_vocabulary
+                   )
+        if REQUEST is not None:
+            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
+               + '/elementPoliciesForm'
+               + '?element=' + element
+               + '&manage_tabs_message=Policy+added.'
+               )
+
+    security.declareProtected(ManagePortal, 'removeElementPolicy')
+    def removeElementPolicy( self
+                           , element
+                           , content_type
+                           , REQUEST=None
+                           ):
+        """ Remvoe a type-specific policy for one of our elements.
+        """
+        if content_type == '<default>':
+            content_type = None
+
+        spec = self.getElementSpec( element )
+        spec.removePolicy( content_type )
+        if REQUEST is not None:
+            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
+               + '/elementPoliciesForm'
+               + '?element=' + element
+               + '&manage_tabs_message=Policy+removed.'
+               )
+
+    security.declareProtected(ManagePortal, 'updateElementPolicy')
+    def updateElementPolicy( self
+                           , element
+                           , content_type
+                           , is_required
+                           , supply_default
+                           , default_value
+                           , enforce_vocabulary
+                           , allowed_vocabulary
+                           , REQUEST=None
+                           ):
+        """ Update a policy for one of our elements 
+
+        o 'content_type' will be '<default>' when we edit the default.
+        """
+        if content_type == '<default>':
+            content_type = None
+        spec = self.getElementSpec( element )
+        policy = spec.getPolicy( content_type )
+        policy.edit( is_required
+                   , supply_default
+                   , default_value
+                   , enforce_vocabulary
+                   , allowed_vocabulary
+                   )
+        if REQUEST is not None:
+            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
+               + '/elementPoliciesForm'
+               + '?element=' + element
+               + '&manage_tabs_message=Policy+updated.'
+               )
+
+
+    #
+    #   Element spec manipulation.
+    #
+    security.declareProtected(ManagePortal, 'listElementSpecs')
+    def listElementSpecs( self ):
+        """ Return a list of ElementSpecs representing the elements we manage.
+        """
+        res = []
+        for k, v in self.element_specs.items():
+            res.append((k, v.__of__(self)))
+        return res
+
+    security.declareProtected(ManagePortal, 'getElementSpec')
+    def getElementSpec( self, element ):
+        """ Return an ElementSpec for the given 'element'.
+        """
+        return self.element_specs[ element ].__of__( self )
+
+    security.declareProtected(ManagePortal, 'addElementSpec')
+    def addElementSpec( self, element, is_multi_valued, REQUEST=None ):
+        """ Add 'element' to our list of managed elements.
+        """
+        # Don't replace.
+        if self.element_specs.has_key( element ):
+            return
+
+        self.element_specs[ element ] = ElementSpec( is_multi_valued )
+
+        if REQUEST is not None:
+            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
+               + '/propertiesForm'
+               + '?manage_tabs_message=Element+' + element + '+added.'
+               )
+
+    security.declareProtected(ManagePortal, 'removeElementSpec')
+    def removeElementSpec( self, element, REQUEST=None ):
+        """ Remove 'element' from our list of managed elements.
+        """
+        del self.element_specs[ element ]
+
+        if REQUEST is not None:
+            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
+               + '/propertiesForm'
+               + '?manage_tabs_message=Element+' + element + '+removed.'
+               )
+
+    security.declareProtected(ManagePortal, 'listPolicies')
+    def listPolicies( self, typ=None ):
+        """ Show all policies for a given content type
+
+        o If 'typ' is none, return the list of default policies.
+        """
+        result = []
+        for element, spec in self.listElementSpecs():
+            result.append( ( element, spec.getPolicy( typ ) ) )
+        return result
+
+InitializeClass(MetadataSchema)
+
+
+_DCMI_ELEMENT_SPECS = ( ( 'Title', 0 )
+                      , ( 'Description', 0 )
+                      , ( 'Subject', 1 )
+                      , ( 'Format', 0 )
+                      , ( 'Language', 0 )
+                      , ( 'Rights', 0 )
+                      )
+
+class MetadataTool(UniqueObject, Folder):
+
+    implements(IMetadataTool)
+
+    id = 'portal_metadata'
+    meta_type = 'Default Metadata Tool'
+
+    #
+    #   Default values.
+    #
+    publisher           = ''
+
+    security = ClassSecurityInfo()
+
+    def __init__( self, publisher=None ):
+
+        self.editProperties(publisher)
+        self.DCMI = MetadataSchema('DCMI', _DCMI_ELEMENT_SPECS)
+
+    #
+    #   ZMI methods
+    #
+    manage_options = ( ( { 'label'      : 'Schema'
+                         , 'action'     : 'propertiesForm'
+                         }
+                       , { 'label'      : 'Overview'
+                         , 'action'     : 'manage_overview'
+                         }
+                       )
+                     + Folder.manage_options
+                     )
+
+    security.declareProtected(ManagePortal, 'manage_overview')
+    manage_overview = DTMLFile( 'explainMetadataTool', _dtmldir )
+
+    security.declareProtected(ManagePortal, 'propertiesForm')
+    propertiesForm = DTMLFile( 'metadataProperties', _dtmldir )
+
+    security.declareProtected(ManagePortal, 'editProperties')
+    def editProperties( self
+                      , publisher=None
+                      , REQUEST=None
+                      ):
+        """ Form handler for "tool-wide" properties 
+        """
+        if publisher is not None:
+            self.publisher = publisher
+
+        if REQUEST is not None:
+            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
+                                        + '/propertiesForm'
+                                        + '?manage_tabs_message=Tool+updated.'
+                                        )
+
+    security.declareProtected(ManagePortal, 'manage_addSchema')
+    def manage_addSchema( self, schema_id, elements, REQUEST ):
+        """ ZMI wrapper around addSchema
+        """
+        massaged = []
+        for element in elements:
+            if isinstance(element, basestring):
+                element = element.split(',')
+                if len( element ) < 2:
+                    element.append(0)
+            massaged.append( element )
+        self.addSchema( schema_id, massaged )
+
+        REQUEST['RESPONSE'].redirect( self.absolute_url()
+                                    + '/propertiesForm'
+                                    + '?manage_tabs_message=Schema+added.'
+                                    )
+
+    security.declareProtected(ManagePortal, 'manage_removeSchemas')
+    def manage_removeSchemas( self, schema_ids, REQUEST ):
+        """ ZMI wrapper around removeSchema
+        """
+        if not schema_ids:
+            raise ValueError, 'No schemas selected!'
+
+        for schema_id in schema_ids:
+            self.removeSchema( schema_id )
+
+        REQUEST['RESPONSE'].redirect( self.absolute_url()
+                                    + '/propertiesForm'
+                                    + '?manage_tabs_message=Schemas+removed.'
+                                    )
+
+    security.declarePrivate( 'getFullName' )
+    def getFullName( self, userid ):
+        """ See IMetadataTool.
+        """
+        return userid   # TODO: do lookup here
+
+    security.declarePublic( 'getPublisher' )
+    def getPublisher( self ):
+        """ See IMetadataTool.
+        """
+        return self.publisher
+
+    security.declarePublic( 'listAllowedSubjects' )
+    def listAllowedSubjects( self, content=None, content_type=None ):
+        """ See IMetadataTool.
+        """
+        return self.listAllowedVocabulary( 'DCMI'
+                                         , 'Subject'
+                                         , content
+                                         , content_type
+                                         )
+
+    security.declarePublic( 'listAllowedFormats' )
+    def listAllowedFormats( self, content=None, content_type=None ):
+        """ See IMetadataTool.
+        """
+        return self.listAllowedVocabulary( 'DCMI'
+                                         , 'Format'
+                                         , content
+                                         , content_type
+                                         )
+
+    security.declarePublic( 'listAllowedLanguages' )
+    def listAllowedLanguages( self, content=None, content_type=None ):
+        """ See IMetadataTool.
+        """
+        return self.listAllowedVocabulary( 'DCMI'
+                                         , 'Language'
+                                         , content
+                                         , content_type
+                                         )
+
+    security.declarePublic( 'listAllowedRights' )
+    def listAllowedRights( self, content=None, content_type=None ):
+        """ See IMetadata Tool.
+        """
+        return self.listAllowedVocabulary( 'DCMI'
+                                         , 'Rights'
+                                         , content
+                                         , content_type
+                                         )
+
+    security.declarePublic( 'listAllowedVocabulary' )
+    def listAllowedVocabulary( self
+                             , schema
+                             , element
+                             , content=None
+                             , content_type=None
+                             ):
+        """ See IMetadataTool.
+        """
+        schema_def = getattr( self, schema )
+        spec = schema_def.getElementSpec( element )
+        if content_type is None and content:
+            content_type = content.getPortalTypeName()
+        return spec.getPolicy( content_type ).allowedVocabulary()
+
+    security.declarePublic( 'listSchemas' )
+    def listSchemas( self ):
+        """ See IMetadataTool.
+        """
+        result = [ ( 'DCMI', self.DCMI ) ]
+        result.extend( self.objectItems( [ MetadataSchema.meta_type ] ) )
+        return result
+
+    security.declareProtected(ModifyPortalContent, 'addSchema')
+    def addSchema( self, schema_id, elements=() ):
+        """ See IMetadataTool.
+        """
+        if schema_id == 'DCMI' or schema_id in self.objectIds():
+            raise KeyError, 'Duplicate schema ID: %s' % schema_id
+
+        schema = MetadataSchema( schema_id, elements )
+        self._setObject( schema_id, schema )
+
+        return self._getOb( schema_id )
+
+    security.declareProtected(ModifyPortalContent, 'removeSchema')
+    def removeSchema( self, schema_id ):
+        """ See IMetadataTool.
+        """
+        if schema_id == 'DCMI' or schema_id not in self.objectIds():
+            raise KeyError, 'Invalid schema ID: %s' % schema_id
+
+        self._delObject( schema_id )
+
+    security.declareProtected(ModifyPortalContent, 'setInitialMetadata')
+    def setInitialMetadata( self, content ):
+        """ See IMetadataTool.
+        """
+        for schema_id, schema in self.listSchemas():
+            for element, policy in schema.listPolicies(
+                                    content.getPortalTypeName()):
+
+                if not getattr( content, element )():
+
+                    if policy.supplyDefault():
+                        setter = getattr( content, 'set%s' % element )
+                        setter( policy.defaultValue() )
+                    elif policy.isRequired():
+                        raise MetadataError, \
+                            'Metadata element %s is required.' % element
+
+        # TODO:  Call initial_values_hook, if present
+
+    security.declareProtected(View, 'validateMetadata')
+    def validateMetadata( self, content ):
+        """ See IMetadataTool.
+        """
+        for schema_id, schema in self.listSchemas():
+            for element, policy in schema.listPolicies(
+                                    content.getPortalTypeName()):
+
+                value = getattr( content, element )()
+                if not value and policy.isRequired():
+                    raise MetadataError, \
+                            'Metadata element %s is required.' % element
+
+                if value and policy.enforceVocabulary():
+                    values = policy.isMultiValued() and value or [ value ]
+                    for value in values:
+                        if not value in policy.allowedVocabulary():
+                            raise MetadataError, \
+                            'Value %s is not in allowed vocabulary for ' \
+                            'metadata element %s.' % ( value, element )
+
+InitializeClass( MetadataTool )
+registerToolInterface('portal_metadata', IMetadataTool)


Repository: Products.ATContentTypes
Branch: refs/heads/master
Date: 2015-04-24T21:38:40+02:00
Author: Tom Gross (tomgross) <itconsense@gmail.com>
Commit: https://github.com/plone/Products.ATContentTypes/commit/e9dfb56e8d1362fdf99d811b2bacd2e477eb7295

port all CMFDefault occurenceces

Files changed:
A Products/ATContentTypes/www/explainMetadataTool.dtml
A Products/ATContentTypes/www/metadataElementPolicies.dtml
A Products/ATContentTypes/www/metadataProperties.dtml
M Products/ATContentTypes/content/document.py
M Products/ATContentTypes/tool/metadata.py
D Products/ATContentTypes/tool/MetadataTool.py

diff --git a/Products/ATContentTypes/content/document.py b/Products/ATContentTypes/content/document.py
index 2a2d6b8..059d497 100644
--- a/Products/ATContentTypes/content/document.py
+++ b/Products/ATContentTypes/content/document.py
@@ -9,7 +9,7 @@
 from AccessControl import ClassSecurityInfo
 from ComputedAttribute import ComputedAttribute
 
-from Products.CMFDefault.utils import SimpleHTMLParser
+from lxml import etree
 from Products.GenericSetup.interfaces import IDAVAware
 
 from Products.Archetypes.atapi import Schema
@@ -216,10 +216,11 @@ def manage_afterPUT(self, data, marshall_data, file, context, mimetype,
             content = data
 
         if -1 != content.lower().find("<html"):
-            parser = SimpleHTMLParser()
-            parser.feed(content)
-            if parser.title:
-                self.setTitle(parser.title)
+            parser = etree.HTMLParser()
+            tree = etree.fromstring(content, parser=parser)
+            titletag = tree.xpath('//title')
+            if titletag:
+                self.setTitle(titletag[0].text)
             return
 
         ATCTContent.manage_afterPUT(self, data, marshall_data, file,
diff --git a/Products/ATContentTypes/tool/MetadataTool.py b/Products/ATContentTypes/tool/MetadataTool.py
deleted file mode 100644
index 83b5720..0000000
--- a/Products/ATContentTypes/tool/MetadataTool.py
+++ /dev/null
@@ -1,592 +0,0 @@
-##############################################################################
-#
-# Copyright (c) 2001 Zope Foundation and Contributors.
-#
-# This software is subject to the provisions of the Zope Public License,
-# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
-# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
-# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
-# FOR A PARTICULAR PURPOSE.
-#
-##############################################################################
-""" CMFDefault portal_metadata tool. """
-
-from AccessControl.SecurityInfo import ClassSecurityInfo
-from App.class_init import InitializeClass
-from App.special_dtml import DTMLFile
-from OFS.Folder import Folder
-from OFS.SimpleItem import SimpleItem
-from Persistence import PersistentMapping
-from zope.interface import implements
-
-from Products.CMFCore.interfaces import IMetadataTool
-from Products.CMFCore.utils import registerToolInterface
-from Products.CMFCore.utils import UniqueObject
-from Products.CMFDefault.exceptions import MetadataError
-from Products.CMFDefault.permissions import ManagePortal
-from Products.CMFDefault.permissions import ModifyPortalContent
-from Products.CMFDefault.permissions import View
-from Products.CMFDefault.utils import _dtmldir
-
-
-class MetadataElementPolicy( SimpleItem ):
-
-    """ Represent a type-specific policy about a particular metadata element.
-    """
-
-    security = ClassSecurityInfo()
-    #
-    #   Default values.
-    #
-    is_required         = 0
-    supply_default      = 0
-    default_value       = ''
-    enforce_vocabulary  = 0
-    allowed_vocabulary  = ()
-
-    def __init__(self, is_multi_valued=False):
-        self.is_multi_valued = bool(is_multi_valued)
-
-    #
-    #   Mutator.
-    #
-    security.declareProtected(ManagePortal , 'edit')
-    def edit( self
-            , is_required
-            , supply_default
-            , default_value
-            , enforce_vocabulary
-            , allowed_vocabulary
-            ):
-        self.is_required        = bool(is_required)
-        self.supply_default     = bool(supply_default)
-        self.default_value      = default_value
-        self.enforce_vocabulary = bool(enforce_vocabulary)
-        self.allowed_vocabulary = tuple(allowed_vocabulary)
-
-    #
-    #   Query interface
-    #
-    security.declareProtected(View , 'isMultiValued')
-    def isMultiValued( self ):
-        """ Can this element hold multiple values?
-        """
-        return self.is_multi_valued
-
-    security.declareProtected(View , 'isRequired')
-    def isRequired( self ):
-        """ Must this element be supplied?
-        """
-        return self.is_required
-
-    security.declareProtected(View , 'supplyDefault')
-    def supplyDefault( self ):
-        """ Should the tool supply a default?
-        """
-        return self.supply_default
-
-    security.declareProtected(View , 'defaultValue')
-    def defaultValue( self ):
-        """ If so, what is the default?
-        """
-        return self.default_value
-
-    security.declareProtected(View , 'enforceVocabulary')
-    def enforceVocabulary( self ):
-        """ Should the tool enforce the policy's vocabulary?
-        """
-        return self.enforce_vocabulary
-
-    security.declareProtected(View , 'allowedVocabulary')
-    def allowedVocabulary( self ):
-        """ What are the allowed values?
-        """
-        return self.allowed_vocabulary
-
-InitializeClass( MetadataElementPolicy )
-
-
-
-class ElementSpec( SimpleItem ):
-
-    """ Represent all the tool knows about a single metadata element.
-    """
-
-    security = ClassSecurityInfo()
-
-    #
-    #   Default values.
-    #
-    is_multi_valued = 0
-
-    def __init__( self, is_multi_valued ):
-        self.is_multi_valued  = is_multi_valued
-        self.policies         = PersistentMapping()
-        self.policies[ None ] = self._makePolicy()  # set default policy
-
-    security.declarePrivate( '_makePolicy' )
-    def _makePolicy( self ):
-        return MetadataElementPolicy( self.is_multi_valued )
-
-    security.declareProtected(View , 'isMultiValued')
-    def isMultiValued( self ):
-        """
-            Is this element multi-valued?
-        """
-        return self.is_multi_valued
-
-    security.declareProtected(View , 'getPolicy')
-    def getPolicy( self, typ=None ):
-        """ Find the policy for this element for objects of the given type.
-
-        o Return a default, if none found.
-        """
-        try:
-            return self.policies[ typ ].__of__(self)
-        except KeyError:
-            return self.policies[ None ].__of__(self)
-
-    security.declareProtected(View , 'listPolicies')
-    def listPolicies( self ):
-        """ Return a list of all policies for this element.
-        """
-        res = []
-        for k, v in self.policies.items():
-            res.append((k, v.__of__(self)))
-        return res
-
-    security.declareProtected(ManagePortal , 'addPolicy')
-    def addPolicy( self, typ ):
-        """ Add a policy to this element for objects of the given type.
-        """
-        if typ is None:
-            raise MetadataError, "Can't replace default policy."
-
-        if self.policies.has_key( typ ):
-            raise MetadataError, "Existing policy for content type:" + typ
-
-        self.policies[ typ ] = self._makePolicy()
-
-    security.declareProtected(ManagePortal, 'removePolicy')
-    def removePolicy( self, typ ):
-        """ Remove the policy from this element for objects of the given type.
-
-        o Do *not* remvoe the default, however.
-        """
-        if typ is None:
-            raise MetadataError, "Can't remove default policy."
-        del self.policies[ typ ]
-
-InitializeClass( ElementSpec )
-
-
-class MetadataSchema( SimpleItem ):
-
-    """ Describe a metadata schema.
-    """
-
-    security = ClassSecurityInfo()
-
-    meta_type = 'Metadata Schema'
-    publisher = ''
-
-    def __init__( self, id, element_specs=() ):
-        self._setId( id )
-        self.element_specs = PersistentMapping()
-        for name, is_multi_valued in element_specs:
-            self.element_specs[ name ] = ElementSpec( is_multi_valued )
-
-
-    #
-    #   ZMI methods
-    #
-    manage_options = ( ( { 'label'      : 'Elements'
-                         , 'action'     : 'elementPoliciesForm'
-                         }
-                       ,
-                       )
-                     + SimpleItem.manage_options
-                     )
-
-    security.declareProtected(ManagePortal, 'elementPoliciesForm')
-    elementPoliciesForm = DTMLFile( 'metadataElementPolicies', _dtmldir )
-
-    security.declareProtected(ManagePortal, 'addElementPolicy')
-    def addElementPolicy( self
-                        , element
-                        , content_type
-                        , is_required
-                        , supply_default
-                        , default_value
-                        , enforce_vocabulary
-                        , allowed_vocabulary
-                        , REQUEST=None
-                        ):
-        """ Add a type-specific policy for one of our elements.
-        """
-        if content_type == '<default>':
-            content_type = None
-
-        spec = self.getElementSpec( element )
-        spec.addPolicy( content_type )
-        policy = spec.getPolicy( content_type )
-        policy.edit( is_required
-                   , supply_default
-                   , default_value
-                   , enforce_vocabulary
-                   , allowed_vocabulary
-                   )
-        if REQUEST is not None:
-            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
-               + '/elementPoliciesForm'
-               + '?element=' + element
-               + '&manage_tabs_message=Policy+added.'
-               )
-
-    security.declareProtected(ManagePortal, 'removeElementPolicy')
-    def removeElementPolicy( self
-                           , element
-                           , content_type
-                           , REQUEST=None
-                           ):
-        """ Remvoe a type-specific policy for one of our elements.
-        """
-        if content_type == '<default>':
-            content_type = None
-
-        spec = self.getElementSpec( element )
-        spec.removePolicy( content_type )
-        if REQUEST is not None:
-            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
-               + '/elementPoliciesForm'
-               + '?element=' + element
-               + '&manage_tabs_message=Policy+removed.'
-               )
-
-    security.declareProtected(ManagePortal, 'updateElementPolicy')
-    def updateElementPolicy( self
-                           , element
-                           , content_type
-                           , is_required
-                           , supply_default
-                           , default_value
-                           , enforce_vocabulary
-                           , allowed_vocabulary
-                           , REQUEST=None
-                           ):
-        """ Update a policy for one of our elements 
-
-        o 'content_type' will be '<default>' when we edit the default.
-        """
-        if content_type == '<default>':
-            content_type = None
-        spec = self.getElementSpec( element )
-        policy = spec.getPolicy( content_type )
-        policy.edit( is_required
-                   , supply_default
-                   , default_value
-                   , enforce_vocabulary
-                   , allowed_vocabulary
-                   )
-        if REQUEST is not None:
-            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
-               + '/elementPoliciesForm'
-               + '?element=' + element
-               + '&manage_tabs_message=Policy+updated.'
-               )
-
-
-    #
-    #   Element spec manipulation.
-    #
-    security.declareProtected(ManagePortal, 'listElementSpecs')
-    def listElementSpecs( self ):
-        """ Return a list of ElementSpecs representing the elements we manage.
-        """
-        res = []
-        for k, v in self.element_specs.items():
-            res.append((k, v.__of__(self)))
-        return res
-
-    security.declareProtected(ManagePortal, 'getElementSpec')
-    def getElementSpec( self, element ):
-        """ Return an ElementSpec for the given 'element'.
-        """
-        return self.element_specs[ element ].__of__( self )
-
-    security.declareProtected(ManagePortal, 'addElementSpec')
-    def addElementSpec( self, element, is_multi_valued, REQUEST=None ):
-        """ Add 'element' to our list of managed elements.
-        """
-        # Don't replace.
-        if self.element_specs.has_key( element ):
-            return
-
-        self.element_specs[ element ] = ElementSpec( is_multi_valued )
-
-        if REQUEST is not None:
-            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
-               + '/propertiesForm'
-               + '?manage_tabs_message=Element+' + element + '+added.'
-               )
-
-    security.declareProtected(ManagePortal, 'removeElementSpec')
-    def removeElementSpec( self, element, REQUEST=None ):
-        """ Remove 'element' from our list of managed elements.
-        """
-        del self.element_specs[ element ]
-
-        if REQUEST is not None:
-            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
-               + '/propertiesForm'
-               + '?manage_tabs_message=Element+' + element + '+removed.'
-               )
-
-    security.declareProtected(ManagePortal, 'listPolicies')
-    def listPolicies( self, typ=None ):
-        """ Show all policies for a given content type
-
-        o If 'typ' is none, return the list of default policies.
-        """
-        result = []
-        for element, spec in self.listElementSpecs():
-            result.append( ( element, spec.getPolicy( typ ) ) )
-        return result
-
-InitializeClass(MetadataSchema)
-
-
-_DCMI_ELEMENT_SPECS = ( ( 'Title', 0 )
-                      , ( 'Description', 0 )
-                      , ( 'Subject', 1 )
-                      , ( 'Format', 0 )
-                      , ( 'Language', 0 )
-                      , ( 'Rights', 0 )
-                      )
-
-class MetadataTool(UniqueObject, Folder):
-
-    implements(IMetadataTool)
-
-    id = 'portal_metadata'
-    meta_type = 'Default Metadata Tool'
-
-    #
-    #   Default values.
-    #
-    publisher           = ''
-
-    security = ClassSecurityInfo()
-
-    def __init__( self, publisher=None ):
-
-        self.editProperties(publisher)
-        self.DCMI = MetadataSchema('DCMI', _DCMI_ELEMENT_SPECS)
-
-    #
-    #   ZMI methods
-    #
-    manage_options = ( ( { 'label'      : 'Schema'
-                         , 'action'     : 'propertiesForm'
-                         }
-                       , { 'label'      : 'Overview'
-                         , 'action'     : 'manage_overview'
-                         }
-                       )
-                     + Folder.manage_options
-                     )
-
-    security.declareProtected(ManagePortal, 'manage_overview')
-    manage_overview = DTMLFile( 'explainMetadataTool', _dtmldir )
-
-    security.declareProtected(ManagePortal, 'propertiesForm')
-    propertiesForm = DTMLFile( 'metadataProperties', _dtmldir )
-
-    security.declareProtected(ManagePortal, 'editProperties')
-    def editProperties( self
-                      , publisher=None
-                      , REQUEST=None
-                      ):
-        """ Form handler for "tool-wide" properties 
-        """
-        if publisher is not None:
-            self.publisher = publisher
-
-        if REQUEST is not None:
-            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
-                                        + '/propertiesForm'
-                                        + '?manage_tabs_message=Tool+updated.'
-                                        )
-
-    security.declareProtected(ManagePortal, 'manage_addSchema')
-    def manage_addSchema( self, schema_id, elements, REQUEST ):
-        """ ZMI wrapper around addSchema
-        """
-        massaged = []
-        for element in elements:
-            if isinstance(element, basestring):
-                element = element.split(',')
-                if len( element ) < 2:
-                    element.append(0)
-            massaged.append( element )
-        self.addSchema( schema_id, massaged )
-
-        REQUEST['RESPONSE'].redirect( self.absolute_url()
-                                    + '/propertiesForm'
-                                    + '?manage_tabs_message=Schema+added.'
-                                    )
-
-    security.declareProtected(ManagePortal, 'manage_removeSchemas')
-    def manage_removeSchemas( self, schema_ids, REQUEST ):
-        """ ZMI wrapper around removeSchema
-        """
-        if not schema_ids:
-            raise ValueError, 'No schemas selected!'
-
-        for schema_id in schema_ids:
-            self.removeSchema( schema_id )
-
-        REQUEST['RESPONSE'].redirect( self.absolute_url()
-                                    + '/propertiesForm'
-                                    + '?manage_tabs_message=Schemas+removed.'
-                                    )
-
-    security.declarePrivate( 'getFullName' )
-    def getFullName( self, userid ):
-        """ See IMetadataTool.
-        """
-        return userid   # TODO: do lookup here
-
-    security.declarePublic( 'getPublisher' )
-    def getPublisher( self ):
-        """ See IMetadataTool.
-        """
-        return self.publisher
-
-    security.declarePublic( 'listAllowedSubjects' )
-    def listAllowedSubjects( self, content=None, content_type=None ):
-        """ See IMetadataTool.
-        """
-        return self.listAllowedVocabulary( 'DCMI'
-                                         , 'Subject'
-                                         , content
-                                         , content_type
-                                         )
-
-    security.declarePublic( 'listAllowedFormats' )
-    def listAllowedFormats( self, content=None, content_type=None ):
-        """ See IMetadataTool.
-        """
-        return self.listAllowedVocabulary( 'DCMI'
-                                         , 'Format'
-                                         , content
-                                         , content_type
-                                         )
-
-    security.declarePublic( 'listAllowedLanguages' )
-    def listAllowedLanguages( self, content=None, content_type=None ):
-        """ See IMetadataTool.
-        """
-        return self.listAllowedVocabulary( 'DCMI'
-                                         , 'Language'
-                                         , content
-                                         , content_type
-                                         )
-
-    security.declarePublic( 'listAllowedRights' )
-    def listAllowedRights( self, content=None, content_type=None ):
-        """ See IMetadata Tool.
-        """
-        return self.listAllowedVocabulary( 'DCMI'
-                                         , 'Rights'
-                                         , content
-                                         , content_type
-                                         )
-
-    security.declarePublic( 'listAllowedVocabulary' )
-    def listAllowedVocabulary( self
-                             , schema
-                             , element
-                             , content=None
-                             , content_type=None
-                             ):
-        """ See IMetadataTool.
-        """
-        schema_def = getattr( self, schema )
-        spec = schema_def.getElementSpec( element )
-        if content_type is None and content:
-            content_type = content.getPortalTypeName()
-        return spec.getPolicy( content_type ).allowedVocabulary()
-
-    security.declarePublic( 'listSchemas' )
-    def listSchemas( self ):
-        """ See IMetadataTool.
-        """
-        result = [ ( 'DCMI', self.DCMI ) ]
-        result.extend( self.objectItems( [ MetadataSchema.meta_type ] ) )
-        return result
-
-    security.declareProtected(ModifyPortalContent, 'addSchema')
-    def addSchema( self, schema_id, elements=() ):
-        """ See IMetadataTool.
-        """
-        if schema_id == 'DCMI' or schema_id in self.objectIds():
-            raise KeyError, 'Duplicate schema ID: %s' % schema_id
-
-        schema = MetadataSchema( schema_id, elements )
-        self._setObject( schema_id, schema )
-
-        return self._getOb( schema_id )
-
-    security.declareProtected(ModifyPortalContent, 'removeSchema')
-    def removeSchema( self, schema_id ):
-        """ See IMetadataTool.
-        """
-        if schema_id == 'DCMI' or schema_id not in self.objectIds():
-            raise KeyError, 'Invalid schema ID: %s' % schema_id
-
-        self._delObject( schema_id )
-
-    security.declareProtected(ModifyPortalContent, 'setInitialMetadata')
-    def setInitialMetadata( self, content ):
-        """ See IMetadataTool.
-        """
-        for schema_id, schema in self.listSchemas():
-            for element, policy in schema.listPolicies(
-                                    content.getPortalTypeName()):
-
-                if not getattr( content, element )():
-
-                    if policy.supplyDefault():
-                        setter = getattr( content, 'set%s' % element )
-                        setter( policy.defaultValue() )
-                    elif policy.isRequired():
-                        raise MetadataError, \
-                            'Metadata element %s is required.' % element
-
-        # TODO:  Call initial_values_hook, if present
-
-    security.declareProtected(View, 'validateMetadata')
-    def validateMetadata( self, content ):
-        """ See IMetadataTool.
-        """
-        for schema_id, schema in self.listSchemas():
-            for element, policy in schema.listPolicies(
-                                    content.getPortalTypeName()):
-
-                value = getattr( content, element )()
-                if not value and policy.isRequired():
-                    raise MetadataError, \
-                            'Metadata element %s is required.' % element
-
-                if value and policy.enforceVocabulary():
-                    values = policy.isMultiValued() and value or [ value ]
-                    for value in values:
-                        if not value in policy.allowedVocabulary():
-                            raise MetadataError, \
-                            'Value %s is not in allowed vocabulary for ' \
-                            'metadata element %s.' % ( value, element )
-
-InitializeClass( MetadataTool )
-registerToolInterface('portal_metadata', IMetadataTool)
diff --git a/Products/ATContentTypes/tool/metadata.py b/Products/ATContentTypes/tool/metadata.py
index aef4670..5b72653 100644
--- a/Products/ATContentTypes/tool/metadata.py
+++ b/Products/ATContentTypes/tool/metadata.py
@@ -1,16 +1,597 @@
-from AccessControl import ClassSecurityInfo
+##############################################################################
+#
+# Copyright (c) 2001 Zope Foundation and Contributors.
+#
+# This software is subject to the provisions of the Zope Public License,
+# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
+# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
+# FOR A PARTICULAR PURPOSE.
+#
+##############################################################################
+""" ATContentTypes portal_metadata tool. """
+
+from AccessControl.SecurityInfo import ClassSecurityInfo
 from App.class_init import InitializeClass
-from Products.CMFDefault.MetadataTool import MetadataTool as BaseTool
+from App.special_dtml import DTMLFile
+from OFS.Folder import Folder
+from OFS.SimpleItem import SimpleItem
+from Persistence import PersistentMapping
+from zope.interface import implements
+
+from Products.ATContentTypes.config import WWW_DIR
+from Products.CMFCore.interfaces import IMetadataTool
+from Products.CMFCore.utils import registerToolInterface
+from Products.CMFCore.utils import UniqueObject
+from Products.CMFPlone.permissions import ManagePortal
+from Products.CMFPlone.permissions import ModifyPortalContent
+from Products.CMFPlone.permissions import View
 from Products.CMFPlone.PloneBaseTool import PloneBaseTool
 
 
-class MetadataTool(PloneBaseTool, BaseTool):
+class MetadataError(Exception):
+    """ Metadata error.  """
+
+
+class MetadataElementPolicy( SimpleItem ):
+
+    """ Represent a type-specific policy about a particular metadata element.
+    """
 
-    meta_type = 'Plone Metadata Tool'
     security = ClassSecurityInfo()
+    #
+    #   Default values.
+    #
+    is_required         = 0
+    supply_default      = 0
+    default_value       = ''
+    enforce_vocabulary  = 0
+    allowed_vocabulary  = ()
+
+    def __init__(self, is_multi_valued=False):
+        self.is_multi_valued = bool(is_multi_valued)
+
+    #
+    #   Mutator.
+    #
+    security.declareProtected(ManagePortal , 'edit')
+    def edit( self
+            , is_required
+            , supply_default
+            , default_value
+            , enforce_vocabulary
+            , allowed_vocabulary
+            ):
+        self.is_required        = bool(is_required)
+        self.supply_default     = bool(supply_default)
+        self.default_value      = default_value
+        self.enforce_vocabulary = bool(enforce_vocabulary)
+        self.allowed_vocabulary = tuple(allowed_vocabulary)
+
+    #
+    #   Query interface
+    #
+    security.declareProtected(View , 'isMultiValued')
+    def isMultiValued( self ):
+        """ Can this element hold multiple values?
+        """
+        return self.is_multi_valued
+
+    security.declareProtected(View , 'isRequired')
+    def isRequired( self ):
+        """ Must this element be supplied?
+        """
+        return self.is_required
+
+    security.declareProtected(View , 'supplyDefault')
+    def supplyDefault( self ):
+        """ Should the tool supply a default?
+        """
+        return self.supply_default
+
+    security.declareProtected(View , 'defaultValue')
+    def defaultValue( self ):
+        """ If so, what is the default?
+        """
+        return self.default_value
+
+    security.declareProtected(View , 'enforceVocabulary')
+    def enforceVocabulary( self ):
+        """ Should the tool enforce the policy's vocabulary?
+        """
+        return self.enforce_vocabulary
+
+    security.declareProtected(View , 'allowedVocabulary')
+    def allowedVocabulary( self ):
+        """ What are the allowed values?
+        """
+        return self.allowed_vocabulary
+
+InitializeClass( MetadataElementPolicy )
+
+
+
+class ElementSpec( SimpleItem ):
+
+    """ Represent all the tool knows about a single metadata element.
+    """
+
+    security = ClassSecurityInfo()
+
+    #
+    #   Default values.
+    #
+    is_multi_valued = 0
+
+    def __init__( self, is_multi_valued ):
+        self.is_multi_valued  = is_multi_valued
+        self.policies         = PersistentMapping()
+        self.policies[ None ] = self._makePolicy()  # set default policy
+
+    security.declarePrivate( '_makePolicy' )
+    def _makePolicy( self ):
+        return MetadataElementPolicy( self.is_multi_valued )
+
+    security.declareProtected(View , 'isMultiValued')
+    def isMultiValued( self ):
+        """
+            Is this element multi-valued?
+        """
+        return self.is_multi_valued
+
+    security.declareProtected(View , 'getPolicy')
+    def getPolicy( self, typ=None ):
+        """ Find the policy for this element for objects of the given type.
+
+        o Return a default, if none found.
+        """
+        try:
+            return self.policies[ typ ].__of__(self)
+        except KeyError:
+            return self.policies[ None ].__of__(self)
+
+    security.declareProtected(View , 'listPolicies')
+    def listPolicies( self ):
+        """ Return a list of all policies for this element.
+        """
+        res = []
+        for k, v in self.policies.items():
+            res.append((k, v.__of__(self)))
+        return res
+
+    security.declareProtected(ManagePortal , 'addPolicy')
+    def addPolicy( self, typ ):
+        """ Add a policy to this element for objects of the given type.
+        """
+        if typ is None:
+            raise MetadataError, "Can't replace default policy."
+
+        if self.policies.has_key( typ ):
+            raise MetadataError, "Existing policy for content type:" + typ
+
+        self.policies[ typ ] = self._makePolicy()
+
+    security.declareProtected(ManagePortal, 'removePolicy')
+    def removePolicy( self, typ ):
+        """ Remove the policy from this element for objects of the given type.
+
+        o Do *not* remvoe the default, however.
+        """
+        if typ is None:
+            raise MetadataError, "Can't remove default policy."
+        del self.policies[ typ ]
+
+InitializeClass( ElementSpec )
+
+
+class MetadataSchema( SimpleItem ):
+
+    """ Describe a metadata schema.
+    """
+
+    security = ClassSecurityInfo()
+
+    meta_type = 'Metadata Schema'
+    publisher = ''
+
+    def __init__( self, id, element_specs=() ):
+        self._setId( id )
+        self.element_specs = PersistentMapping()
+        for name, is_multi_valued in element_specs:
+            self.element_specs[ name ] = ElementSpec( is_multi_valued )
+
+
+    #
+    #   ZMI methods
+    #
+    manage_options = ( ( { 'label'      : 'Elements'
+                         , 'action'     : 'elementPoliciesForm'
+                         }
+                       ,
+                       )
+                     + SimpleItem.manage_options
+                     )
+
+    security.declareProtected(ManagePortal, 'elementPoliciesForm')
+    elementPoliciesForm = DTMLFile( 'metadataElementPolicies', WWW_DIR )
+
+    security.declareProtected(ManagePortal, 'addElementPolicy')
+    def addElementPolicy( self
+                        , element
+                        , content_type
+                        , is_required
+                        , supply_default
+                        , default_value
+                        , enforce_vocabulary
+                        , allowed_vocabulary
+                        , REQUEST=None
+                        ):
+        """ Add a type-specific policy for one of our elements.
+        """
+        if content_type == '<default>':
+            content_type = None
+
+        spec = self.getElementSpec( element )
+        spec.addPolicy( content_type )
+        policy = spec.getPolicy( content_type )
+        policy.edit( is_required
+                   , supply_default
+                   , default_value
+                   , enforce_vocabulary
+                   , allowed_vocabulary
+                   )
+        if REQUEST is not None:
+            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
+               + '/elementPoliciesForm'
+               + '?element=' + element
+               + '&manage_tabs_message=Policy+added.'
+               )
+
+    security.declareProtected(ManagePortal, 'removeElementPolicy')
+    def removeElementPolicy( self
+                           , element
+                           , content_type
+                           , REQUEST=None
+                           ):
+        """ Remvoe a type-specific policy for one of our elements.
+        """
+        if content_type == '<default>':
+            content_type = None
+
+        spec = self.getElementSpec( element )
+        spec.removePolicy( content_type )
+        if REQUEST is not None:
+            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
+               + '/elementPoliciesForm'
+               + '?element=' + element
+               + '&manage_tabs_message=Policy+removed.'
+               )
+
+    security.declareProtected(ManagePortal, 'updateElementPolicy')
+    def updateElementPolicy( self
+                           , element
+                           , content_type
+                           , is_required
+                           , supply_default
+                           , default_value
+                           , enforce_vocabulary
+                           , allowed_vocabulary
+                           , REQUEST=None
+                           ):
+        """ Update a policy for one of our elements 
+
+        o 'content_type' will be '<default>' when we edit the default.
+        """
+        if content_type == '<default>':
+            content_type = None
+        spec = self.getElementSpec( element )
+        policy = spec.getPolicy( content_type )
+        policy.edit( is_required
+                   , supply_default
+                   , default_value
+                   , enforce_vocabulary
+                   , allowed_vocabulary
+                   )
+        if REQUEST is not None:
+            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
+               + '/elementPoliciesForm'
+               + '?element=' + element
+               + '&manage_tabs_message=Policy+updated.'
+               )
+
+
+    #
+    #   Element spec manipulation.
+    #
+    security.declareProtected(ManagePortal, 'listElementSpecs')
+    def listElementSpecs( self ):
+        """ Return a list of ElementSpecs representing the elements we manage.
+        """
+        res = []
+        for k, v in self.element_specs.items():
+            res.append((k, v.__of__(self)))
+        return res
+
+    security.declareProtected(ManagePortal, 'getElementSpec')
+    def getElementSpec( self, element ):
+        """ Return an ElementSpec for the given 'element'.
+        """
+        return self.element_specs[ element ].__of__( self )
+
+    security.declareProtected(ManagePortal, 'addElementSpec')
+    def addElementSpec( self, element, is_multi_valued, REQUEST=None ):
+        """ Add 'element' to our list of managed elements.
+        """
+        # Don't replace.
+        if self.element_specs.has_key( element ):
+            return
+
+        self.element_specs[ element ] = ElementSpec( is_multi_valued )
+
+        if REQUEST is not None:
+            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
+               + '/propertiesForm'
+               + '?manage_tabs_message=Element+' + element + '+added.'
+               )
+
+    security.declareProtected(ManagePortal, 'removeElementSpec')
+    def removeElementSpec( self, element, REQUEST=None ):
+        """ Remove 'element' from our list of managed elements.
+        """
+        del self.element_specs[ element ]
+
+        if REQUEST is not None:
+            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
+               + '/propertiesForm'
+               + '?manage_tabs_message=Element+' + element + '+removed.'
+               )
+
+    security.declareProtected(ManagePortal, 'listPolicies')
+    def listPolicies( self, typ=None ):
+        """ Show all policies for a given content type
+
+        o If 'typ' is none, return the list of default policies.
+        """
+        result = []
+        for element, spec in self.listElementSpecs():
+            result.append( ( element, spec.getPolicy( typ ) ) )
+        return result
+
+InitializeClass(MetadataSchema)
+
+
+_DCMI_ELEMENT_SPECS = ( ( 'Title', 0 )
+                      , ( 'Description', 0 )
+                      , ( 'Subject', 1 )
+                      , ( 'Format', 0 )
+                      , ( 'Language', 0 )
+                      , ( 'Rights', 0 )
+                      )
+
+class MetadataTool(PloneBaseTool, UniqueObject, Folder):
+
+    implements(IMetadataTool)
+
+    id = 'portal_metadata'
+    meta_type = 'Default Metadata Tool'
     toolicon = 'skins/plone_images/info_icon.png'
 
+    #
+    #   Default values.
+    #
+    publisher           = ''
+
+    security = ClassSecurityInfo()
+
+    def __init__( self, publisher=None ):
+
+        self.editProperties(publisher)
+        self.DCMI = MetadataSchema('DCMI', _DCMI_ELEMENT_SPECS)
+
+    #
+    #   ZMI methods
+    #
+    manage_options = ( ( { 'label'      : 'Schema'
+                         , 'action'     : 'propertiesForm'
+                         }
+                       , { 'label'      : 'Overview'
+                         , 'action'     : 'manage_overview'
+                         }
+                       )
+                     + Folder.manage_options
+                     )
+
+    security.declareProtected(ManagePortal, 'manage_overview')
+    manage_overview = DTMLFile( 'explainMetadataTool', WWW_DIR )
+
+    security.declareProtected(ManagePortal, 'propertiesForm')
+    propertiesForm = DTMLFile( 'metadataProperties', WWW_DIR )
+
+    security.declareProtected(ManagePortal, 'editProperties')
+    def editProperties( self
+                      , publisher=None
+                      , REQUEST=None
+                      ):
+        """ Form handler for "tool-wide" properties 
+        """
+        if publisher is not None:
+            self.publisher = publisher
+
+        if REQUEST is not None:
+            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
+                                        + '/propertiesForm'
+                                        + '?manage_tabs_message=Tool+updated.'
+                                        )
+
+    security.declareProtected(ManagePortal, 'manage_addSchema')
+    def manage_addSchema( self, schema_id, elements, REQUEST ):
+        """ ZMI wrapper around addSchema
+        """
+        massaged = []
+        for element in elements:
+            if isinstance(element, basestring):
+                element = element.split(',')
+                if len( element ) < 2:
+                    element.append(0)
+            massaged.append( element )
+        self.addSchema( schema_id, massaged )
+
+        REQUEST['RESPONSE'].redirect( self.absolute_url()
+                                    + '/propertiesForm'
+                                    + '?manage_tabs_message=Schema+added.'
+                                    )
+
+    security.declareProtected(ManagePortal, 'manage_removeSchemas')
+    def manage_removeSchemas( self, schema_ids, REQUEST ):
+        """ ZMI wrapper around removeSchema
+        """
+        if not schema_ids:
+            raise ValueError, 'No schemas selected!'
+
+        for schema_id in schema_ids:
+            self.removeSchema( schema_id )
+
+        REQUEST['RESPONSE'].redirect( self.absolute_url()
+                                    + '/propertiesForm'
+                                    + '?manage_tabs_message=Schemas+removed.'
+                                    )
+
+    security.declarePrivate( 'getFullName' )
+    def getFullName( self, userid ):
+        """ See IMetadataTool.
+        """
+        return userid   # TODO: do lookup here
+
+    security.declarePublic( 'getPublisher' )
+    def getPublisher( self ):
+        """ See IMetadataTool.
+        """
+        return self.publisher
+
+    security.declarePublic( 'listAllowedSubjects' )
+    def listAllowedSubjects( self, content=None, content_type=None ):
+        """ See IMetadataTool.
+        """
+        return self.listAllowedVocabulary( 'DCMI'
+                                         , 'Subject'
+                                         , content
+                                         , content_type
+                                         )
+
+    security.declarePublic( 'listAllowedFormats' )
+    def listAllowedFormats( self, content=None, content_type=None ):
+        """ See IMetadataTool.
+        """
+        return self.listAllowedVocabulary( 'DCMI'
+                                         , 'Format'
+                                         , content
+                                         , content_type
+                                         )
+
+    security.declarePublic( 'listAllowedLanguages' )
+    def listAllowedLanguages( self, content=None, content_type=None ):
+        """ See IMetadataTool.
+        """
+        return self.listAllowedVocabulary( 'DCMI'
+                                         , 'Language'
+                                         , content
+                                         , content_type
+                                         )
+
+    security.declarePublic( 'listAllowedRights' )
+    def listAllowedRights( self, content=None, content_type=None ):
+        """ See IMetadata Tool.
+        """
+        return self.listAllowedVocabulary( 'DCMI'
+                                         , 'Rights'
+                                         , content
+                                         , content_type
+                                         )
+
+    security.declarePublic( 'listAllowedVocabulary' )
+    def listAllowedVocabulary( self
+                             , schema
+                             , element
+                             , content=None
+                             , content_type=None
+                             ):
+        """ See IMetadataTool.
+        """
+        schema_def = getattr( self, schema )
+        spec = schema_def.getElementSpec( element )
+        if content_type is None and content:
+            content_type = content.getPortalTypeName()
+        return spec.getPolicy( content_type ).allowedVocabulary()
+
+    security.declarePublic( 'listSchemas' )
+    def listSchemas( self ):
+        """ See IMetadataTool.
+        """
+        result = [ ( 'DCMI', self.DCMI ) ]
+        result.extend( self.objectItems( [ MetadataSchema.meta_type ] ) )
+        return result
+
+    security.declareProtected(ModifyPortalContent, 'addSchema')
+    def addSchema( self, schema_id, elements=() ):
+        """ See IMetadataTool.
+        """
+        if schema_id == 'DCMI' or schema_id in self.objectIds():
+            raise KeyError, 'Duplicate schema ID: %s' % schema_id
+
+        schema = MetadataSchema( schema_id, elements )
+        self._setObject( schema_id, schema )
+
+        return self._getOb( schema_id )
+
+    security.declareProtected(ModifyPortalContent, 'removeSchema')
+    def removeSchema( self, schema_id ):
+        """ See IMetadataTool.
+        """
+        if schema_id == 'DCMI' or schema_id not in self.objectIds():
+            raise KeyError, 'Invalid schema ID: %s' % schema_id
+
+        self._delObject( schema_id )
+
+    security.declareProtected(ModifyPortalContent, 'setInitialMetadata')
+    def setInitialMetadata( self, content ):
+        """ See IMetadataTool.
+        """
+        for schema_id, schema in self.listSchemas():
+            for element, policy in schema.listPolicies(
+                                    content.getPortalTypeName()):
+
+                if not getattr( content, element )():
+
+                    if policy.supplyDefault():
+                        setter = getattr( content, 'set%s' % element )
+                        setter( policy.defaultValue() )
+                    elif policy.isRequired():
+                        raise MetadataError, \
+                            'Metadata element %s is required.' % element
+
+        # TODO:  Call initial_values_hook, if present
+
+    security.declareProtected(View, 'validateMetadata')
+    def validateMetadata( self, content ):
+        """ See IMetadataTool.
+        """
+        for schema_id, schema in self.listSchemas():
+            for element, policy in schema.listPolicies(
+                                    content.getPortalTypeName()):
+
+                value = getattr( content, element )()
+                if not value and policy.isRequired():
+                    raise MetadataError, \
+                            'Metadata element %s is required.' % element
 
-MetadataTool.__doc__ = BaseTool.__doc__
+                if value and policy.enforceVocabulary():
+                    values = policy.isMultiValued() and value or [ value ]
+                    for value in values:
+                        if not value in policy.allowedVocabulary():
+                            raise MetadataError, \
+                            'Value %s is not in allowed vocabulary for ' \
+                            'metadata element %s.' % ( value, element )
 
-InitializeClass(MetadataTool)
+InitializeClass( MetadataTool )
+registerToolInterface('portal_metadata', IMetadataTool)
diff --git a/Products/ATContentTypes/www/explainMetadataTool.dtml b/Products/ATContentTypes/www/explainMetadataTool.dtml
new file mode 100644
index 0000000..a2617cb
--- /dev/null
+++ b/Products/ATContentTypes/www/explainMetadataTool.dtml
@@ -0,0 +1,11 @@
+<dtml-var manage_page_header>
+<dtml-var manage_tabs>
+
+<h3> <code>portal_metadata</code> Tool </h3>
+
+<p> This tool embodies site-wide policies concerning required metadata
+    for each content type, as well as default values and controlled
+    vocabularies.
+</p>
+
+<dtml-var manage_page_footer>
diff --git a/Products/ATContentTypes/www/metadataElementPolicies.dtml b/Products/ATContentTypes/www/metadataElementPolicies.dtml
new file mode 100644
index 0000000..6fc2bcb
--- /dev/null
+++ b/Products/ATContentTypes/www/metadataElementPolicies.dtml
@@ -0,0 +1,179 @@
+<dtml-var manage_page_header>
+<dtml-var manage_tabs>
+
+<dtml-let specs=listElementSpecs
+          def_spec="specs and specs[0][0] or None"
+          current="REQUEST.get( 'element', def_spec )">
+
+<h3> Update Element Metadata Policies </h3>
+
+<table class="FormLayout">
+
+ <tr>
+  <th> Element: </th>
+  <td colspan="3"> 
+   <dtml-in listElementSpecs>
+    <dtml-let key=sequence-key>
+     <dtml-if expr="key == current">
+     &dtml-key;  &nbsp;
+     <dtml-else>
+      <a href="&dtml-URL;?element=&dtml-key;"> &dtml-key; </a> &nbsp;
+     </dtml-if>
+    </dtml-let>
+   </dtml-in>
+  </td>
+ </tr>
+
+ <dtml-if def_spec>
+ <dtml-let spec="getElementSpec( element=current )"
+           multi="spec.isMultiValued()"
+           tokenz="multi and ':tokens' or ''"
+ >
+
+ <dtml-in expr="spec.listPolicies()" sort>
+ <dtml-let key=sequence-key
+           typ="key or '<default>'"
+           policy=sequence-item
+           rqd="policy.isRequired() and 'checked' or ''"
+           canRemove="key is not _.None"
+           supply="policy.supplyDefault() and 'checked' or ''"
+           rawdef="policy.defaultValue()"
+           defval="(multi and ( _.string.join( rawdef ), ) or ( rawdef, ))[0]"
+           enforce="policy.enforceVocabulary() and 'checked' or ''"
+           vocab="_.string.join( policy.allowedVocabulary(), '\n' )"
+ >
+
+ <form action="&dtml-absolute_url;" method="POST">
+ <input type="hidden" name="element" value="&dtml-current;"> 
+ <input type="hidden" name="content_type" value="&dtml-typ;"> 
+
+ <tr style="background-color: DarkGray; color: DarkBlue">
+  <th colspan="4"> <br> </th>
+ </tr>
+
+ <tr valign="top">
+  <th> Content type </th>
+  <td>
+    <dtml-if "typ == '<default>'">
+      &dtml-typ;
+    <dtml-else>
+      <dtml-let typeinfo="portal_types.getTypeInfo(typ)">
+        <dtml-if typeinfo>
+          <dtml-var "typeinfo.Title()" html_quote>
+        <dtml-else>
+          &dtml-typ; (deleted)
+        </dtml-if>
+      </dtml-let>
+    </dtml-if>
+  </td>
+  <th> Required? </th>
+  <td>
+    <input type="checkbox" name="is_required:boolean" &dtml-rqd;>
+    <input type="hidden" name="is_required:int:default" value="0">
+  </td>
+ </tr>
+ 
+ <tr valign="top">
+  <th> Supply default? </th>
+  <td>
+    <input type="checkbox" name="supply_default:boolean" &dtml-supply;>
+    <input type="hidden" name="supply_default:int:default" value="0">
+  </td>
+  <th> Default </th>
+  <td> <input type="text" name="default_value&dtml-tokenz;"
+              value="&dtml-defval;" size="40"> </td>
+ </tr>
+ 
+ <tr valign="top">
+  <th> Enforce vocabulary? </th>
+  <td>
+    <input type="checkbox" name="enforce_vocabulary:boolean" &dtml-enforce;>
+    <input type="hidden" name="enforce_vocabulary:int:default" value="0">
+  </td>
+  <th> Vocabulary </th>
+  <td> <textarea name="allowed_vocabulary:lines"
+                 rows="5" cols="20">&dtml-vocab;</textarea>
+ </tr>
+ 
+ <tr valign="top">
+  <td> <br> </td>
+  <td colspan="3">
+   <input type="submit" name="updateElementPolicy:method" value=" Update ">
+   <dtml-if canRemove>
+    <input type="submit" name="removeElementPolicy:method" value=" Remove ">
+   </dtml-if>
+  </td>
+ </tr>
+
+ </form>
+ </dtml-let>
+ </dtml-in>
+
+ <form action="&dtml-absolute_url;" method="POST">
+ <input type="hidden" name="element" value="&dtml-current;"> 
+
+ <tr style="background-color: DarkGray; color: DarkBlue">
+  <th colspan="4"> &lt;new type&gt; </th>
+ </tr>
+
+ <tr valign="top">
+  <th> Content type </th>
+
+  <dtml-let typeinfos="portal_types.listTypeInfo()">
+  <td>
+   <select name="content_type">
+    <dtml-in typeinfos>
+     <option value="&dtml-getId;"> &dtml-Title; </option>
+    </dtml-in>
+   </select>
+  </td>
+  </dtml-let>
+
+  <th> Required? </th>
+  <td>
+    <input type="checkbox" name="is_required:boolean">
+    <input type="hidden" name="is_required:int:default" value="0">
+  </td>
+ </tr>
+ 
+ <tr valign="top">
+  <th> Supply default? </th>
+  <td>
+    <input type="checkbox" name="supply_default:boolean">
+    <input type="hidden" name="supply_default:int:default" value="0">
+  </td>
+  <th> Default </th>
+  <td> <input type="text" name="default_value&dtml-tokenz;" size="40"> </td>
+ </tr>
+ 
+ <tr valign="top">
+  <th> Enforce vocabulary? </th>
+  <td>
+    <input type="checkbox" name="enforce_vocabulary:boolean">
+    <input type="hidden" name="enforce_vocabulary:int:default" value="0">
+  </td>
+  <th> Vocabulary </th>
+  <td> <textarea name="allowed_vocabulary:lines"
+                 rows="5" cols="20"></textarea>
+ </tr>
+ 
+ <tr valign="top">
+  <td> <br> </td>
+  <td>
+   <input type="submit" name="addElementPolicy:method" value=" Add ">
+  </td>
+ </tr>
+
+ </form>
+
+ <tr style="background-color: DarkGray; color: DarkBlue">
+  <th colspan="4"> <br> </th>
+ </tr>
+
+ </dtml-let>
+ </dtml-if>
+</table>
+
+</dtml-let>
+
+<dtml-var manage_page_footer>
diff --git a/Products/ATContentTypes/www/metadataProperties.dtml b/Products/ATContentTypes/www/metadataProperties.dtml
new file mode 100644
index 0000000..2e1b2d7
--- /dev/null
+++ b/Products/ATContentTypes/www/metadataProperties.dtml
@@ -0,0 +1,96 @@
+<dtml-var manage_page_header>
+<dtml-var manage_tabs>
+
+<h3> Update Metadata Tool Properties </h3>
+
+<form action="editProperties" method="POST">
+<table>
+
+ <tr valign="middle">
+  <th width="100" align="right"> Publisher: </th>
+  <td> <input type="text" name="publisher"
+              value="&dtml-getPublisher;" size="40"> </td>
+ </tr>
+
+ <tr valign="middle">
+  <td> <br> </td>
+  <td> <input type="submit" value=" Change "> </td>
+ </tr>
+
+</table>
+</form>
+
+<h3> Metadata Schemas </h3>
+
+<form action="&dtml-absolute_url;" method="POST">
+<table>
+
+ <dtml-in listSchemas>
+ <dtml-if sequence-start>
+
+ <tr valign="middle">
+  <td width="16">
+    <br /> <!-- can't remove DCMI schema! -->
+  </td>
+  <td>
+   <a href="&dtml-absolute_url;/manage_workspace">DCMI</a>
+  </td>
+ </tr>
+
+ <dtml-else>
+
+ <tr valign="middle">
+  <td>
+   <input type="checkbox" name="schema_ids:list" value="&dtml-sequence-key;" />
+  </td>
+  <td>
+   <a href="&dtml-absolute_url;/manage_workspace"
+   > &dtml-sequence-key; </a>
+  </td>
+ </tr>
+
+ </dtml-if>
+ </dtml-in>
+
+ <tr valign="middle">
+  <td colspan="2">
+    <input type="submit" name="manage_removeSchemas:method"
+        value=" Remove Schemas ">
+  </td>
+ </tr>
+</table>
+
+<br />
+
+<table>
+
+ <tr>
+  <th colspan="2"
+      style="background-color:#CCCCCC; color:#000088">
+   Add a Schema
+  </th>
+ <tr>
+  <th> Schema ID </th>
+  <td>
+    <input type="text" name="schema_id" size="20"><br />
+  </td>
+ </tr>
+
+ <tr>
+  <th> Elements </th>
+  <td>
+    <textarea name="elements:lines" cols="30" rows="10"></textarea>
+  </td>
+ </tr>
+
+ <tr>
+  <td> <br /> </td>
+  <td>
+    <input type="submit" name="manage_addSchema:method" value=" Add Schema ">
+  </td>
+ </tr>
+
+</table>
+</form>
+
+<dtml-var manage_page_footer>


Repository: Products.ATContentTypes
Branch: refs/heads/master
Date: 2015-04-26T00:17:34+02:00
Author: Gil Forcada Codinachs (gforcada) <gforcada@gnome.org>
Commit: https://github.com/plone/Products.ATContentTypes/commit/44549ca127968260c34e1a0437c42fe015e46c59

Merge pull request #18 from plone/tomgross-nocmfdefault

Remove all CMFDefault dependencies

Files changed:
A Products/ATContentTypes/www/explainMetadataTool.dtml
A Products/ATContentTypes/www/metadataElementPolicies.dtml
A Products/ATContentTypes/www/metadataProperties.dtml
M Products/ATContentTypes/content/document.py
M Products/ATContentTypes/setuphandlers.py
M Products/ATContentTypes/tool/metadata.py
M setup.py

diff --git a/Products/ATContentTypes/content/document.py b/Products/ATContentTypes/content/document.py
index 2a2d6b8..059d497 100644
--- a/Products/ATContentTypes/content/document.py
+++ b/Products/ATContentTypes/content/document.py
@@ -9,7 +9,7 @@
 from AccessControl import ClassSecurityInfo
 from ComputedAttribute import ComputedAttribute
 
-from Products.CMFDefault.utils import SimpleHTMLParser
+from lxml import etree
 from Products.GenericSetup.interfaces import IDAVAware
 
 from Products.Archetypes.atapi import Schema
@@ -216,10 +216,11 @@ def manage_afterPUT(self, data, marshall_data, file, context, mimetype,
             content = data
 
         if -1 != content.lower().find("<html"):
-            parser = SimpleHTMLParser()
-            parser.feed(content)
-            if parser.title:
-                self.setTitle(parser.title)
+            parser = etree.HTMLParser()
+            tree = etree.fromstring(content, parser=parser)
+            titletag = tree.xpath('//title')
+            if titletag:
+                self.setTitle(titletag[0].text)
             return
 
         ATCTContent.manage_afterPUT(self, data, marshall_data, file,
diff --git a/Products/ATContentTypes/setuphandlers.py b/Products/ATContentTypes/setuphandlers.py
index c180638..11e3a73 100644
--- a/Products/ATContentTypes/setuphandlers.py
+++ b/Products/ATContentTypes/setuphandlers.py
@@ -1,7 +1,7 @@
 from Acquisition import aq_base
 from Products.ATContentTypes.lib import constraintypes
 from Products.CMFCore.utils import getToolByName
-from Products.CMFDefault.utils import bodyfinder
+from Products.CMFPlone.utils import bodyfinder
 from Products.CMFPlone.utils import _createObjectByType
 from plone.i18n.normalizer.interfaces import IURLNormalizer
 from plone.portlets.interfaces import ILocalPortletAssignmentManager
@@ -13,11 +13,7 @@
 from plone.registry.interfaces import IRegistry
 from zope.component import getUtility
 
-try:
-    from Products.CMFPlone.interfaces import ILanguageSchema
-    PLONE_5 = True
-except:
-    PLONE_5 = False
+from Products.CMFPlone.interfaces import ILanguageSchema
 
 
 def assignTitles(portal):
@@ -62,23 +58,14 @@ def setupPortalContent(p):
     pprop = getToolByName(p, "portal_properties")
     sheet = pprop.site_properties
 
-    if PLONE_5:
-        registry = getUtility(IRegistry)
-        language_settings = registry.forInterface(
-            ILanguageSchema,
-            prefix='plone'
-        )
-        language_settings.use_combined_language_codes = use_combined
-        language_settings.default_language = language
-        language_settings.available_languages = [language]
-    else:
-        tool = getToolByName(p, "portal_languages")
-        tool.manage_setLanguageSettings(
-            language,
-            [language],
-            setUseCombinedLanguageCodes=use_combined,
-            startNeutral=False
-        )
+    registry = getUtility(IRegistry)
+    language_settings = registry.forInterface(
+        ILanguageSchema,
+        prefix='plone'
+    )
+    language_settings.use_combined_language_codes = use_combined
+    language_settings.default_language = language
+    language_settings.available_languages = [language]
 
     # Enable visible_ids for non-latin scripts
 
diff --git a/Products/ATContentTypes/tool/metadata.py b/Products/ATContentTypes/tool/metadata.py
index aef4670..5b72653 100644
--- a/Products/ATContentTypes/tool/metadata.py
+++ b/Products/ATContentTypes/tool/metadata.py
@@ -1,16 +1,597 @@
-from AccessControl import ClassSecurityInfo
+##############################################################################
+#
+# Copyright (c) 2001 Zope Foundation and Contributors.
+#
+# This software is subject to the provisions of the Zope Public License,
+# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
+# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
+# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
+# FOR A PARTICULAR PURPOSE.
+#
+##############################################################################
+""" ATContentTypes portal_metadata tool. """
+
+from AccessControl.SecurityInfo import ClassSecurityInfo
 from App.class_init import InitializeClass
-from Products.CMFDefault.MetadataTool import MetadataTool as BaseTool
+from App.special_dtml import DTMLFile
+from OFS.Folder import Folder
+from OFS.SimpleItem import SimpleItem
+from Persistence import PersistentMapping
+from zope.interface import implements
+
+from Products.ATContentTypes.config import WWW_DIR
+from Products.CMFCore.interfaces import IMetadataTool
+from Products.CMFCore.utils import registerToolInterface
+from Products.CMFCore.utils import UniqueObject
+from Products.CMFPlone.permissions import ManagePortal
+from Products.CMFPlone.permissions import ModifyPortalContent
+from Products.CMFPlone.permissions import View
 from Products.CMFPlone.PloneBaseTool import PloneBaseTool
 
 
-class MetadataTool(PloneBaseTool, BaseTool):
+class MetadataError(Exception):
+    """ Metadata error.  """
+
+
+class MetadataElementPolicy( SimpleItem ):
+
+    """ Represent a type-specific policy about a particular metadata element.
+    """
 
-    meta_type = 'Plone Metadata Tool'
     security = ClassSecurityInfo()
+    #
+    #   Default values.
+    #
+    is_required         = 0
+    supply_default      = 0
+    default_value       = ''
+    enforce_vocabulary  = 0
+    allowed_vocabulary  = ()
+
+    def __init__(self, is_multi_valued=False):
+        self.is_multi_valued = bool(is_multi_valued)
+
+    #
+    #   Mutator.
+    #
+    security.declareProtected(ManagePortal , 'edit')
+    def edit( self
+            , is_required
+            , supply_default
+            , default_value
+            , enforce_vocabulary
+            , allowed_vocabulary
+            ):
+        self.is_required        = bool(is_required)
+        self.supply_default     = bool(supply_default)
+        self.default_value      = default_value
+        self.enforce_vocabulary = bool(enforce_vocabulary)
+        self.allowed_vocabulary = tuple(allowed_vocabulary)
+
+    #
+    #   Query interface
+    #
+    security.declareProtected(View , 'isMultiValued')
+    def isMultiValued( self ):
+        """ Can this element hold multiple values?
+        """
+        return self.is_multi_valued
+
+    security.declareProtected(View , 'isRequired')
+    def isRequired( self ):
+        """ Must this element be supplied?
+        """
+        return self.is_required
+
+    security.declareProtected(View , 'supplyDefault')
+    def supplyDefault( self ):
+        """ Should the tool supply a default?
+        """
+        return self.supply_default
+
+    security.declareProtected(View , 'defaultValue')
+    def defaultValue( self ):
+        """ If so, what is the default?
+        """
+        return self.default_value
+
+    security.declareProtected(View , 'enforceVocabulary')
+    def enforceVocabulary( self ):
+        """ Should the tool enforce the policy's vocabulary?
+        """
+        return self.enforce_vocabulary
+
+    security.declareProtected(View , 'allowedVocabulary')
+    def allowedVocabulary( self ):
+        """ What are the allowed values?
+        """
+        return self.allowed_vocabulary
+
+InitializeClass( MetadataElementPolicy )
+
+
+
+class ElementSpec( SimpleItem ):
+
+    """ Represent all the tool knows about a single metadata element.
+    """
+
+    security = ClassSecurityInfo()
+
+    #
+    #   Default values.
+    #
+    is_multi_valued = 0
+
+    def __init__( self, is_multi_valued ):
+        self.is_multi_valued  = is_multi_valued
+        self.policies         = PersistentMapping()
+        self.policies[ None ] = self._makePolicy()  # set default policy
+
+    security.declarePrivate( '_makePolicy' )
+    def _makePolicy( self ):
+        return MetadataElementPolicy( self.is_multi_valued )
+
+    security.declareProtected(View , 'isMultiValued')
+    def isMultiValued( self ):
+        """
+            Is this element multi-valued?
+        """
+        return self.is_multi_valued
+
+    security.declareProtected(View , 'getPolicy')
+    def getPolicy( self, typ=None ):
+        """ Find the policy for this element for objects of the given type.
+
+        o Return a default, if none found.
+        """
+        try:
+            return self.policies[ typ ].__of__(self)
+        except KeyError:
+            return self.policies[ None ].__of__(self)
+
+    security.declareProtected(View , 'listPolicies')
+    def listPolicies( self ):
+        """ Return a list of all policies for this element.
+        """
+        res = []
+        for k, v in self.policies.items():
+            res.append((k, v.__of__(self)))
+        return res
+
+    security.declareProtected(ManagePortal , 'addPolicy')
+    def addPolicy( self, typ ):
+        """ Add a policy to this element for objects of the given type.
+        """
+        if typ is None:
+            raise MetadataError, "Can't replace default policy."
+
+        if self.policies.has_key( typ ):
+            raise MetadataError, "Existing policy for content type:" + typ
+
+        self.policies[ typ ] = self._makePolicy()
+
+    security.declareProtected(ManagePortal, 'removePolicy')
+    def removePolicy( self, typ ):
+        """ Remove the policy from this element for objects of the given type.
+
+        o Do *not* remvoe the default, however.
+        """
+        if typ is None:
+            raise MetadataError, "Can't remove default policy."
+        del self.policies[ typ ]
+
+InitializeClass( ElementSpec )
+
+
+class MetadataSchema( SimpleItem ):
+
+    """ Describe a metadata schema.
+    """
+
+    security = ClassSecurityInfo()
+
+    meta_type = 'Metadata Schema'
+    publisher = ''
+
+    def __init__( self, id, element_specs=() ):
+        self._setId( id )
+        self.element_specs = PersistentMapping()
+        for name, is_multi_valued in element_specs:
+            self.element_specs[ name ] = ElementSpec( is_multi_valued )
+
+
+    #
+    #   ZMI methods
+    #
+    manage_options = ( ( { 'label'      : 'Elements'
+                         , 'action'     : 'elementPoliciesForm'
+                         }
+                       ,
+                       )
+                     + SimpleItem.manage_options
+                     )
+
+    security.declareProtected(ManagePortal, 'elementPoliciesForm')
+    elementPoliciesForm = DTMLFile( 'metadataElementPolicies', WWW_DIR )
+
+    security.declareProtected(ManagePortal, 'addElementPolicy')
+    def addElementPolicy( self
+                        , element
+                        , content_type
+                        , is_required
+                        , supply_default
+                        , default_value
+                        , enforce_vocabulary
+                        , allowed_vocabulary
+                        , REQUEST=None
+                        ):
+        """ Add a type-specific policy for one of our elements.
+        """
+        if content_type == '<default>':
+            content_type = None
+
+        spec = self.getElementSpec( element )
+        spec.addPolicy( content_type )
+        policy = spec.getPolicy( content_type )
+        policy.edit( is_required
+                   , supply_default
+                   , default_value
+                   , enforce_vocabulary
+                   , allowed_vocabulary
+                   )
+        if REQUEST is not None:
+            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
+               + '/elementPoliciesForm'
+               + '?element=' + element
+               + '&manage_tabs_message=Policy+added.'
+               )
+
+    security.declareProtected(ManagePortal, 'removeElementPolicy')
+    def removeElementPolicy( self
+                           , element
+                           , content_type
+                           , REQUEST=None
+                           ):
+        """ Remvoe a type-specific policy for one of our elements.
+        """
+        if content_type == '<default>':
+            content_type = None
+
+        spec = self.getElementSpec( element )
+        spec.removePolicy( content_type )
+        if REQUEST is not None:
+            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
+               + '/elementPoliciesForm'
+               + '?element=' + element
+               + '&manage_tabs_message=Policy+removed.'
+               )
+
+    security.declareProtected(ManagePortal, 'updateElementPolicy')
+    def updateElementPolicy( self
+                           , element
+                           , content_type
+                           , is_required
+                           , supply_default
+                           , default_value
+                           , enforce_vocabulary
+                           , allowed_vocabulary
+                           , REQUEST=None
+                           ):
+        """ Update a policy for one of our elements 
+
+        o 'content_type' will be '<default>' when we edit the default.
+        """
+        if content_type == '<default>':
+            content_type = None
+        spec = self.getElementSpec( element )
+        policy = spec.getPolicy( content_type )
+        policy.edit( is_required
+                   , supply_default
+                   , default_value
+                   , enforce_vocabulary
+                   , allowed_vocabulary
+                   )
+        if REQUEST is not None:
+            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
+               + '/elementPoliciesForm'
+               + '?element=' + element
+               + '&manage_tabs_message=Policy+updated.'
+               )
+
+
+    #
+    #   Element spec manipulation.
+    #
+    security.declareProtected(ManagePortal, 'listElementSpecs')
+    def listElementSpecs( self ):
+        """ Return a list of ElementSpecs representing the elements we manage.
+        """
+        res = []
+        for k, v in self.element_specs.items():
+            res.append((k, v.__of__(self)))
+        return res
+
+    security.declareProtected(ManagePortal, 'getElementSpec')
+    def getElementSpec( self, element ):
+        """ Return an ElementSpec for the given 'element'.
+        """
+        return self.element_specs[ element ].__of__( self )
+
+    security.declareProtected(ManagePortal, 'addElementSpec')
+    def addElementSpec( self, element, is_multi_valued, REQUEST=None ):
+        """ Add 'element' to our list of managed elements.
+        """
+        # Don't replace.
+        if self.element_specs.has_key( element ):
+            return
+
+        self.element_specs[ element ] = ElementSpec( is_multi_valued )
+
+        if REQUEST is not None:
+            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
+               + '/propertiesForm'
+               + '?manage_tabs_message=Element+' + element + '+added.'
+               )
+
+    security.declareProtected(ManagePortal, 'removeElementSpec')
+    def removeElementSpec( self, element, REQUEST=None ):
+        """ Remove 'element' from our list of managed elements.
+        """
+        del self.element_specs[ element ]
+
+        if REQUEST is not None:
+            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
+               + '/propertiesForm'
+               + '?manage_tabs_message=Element+' + element + '+removed.'
+               )
+
+    security.declareProtected(ManagePortal, 'listPolicies')
+    def listPolicies( self, typ=None ):
+        """ Show all policies for a given content type
+
+        o If 'typ' is none, return the list of default policies.
+        """
+        result = []
+        for element, spec in self.listElementSpecs():
+            result.append( ( element, spec.getPolicy( typ ) ) )
+        return result
+
+InitializeClass(MetadataSchema)
+
+
+_DCMI_ELEMENT_SPECS = ( ( 'Title', 0 )
+                      , ( 'Description', 0 )
+                      , ( 'Subject', 1 )
+                      , ( 'Format', 0 )
+                      , ( 'Language', 0 )
+                      , ( 'Rights', 0 )
+                      )
+
+class MetadataTool(PloneBaseTool, UniqueObject, Folder):
+
+    implements(IMetadataTool)
+
+    id = 'portal_metadata'
+    meta_type = 'Default Metadata Tool'
     toolicon = 'skins/plone_images/info_icon.png'
 
+    #
+    #   Default values.
+    #
+    publisher           = ''
+
+    security = ClassSecurityInfo()
+
+    def __init__( self, publisher=None ):
+
+        self.editProperties(publisher)
+        self.DCMI = MetadataSchema('DCMI', _DCMI_ELEMENT_SPECS)
+
+    #
+    #   ZMI methods
+    #
+    manage_options = ( ( { 'label'      : 'Schema'
+                         , 'action'     : 'propertiesForm'
+                         }
+                       , { 'label'      : 'Overview'
+                         , 'action'     : 'manage_overview'
+                         }
+                       )
+                     + Folder.manage_options
+                     )
+
+    security.declareProtected(ManagePortal, 'manage_overview')
+    manage_overview = DTMLFile( 'explainMetadataTool', WWW_DIR )
+
+    security.declareProtected(ManagePortal, 'propertiesForm')
+    propertiesForm = DTMLFile( 'metadataProperties', WWW_DIR )
+
+    security.declareProtected(ManagePortal, 'editProperties')
+    def editProperties( self
+                      , publisher=None
+                      , REQUEST=None
+                      ):
+        """ Form handler for "tool-wide" properties 
+        """
+        if publisher is not None:
+            self.publisher = publisher
+
+        if REQUEST is not None:
+            REQUEST[ 'RESPONSE' ].redirect( self.absolute_url()
+                                        + '/propertiesForm'
+                                        + '?manage_tabs_message=Tool+updated.'
+                                        )
+
+    security.declareProtected(ManagePortal, 'manage_addSchema')
+    def manage_addSchema( self, schema_id, elements, REQUEST ):
+        """ ZMI wrapper around addSchema
+        """
+        massaged = []
+        for element in elements:
+            if isinstance(element, basestring):
+                element = element.split(',')
+                if len( element ) < 2:
+                    element.append(0)
+            massaged.append( element )
+        self.addSchema( schema_id, massaged )
+
+        REQUEST['RESPONSE'].redirect( self.absolute_url()
+                                    + '/propertiesForm'
+                                    + '?manage_tabs_message=Schema+added.'
+                                    )
+
+    security.declareProtected(ManagePortal, 'manage_removeSchemas')
+    def manage_removeSchemas( self, schema_ids, REQUEST ):
+        """ ZMI wrapper around removeSchema
+        """
+        if not schema_ids:
+            raise ValueError, 'No schemas selected!'
+
+        for schema_id in schema_ids:
+            self.removeSchema( schema_id )
+
+        REQUEST['RESPONSE'].redirect( self.absolute_url()
+                                    + '/propertiesForm'
+                                    + '?manage_tabs_message=Schemas+removed.'
+                                    )
+
+    security.declarePrivate( 'getFullName' )
+    def getFullName( self, userid ):
+        """ See IMetadataTool.
+        """
+        return userid   # TODO: do lookup here
+
+    security.declarePublic( 'getPublisher' )
+    def getPublisher( self ):
+        """ See IMetadataTool.
+        """
+        return self.publisher
+
+    security.declarePublic( 'listAllowedSubjects' )
+    def listAllowedSubjects( self, content=None, content_type=None ):
+        """ See IMetadataTool.
+        """
+        return self.listAllowedVocabulary( 'DCMI'
+                                         , 'Subject'
+                                         , content
+                                         , content_type
+                                         )
+
+    security.declarePublic( 'listAllowedFormats' )
+    def listAllowedFormats( self, content=None, content_type=None ):
+        """ See IMetadataTool.
+        """
+        return self.listAllowedVocabulary( 'DCMI'
+                                         , 'Format'
+                                         , content
+                                         , content_type
+                                         )
+
+    security.declarePublic( 'listAllowedLanguages' )
+    def listAllowedLanguages( self, content=None, content_type=None ):
+        """ See IMetadataTool.
+        """
+        return self.listAllowedVocabulary( 'DCMI'
+                                         , 'Language'
+                                         , content
+                                         , content_type
+                                         )
+
+    security.declarePublic( 'listAllowedRights' )
+    def listAllowedRights( self, content=None, content_type=None ):
+        """ See IMetadata Tool.
+        """
+        return self.listAllowedVocabulary( 'DCMI'
+                                         , 'Rights'
+                                         , content
+                                         , content_type
+                                         )
+
+    security.declarePublic( 'listAllowedVocabulary' )
+    def listAllowedVocabulary( self
+                             , schema
+                             , element
+                             , content=None
+                             , content_type=None
+                             ):
+        """ See IMetadataTool.
+        """
+        schema_def = getattr( self, schema )
+        spec = schema_def.getElementSpec( element )
+        if content_type is None and content:
+            content_type = content.getPortalTypeName()
+        return spec.getPolicy( content_type ).allowedVocabulary()
+
+    security.declarePublic( 'listSchemas' )
+    def listSchemas( self ):
+        """ See IMetadataTool.
+        """
+        result = [ ( 'DCMI', self.DCMI ) ]
+        result.extend( self.objectItems( [ MetadataSchema.meta_type ] ) )
+        return result
+
+    security.declareProtected(ModifyPortalContent, 'addSchema')
+    def addSchema( self, schema_id, elements=() ):
+        """ See IMetadataTool.
+        """
+        if schema_id == 'DCMI' or schema_id in self.objectIds():
+            raise KeyError, 'Duplicate schema ID: %s' % schema_id
+
+        schema = MetadataSchema( schema_id, elements )
+        self._setObject( schema_id, schema )
+
+        return self._getOb( schema_id )
+
+    security.declareProtected(ModifyPortalContent, 'removeSchema')
+    def removeSchema( self, schema_id ):
+        """ See IMetadataTool.
+        """
+        if schema_id == 'DCMI' or schema_id not in self.objectIds():
+            raise KeyError, 'Invalid schema ID: %s' % schema_id
+
+        self._delObject( schema_id )
+
+    security.declareProtected(ModifyPortalContent, 'setInitialMetadata')
+    def setInitialMetadata( self, content ):
+        """ See IMetadataTool.
+        """
+        for schema_id, schema in self.listSchemas():
+            for element, policy in schema.listPolicies(
+                                    content.getPortalTypeName()):
+
+                if not getattr( content, element )():
+
+                    if policy.supplyDefault():
+                        setter = getattr( content, 'set%s' % element )
+                        setter( policy.defaultValue() )
+                    elif policy.isRequired():
+                        raise MetadataError, \
+                            'Metadata element %s is required.' % element
+
+        # TODO:  Call initial_values_hook, if present
+
+    security.declareProtected(View, 'validateMetadata')
+    def validateMetadata( self, content ):
+        """ See IMetadataTool.
+        """
+        for schema_id, schema in self.listSchemas():
+            for element, policy in schema.listPolicies(
+                                    content.getPortalTypeName()):
+
+                value = getattr( content, element )()
+                if not value and policy.isRequired():
+                    raise MetadataError, \
+                            'Metadata element %s is required.' % element
 
-MetadataTool.__doc__ = BaseTool.__doc__
+                if value and policy.enforceVocabulary():
+                    values = policy.isMultiValued() and value or [ value ]
+                    for value in values:
+                        if not value in policy.allowedVocabulary():
+                            raise MetadataError, \
+                            'Value %s is not in allowed vocabulary for ' \
+                            'metadata element %s.' % ( value, element )
 
-InitializeClass(MetadataTool)
+InitializeClass( MetadataTool )
+registerToolInterface('portal_metadata', IMetadataTool)
diff --git a/Products/ATContentTypes/www/explainMetadataTool.dtml b/Products/ATContentTypes/www/explainMetadataTool.dtml
new file mode 100644
index 0000000..a2617cb
--- /dev/null
+++ b/Products/ATContentTypes/www/explainMetadataTool.dtml
@@ -0,0 +1,11 @@
+<dtml-var manage_page_header>
+<dtml-var manage_tabs>
+
+<h3> <code>portal_metadata</code> Tool </h3>
+
+<p> This tool embodies site-wide policies concerning required metadata
+    for each content type, as well as default values and controlled
+    vocabularies.
+</p>
+
+<dtml-var manage_page_footer>
diff --git a/Products/ATContentTypes/www/metadataElementPolicies.dtml b/Products/ATContentTypes/www/metadataElementPolicies.dtml
new file mode 100644
index 0000000..6fc2bcb
--- /dev/null
+++ b/Products/ATContentTypes/www/metadataElementPolicies.dtml
@@ -0,0 +1,179 @@
+<dtml-var manage_page_header>
+<dtml-var manage_tabs>
+
+<dtml-let specs=listElementSpecs
+          def_spec="specs and specs[0][0] or None"
+          current="REQUEST.get( 'element', def_spec )">
+
+<h3> Update Element Metadata Policies </h3>
+
+<table class="FormLayout">
+
+ <tr>
+  <th> Element: </th>
+  <td colspan="3"> 
+   <dtml-in listElementSpecs>
+    <dtml-let key=sequence-key>
+     <dtml-if expr="key == current">
+     &dtml-key;  &nbsp;
+     <dtml-else>
+      <a href="&dtml-URL;?element=&dtml-key;"> &dtml-key; </a> &nbsp;
+     </dtml-if>
+    </dtml-let>
+   </dtml-in>
+  </td>
+ </tr>
+
+ <dtml-if def_spec>
+ <dtml-let spec="getElementSpec( element=current )"
+           multi="spec.isMultiValued()"
+           tokenz="multi and ':tokens' or ''"
+ >
+
+ <dtml-in expr="spec.listPolicies()" sort>
+ <dtml-let key=sequence-key
+           typ="key or '<default>'"
+           policy=sequence-item
+           rqd="policy.isRequired() and 'checked' or ''"
+           canRemove="key is not _.None"
+           supply="policy.supplyDefault() and 'checked' or ''"
+           rawdef="policy.defaultValue()"
+           defval="(multi and ( _.string.join( rawdef ), ) or ( rawdef, ))[0]"
+           enforce="policy.enforceVocabulary() and 'checked' or ''"
+           vocab="_.string.join( policy.allowedVocabulary(), '\n' )"
+ >
+
+ <form action="&dtml-absolute_url;" method="POST">
+ <input type="hidden" name="element" value="&dtml-current;"> 
+ <input type="hidden" name="content_type" value="&dtml-typ;"> 
+
+ <tr style="background-color: DarkGray; color: DarkBlue">
+  <th colspan="4"> <br> </th>
+ </tr>
+
+ <tr valign="top">
+  <th> Content type </th>
+  <td>
+    <dtml-if "typ == '<default>'">
+      &dtml-typ;
+    <dtml-else>
+      <dtml-let typeinfo="portal_types.getTypeInfo(typ)">
+        <dtml-if typeinfo>
+          <dtml-var "typeinfo.Title()" html_quote>
+        <dtml-else>
+          &dtml-typ; (deleted)
+        </dtml-if>
+      </dtml-let>
+    </dtml-if>
+  </td>
+  <th> Required? </th>
+  <td>
+    <input type="checkbox" name="is_required:boolean" &dtml-rqd;>
+    <input type="hidden" name="is_required:int:default" value="0">
+  </td>
+ </tr>
+ 
+ <tr valign="top">
+  <th> Supply default? </th>
+  <td>
+    <input type="checkbox" name="supply_default:boolean" &dtml-supply;>
+    <input type="hidden" name="supply_default:int:default" value="0">
+  </td>
+  <th> Default </th>
+  <td> <input type="text" name="default_value&dtml-tokenz;"
+              value="&dtml-defval;" size="40"> </td>
+ </tr>
+ 
+ <tr valign="top">
+  <th> Enforce vocabulary? </th>
+  <td>
+    <input type="checkbox" name="enforce_vocabulary:boolean" &dtml-enforce;>
+    <input type="hidden" name="enforce_vocabulary:int:default" value="0">
+  </td>
+  <th> Vocabulary </th>
+  <td> <textarea name="allowed_vocabulary:lines"
+                 rows="5" cols="20">&dtml-vocab;</textarea>
+ </tr>
+ 
+ <tr valign="top">
+  <td> <br> </td>
+  <td colspan="3">
+   <input type="submit" name="updateElementPolicy:method" value=" Update ">
+   <dtml-if canRemove>
+    <input type="submit" name="removeElementPolicy:method" value=" Remove ">
+   </dtml-if>
+  </td>
+ </tr>
+
+ </form>
+ </dtml-let>
+ </dtml-in>
+
+ <form action="&dtml-absolute_url;" method="POST">
+ <input type="hidden" name="element" value="&dtml-current;"> 
+
+ <tr style="background-color: DarkGray; color: DarkBlue">
+  <th colspan="4"> &lt;new type&gt; </th>
+ </tr>
+
+ <tr valign="top">
+  <th> Content type </th>
+
+  <dtml-let typeinfos="portal_types.listTypeInfo()">
+  <td>
+   <select name="content_type">
+    <dtml-in typeinfos>
+     <option value="&dtml-getId;"> &dtml-Title; </option>
+    </dtml-in>
+   </select>
+  </td>
+  </dtml-let>
+
+  <th> Required? </th>
+  <td>
+    <input type="checkbox" name="is_required:boolean">
+    <input type="hidden" name="is_required:int:default" value="0">
+  </td>
+ </tr>
+ 
+ <tr valign="top">
+  <th> Supply default? </th>
+  <td>
+    <input type="checkbox" name="supply_default:boolean">
+    <input type="hidden" name="supply_default:int:default" value="0">
+  </td>
+  <th> Default </th>
+  <td> <input type="text" name="default_value&dtml-tokenz;" size="40"> </td>
+ </tr>
+ 
+ <tr valign="top">
+  <th> Enforce vocabulary? </th>
+  <td>
+    <input type="checkbox" name="enforce_vocabulary:boolean">
+    <input type="hidden" name="enforce_vocabulary:int:default" value="0">
+  </td>
+  <th> Vocabulary </th>
+  <td> <textarea name="allowed_vocabulary:lines"
+                 rows="5" cols="20"></textarea>
+ </tr>
+ 
+ <tr valign="top">
+  <td> <br> </td>
+  <td>
+   <input type="submit" name="addElementPolicy:method" value=" Add ">
+  </td>
+ </tr>
+
+ </form>
+
+ <tr style="background-color: DarkGray; color: DarkBlue">
+  <th colspan="4"> <br> </th>
+ </tr>
+
+ </dtml-let>
+ </dtml-if>
+</table>
+
+</dtml-let>
+
+<dtml-var manage_page_footer>
diff --git a/Products/ATContentTypes/www/metadataProperties.dtml b/Products/ATContentTypes/www/metadataProperties.dtml
new file mode 100644
index 0000000..2e1b2d7
--- /dev/null
+++ b/Products/ATContentTypes/www/metadataProperties.dtml
@@ -0,0 +1,96 @@
+<dtml-var manage_page_header>
+<dtml-var manage_tabs>
+
+<h3> Update Metadata Tool Properties </h3>
+
+<form action="editProperties" method="POST">
+<table>
+
+ <tr valign="middle">
+  <th width="100" align="right"> Publisher: </th>
+  <td> <input type="text" name="publisher"
+              value="&dtml-getPublisher;" size="40"> </td>
+ </tr>
+
+ <tr valign="middle">
+  <td> <br> </td>
+  <td> <input type="submit" value=" Change "> </td>
+ </tr>
+
+</table>
+</form>
+
+<h3> Metadata Schemas </h3>
+
+<form action="&dtml-absolute_url;" method="POST">
+<table>
+
+ <dtml-in listSchemas>
+ <dtml-if sequence-start>
+
+ <tr valign="middle">
+  <td width="16">
+    <br /> <!-- can't remove DCMI schema! -->
+  </td>
+  <td>
+   <a href="&dtml-absolute_url;/manage_workspace">DCMI</a>
+  </td>
+ </tr>
+
+ <dtml-else>
+
+ <tr valign="middle">
+  <td>
+   <input type="checkbox" name="schema_ids:list" value="&dtml-sequence-key;" />
+  </td>
+  <td>
+   <a href="&dtml-absolute_url;/manage_workspace"
+   > &dtml-sequence-key; </a>
+  </td>
+ </tr>
+
+ </dtml-if>
+ </dtml-in>
+
+ <tr valign="middle">
+  <td colspan="2">
+    <input type="submit" name="manage_removeSchemas:method"
+        value=" Remove Schemas ">
+  </td>
+ </tr>
+</table>
+
+<br />
+
+<table>
+
+ <tr>
+  <th colspan="2"
+      style="background-color:#CCCCCC; color:#000088">
+   Add a Schema
+  </th>
+ <tr>
+  <th> Schema ID </th>
+  <td>
+    <input type="text" name="schema_id" size="20"><br />
+  </td>
+ </tr>
+
+ <tr>
+  <th> Elements </th>
+  <td>
+    <textarea name="elements:lines" cols="30" rows="10"></textarea>
+  </td>
+ </tr>
+
+ <tr>
+  <td> <br /> </td>
+  <td>
+    <input type="submit" name="manage_addSchema:method" value=" Add Schema ">
+  </td>
+ </tr>
+
+</table>
+</form>
+
+<dtml-var manage_page_footer>
diff --git a/setup.py b/setup.py
index 173b315..2bdc7a3 100644
--- a/setup.py
+++ b/setup.py
@@ -8,6 +8,8 @@
       long_description=open("README.txt").read() + "\n" + \
                        open("CHANGES.txt").read(),
       classifiers=[
+        "Programming Language :: Python",
+        "Programming Language :: Python :: 2.7",
         "Framework :: Plone",
         "Framework :: Plone :: 5.0",
         ],
@@ -46,7 +48,6 @@
           'Products.Archetypes',
           'Products.CMFCore',
           'Products.CMFDynamicViewFTI',
-          'Products.CMFDefault',
           'Products.CMFFormController',
           'Products.GenericSetup',
           'Products.MimetypesRegistry',


