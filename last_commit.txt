Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:36:17+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/bb791b928adb98a9e24e5812eefac00e9d1a6431

basic pep8 et al, review and minor mods, zca and security decorators

Files changed:
A CHANGES.rst
A README.rst
M Products/PlonePAS/__init__.py
M Products/PlonePAS/config.py
M Products/PlonePAS/configure.zcml
M Products/PlonePAS/events.py
M Products/PlonePAS/exportimport.zcml
M Products/PlonePAS/gruf_support.py
M Products/PlonePAS/ldapmp.py
M Products/PlonePAS/pas.py
M Products/PlonePAS/patch.py
M Products/PlonePAS/permissions.py
M Products/PlonePAS/setuphandlers.py
M Products/PlonePAS/storage.py
M Products/PlonePAS/tests/__init__.py
M Products/PlonePAS/tests/base.py
M Products/PlonePAS/tests/dummy.py
M Products/PlonePAS/tests/test_basic_ops.py
M Products/PlonePAS/tests/test_doctests.py
M Products/PlonePAS/tests/test_groupdatatool.py
M Products/PlonePAS/tests/test_groupstool.py
M Products/PlonePAS/tests/test_memberdatatool.py
M Products/PlonePAS/tests/test_membershiptool.py
M Products/PlonePAS/tests/test_properties.py
M Products/PlonePAS/tests/test_role_plugin.py
M Products/PlonePAS/tests/test_views.py
M Products/PlonePAS/tools/__init__.py
M Products/PlonePAS/tools/groupdata.py
M Products/PlonePAS/tools/groups.py
M Products/PlonePAS/tools/memberdata.py
M Products/PlonePAS/tools/membership.py
M Products/PlonePAS/utils.py
M Products/__init__.py
M setup.py
D CHANGES.txt
D README.txt

diff --git a/CHANGES.rst b/CHANGES.rst
new file mode 100644
index 0000000..e7e5990
--- /dev/null
+++ b/CHANGES.rst
@@ -0,0 +1,879 @@
+Changelog
+=========
+
+5.0.1 (unreleased)
+------------------
+
+- Cleanup: PEP8 et all, zca decorators, rough code review
+  [jensens]
+
+- In searchForMembers, ensure that request parameters are properly
+  decoded to unicode
+  [do3cc]
+
+
+5.0 (2014-04-05)
+----------------
+
+- Do not write member data on read
+  [vangheem]
+
+- Allow ``properties`` to be passed to ``PloneUser.setProperties``.
+  This was previously ignored as ``setProperties`` solely utilised
+  keyword arguments.
+  [davidjb]
+
+
+4.1.2 (2014-01-27)
+------------------
+
+- Don't try to migrate the root user folder if the portal has no parent.
+  [davisagli]
+
+- Use batteries included odict implementation in favour of homegrown one.
+  [tomgross]
+
+- Use correct methods for getting users from id or names
+  [tomgross]
+
+- Ported tests to plone.app.testing
+  [tomgross]
+
+4.1.1 (2013-03-05)
+------------------
+
+- Fix a bug in setSecurityProfile where the login name was passed
+  instead of the user id.
+  [davisagli]
+
+- Added empty updateUser and updateEveryLoginName methods in
+  ZODBMutablePropertyProvider to fulfill the new standards of the
+  IUserEnumerationPlugin.
+  [maurits]
+
+
+4.1 (2013-01-01)
+----------------
+
+- Fix assignRoleToPrincipal to work with new Products.PluggableAuthService 1.10.0.
+  [maurits]
+
+- Fix saving, getting and deleting the user portrait for non-standard
+  user ids like 'bob-jones' or 'bob-jones+test@example.org'.
+  [maurits]
+
+- Fix the test for the current password if the user id differs from
+  the login name.
+  [maurits]
+
+
+4.1a2 (2012-08-29)
+------------------
+
+- Bug fix: User with e-mail login got 'Insufficient Privileges' when
+  trying to delete own portrait. Fixes http://dev.plone.org/ticket/12819.
+  [patch by kagesenshi, applied by kleist]
+
+- MembershipTool.searchForMembers() now preserves sort order.
+  Fixes http://dev.plone.org/ticket/11716.
+  [patch by neaj, applied by kleist]
+
+- Changed deprecated getSiteEncoding to hardcoded `utf-8`
+  [tom_gross]
+
+
+4.1a1 (2012-06-29)
+------------------
+
+- Allow members with usernames that contain special characters
+  (such as @ when use email to login), set their own member portrait
+  [erral]
+
+- PEP8 Cleanup
+  [pbdiode]
+
+- Add a default password validation policy as PAS plugin,
+  see http://dev.plone.org/ticket/10959
+
+- Extensions/Install.py: Don't use list as default argument value
+  to activatePluginInterfaces()
+  [patch by rossp, applied by kleist]
+
+
+4.0.13 (2012-05-07)
+-------------------
+
+- Require ListPortalMembers permission for searchForMembers
+  so anonymous users can not get a list of site users.
+  [vangheem]
+
+
+4.0.12 (2012-04-09)
+-------------------
+
+- Make sure that during registration you can change your member
+  portrait (if this has been enabled the member registration config).
+  Refs http://dev.plone.org/ticket/5432
+  [maurits]
+
+
+4.0.11 (2012-02-08)
+-------------------
+
+- Do some more checks when changing or deleting a member portrait.
+  Fixes http://dev.plone.org/ticket/5432
+  [maurits]
+
+- Pass request along to getGroupsForPrincipal for caching purposes.
+  [esteele]
+
+
+4.0.10 (2012-01-04)
+-------------------
+
+- Fixed typo in method name hasOpenIDExtractor, keeping the old name
+  (hasOpenIDdExtractor) around for backwards compatibility.
+  Fixes http://dev.plone.org/ticket/11040
+  [maurits]
+
+
+4.0.9 (2011-11-24)
+------------------
+
+- Avoid a failure when we try to add a role to principal that is managed by
+  an other plugin.
+  [thomasdesvenain]
+
+- Cleaned up and reduced dependencies. New extra ``atstorage`` for the rare case
+  someone uses PlonePAS w/o Plone but with Archetypes (if this is this
+  possible). [jensens]
+
+4.0.8 - 2011-06-30
+------------------
+
+- Fire IPrincipalDeleted when a user is deleted.
+  [stefan, ggozad]
+
+4.0.7 - 2011-05-12
+------------------
+
+- Copy in CleanupTemp from CMFCore as it has been removed from CMFCore 2.3.
+  [elro]
+
+- Move import step to be registered in ZCML rather than XML.
+  Remove the non-existent dependency on `plonepas-content`.
+  [kiorky]
+
+4.0.6 - 2011-02-25
+------------------
+
+- Fix missing and broken security declarations.
+  [davisagli]
+
+4.0.5 - 2011-02-14
+------------------
+
+- Avoid breaking on startup if PIL isn't present.
+  [davisagli]
+
+- Use 'defaultUser.png' as the default user portrait, since the .gif version
+  has been deprecated for a long time now. See
+  http://dev.plone.org/plone/changeset/36350
+  [mj]
+
+4.0.4 - 2011-01-03
+------------------
+
+- Remove plone.openid dependency in setup.py, import errors are already caught
+  in PASInfoView.
+  [elro]
+
+- The code to search by id in mutable_properties.enumerateUsers didn't work at
+  all, an exception was always raised and it was actually a good thing.
+  We tried to implement it in 3.10 and we had strange listing in Plone UI. Then
+  we reverted it in the next version so the behavior was backward compatible
+  with previous versions.
+  If we allow search by id, we can potentially break other part of the code. For
+  example acl_users/portal_role_manager/manage_roles will break because
+  Products.PluggableAuthService.plugins.ZODBRoleManager.listAssignedPrincipals
+  raises MultiplePrincipalError, and maybe it will break somewhere else.
+  Versions 4.0.4 and 3.13 use now the same algorithm.
+  References http://dev.plone.org/plone/ticket/9361
+  [vincenfretin]
+
+- When calling editGroup method, avoid error
+  while trying to remove dynamic 'AuthenticatedUsers' group.
+  [thomasdesvenain]
+
+- In Plone 4.1+, create a Site Administrators group with the new Site
+  Administrator role.
+  [davisagli]
+
+- Fix critical error on groupprefs page
+  when some groups have a non-ascii character in their title.
+  Sort groups on their title normalized.
+  This fixes http://dev.plone.org/plone/ticket/11301
+  [thomasdesvenain]
+
+- Fix interface error: doChangeUser takes a user id as parameter,
+  not a login name.
+  [wichert]
+
+4.0.3 - 2010-09-09
+------------------
+
+- Check we have a REQUEST attribute before accessing it in
+  getRolesForPrincipal.
+  [vincentfretin]
+
+- Use safe_unicode to correctly find users with
+  non-ascii properties, regardless of the sys.defaultencoding.
+  This fixes http://dev.plone.org/plone/ticket/10898
+  [mr_savage]
+
+4.0.2 - 2010-08-08
+------------------
+
+- Made last_login_time logic compatible with DateTime 2.12.5.
+  [hannosch]
+
+4.0.1 - 2010-07-31
+------------------
+
+- Clean up some unused imports and variable assigments.
+  [esteele]
+
+- Stop looking to GRUF to check if group properties can be edited.
+  [esteele]
+
+4.0 - 2010-07-18
+----------------
+
+- Avoid a deprecation warning for the credentialsChanged method.
+  [hannosch]
+
+- Fixed problems with missing user cache invalidation. This closes
+  http://dev.plone.org/plone/ticket/10715.
+  [fafhrd, hannosch]
+
+- Make VirtualGroup inherit from PropertiedUser so it gets wrapped correctly.
+  Have getGroupsForPrincipal not return the AutoGroup as a member of itself.
+  Closes http://dev.plone.org/plone/ticket/10568.
+  [cah190]
+
+- PluggableAuthService expects a list of group ids from getGroups, don't pass a
+  list of wrapped groups instead.
+  [cah190, esteele]
+
+- Added a custom `IMembershipTool` interface to PlonePAS extending the base one
+  from CMFCore. It adds the `getMemberInfo` method to the mix. This closes
+  http://dev.plone.org/plone/ticket/10240.
+  [hannosch]
+
+4.0b9 - 2010-06-03
+------------------
+
+- Fixed a test to no longer use removed Large Plone Folder type.
+  [davisagli]
+
+4.0b8 - 2010-05-01
+------------------
+
+- Removed special unauthorized view workaround, after the underlying issue
+  has been fixed in Zope2.
+  [davisagli, hannosch]
+
+4.0b7 - 2010-04-07
+------------------
+
+- Added manage_setMembersFolderById method for ZMI.
+  Fixes http://dev.plone.org/plone/ticket/10400
+  [daftdog]
+
+4.0b6 - 2010-03-05
+------------------
+
+- Revert incorrect PIL import change.
+  [hannosch]
+
+4.0b5 - 2010-03-03
+------------------
+
+- Install recursive_groups in new sites by default. Make it the last
+  IGroupsPlugin installed.
+  [esteele]
+
+- Remove caching of utils.py's getGroupsForPrincipal method as it was nastily
+  overzealous.
+  [esteele, cah190]
+
+- Use sets instead of util.py's 'unique' method.
+  [esteele]
+
+4.0b4 - 2010-02-18
+------------------
+
+- Properly import from PIL 1.1.7
+  [tom_gross]
+
+- Cache getGroupsForPrincipal per principal id per request (when available).
+  [esteele]
+
+4.0b3 - 2010-01-31
+------------------
+
+- Role plugin's tests no longer subclass (and run all of) ZODBRoleManagerTests
+  as they cannot properly handle the plugin's expectation of finding a
+  PluginRegistry with IGroupsPlugin
+  [erikrose, esteele]
+
+- Revert changes made to ZODBMutablePropertyProvider's enumerateUsers method
+  which prevented lookup of users by id. Some refactoring.
+  Refs http://dev.plone.org/plone/ticket/9361
+  [erikrose, esteele]
+
+- GroupAwareRoleManager now properly computes the roles of deeply-nested
+  principals.
+  [erikrose, esteele]
+
+- Factor up getGroupsForPrincipal call.
+  [erikrose, esteele]
+
+- AutoGroup now implements IPropertiesPlugin to return group title and description.
+  [erikrose, esteele]
+
+- GroupsTool's getGroupsForPrincipal and getGroupMembers now return a list
+  made up of groups/members from all responding plugins instead of just the
+  first responder.
+  [erikrose, esteele]
+
+- Remove GroupData's _gruf_getProperty method, move remaining functionality
+  into getProperty. getProperty now searches for properties in the following
+  places: property sheets directly on the group object, PAS
+  IPropertyProviders, portal_groupdata properties, and attributes on its
+  GroupData entry. It returns the first piece of data found.
+  Closes http://dev.plone.org/plone/ticket/9828
+  [erikrose, esteele]
+
+- Added __ignore_direct_roles__ request flag to getRolesForPrincipal() to
+  permit retrieval of only group-provided (inherited) roles.
+  [cah190]
+
+- getGroupsForPrincipal is a method of PAS' IGroupsPlugin, adjust the groups
+  tool's plugin lookup accordingly.
+  [esteele]
+
+- Rework the group detection of the ZODBMutablePropertyProvider so that
+  enumerateUsers only returns users.
+  [esteele]
+
+- Add, but don't activate, a recursive groups plugin on installation.
+  [esteele]
+
+- Set proper titles for default groups.
+  [esteele]
+
+- Avoid the use of the classImplements helper from PAS. It dealt with the now
+  gone Zope2 Interface variants and is no longer needed.
+  [hannosch]
+
+- Fix a misnamed kwarg in autogroup plugin.
+  [cah190]
+
+- Allow the groups tool's searchForGroups to handle an empty search string as
+  'find all'.
+  [esteele, cah190]
+
+- Allow PASSearchView's searchGroups method to accept a sorting option.
+  [esteele]
+
+- Apply deiter's patch from http://dev.plone.org/plone/ticket/9460 to prevent
+  GroupManager's 'getGroupById' from returning groups managed by other group
+  managers.
+  [esteele]
+
+- GroupsTool.editGroup() now stores title and description in PAS
+  propertysheets in addition to Plone-specific tools. This helps us not pave
+  over group titles with IDs.
+  [erikrose]
+
+- Query the correct keyword variable for the group's description.
+  [esteele]
+
+- Fix an incorrect setdefault syntax.
+  Closes http://dev.plone.org/plone/ticket/7345
+  [esteele]
+
+4.0b2 - 2010-01-02
+------------------
+
+- Don't specify PIL as a direct dependencies. It is not installed as an egg on
+  all platforms.
+  [hannosch]
+
+4.0b1 - 2009-12-27
+------------------
+
+- Fixed package dependencies declaration.
+  [hannosch]
+
+4.0a2 - 2009-12-16
+------------------
+
+- Added backwards compatibility alias for PloneTool to support upgrades from
+  Plone 2.5 to work.
+  [hannosch]
+
+- Added 'has_email' to the info returned by getMemberInfo.
+  Refs http://dev.plone.org/plone/ticket/8707
+  [maurits]
+
+4.0a1 - 2009-11-14
+------------------
+
+- Simplified ``pas_member`` view.  Also return info when no member
+  with the requested id exists, so this can be safely used also to get
+  "member info" for deleted members.
+  [maurits]
+
+- Added new ``pas_member`` view, which provides easy access to the membership
+  tools getMemberInfo method but caches the result on the request.
+  [hannosch]
+
+- Changed the default value of `memberareaCreationFlag` for the membership
+  tool to False, as it was done during Plone site creation so far.
+  [hannosch]
+
+- Removed patch on ZODBUserManager.enumerateUsers which was introduced
+  historical because of a former missing release of PluggableAuthService 1.5.
+  This now superfluous patch also reduced the functionality of the
+  patched method and introduced different behavior compared to i.e in
+  a similar method on LDAPMultiPlugins. For details on the former
+  patch see:
+  http://dev.plone.org/collective/changeset/41512/PlonePAS/trunk/pas.py
+  [jensens]
+
+- Moved a couple DTML files here from CMFPlone that got left out of the earlier
+  refactoring.
+  [davisagli]
+
+- Added a view of the Unauthorized exception which re-raises that exception
+  in order to make sure that it triggers PAS' challenge plugin rather than
+  rendering the standard_error_message.
+  [davisagli]
+
+- Removed deprecation warnings for various methods. These never happened.
+  [hannosch]
+
+- Removed half-done ZCacheable caching for users and groups.
+  [hannosch]
+
+- Removed the CMFDefault dependency of the membership tool. We only need the
+  CMFCore functionality.
+  [hannosch]
+
+- PlonePAS.gruf_support.authenticate method was not breaking out of
+  the loop upon successful authenticateCredentials.
+  [runyaga]
+
+- Changed objectIds and objectValues calls to use the IContainer API.
+  [hannosch]
+
+- Removed parts of the outdated Extensions.Install code.
+  [hannosch]
+
+- Removed a dependency on CMFPlone's `_createObjectByType` method.
+  [hannosch]
+
+- Removed magical `homePageText` lookup for initial memberarea content. You
+  can use the `notifyMemberAreaCreated` hook for any kind of custom behavior.
+  [hannosch]
+
+- Moved the `scale_image` function from CMFPlone.utils into our own utils
+  module, as we are the only user of it. Also made the tests independent of
+  any CMFPlone code.
+  [hannosch]
+
+- Cleaned up package metadata.
+  [hannosch]
+
+- Declare test dependencies in an extra and fixed deprecation warnings
+  for use of Globals.
+  [hannosch]
+
+- Switched the installation progress reporting to the logging framework.
+  [hannosch]
+
+- Cleaned up annoying license headers in all files. We have a central place
+  to state the license.
+  [hannosch]
+
+- Started cleaning up deprecated methods and comments.
+  [hannosch]
+
+- Removed support for group workspaces. This part from GRUF hasn't been
+  supported for many releases anymore.
+  [hannosch]
+
+- Merged all code for the groups tool from GRUF into this package, we are
+  officially GRUF-dependency-free :)
+  [hannosch]
+
+- Merged all code for the group data tool from GRUF into this package.
+  [hannosch]
+
+- Removed the GRUFBridge plugin. PAS inside GRUF isn't supported anymore.
+  [hannosch]
+
+- Merged tests moved from CMFPlone into the same modules as the existing
+  tests and normalized file names.
+  [hannosch]
+
+- Modernized tests and introduce a proper base testcase and layer.
+  [hannosch]
+
+- Removed cookie auth tests, these don't work anymore with plone.session.
+  [hannosch]
+
+- Moved over all tests for the four tools from CMFPlone.
+  [hannosch]
+
+- Removed the user folder migration code and cleaned up tests.
+  [hannosch]
+
+- Moved all code from the four tools from CMFPlone into this package.
+  [hannosch]
+
+- Removed 'listed' member property support from one of the many search
+  functions following Plone.
+  [hannosch]
+
+- Copied setLoginFormInCookieAuth from CMFPlone migrations.
+  [hannosch]
+
+- Purged old Zope 2 Interface interfaces for Zope 2.12 compatibility.
+  (only a test in this case)
+  [elro]
+
+
+3.12 - 2009-10-16
+-----------------
+
+- Fixed the performance fix again. enumerateUsers from mutable_properties
+  plugin should return all the users if kw is empty. And it returns empty
+  tuple if login or id parameter is used.
+  [vincentfretin]
+
+
+3.11 - 2009-10-05
+-----------------
+
+- Revert performance fix introduced in 3.10 for the mutable properties plugin.
+  enumerateUsers shouldn't return results if id or login is not None like in
+  3.9 (data dict doesn't contain id or login key, so testMemberData returns
+  always False). The search should be performed only if kw parameter is not
+  empty. This is the new optimization fix.
+  [vincentfretin]
+
+
+3.10 - 2009-09-06
+-----------------
+
+- Performance fix for searching in the mutable properties plugin:
+  when only searching on user id do not walk over all properties,
+  but only test if the user id is known. This fixes
+  http://dev.plone.org/plone/ticket/9361
+  [toutpt]
+
+- Nested groups are now visible in prefs_group_members. This closes
+  http://dev.plone.org/plone/ticket/8557
+  [vincentfretin]
+
+- Add sort and merge PASSearchView's interface to prevent code duplication.
+  [csenger]
+
+
+3.9 - 2009-04-21
+----------------
+
+- Fix the cookie plugin's login handler to not trust the username
+  from the request. Instead we use the login name of the currently
+  authenticated user. This fixes CVE-2009-0662 (see
+  http://plone.org/products/plone/security/advisories/cve-2009-0662
+  for more information).
+  [wichert]
+
+
+3.8 - 2009-02-13
+----------------
+
+- Update the role manager's assignRoleToPrincipal method to lazily
+  update the cached list of portal roles. This fixes problems with
+  adding users with GenericSetup-created roles.
+  [wichert]
+
+- Fixed our OrderedDict to be unpickable with pickle protocol 2. On
+  unpickling a __init__ method is not called and an optimization in
+  protocol 2 would call __setitem__ without the _list to be initialized.
+  Even using a __getstate__ / __setstate__ combination wouldn't work
+  around that. This change was found in using membrane and
+  MemcachedManager.
+  [hannosch, tesdal]
+
+
+3.7 - 2008-09-28
+----------------
+
+- Removed deprecation zcml statements for PluggableAuthService components:
+  these are now in PluggableAuthService itself.
+  [wichert]
+
+- Adjusted deprecation warnings to point to Plone 4.0 instead of Plone 3.5
+  since we changed the version numbering again.
+  [hannosch]
+
+
+3.6 - 2008-06-25
+----------------
+
+- Modify PloneGroup.getMemberIds to use all IGroupIntrospection plugins
+  to get the group members. This makes it possible to list members in
+  an LDAP group.
+  [wichert]
+
+
+3.5 - 2008-06-25
+----------------
+
+- Make PASSearchView.merge actually merge search results. Its previous
+  behaviour was quite nasty: it preferred search results from the
+  enumeration plugin with the lowest priority!
+  [wichert]
+
+
+3.4 - 2008-03-26
+----------------
+
+- Added BBB code for changed setLoginFormInCookieAuth upgrade method.
+  [hannosch]
+
+- Ignore but log users without passwords during migration from pre-PAS, as
+  these cannot be added to any standard user source.
+  [hannosch]
+
+- Fix listRoleInfo on the role plugin to also lazily update the list
+  of portal roles.
+  [wichert]
+
+3.3 - 2007-03-07
+----------------
+
+- Added metadata.xml file to the profile.
+  [hannosch]
+
+- Move global role lookup out of the local role plugin. Part of the
+  PLIP 127 merge for Plone 3.1.
+  [alecm]
+
+
+3.2 - 2008-02-15
+----------------
+
+- Fix schema handling for ZODBMutablePropertyProvider initialization.
+  [maurits]
+
+- Remove some exception swallowing from the installation logic so errors
+  are not hidden.
+  [hannosch]
+
+- Correct handling an empty roles list when modifying groups.
+  This fixes http://dev.plone.org/plone/ticket/6994
+  [rsantos]
+
+
+3.1 - 2007-10-08
+----------------
+
+- Improve handing of sorting for searches.
+  [csenger]
+
+- Updating the roles for a group did not invalidate the _findGroup cache.
+  [wichert]
+
+- Fixed some tool icons to point to existing icons.
+  [hannosch]
+
+
+3.0 - 2007-08-16
+----------------
+
+- Fix check for authenticateCredentials return value
+  [rossp]
+
+
+3.0rc2 - 2007-07-27
+-------------------
+
+- Fake a getPhysicalPath on our search view so ZCacheing works properly
+  everywhere.
+  [wichert]
+
+- Add event classes for logged-in and logged-out events.
+  [wichert]
+
+
+3.0rc1 - 2007-07-08
+-------------------
+
+- Correct logic in MemberData capability methods: any plugin is
+  allowed to (re)set a password, delete the user or add roles.
+  [wichert]
+
+- Use the proper API to get the containing PAS in the group plugin
+  [wichert]
+
+- Fix setting user properties on the user object.
+  [wichert]
+
+
+3.0b7 - 2007-05-05
+------------------
+
+- Removed the five:registerPackage statement again. It causes problems in a
+  ZEO environment.
+  [hannosch]
+
+- Removed our version of the Plone tool from ToolInit. It won't get an icon
+  anymore and you cannot add it, but existing instances still work. We
+  migrate all instances back to the regular tool anyways.
+  [hannosch]
+
+
+3.0b6 - 2007-05-05
+------------------
+
+- Fixed two migration related test failures.
+  [hannosch]
+
+- Spring cleaning, removed some cruft, pyflaked and corrected some more
+  undefined names.
+  [hannosch]
+
+- New package layout, following standard Python package conventions.
+  [hannosch]
+
+- Fixed tool names in ToolInit, so the permission has a proper name. This
+  closes http://dev.plone.org/plone/ticket/6525.
+  [hannosch]
+
+
+3.0-beta5 - 2007-05-02
+----------------------
+
+- Modify the roles plugin to lazily update its roles list from the portal.
+  [wichert]
+
+- Filter duplicate search results.
+  [laz, wichert]
+
+- Add a sort_by option to the search methods to allow sorting of results
+  by a property.
+  [laz, wichert]
+
+- Modify login method for the cookie plugin to perform the credential
+  update in the PAS of the user instead of the PAS of the plugin. This
+  helps in making sure that users will only authenticate against their
+  own user folder, so we get all their roles, properties, etc. correctly.
+  [wichert]
+
+- Update installation logic to use plone.session for cookies
+  [wichert]
+
+- Add pas_info and pas_search browser views.
+  [wichert]
+
+- Deprecate the PlonePAS PloneTool; its changes have been merged in the
+  standard Plone version.
+  [wichert]
+
+- Use getUtility to get the portal object.
+  [wichert]
+
+- Deprecate user and group searching through CMF member and group tools
+  in favour of PAS enumeration.
+  [wichert]
+
+- Refactor user searching in the membership tool to use standard PAS
+  searches.
+  [wichert]
+
+- Add user enumeration capabilities to the mutable properties plugin.
+  [wichert]
+
+- Add a new automatic group plugin which puts all users in a virtual
+  group. This is useful for permissions handling: since it is not
+  possible to add roles to users with the Authenticated role a
+  virtual group can be used instead.
+  [wichert]
+
+- Added support to import PloneUserFactory and added stub
+  for ZODBMutableProperties. Attention: Latter needs a real
+  export and import! At the moment it do not export the
+  propertysheets. This is a TODO. At least with this two
+  additions PlonePAS import runs. Additional I needed to
+  hack PluginRegistry and and PluggableAuthService slightly.
+  [jensens]
+
+- Added HISTORY.txt and updated version information.
+  [hannosch]
+
+
+2.4 - 2007-04-15
+----------------
+
+- Optomise the local roles plugin for the common case where
+  local_roles is empty
+  [dreamcatcher]
+
+- the plone user was assuming a one to one mapping between property plugin
+  and user property sheet, and stripping away additional ones as part of
+  the retrieval of ordered sheets, instead, it now stores all
+  propertysheets in an ordered dictionary, so this assumption is not needed
+  [k_vertigo]
+
+- More postonly security changes
+  [alecm, ramon]
+
+
+2.3 - 2007-05-30
+----------------
+
+- Use a local postonly decorator so PlonePAS can be used with Plone
+  2.5, 2.5.1 and 2.5.2.
+  [wichert]
+
+- Protect the tools with postonly security modifiers.
+  [mj]
+
+- Update GRUF compatibility functions to use the same security checks
+  as GRUF itself uses.
+  [mj]
+
+- Fix migration to handle properties of selection or multiple selection
+  types.
+  [reinout]
+
+- Correct creation of groups wich default group managers.
+  [dreamcatcher]
+
+- Fix migration from GRUF sites: also include the member properties in the
+  migration.
+  [tesdal]
+
+- Correct the test for creation of groups with the same id as users: search
+  for the exact id, not substrings.
+  [tesdal]
+
+- Fix bad form action which made it impossible to add a plone user factory
+  plugin through the ZMI. Backported from trunk.
+  [wichert]
diff --git a/CHANGES.txt b/CHANGES.txt
deleted file mode 100644
index 3c74db1..0000000
--- a/CHANGES.txt
+++ /dev/null
@@ -1,876 +0,0 @@
-Changelog
-=========
-
-5.0.1 (unreleased)
-------------------
-
-- In searchForMembers, ensure that request parameters are properly
-  decoded to unicode
-  [do3cc]
-
-
-5.0 (2014-04-05)
-----------------
-
-- Do not write member data on read
-  [vangheem]
-
-- Allow ``properties`` to be passed to ``PloneUser.setProperties``.
-  This was previously ignored as ``setProperties`` solely utilised
-  keyword arguments.
-  [davidjb]
-
-
-4.1.2 (2014-01-27)
-------------------
-
-- Don't try to migrate the root user folder if the portal has no parent.
-  [davisagli]
-
-- Use batteries included odict implementation in favour of homegrown one.
-  [tomgross]
-
-- Use correct methods for getting users from id or names
-  [tomgross]
-
-- Ported tests to plone.app.testing
-  [tomgross]
-
-4.1.1 (2013-03-05)
-------------------
-
-- Fix a bug in setSecurityProfile where the login name was passed
-  instead of the user id.
-  [davisagli]
-
-- Added empty updateUser and updateEveryLoginName methods in
-  ZODBMutablePropertyProvider to fulfill the new standards of the
-  IUserEnumerationPlugin.
-  [maurits]
-
-
-4.1 (2013-01-01)
-----------------
-
-- Fix assignRoleToPrincipal to work with new Products.PluggableAuthService 1.10.0.
-  [maurits]
-
-- Fix saving, getting and deleting the user portrait for non-standard
-  user ids like 'bob-jones' or 'bob-jones+test@example.org'.
-  [maurits]
-
-- Fix the test for the current password if the user id differs from
-  the login name.
-  [maurits]
-
-
-4.1a2 (2012-08-29)
-------------------
-
-- Bug fix: User with e-mail login got 'Insufficient Privileges' when
-  trying to delete own portrait. Fixes http://dev.plone.org/ticket/12819.
-  [patch by kagesenshi, applied by kleist]
-
-- MembershipTool.searchForMembers() now preserves sort order.
-  Fixes http://dev.plone.org/ticket/11716.
-  [patch by neaj, applied by kleist]
-
-- Changed deprecated getSiteEncoding to hardcoded `utf-8`
-  [tom_gross]
-
-
-4.1a1 (2012-06-29)
-------------------
-
-- Allow members with usernames that contain special characters
-  (such as @ when use email to login), set their own member portrait
-  [erral]
-
-- PEP8 Cleanup
-  [pbdiode]
-
-- Add a default password validation policy as PAS plugin,
-  see http://dev.plone.org/ticket/10959
-
-- Extensions/Install.py: Don't use list as default argument value
-  to activatePluginInterfaces()
-  [patch by rossp, applied by kleist]
-
-
-4.0.13 (2012-05-07)
--------------------
-
-- Require ListPortalMembers permission for searchForMembers
-  so anonymous users can not get a list of site users.
-  [vangheem]
-
-
-4.0.12 (2012-04-09)
--------------------
-
-- Make sure that during registration you can change your member
-  portrait (if this has been enabled the member registration config).
-  Refs http://dev.plone.org/ticket/5432
-  [maurits]
-
-
-4.0.11 (2012-02-08)
--------------------
-
-- Do some more checks when changing or deleting a member portrait.
-  Fixes http://dev.plone.org/ticket/5432
-  [maurits]
-
-- Pass request along to getGroupsForPrincipal for caching purposes.
-  [esteele]
-
-
-4.0.10 (2012-01-04)
--------------------
-
-- Fixed typo in method name hasOpenIDExtractor, keeping the old name
-  (hasOpenIDdExtractor) around for backwards compatibility.
-  Fixes http://dev.plone.org/ticket/11040
-  [maurits]
-
-
-4.0.9 (2011-11-24)
-------------------
-
-- Avoid a failure when we try to add a role to principal that is managed by
-  an other plugin.
-  [thomasdesvenain]
-
-- Cleaned up and reduced dependencies. New extra ``atstorage`` for the rare case
-  someone uses PlonePAS w/o Plone but with Archetypes (if this is this
-  possible). [jensens]
-
-4.0.8 - 2011-06-30
-------------------
-
-- Fire IPrincipalDeleted when a user is deleted.
-  [stefan, ggozad]
-
-4.0.7 - 2011-05-12
-------------------
-
-- Copy in CleanupTemp from CMFCore as it has been removed from CMFCore 2.3.
-  [elro]
-
-- Move import step to be registered in ZCML rather than XML.
-  Remove the non-existent dependency on `plonepas-content`.
-  [kiorky]
-
-4.0.6 - 2011-02-25
-------------------
-
-- Fix missing and broken security declarations.
-  [davisagli]
-
-4.0.5 - 2011-02-14
-------------------
-
-- Avoid breaking on startup if PIL isn't present.
-  [davisagli]
-
-- Use 'defaultUser.png' as the default user portrait, since the .gif version
-  has been deprecated for a long time now. See
-  http://dev.plone.org/plone/changeset/36350
-  [mj]
-
-4.0.4 - 2011-01-03
-------------------
-
-- Remove plone.openid dependency in setup.py, import errors are already caught
-  in PASInfoView.
-  [elro]
-
-- The code to search by id in mutable_properties.enumerateUsers didn't work at
-  all, an exception was always raised and it was actually a good thing.
-  We tried to implement it in 3.10 and we had strange listing in Plone UI. Then
-  we reverted it in the next version so the behavior was backward compatible
-  with previous versions.
-  If we allow search by id, we can potentially break other part of the code. For
-  example acl_users/portal_role_manager/manage_roles will break because
-  Products.PluggableAuthService.plugins.ZODBRoleManager.listAssignedPrincipals
-  raises MultiplePrincipalError, and maybe it will break somewhere else.
-  Versions 4.0.4 and 3.13 use now the same algorithm.
-  References http://dev.plone.org/plone/ticket/9361
-  [vincenfretin]
-
-- When calling editGroup method, avoid error
-  while trying to remove dynamic 'AuthenticatedUsers' group.
-  [thomasdesvenain]
-
-- In Plone 4.1+, create a Site Administrators group with the new Site
-  Administrator role.
-  [davisagli]
-
-- Fix critical error on groupprefs page
-  when some groups have a non-ascii character in their title.
-  Sort groups on their title normalized.
-  This fixes http://dev.plone.org/plone/ticket/11301
-  [thomasdesvenain]
-
-- Fix interface error: doChangeUser takes a user id as parameter,
-  not a login name.
-  [wichert]
-
-4.0.3 - 2010-09-09
-------------------
-
-- Check we have a REQUEST attribute before accessing it in
-  getRolesForPrincipal.
-  [vincentfretin]
-
-- Use safe_unicode to correctly find users with
-  non-ascii properties, regardless of the sys.defaultencoding.
-  This fixes http://dev.plone.org/plone/ticket/10898
-  [mr_savage]
-
-4.0.2 - 2010-08-08
-------------------
-
-- Made last_login_time logic compatible with DateTime 2.12.5.
-  [hannosch]
-
-4.0.1 - 2010-07-31
-------------------
-
-- Clean up some unused imports and variable assigments.
-  [esteele]
-
-- Stop looking to GRUF to check if group properties can be edited.
-  [esteele]
-
-4.0 - 2010-07-18
-----------------
-
-- Avoid a deprecation warning for the credentialsChanged method.
-  [hannosch]
-
-- Fixed problems with missing user cache invalidation. This closes
-  http://dev.plone.org/plone/ticket/10715.
-  [fafhrd, hannosch]
-
-- Make VirtualGroup inherit from PropertiedUser so it gets wrapped correctly.
-  Have getGroupsForPrincipal not return the AutoGroup as a member of itself.
-  Closes http://dev.plone.org/plone/ticket/10568.
-  [cah190]
-
-- PluggableAuthService expects a list of group ids from getGroups, don't pass a
-  list of wrapped groups instead.
-  [cah190, esteele]
-
-- Added a custom `IMembershipTool` interface to PlonePAS extending the base one
-  from CMFCore. It adds the `getMemberInfo` method to the mix. This closes
-  http://dev.plone.org/plone/ticket/10240.
-  [hannosch]
-
-4.0b9 - 2010-06-03
-------------------
-
-- Fixed a test to no longer use removed Large Plone Folder type.
-  [davisagli]
-
-4.0b8 - 2010-05-01
-------------------
-
-- Removed special unauthorized view workaround, after the underlying issue
-  has been fixed in Zope2.
-  [davisagli, hannosch]
-
-4.0b7 - 2010-04-07
-------------------
-
-- Added manage_setMembersFolderById method for ZMI.
-  Fixes http://dev.plone.org/plone/ticket/10400
-  [daftdog]
-
-4.0b6 - 2010-03-05
-------------------
-
-- Revert incorrect PIL import change.
-  [hannosch]
-
-4.0b5 - 2010-03-03
-------------------
-
-- Install recursive_groups in new sites by default. Make it the last
-  IGroupsPlugin installed.
-  [esteele]
-
-- Remove caching of utils.py's getGroupsForPrincipal method as it was nastily
-  overzealous.
-  [esteele, cah190]
-
-- Use sets instead of util.py's 'unique' method.
-  [esteele]
-
-4.0b4 - 2010-02-18
-------------------
-
-- Properly import from PIL 1.1.7
-  [tom_gross]
-
-- Cache getGroupsForPrincipal per principal id per request (when available).
-  [esteele]
-
-4.0b3 - 2010-01-31
-------------------
-
-- Role plugin's tests no longer subclass (and run all of) ZODBRoleManagerTests
-  as they cannot properly handle the plugin's expectation of finding a
-  PluginRegistry with IGroupsPlugin
-  [erikrose, esteele]
-
-- Revert changes made to ZODBMutablePropertyProvider's enumerateUsers method
-  which prevented lookup of users by id. Some refactoring.
-  Refs http://dev.plone.org/plone/ticket/9361
-  [erikrose, esteele]
-
-- GroupAwareRoleManager now properly computes the roles of deeply-nested
-  principals.
-  [erikrose, esteele]
-
-- Factor up getGroupsForPrincipal call.
-  [erikrose, esteele]
-
-- AutoGroup now implements IPropertiesPlugin to return group title and description.
-  [erikrose, esteele]
-
-- GroupsTool's getGroupsForPrincipal and getGroupMembers now return a list
-  made up of groups/members from all responding plugins instead of just the
-  first responder.
-  [erikrose, esteele]
-
-- Remove GroupData's _gruf_getProperty method, move remaining functionality
-  into getProperty. getProperty now searches for properties in the following
-  places: property sheets directly on the group object, PAS
-  IPropertyProviders, portal_groupdata properties, and attributes on its
-  GroupData entry. It returns the first piece of data found.
-  Closes http://dev.plone.org/plone/ticket/9828
-  [erikrose, esteele]
-
-- Added __ignore_direct_roles__ request flag to getRolesForPrincipal() to
-  permit retrieval of only group-provided (inherited) roles.
-  [cah190]
-
-- getGroupsForPrincipal is a method of PAS' IGroupsPlugin, adjust the groups
-  tool's plugin lookup accordingly.
-  [esteele]
-
-- Rework the group detection of the ZODBMutablePropertyProvider so that
-  enumerateUsers only returns users.
-  [esteele]
-
-- Add, but don't activate, a recursive groups plugin on installation.
-  [esteele]
-
-- Set proper titles for default groups.
-  [esteele]
-
-- Avoid the use of the classImplements helper from PAS. It dealt with the now
-  gone Zope2 Interface variants and is no longer needed.
-  [hannosch]
-
-- Fix a misnamed kwarg in autogroup plugin.
-  [cah190]
-
-- Allow the groups tool's searchForGroups to handle an empty search string as
-  'find all'.
-  [esteele, cah190]
-
-- Allow PASSearchView's searchGroups method to accept a sorting option.
-  [esteele]
-
-- Apply deiter's patch from http://dev.plone.org/plone/ticket/9460 to prevent
-  GroupManager's 'getGroupById' from returning groups managed by other group
-  managers.
-  [esteele]
-
-- GroupsTool.editGroup() now stores title and description in PAS
-  propertysheets in addition to Plone-specific tools. This helps us not pave
-  over group titles with IDs.
-  [erikrose]
-
-- Query the correct keyword variable for the group's description.
-  [esteele]
-
-- Fix an incorrect setdefault syntax.
-  Closes http://dev.plone.org/plone/ticket/7345
-  [esteele]
-
-4.0b2 - 2010-01-02
-------------------
-
-- Don't specify PIL as a direct dependencies. It is not installed as an egg on
-  all platforms.
-  [hannosch]
-
-4.0b1 - 2009-12-27
-------------------
-
-- Fixed package dependencies declaration.
-  [hannosch]
-
-4.0a2 - 2009-12-16
-------------------
-
-- Added backwards compatibility alias for PloneTool to support upgrades from
-  Plone 2.5 to work.
-  [hannosch]
-
-- Added 'has_email' to the info returned by getMemberInfo.
-  Refs http://dev.plone.org/plone/ticket/8707
-  [maurits]
-
-4.0a1 - 2009-11-14
-------------------
-
-- Simplified ``pas_member`` view.  Also return info when no member
-  with the requested id exists, so this can be safely used also to get
-  "member info" for deleted members.
-  [maurits]
-
-- Added new ``pas_member`` view, which provides easy access to the membership
-  tools getMemberInfo method but caches the result on the request.
-  [hannosch]
-
-- Changed the default value of `memberareaCreationFlag` for the membership
-  tool to False, as it was done during Plone site creation so far.
-  [hannosch]
-
-- Removed patch on ZODBUserManager.enumerateUsers which was introduced
-  historical because of a former missing release of PluggableAuthService 1.5.
-  This now superfluous patch also reduced the functionality of the
-  patched method and introduced different behavior compared to i.e in
-  a similar method on LDAPMultiPlugins. For details on the former
-  patch see:
-  http://dev.plone.org/collective/changeset/41512/PlonePAS/trunk/pas.py
-  [jensens]
-
-- Moved a couple DTML files here from CMFPlone that got left out of the earlier
-  refactoring.
-  [davisagli]
-
-- Added a view of the Unauthorized exception which re-raises that exception
-  in order to make sure that it triggers PAS' challenge plugin rather than
-  rendering the standard_error_message.
-  [davisagli]
-
-- Removed deprecation warnings for various methods. These never happened.
-  [hannosch]
-
-- Removed half-done ZCacheable caching for users and groups.
-  [hannosch]
-
-- Removed the CMFDefault dependency of the membership tool. We only need the
-  CMFCore functionality.
-  [hannosch]
-
-- PlonePAS.gruf_support.authenticate method was not breaking out of
-  the loop upon successful authenticateCredentials.
-  [runyaga]
-
-- Changed objectIds and objectValues calls to use the IContainer API.
-  [hannosch]
-
-- Removed parts of the outdated Extensions.Install code.
-  [hannosch]
-
-- Removed a dependency on CMFPlone's `_createObjectByType` method.
-  [hannosch]
-
-- Removed magical `homePageText` lookup for initial memberarea content. You
-  can use the `notifyMemberAreaCreated` hook for any kind of custom behavior.
-  [hannosch]
-
-- Moved the `scale_image` function from CMFPlone.utils into our own utils
-  module, as we are the only user of it. Also made the tests independent of
-  any CMFPlone code.
-  [hannosch]
-
-- Cleaned up package metadata.
-  [hannosch]
-
-- Declare test dependencies in an extra and fixed deprecation warnings
-  for use of Globals.
-  [hannosch]
-
-- Switched the installation progress reporting to the logging framework.
-  [hannosch]
-
-- Cleaned up annoying license headers in all files. We have a central place
-  to state the license.
-  [hannosch]
-
-- Started cleaning up deprecated methods and comments.
-  [hannosch]
-
-- Removed support for group workspaces. This part from GRUF hasn't been
-  supported for many releases anymore.
-  [hannosch]
-
-- Merged all code for the groups tool from GRUF into this package, we are
-  officially GRUF-dependency-free :)
-  [hannosch]
-
-- Merged all code for the group data tool from GRUF into this package.
-  [hannosch]
-
-- Removed the GRUFBridge plugin. PAS inside GRUF isn't supported anymore.
-  [hannosch]
-
-- Merged tests moved from CMFPlone into the same modules as the existing
-  tests and normalized file names.
-  [hannosch]
-
-- Modernized tests and introduce a proper base testcase and layer.
-  [hannosch]
-
-- Removed cookie auth tests, these don't work anymore with plone.session.
-  [hannosch]
-
-- Moved over all tests for the four tools from CMFPlone.
-  [hannosch]
-
-- Removed the user folder migration code and cleaned up tests.
-  [hannosch]
-
-- Moved all code from the four tools from CMFPlone into this package.
-  [hannosch]
-
-- Removed 'listed' member property support from one of the many search
-  functions following Plone.
-  [hannosch]
-
-- Copied setLoginFormInCookieAuth from CMFPlone migrations.
-  [hannosch]
-
-- Purged old Zope 2 Interface interfaces for Zope 2.12 compatibility.
-  (only a test in this case)
-  [elro]
-
-
-3.12 - 2009-10-16
------------------
-
-- Fixed the performance fix again. enumerateUsers from mutable_properties
-  plugin should return all the users if kw is empty. And it returns empty
-  tuple if login or id parameter is used.
-  [vincentfretin]
-
-
-3.11 - 2009-10-05
------------------
-
-- Revert performance fix introduced in 3.10 for the mutable properties plugin.
-  enumerateUsers shouldn't return results if id or login is not None like in
-  3.9 (data dict doesn't contain id or login key, so testMemberData returns
-  always False). The search should be performed only if kw parameter is not
-  empty. This is the new optimization fix.
-  [vincentfretin]
-
-
-3.10 - 2009-09-06
------------------
-
-- Performance fix for searching in the mutable properties plugin:
-  when only searching on user id do not walk over all properties,
-  but only test if the user id is known. This fixes
-  http://dev.plone.org/plone/ticket/9361
-  [toutpt]
-
-- Nested groups are now visible in prefs_group_members. This closes
-  http://dev.plone.org/plone/ticket/8557
-  [vincentfretin]
-
-- Add sort and merge PASSearchView's interface to prevent code duplication.
-  [csenger]
-
-
-3.9 - 2009-04-21
-----------------
-
-- Fix the cookie plugin's login handler to not trust the username
-  from the request. Instead we use the login name of the currently
-  authenticated user. This fixes CVE-2009-0662 (see
-  http://plone.org/products/plone/security/advisories/cve-2009-0662
-  for more information).
-  [wichert]
-
-
-3.8 - 2009-02-13
-----------------
-
-- Update the role manager's assignRoleToPrincipal method to lazily
-  update the cached list of portal roles. This fixes problems with
-  adding users with GenericSetup-created roles.
-  [wichert]
-
-- Fixed our OrderedDict to be unpickable with pickle protocol 2. On
-  unpickling a __init__ method is not called and an optimization in
-  protocol 2 would call __setitem__ without the _list to be initialized.
-  Even using a __getstate__ / __setstate__ combination wouldn't work
-  around that. This change was found in using membrane and
-  MemcachedManager.
-  [hannosch, tesdal]
-
-
-3.7 - 2008-09-28
-----------------
-
-- Removed deprecation zcml statements for PluggableAuthService components:
-  these are now in PluggableAuthService itself.
-  [wichert]
-
-- Adjusted deprecation warnings to point to Plone 4.0 instead of Plone 3.5
-  since we changed the version numbering again.
-  [hannosch]
-
-
-3.6 - 2008-06-25
-----------------
-
-- Modify PloneGroup.getMemberIds to use all IGroupIntrospection plugins
-  to get the group members. This makes it possible to list members in
-  an LDAP group.
-  [wichert]
-
-
-3.5 - 2008-06-25
-----------------
-
-- Make PASSearchView.merge actually merge search results. Its previous
-  behaviour was quite nasty: it preferred search results from the
-  enumeration plugin with the lowest priority!
-  [wichert]
-
-
-3.4 - 2008-03-26
-----------------
-
-- Added BBB code for changed setLoginFormInCookieAuth upgrade method.
-  [hannosch]
-
-- Ignore but log users without passwords during migration from pre-PAS, as
-  these cannot be added to any standard user source.
-  [hannosch]
-
-- Fix listRoleInfo on the role plugin to also lazily update the list
-  of portal roles.
-  [wichert]
-
-3.3 - 2007-03-07
-----------------
-
-- Added metadata.xml file to the profile.
-  [hannosch]
-
-- Move global role lookup out of the local role plugin. Part of the
-  PLIP 127 merge for Plone 3.1.
-  [alecm]
-
-
-3.2 - 2008-02-15
-----------------
-
-- Fix schema handling for ZODBMutablePropertyProvider initialization.
-  [maurits]
-
-- Remove some exception swallowing from the installation logic so errors
-  are not hidden.
-  [hannosch]
-
-- Correct handling an empty roles list when modifying groups.
-  This fixes http://dev.plone.org/plone/ticket/6994
-  [rsantos]
-
-
-3.1 - 2007-10-08
-----------------
-
-- Improve handing of sorting for searches.
-  [csenger]
-
-- Updating the roles for a group did not invalidate the _findGroup cache.
-  [wichert]
-
-- Fixed some tool icons to point to existing icons.
-  [hannosch]
-
-
-3.0 - 2007-08-16
-----------------
-
-- Fix check for authenticateCredentials return value
-  [rossp]
-
-
-3.0rc2 - 2007-07-27
--------------------
-
-- Fake a getPhysicalPath on our search view so ZCacheing works properly
-  everywhere.
-  [wichert]
-
-- Add event classes for logged-in and logged-out events.
-  [wichert]
-
-
-3.0rc1 - 2007-07-08
--------------------
-
-- Correct logic in MemberData capability methods: any plugin is
-  allowed to (re)set a password, delete the user or add roles.
-  [wichert]
-
-- Use the proper API to get the containing PAS in the group plugin
-  [wichert]
-
-- Fix setting user properties on the user object.
-  [wichert]
-
-
-3.0b7 - 2007-05-05
-------------------
-
-- Removed the five:registerPackage statement again. It causes problems in a
-  ZEO environment.
-  [hannosch]
-
-- Removed our version of the Plone tool from ToolInit. It won't get an icon
-  anymore and you cannot add it, but existing instances still work. We
-  migrate all instances back to the regular tool anyways.
-  [hannosch]
-
-
-3.0b6 - 2007-05-05
-------------------
-
-- Fixed two migration related test failures.
-  [hannosch]
-
-- Spring cleaning, removed some cruft, pyflaked and corrected some more
-  undefined names.
-  [hannosch]
-
-- New package layout, following standard Python package conventions.
-  [hannosch]
-
-- Fixed tool names in ToolInit, so the permission has a proper name. This
-  closes http://dev.plone.org/plone/ticket/6525.
-  [hannosch]
-
-
-3.0-beta5 - 2007-05-02
-----------------------
-
-- Modify the roles plugin to lazily update its roles list from the portal.
-  [wichert]
-
-- Filter duplicate search results.
-  [laz, wichert]
-
-- Add a sort_by option to the search methods to allow sorting of results
-  by a property.
-  [laz, wichert]
-
-- Modify login method for the cookie plugin to perform the credential
-  update in the PAS of the user instead of the PAS of the plugin. This
-  helps in making sure that users will only authenticate against their
-  own user folder, so we get all their roles, properties, etc. correctly.
-  [wichert]
-
-- Update installation logic to use plone.session for cookies
-  [wichert]
-
-- Add pas_info and pas_search browser views.
-  [wichert]
-
-- Deprecate the PlonePAS PloneTool; its changes have been merged in the
-  standard Plone version.
-  [wichert]
-
-- Use getUtility to get the portal object.
-  [wichert]
-
-- Deprecate user and group searching through CMF member and group tools
-  in favour of PAS enumeration.
-  [wichert]
-
-- Refactor user searching in the membership tool to use standard PAS
-  searches.
-  [wichert]
-
-- Add user enumeration capabilities to the mutable properties plugin.
-  [wichert]
-
-- Add a new automatic group plugin which puts all users in a virtual
-  group. This is useful for permissions handling: since it is not
-  possible to add roles to users with the Authenticated role a
-  virtual group can be used instead.
-  [wichert]
-
-- Added support to import PloneUserFactory and added stub
-  for ZODBMutableProperties. Attention: Latter needs a real
-  export and import! At the moment it do not export the
-  propertysheets. This is a TODO. At least with this two
-  additions PlonePAS import runs. Additional I needed to
-  hack PluginRegistry and and PluggableAuthService slightly.
-  [jensens]
-
-- Added HISTORY.txt and updated version information.
-  [hannosch]
-
-
-2.4 - 2007-04-15
-----------------
-
-- Optomise the local roles plugin for the common case where
-  local_roles is empty
-  [dreamcatcher]
-
-- the plone user was assuming a one to one mapping between property plugin
-  and user property sheet, and stripping away additional ones as part of
-  the retrieval of ordered sheets, instead, it now stores all
-  propertysheets in an ordered dictionary, so this assumption is not needed
-  [k_vertigo]
-
-- More postonly security changes
-  [alecm, ramon]
-
-
-2.3 - 2007-05-30
-----------------
-
-- Use a local postonly decorator so PlonePAS can be used with Plone
-  2.5, 2.5.1 and 2.5.2.
-  [wichert]
-
-- Protect the tools with postonly security modifiers.
-  [mj]
-
-- Update GRUF compatibility functions to use the same security checks
-  as GRUF itself uses.
-  [mj]
-
-- Fix migration to handle properties of selection or multiple selection
-  types.
-  [reinout]
-
-- Correct creation of groups wich default group managers.
-  [dreamcatcher]
-
-- Fix migration from GRUF sites: also include the member properties in the
-  migration.
-  [tesdal]
-
-- Correct the test for creation of groups with the same id as users: search
-  for the exact id, not substrings.
-  [tesdal]
-
-- Fix bad form action which made it impossible to add a plone user factory
-  plugin through the ZMI. Backported from trunk.
-  [wichert]
diff --git a/Products/PlonePAS/__init__.py b/Products/PlonePAS/__init__.py
index 5a98e20..1911708 100644
--- a/Products/PlonePAS/__init__.py
+++ b/Products/PlonePAS/__init__.py
@@ -1,48 +1,47 @@
+# -*- coding: utf-8 -*-
 from AccessControl.Permissions import add_user_folders
 from Products.CMFCore.utils import ToolInit
+from Products.PlonePAS import config
+from Products.PlonePAS import pas
+from Products.PlonePAS.plugins import autogroup
+from Products.PlonePAS.plugins import cookie_handler
+from Products.PlonePAS.plugins import crumbler
+from Products.PlonePAS.plugins import group
+from Products.PlonePAS.plugins import local_role
+from Products.PlonePAS.plugins import passwordpolicy
+from Products.PlonePAS.plugins import property
+from Products.PlonePAS.plugins import role
+from Products.PlonePAS.plugins import ufactory
+from Products.PlonePAS.plugins import user
+from Products.PlonePAS.tools.groupdata import GroupDataTool
+from Products.PlonePAS.tools.groups import GroupsTool
+from Products.PlonePAS.tools.memberdata import MemberDataTool
+from Products.PlonePAS.tools.membership import MembershipTool
 from Products.PluggableAuthService import registerMultiPlugin
 
-import config
-
-#################################
-# plugins
-from plugins import user
-from plugins import group
-from plugins import role
-from plugins import local_role
-from plugins import ufactory
-from plugins import property
-from plugins import crumbler
-from plugins import cookie_handler
-from plugins import autogroup
-from plugins import passwordpolicy
-
-#################################
-# pas monkies
-import pas
-
 #################################
 # ldapmp monkies if available
-
+# quite dirty, must be moved to PloneLDAP
 try:
     from Products import LDAPMultiPlugins
     from Products import LDAPUserFolder
 except ImportError:
     pass
 else:
-    import ldapmp
+    from Products.PlonePAS import  ldapmp
 
 #################################
 # pas monkies 2 play w/ gruf
 if config.PAS_INSIDE_GRUF:
-    import gruf_support
+    from Products.PlonePAS import gruf_support
+
+
+####################################
+# monkey patch pas, the evil happens
+pas.patch_all()
 
 #################################
 # new groups tool
-from tools.membership import MembershipTool
-from tools.memberdata import MemberDataTool
-from tools.groups import GroupsTool
-from tools.groupdata import GroupDataTool
 
 #################################
 # register plugins with pas
@@ -56,7 +55,7 @@
     registerMultiPlugin(crumbler.CookieCrumblingPlugin.meta_type)
     registerMultiPlugin(cookie_handler.ExtendedCookieAuthHelper.meta_type)
     registerMultiPlugin(autogroup.AutoGroup.meta_type)
-    registerMultiPlugin( passwordpolicy.PasswordPolicyPlugin.meta_type )
+    registerMultiPlugin(passwordpolicy.PasswordPolicyPlugin.meta_type)
 except RuntimeError:
     # make refresh users happy
     pass
@@ -66,83 +65,100 @@ def initialize(context):
 
     tools = (GroupsTool, GroupDataTool, MembershipTool, MemberDataTool)
 
-    ToolInit('PlonePAS Tool',
-                         tools=tools,
-                         icon='tool.gif',
-                         ).initialize(context)
-
-    context.registerClass(role.GroupAwareRoleManager,
-                          permission=add_user_folders,
-                          constructors=(
-                              role.manage_addGroupAwareRoleManagerForm,
-                              role.manage_addGroupAwareRoleManager),
-                          visibility=None
-                          )
-
-    context.registerClass(user.UserManager,
-                          permission=add_user_folders,
-                          constructors=(user.manage_addUserManagerForm,
-                                        user.manage_addUserManager),
-                          visibility=None
-                          )
-
-    context.registerClass(group.GroupManager,
-                          permission=add_user_folders,
-                          constructors=(group.manage_addGroupManagerForm,
-                                        group.manage_addGroupManager),
-                          visibility=None
-                          )
-
-    context.registerClass(ufactory.PloneUserFactory,
-                          permission=add_user_folders,
-                          constructors=(
-                              ufactory.manage_addPloneUserFactoryForm,
-                              ufactory.manage_addPloneUserFactory),
-                          visibility=None
-                          )
-
-    context.registerClass(local_role.LocalRolesManager,
-                          permission=add_user_folders,
-                          constructors=(
-                              local_role.manage_addLocalRolesManagerForm,
-                              local_role.manage_addLocalRolesManager),
-                          visibility=None
-                          )
-
-    context.registerClass(property.ZODBMutablePropertyProvider,
-                          permission=add_user_folders,
-                          constructors=(
-                            property.manage_addZODBMutablePropertyProviderForm,
-                            property.manage_addZODBMutablePropertyProvider),
-                          visibility=None
-                          )
-
-    context.registerClass(crumbler.CookieCrumblingPlugin,
-                          permission=add_user_folders,
-                          constructors=(
-                              crumbler.manage_addCookieCrumblingPluginForm,
-                              crumbler.manage_addCookieCrumblingPlugin),
-                          visibility=None
-                          )
-
-    context.registerClass(cookie_handler.ExtendedCookieAuthHelper,
-                          permission=add_user_folders,
-                          constructors=(
-                            cookie_handler.manage_addExtendedCookieAuthHelperForm,
-                            cookie_handler.manage_addExtendedCookieAuthHelper),
-                          visibility=None
-                          )
-
-    context.registerClass(autogroup.AutoGroup,
-                          permission=add_user_folders,
-                          constructors=(autogroup.manage_addAutoGroupForm,
-                                        autogroup.manage_addAutoGroup),
-                          visibility=None
-                          )
-
-    context.registerClass( passwordpolicy.PasswordPolicyPlugin,
-                           permission = add_user_folders,
-                           constructors = ( passwordpolicy.manage_addPasswordPolicyForm,
-                                            passwordpolicy.manage_addPasswordPolicyPlugin ),
-                           visibility = None
-                           )
+    ToolInit(
+        'PlonePAS Tool',
+        tools=tools,
+        icon='tool.gif',
+    ).initialize(context)
+
+    context.registerClass(
+        role.GroupAwareRoleManager,
+        permission=add_user_folders,
+        constructors=(
+            role.manage_addGroupAwareRoleManagerForm,
+            role.manage_addGroupAwareRoleManager),
+        visibility=None
+    )
+
+    context.registerClass(
+        user.UserManager,
+        permission=add_user_folders,
+        constructors=(
+            user.manage_addUserManagerForm,
+            user.manage_addUserManager),
+        visibility=None
+    )
+
+    context.registerClass(
+        group.GroupManager,
+        permission=add_user_folders,
+        constructors=(
+            group.manage_addGroupManagerForm,
+            group.manage_addGroupManager
+        ),
+        visibility=None
+    )
+
+    context.registerClass(
+        ufactory.PloneUserFactory,
+        permission=add_user_folders,
+        constructors=(
+            ufactory.manage_addPloneUserFactoryForm,
+            ufactory.manage_addPloneUserFactory),
+        visibility=None
+    )
+
+    context.registerClass(
+        local_role.LocalRolesManager,
+        permission=add_user_folders,
+        constructors=(
+            local_role.manage_addLocalRolesManagerForm,
+            local_role.manage_addLocalRolesManager),
+        visibility=None
+    )
+
+    context.registerClass(
+        property.ZODBMutablePropertyProvider,
+        permission=add_user_folders,
+        constructors=(
+            property.manage_addZODBMutablePropertyProviderForm,
+            property.manage_addZODBMutablePropertyProvider),
+        visibility=None
+    )
+
+    context.registerClass(
+        crumbler.CookieCrumblingPlugin,
+        permission=add_user_folders,
+        constructors=(
+            crumbler.manage_addCookieCrumblingPluginForm,
+            crumbler.manage_addCookieCrumblingPlugin),
+        visibility=None
+    )
+
+    context.registerClass(
+        cookie_handler.ExtendedCookieAuthHelper,
+        permission=add_user_folders,
+        constructors=(
+            cookie_handler.manage_addExtendedCookieAuthHelperForm,
+            cookie_handler.manage_addExtendedCookieAuthHelper),
+        visibility=None
+    )
+
+    context.registerClass(
+        autogroup.AutoGroup,
+        permission=add_user_folders,
+        constructors=(
+            autogroup.manage_addAutoGroupForm,
+            autogroup.manage_addAutoGroup),
+        visibility=None
+    )
+
+    context.registerClass(
+        passwordpolicy.PasswordPolicyPlugin,
+        permission=add_user_folders,
+        constructors=(
+            passwordpolicy.manage_addPasswordPolicyForm,
+            passwordpolicy.manage_addPasswordPolicyPlugin
+        ),
+        visibility=None
+    )
diff --git a/Products/PlonePAS/config.py b/Products/PlonePAS/config.py
index a8ccf5f..1d4e134 100644
--- a/Products/PlonePAS/config.py
+++ b/Products/PlonePAS/config.py
@@ -1,12 +1,15 @@
+# -*- coding: utf-8 -*-
 PROJECTNAME = 'PlonePAS'
 GLOBALS = globals()
 
 PAS_INSIDE_GRUF = True
 
 DEFAULT_CHALLENGE_PROTOCOL = ['http']
-DEFAULT_PROTO_MAPPING = {'WebDAV': DEFAULT_CHALLENGE_PROTOCOL,
-                         'FTP': DEFAULT_CHALLENGE_PROTOCOL,
-                         'XML-RPC': DEFAULT_CHALLENGE_PROTOCOL}
+DEFAULT_PROTO_MAPPING = {
+    'WebDAV': DEFAULT_CHALLENGE_PROTOCOL,
+    'FTP': DEFAULT_CHALLENGE_PROTOCOL,
+    'XML-RPC': DEFAULT_CHALLENGE_PROTOCOL
+}
 
 # Settings for member image resize quality
 try:
@@ -17,7 +20,9 @@
 
 PIL_QUALITY = 88
 MEMBER_IMAGE_SCALE = (75, 100)
-IMAGE_SCALE_PARAMS = {'scale': MEMBER_IMAGE_SCALE,
-                      'quality': PIL_QUALITY,
-                      'algorithm': PIL_SCALING_ALGO,
-                      'default_format': 'PNG'}
+IMAGE_SCALE_PARAMS = {
+    'scale': MEMBER_IMAGE_SCALE,
+    'quality': PIL_QUALITY,
+    'algorithm': PIL_SCALING_ALGO,
+    'default_format': 'PNG'
+}
diff --git a/Products/PlonePAS/configure.zcml b/Products/PlonePAS/configure.zcml
index 4527549..f326d9e 100644
--- a/Products/PlonePAS/configure.zcml
+++ b/Products/PlonePAS/configure.zcml
@@ -1,30 +1,26 @@
-<configure xmlns="http://namespaces.zope.org/zope"
-    xmlns:genericsetup="http://namespaces.zope.org/genericsetup"
+<configure
+    i18n_domain="plone"
+    xmlns="http://namespaces.zope.org/zope"
     xmlns:five="http://namespaces.zope.org/five"
-    xmlns:i18n="http://namespaces.zope.org/i18n"
-    i18n_domain="plone">
+    xmlns:genericsetup="http://namespaces.zope.org/genericsetup"
+    xmlns:i18n="http://namespaces.zope.org/i18n">
 
   <include package=".browser" />
-
-  <include file="profiles.zcml"/>
-
+  <include file="profiles.zcml" />
   <include file="exportimport.zcml" />
 
   <genericsetup:importStep
-      name="plonepas"
-      title="PlonePAS setup"
       description="Configure PlonePas"
-      handler="Products.PlonePAS.setuphandlers.setupPlonePAS">
-    <depends name="componentregistry"/>
-    <depends name="controlpanel"/>
-    <depends name="memberdata-properties"/>
-    <depends name="rolemap"/>
+      handler="Products.PlonePAS.setuphandlers.setupPlonePAS"
+      name="plonepas"
+      title="PlonePAS setup">
+    <depends name="componentregistry" />
+    <depends name="controlpanel" />
+    <depends name="memberdata-properties" />
+    <depends name="rolemap" />
   </genericsetup:importStep>
 
-  <five:deprecatedManageAddDelete
-      class=".plugins.cookie_handler.ExtendedCookieAuthHelper" />
-
-  <five:deprecatedManageAddDelete
-      class=".plugins.role.GroupAwareRoleManager" />
+  <five:deprecatedManageAddDelete class=".plugins.cookie_handler.ExtendedCookieAuthHelper" />
+  <five:deprecatedManageAddDelete class=".plugins.role.GroupAwareRoleManager" />
 
 </configure>
diff --git a/Products/PlonePAS/events.py b/Products/PlonePAS/events.py
index 41b6394..79c2433 100644
--- a/Products/PlonePAS/events.py
+++ b/Products/PlonePAS/events.py
@@ -1,18 +1,30 @@
-from Products.PluggableAuthService.interfaces.events import IUserLoggedInEvent
-from Products.PluggableAuthService.interfaces.events import IUserLoggedOutEvent
+# -*- coding: utf-8 -*-
 from Products.PlonePAS.interfaces.events import IUserInitialLoginInEvent
 from Products.PluggableAuthService.events import PASEvent
-from zope.interface import implements
+from Products.PluggableAuthService.interfaces.events import IUserLoggedInEvent
+from Products.PluggableAuthService.interfaces.events import IUserLoggedOutEvent
+from zope.interface import implementer
 
+
+@implementer(IUserLoggedInEvent)
 class UserLoggedInEvent(PASEvent):
-    implements(IUserLoggedInEvent)
+    """Plone Implementation of the logged in event
+
+    PAS Event
+    """
 
 
+@implementer(IUserInitialLoginInEvent)
 class UserInitialLoginInEvent(UserLoggedInEvent):
-    implements(IUserInitialLoginInEvent)
+    """Implementation of the initial logged in event
 
+    Plone only event!
+    """
 
-class UserLoggedOutEvent(PASEvent):
-    implements(IUserLoggedOutEvent)
 
+@implementer(IUserLoggedOutEvent)
+class UserLoggedOutEvent(PASEvent):
+    """Plone Implementation of the logged out event
 
+    PAS Event
+    """
diff --git a/Products/PlonePAS/exportimport.zcml b/Products/PlonePAS/exportimport.zcml
index 09968e8..ae6fa67 100644
--- a/Products/PlonePAS/exportimport.zcml
+++ b/Products/PlonePAS/exportimport.zcml
@@ -2,25 +2,25 @@
 
   <adapter
       factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
-      provides="Products.GenericSetup.interfaces.IFilesystemExporter"
       for="Products.PluggableAuthService.interfaces.plugins.IUserFactoryPlugin"
-      />
+      provides="Products.GenericSetup.interfaces.IFilesystemExporter"
+  />
   <adapter
       factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
-      provides="Products.GenericSetup.interfaces.IFilesystemImporter"
       for="Products.PluggableAuthService.interfaces.plugins.IUserFactoryPlugin"
-      /> 
+      provides="Products.GenericSetup.interfaces.IFilesystemImporter"
+  />
 
-<!-- XXX This should point to an own export/import class! TitleOnly is far not enough -->
+  <!-- XXX This should point to an own export/import class! TitleOnly is far not enough -->
   <adapter
       factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
-      provides="Products.GenericSetup.interfaces.IFilesystemExporter"
       for="Products.PlonePAS.interfaces.plugins.IMutablePropertiesPlugin"
-      />
+      provides="Products.GenericSetup.interfaces.IFilesystemExporter"
+  />
   <adapter
       factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
-      provides="Products.GenericSetup.interfaces.IFilesystemImporter"
       for="Products.PlonePAS.interfaces.plugins.IMutablePropertiesPlugin"
-      /> 
+      provides="Products.GenericSetup.interfaces.IFilesystemImporter"
+  />
 
 </configure>
diff --git a/Products/PlonePAS/gruf_support.py b/Products/PlonePAS/gruf_support.py
index d6417c7..37a0fe5 100644
--- a/Products/PlonePAS/gruf_support.py
+++ b/Products/PlonePAS/gruf_support.py
@@ -1,15 +1,15 @@
+# -*- coding: utf-8 -*-
 # gruf specific hacks to pas, to make it play well in gruf
-
-import logging
-
-from Products.PluggableAuthService.PluggableAuthService import \
-          PluggableAuthService, _SWALLOWABLE_PLUGIN_EXCEPTIONS
-from Products.PluggableAuthService.interfaces.plugins \
-     import IAuthenticationPlugin
+from Products.CMFCore.utils import getToolByName
 from Products.PlonePAS.interfaces.group import IGroupManagement
 from Products.PlonePAS.interfaces.plugins import IUserIntrospection
-
-from Products.CMFCore.utils import getToolByName
+from Products.PluggableAuthService.PluggableAuthService import \
+    PluggableAuthService
+from Products.PluggableAuthService.PluggableAuthService import \
+    _SWALLOWABLE_PLUGIN_EXCEPTIONS
+from Products.PluggableAuthService.interfaces.plugins import \
+    IAuthenticationPlugin
+import logging
 
 logger = logging.getLogger('PlonePAS')
 
diff --git a/Products/PlonePAS/ldapmp.py b/Products/PlonePAS/ldapmp.py
index 9c4522e..751bacb 100644
--- a/Products/PlonePAS/ldapmp.py
+++ b/Products/PlonePAS/ldapmp.py
@@ -1,7 +1,9 @@
-from Products.PlonePAS.patch import call, wrap_method
-from Products.PlonePAS.plugins.group import PloneGroup
-from Products.LDAPMultiPlugins.LDAPPluginBase import LDAPPluginBase
+# -*- coding: utf-8 -*-
 from Products.LDAPMultiPlugins.LDAPMultiPlugin import LDAPMultiPlugin
+from Products.LDAPMultiPlugins.LDAPPluginBase import LDAPPluginBase
+from Products.PlonePAS.patch import call
+from Products.PlonePAS.patch import wrap_method
+from Products.PlonePAS.plugins.group import PloneGroup
 
 GROUP_PROPERTY_MAP = {
     # target property: (possible key, ...)
diff --git a/Products/PlonePAS/pas.py b/Products/PlonePAS/pas.py
index e22f98f..a8c3145 100644
--- a/Products/PlonePAS/pas.py
+++ b/Products/PlonePAS/pas.py
@@ -1,36 +1,36 @@
+# -*- coding: utf-8 -*-
 # pas alterations and monkies
-from zope.event import notify
-
-from Products.CMFCore.utils import getToolByName
-
-from AccessControl import Unauthorized, getSecurityManager
-from AccessControl.Permissions import manage_users as ManageUsers
-from AccessControl.Permissions import manage_properties, change_permissions
+from AccessControl import Unauthorized
+from AccessControl import getSecurityManager
 from AccessControl.PermissionRole import PermissionRole
-
-from Products.PluggableAuthService.PluggableAuthService import \
-     PluggableAuthService, _SWALLOWABLE_PLUGIN_EXCEPTIONS
-from Products.PluggableAuthService.interfaces.plugins \
-    import IRoleAssignerPlugin
-from Products.PluggableAuthService.interfaces.plugins \
-    import IUserEnumerationPlugin
-from Products.PluggableAuthService.interfaces.plugins \
-    import IGroupEnumerationPlugin
-from Products.PluggableAuthService.events import PrincipalDeleted
-
-from Products.PlonePAS.interfaces.plugins \
-    import IUserManagement, ILocalRolesPlugin
+from AccessControl.Permissions import change_permissions
+from AccessControl.Permissions import manage_properties
+from AccessControl.Permissions import manage_users as ManageUsers
+from AccessControl.requestmethod import postonly
+from OFS.Folder import Folder
+from Products.CMFCore.utils import getToolByName
+from Products.CMFCore.utils import registerToolInterface
 from Products.PlonePAS.interfaces.group import IGroupIntrospection
+from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
 from Products.PlonePAS.interfaces.plugins import IUserIntrospection
-from AccessControl.requestmethod import postonly
+from Products.PlonePAS.interfaces.plugins import IUserManagement
+from Products.PluggableAuthService.PluggableAuthService import \
+    PluggableAuthService
+from Products.PluggableAuthService.PluggableAuthService import \
+    _SWALLOWABLE_PLUGIN_EXCEPTIONS
+from Products.PluggableAuthService.events import PrincipalDeleted
+from Products.PluggableAuthService.interfaces.authservice import \
+    IPluggableAuthService
+from Products.PluggableAuthService.interfaces.plugins import \
+    IGroupEnumerationPlugin
+from Products.PluggableAuthService.interfaces.plugins import \
+    IRoleAssignerPlugin
+from Products.PluggableAuthService.interfaces.plugins import \
+    IUserEnumerationPlugin
+from zope.event import notify
 
-# Register the PAS acl_users as a utility
-from Products.CMFCore.utils import registerToolInterface
-from Products.PluggableAuthService.interfaces.authservice \
-    import IPluggableAuthService
 registerToolInterface('acl_users', IPluggableAuthService)
 
-
 #################################
 # pas folder monkies - standard zope user folder api
 
@@ -44,8 +44,6 @@ def _doAddUser(self, login, password, roles, domains, groups=None, **kw):
         self.userSetGroups(login, groups)
     return retval
 
-PluggableAuthService._doAddUser = _doAddUser
-
 
 def _doDelUsers(self, names, REQUEST=None):
     """
@@ -55,8 +53,6 @@ def _doDelUsers(self, names, REQUEST=None):
     for name in names:
         self._doDelUser(name)
 
-PluggableAuthService._doDelUsers = _doDelUsers
-
 
 def _doDelUser(self, id):
     """
@@ -66,8 +62,9 @@ def _doDelUser(self, id):
     userdeleters = plugins.listPlugins(IUserManagement)
 
     if not userdeleters:
-        raise NotImplementedError("There is no plugin that can "
-                                   " delete users.")
+        raise NotImplementedError(
+            "There is no plugin that can delete users."
+        )
 
     for userdeleter_id, userdeleter in userdeleters:
         try:
@@ -78,14 +75,6 @@ def _doDelUser(self, id):
             notify(PrincipalDeleted(id))
 
 
-PluggableAuthService._doDelUser = _doDelUser
-
-PluggableAuthService.userFolderDelUsers = \
-    postonly(PluggableAuthService._doDelUsers)
-PluggableAuthService.userFolderDelUsers__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
-
 def _doChangeUser(self, principal_id, password, roles, domains=(), groups=None,
                   REQUEST=None, **kw):
     """
@@ -113,13 +102,6 @@ def _doChangeUser(self, principal_id, password, roles, domains=(), groups=None,
 
     return True
 
-PluggableAuthService._doChangeUser = _doChangeUser
-
-PluggableAuthService.userFolderEditUser = \
-    postonly(PluggableAuthService._doChangeUser)
-PluggableAuthService.userFolderEditUser__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
 
 def userFolderAddUser(self, login, password, roles, domains,
                       groups=None, REQUEST=None, **kw):
@@ -127,17 +109,11 @@ def userFolderAddUser(self, login, password, roles, domains,
     if groups is not None:
         self.userSetGroups(login, groups)
 
-PluggableAuthService.userFolderAddUser = postonly(userFolderAddUser)
-PluggableAuthService.userFolderAddUser__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
 
 def _doAddGroup(self, id, roles, groups=None, **kw):
     gtool = getToolByName(self, 'portal_groups')
     return gtool.addGroup(id, roles, groups, **kw)
 
-PluggableAuthService._doAddGroup = _doAddGroup
-
 
 # for prefs_group_manage compatibility. really should be using tool.
 def _doDelGroups(self, names, REQUEST=None):
@@ -145,13 +121,6 @@ def _doDelGroups(self, names, REQUEST=None):
     for group_id in names:
         gtool.removeGroup(group_id)
 
-PluggableAuthService._doDelGroups = _doDelGroups
-
-PluggableAuthService.userFolderDelGroups = \
-    postonly(PluggableAuthService._doDelGroups)
-PluggableAuthService.userFolderDelGroups__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
 
 def _doChangeGroup(self, principal_id, roles, groups=None, REQUEST=None, **kw):
     """
@@ -164,8 +133,6 @@ def _doChangeGroup(self, principal_id, roles, groups=None, REQUEST=None, **kw):
     gtool.editGroup(principal_id, roles, groups, **kw)
     return True
 
-PluggableAuthService._doChangeGroup = _doChangeGroup
-
 
 def _updateGroup(self, principal_id, roles=None, groups=None, **kw):
     """
@@ -177,40 +144,21 @@ def _updateGroup(self, principal_id, roles=None, groups=None, **kw):
     """
     return self._doChangeGroup(principal_id, roles, groups, **kw)
 
-PluggableAuthService._updateGroup = _updateGroup
-
-PluggableAuthService.userFolderEditGroup = \
-    postonly(PluggableAuthService._doChangeGroup)
-PluggableAuthService.userFolderEditGroup__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
 
 def getGroups(self):
     gtool = getToolByName(self, 'portal_groups')
     return gtool.listGroups()
 
-PluggableAuthService.getGroups = getGroups
-PluggableAuthService.getGroups__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
 
 def getGroupNames(self):
     gtool = getToolByName(self, 'portal_groups')
     return gtool.getGroupIds()
 
-PluggableAuthService.getGroupNames = getGroupNames
-PluggableAuthService.getGroupNames__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
 
 def getGroupIds(self):
     gtool = getToolByName(self, 'portal_groups')
     return gtool.getGroupIds()
 
-PluggableAuthService.getGroupIds = getGroupIds
-PluggableAuthService.getGroupIds__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
 
 def getGroup(self, group_id):
     """Like getGroupById in groups tool, but doesn't wrap.
@@ -226,10 +174,6 @@ def getGroup(self, group_id):
             break
     return group
 
-PluggableAuthService.getGroup = getGroup
-PluggableAuthService.getGroup__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
 
 def getGroupByName(self, name, default=None):
     ret = self.getGroup(name)
@@ -237,10 +181,6 @@ def getGroupByName(self, name, default=None):
         return default
     return ret
 
-PluggableAuthService.getGroupByName = getGroupByName
-PluggableAuthService.getGroupByName__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
 
 def getGroupById(self, id, default=None):
     gtool = getToolByName(self, "portal_groups")
@@ -250,10 +190,6 @@ def getGroupById(self, id, default=None):
     else:
         return ret
 
-PluggableAuthService.getGroupById = getGroupById
-PluggableAuthService.getGroupById__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
 
 def getLocalRolesForDisplay(self, object):
     """This is used for plone's local roles display
@@ -271,8 +207,6 @@ def getLocalRolesForDisplay(self, object):
 
     return self._getLocalRolesForDisplay(object)
 
-PluggableAuthService.getLocalRolesForDisplay = getLocalRolesForDisplay
-
 
 def _getLocalRolesForDisplay(self, object):
     result = []
@@ -292,8 +226,6 @@ def _getLocalRolesForDisplay(self, object):
         result.append((username, roles, userType, userid))
     return tuple(result)
 
-PluggableAuthService._getLocalRolesForDisplay = _getLocalRolesForDisplay
-
 
 def getUsers(self):
     """
@@ -314,13 +246,6 @@ def getUsers(self):
 
     return retval
 
-PluggableAuthService.getUsers = getUsers
-PluggableAuthService.getUsers__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-PluggableAuthService.getPureUsers = getUsers   # this'll make listMembers work
-PluggableAuthService.getPureUsers__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
 
 def canListAllUsers(self):
     plugins = self._getOb('plugins')
@@ -331,10 +256,6 @@ def canListAllUsers(self):
         return False
     return True
 
-PluggableAuthService.canListAllUsers = canListAllUsers
-PluggableAuthService.canListAllUsers__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
 
 def canListAllGroups(self):
     plugins = self._getOb('plugins')
@@ -345,10 +266,6 @@ def canListAllGroups(self):
         return False
     return True
 
-PluggableAuthService.canListAllGroups = canListAllGroups
-PluggableAuthService.canListAllGroups__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
 
 def userSetPassword(self, userid, password):
     """Emulate GRUF 3 call for password set, for use with PwRT."""
@@ -373,10 +290,6 @@ def userSetPassword(self, userid, password):
         raise RuntimeError("No user management plugins were able "
                            "to successfully modify the user")
 
-PluggableAuthService.userSetPassword = userSetPassword
-PluggableAuthService.userSetPassword__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
 
 def credentialsChanged(self, user, name, new_password):
     """Notifies the authentication mechanism that this user has changed
@@ -392,17 +305,10 @@ def credentialsChanged(self, user, name, new_password):
 
     self.updateCredentials(request, response, login, new_password)
 
-PluggableAuthService.credentialsChanged = credentialsChanged
-PluggableAuthService.credentialsChanged__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
 
 # for ZopeVersionControl, we need to check 'plugins' for more than
 # existence, since it replaces objects (like 'plugins') with SimpleItems
 # and calls _delOb, which tries to use special methods of 'plugins'
-from OFS.Folder import Folder
-
-
 def _delOb(self, id):
     #
     #   Override ObjectManager's version to clean up any plugin
@@ -417,8 +323,6 @@ def _delOb(self, id):
 
     Folder._delOb(self, id)
 
-PluggableAuthService._delOb = _delOb
-
 
 def addRole(self, role):
     plugins = self._getOb('plugins')
@@ -431,10 +335,6 @@ def addRole(self, role):
         except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
             pass
 
-PluggableAuthService.addRole = addRole
-PluggableAuthService.addRole__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
 
 def getAllLocalRoles(self, context):
     # Perform security check on destination object
@@ -442,8 +342,6 @@ def getAllLocalRoles(self, context):
         raise Unauthorized(name="getAllLocalRoles")
     return self._getAllLocalRoles(context)
 
-PluggableAuthService.getAllLocalRoles = getAllLocalRoles
-
 
 def _getAllLocalRoles(self, context):
     plugins = self._getOb('plugins')
@@ -459,4 +357,108 @@ def _getAllLocalRoles(self, context):
 
     return roles
 
-PluggableAuthService._getAllLocalRoles = _getAllLocalRoles
+
+def patch_all():
+    PluggableAuthService._doAddUser = _doAddUser
+    PluggableAuthService._doDelUsers = _doDelUsers
+
+    PluggableAuthService._doDelUser = _doDelUser
+
+    PluggableAuthService.userFolderDelUsers = postonly(
+        PluggableAuthService._doDelUsers
+    )
+    PluggableAuthService.userFolderDelUsers__roles__ = PermissionRole(
+        ManageUsers,
+        ('Manager',)
+    )
+    PluggableAuthService._doChangeUser = _doChangeUser
+
+    PluggableAuthService.userFolderEditUser = postonly(
+        PluggableAuthService._doChangeUser
+    )
+    PluggableAuthService.userFolderEditUser__roles__ = PermissionRole(
+        ManageUsers,
+        ('Manager',)
+    )
+    PluggableAuthService.userFolderAddUser = postonly(userFolderAddUser)
+    PluggableAuthService.userFolderAddUser__roles__ = \
+        PermissionRole(ManageUsers, ('Manager',))
+
+    PluggableAuthService._doAddGroup = _doAddGroup
+
+    PluggableAuthService._doDelGroups = _doDelGroups
+
+    PluggableAuthService.userFolderDelGroups = \
+        postonly(PluggableAuthService._doDelGroups)
+    PluggableAuthService.userFolderDelGroups__roles__ = \
+        PermissionRole(ManageUsers, ('Manager',))
+
+    PluggableAuthService._doChangeGroup = _doChangeGroup
+
+    PluggableAuthService._updateGroup = _updateGroup
+
+    PluggableAuthService.userFolderEditGroup = \
+        postonly(PluggableAuthService._doChangeGroup)
+    PluggableAuthService.userFolderEditGroup__roles__ = \
+        PermissionRole(ManageUsers, ('Manager',))
+
+    PluggableAuthService.getGroups = getGroups
+    PluggableAuthService.getGroups__roles__ = \
+        PermissionRole(ManageUsers, ('Manager',))
+
+    PluggableAuthService.getGroupNames = getGroupNames
+    PluggableAuthService.getGroupNames__roles__ = \
+        PermissionRole(ManageUsers, ('Manager',))
+
+    PluggableAuthService.getGroupIds = getGroupIds
+    PluggableAuthService.getGroupIds__roles__ = \
+        PermissionRole(ManageUsers, ('Manager',))
+
+    PluggableAuthService.getGroup = getGroup
+    PluggableAuthService.getGroup__roles__ = \
+        PermissionRole(ManageUsers, ('Manager',))
+
+    PluggableAuthService.getGroupByName = getGroupByName
+    PluggableAuthService.getGroupByName__roles__ = \
+        PermissionRole(ManageUsers, ('Manager',))
+
+    PluggableAuthService.getGroupById = getGroupById
+    PluggableAuthService.getGroupById__roles__ = \
+        PermissionRole(ManageUsers, ('Manager',))
+
+    PluggableAuthService.getLocalRolesForDisplay = getLocalRolesForDisplay
+    PluggableAuthService._getLocalRolesForDisplay = _getLocalRolesForDisplay
+
+    PluggableAuthService.getUsers = getUsers
+    PluggableAuthService.getUsers__roles__ = \
+        PermissionRole(ManageUsers, ('Manager',))
+
+    # this'll make listMembers work
+    PluggableAuthService.getPureUsers = getUsers
+    PluggableAuthService.getPureUsers__roles__ = \
+        PermissionRole(ManageUsers, ('Manager',))
+
+    PluggableAuthService.canListAllUsers = canListAllUsers
+    PluggableAuthService.canListAllUsers__roles__ = \
+        PermissionRole(ManageUsers, ('Manager',))
+
+    PluggableAuthService.canListAllGroups = canListAllGroups
+    PluggableAuthService.canListAllGroups__roles__ = \
+        PermissionRole(ManageUsers, ('Manager',))
+
+    PluggableAuthService.userSetPassword = userSetPassword
+    PluggableAuthService.userSetPassword__roles__ = \
+        PermissionRole(ManageUsers, ('Manager',))
+
+    PluggableAuthService.credentialsChanged = credentialsChanged
+    PluggableAuthService.credentialsChanged__roles__ = \
+        PermissionRole(ManageUsers, ('Manager',))
+
+    PluggableAuthService._delOb = _delOb
+
+    PluggableAuthService.addRole = addRole
+    PluggableAuthService.addRole__roles__ = \
+        PermissionRole(ManageUsers, ('Manager',))
+
+    PluggableAuthService.getAllLocalRoles = getAllLocalRoles
+    PluggableAuthService._getAllLocalRoles = _getAllLocalRoles
diff --git a/Products/PlonePAS/patch.py b/Products/PlonePAS/patch.py
index 0f7361f..9fafd1c 100644
--- a/Products/PlonePAS/patch.py
+++ b/Products/PlonePAS/patch.py
@@ -1,8 +1,8 @@
+# -*- coding: utf-8 -*-
 import logging
 
 logger = logging.getLogger('PlonePAS')
 
-
 PATTERN = '__PlonePAS_%s__'
 
 
@@ -21,11 +21,14 @@ def isWrapperMethod(meth):
 def wrap_method(klass, name, method, pattern=PATTERN):
     old_method = getattr(klass, name)
     if isWrapperMethod(old_method):
-        logger.info('PlonePAS: *NOT* wrapping already wrapped method at %s.%s',
-            klass.__name__, name)
+        logger.info(
+            'PlonePAS: *NOT* wrapping already wrapped method at '
+            '{0}.{1}'.format(
+                klass.__name__, name)
+            )
+
         return
-    else:
-        logger.info('PlonePAS: Wrapping method at %s.%s', klass.__name__, name)
+    logger.info('PlonePAS: Wrapping method at %s.%s', klass.__name__, name)
     new_name = pattern % name
     setattr(klass, new_name, old_method)
     setattr(method, ORIG_NAME, new_name)
diff --git a/Products/PlonePAS/permissions.py b/Products/PlonePAS/permissions.py
index 3ae3661..126932a 100644
--- a/Products/PlonePAS/permissions.py
+++ b/Products/PlonePAS/permissions.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from Products.CMFCore.permissions import setDefaultRoles
 
 AddGroups = 'Add Groups'
diff --git a/Products/PlonePAS/setuphandlers.py b/Products/PlonePAS/setuphandlers.py
index 2d1bf37..9a68362 100644
--- a/Products/PlonePAS/setuphandlers.py
+++ b/Products/PlonePAS/setuphandlers.py
@@ -1,8 +1,6 @@
-import pkg_resources
-
+# -*- coding: utf-8 -*-
 from Acquisition import aq_parent
 from Products.CMFCore.utils import getToolByName
-
 from Products.PlonePAS.Extensions.Install import challenge_chooser_setup
 from Products.PlonePAS.Extensions.Install import migrate_root_uf
 from Products.PlonePAS.Extensions.Install import registerPluginTypes
@@ -51,24 +49,21 @@ def setupGroups(site):
     uf = getToolByName(site, 'acl_users')
     gtool = getToolByName(site, 'portal_groups')
     if not uf.searchGroups(id='Administrators'):
-        gtool.addGroup('Administrators', title='Administrators',
-                       roles=['Manager'])
-
-    # Add Site Administrators group on Plone 4.1+ only.
-    try:
-        pkg_resources.get_distribution('Products.CMFPlone>=4.1a1')
-    except (pkg_resources.VersionConflict, pkg_resources.DistributionNotFound):
-        pass
-    else:
-        if not uf.searchGroups(id='Site Administrators'):
-            gtool.addGroup('Site Administrators', title='Site Administrators',
-                           roles=['Site Administrator'])
+        gtool.addGroup(
+            'Administrators',
+            title='Administrators',
+            roles=['Manager']
+        )
+
+    if not uf.searchGroups(id='Site Administrators'):
+        gtool.addGroup(
+            'Site Administrators',
+            title='Site Administrators',
+            roles=['Site Administrator']
+        )
 
     if not uf.searchGroups(id='Reviewers'):
         gtool.addGroup('Reviewers', title='Reviewers', roles=['Reviewer'])
-    # if not uf.searchGroups(id='AuthenticatedUsers'):
-    #     gtool.addGroup('Authenticated Users',
-    #                    title='Authenticated Users (Virtual Group)')
 
 
 def installPAS(portal):
diff --git a/Products/PlonePAS/storage.py b/Products/PlonePAS/storage.py
index 652a56b..28bb9b6 100644
--- a/Products/PlonePAS/storage.py
+++ b/Products/PlonePAS/storage.py
@@ -1,21 +1,20 @@
+# -*- coding: utf-8 -*-
 """
 an archetypes storage that delegates to a pas property provider.
 
 main use.. cmfmember integration w/ properties providers
 
 """
-
-from zope.interface import implements
-
 from AccessControl import ClassSecurityInfo
 from Products.Archetypes.public import IStorage
 from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
+from zope.interface import implementer
 
 
+@implementer(IStorage)
 class PASStorage(object):
 
     security = ClassSecurityInfo()
-    implements(IStorage)
 
     def get(self, name, instance, **kwargs):
         user = instance.getUser()
diff --git a/Products/PlonePAS/tests/__init__.py b/Products/PlonePAS/tests/__init__.py
index 8b13789..633f866 100644
--- a/Products/PlonePAS/tests/__init__.py
+++ b/Products/PlonePAS/tests/__init__.py
@@ -1 +1,2 @@
+# -*- coding: utf-8 -*-
 
diff --git a/Products/PlonePAS/tests/base.py b/Products/PlonePAS/tests/base.py
index 924ef4e..f274012 100644
--- a/Products/PlonePAS/tests/base.py
+++ b/Products/PlonePAS/tests/base.py
@@ -1,2 +1,3 @@
+# -*- coding: utf-8 -*-
 from plone.app.testing.bbb import PloneTestCase as TestCase
 from plone.app.testing.bbb import PloneTestCase as FunctionalTestCase
diff --git a/Products/PlonePAS/tests/dummy.py b/Products/PlonePAS/tests/dummy.py
index 4b10a05..346e046 100644
--- a/Products/PlonePAS/tests/dummy.py
+++ b/Products/PlonePAS/tests/dummy.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from OFS.SimpleItem import SimpleItem
 from ZPublisher.HTTPRequest import FileUpload
 
diff --git a/Products/PlonePAS/tests/test_basic_ops.py b/Products/PlonePAS/tests/test_basic_ops.py
index 865e3c7..e70540d 100644
--- a/Products/PlonePAS/tests/test_basic_ops.py
+++ b/Products/PlonePAS/tests/test_basic_ops.py
@@ -1,18 +1,15 @@
-import unittest
+# -*- coding: utf-8 -*-
+from Products.PlonePAS.tests import base
+from Products.PluggableAuthService.PluggableAuthService import \
+    _SWALLOWABLE_PLUGIN_EXCEPTIONS
+from Products.PluggableAuthService.interfaces.authservice import \
+    IPluggableAuthService
+from Products.PluggableAuthService.interfaces.events import \
+    IPrincipalDeletedEvent
+from Products.PluggableAuthService.interfaces.plugins import IRolesPlugin
 from zope.component import adapter
 from zope.component import getGlobalSiteManager
 
-from Products.PluggableAuthService.interfaces.events \
-    import IPrincipalDeletedEvent
-from Products.PluggableAuthService.PluggableAuthService \
-    import _SWALLOWABLE_PLUGIN_EXCEPTIONS
-from Products.PluggableAuthService.interfaces.authservice \
-     import IPluggableAuthService
-from Products.PluggableAuthService.interfaces.plugins \
-     import IRolesPlugin
-
-from Products.PlonePAS.tests import base
-
 
 class BasicOpsTestCase(base.TestCase):
 
diff --git a/Products/PlonePAS/tests/test_doctests.py b/Products/PlonePAS/tests/test_doctests.py
index df6ed7f..9e2c509 100644
--- a/Products/PlonePAS/tests/test_doctests.py
+++ b/Products/PlonePAS/tests/test_doctests.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from plone.app.testing.bbb import PTC_FUNCTIONAL_TESTING
 from plone.testing import layered
 import doctest
@@ -6,9 +7,20 @@
 
 def test_suite():
     suite = unittest.TestSuite()
-    suite.addTest(layered(
-        doctest.DocFileSuite('cookie_auth.rst', package='Products.PlonePAS.tests',
-                             optionflags=doctest.ELLIPSIS),
-        layer=PTC_FUNCTIONAL_TESTING))
-    suite.addTest(doctest.DocTestSuite('Products.PlonePAS.utils', optionflags=doctest.ELLIPSIS)),
+    suite.addTest(
+        layered(
+            doctest.DocFileSuite(
+                'cookie_auth.rst',
+                package='Products.PlonePAS.tests',
+                optionflags=doctest.ELLIPSIS
+            ),
+            layer=PTC_FUNCTIONAL_TESTING
+        )
+    )
+    suite.addTest(
+        doctest.DocTestSuite(
+            'Products.PlonePAS.utils',
+            optionflags=doctest.ELLIPSIS
+        )
+    )
     return suite
diff --git a/Products/PlonePAS/tests/test_groupdatatool.py b/Products/PlonePAS/tests/test_groupdatatool.py
index b3ce414..6bb8600 100644
--- a/Products/PlonePAS/tests/test_groupdatatool.py
+++ b/Products/PlonePAS/tests/test_groupdatatool.py
@@ -1,12 +1,11 @@
+# -*- coding: utf-8 -*-
 from AccessControl import Permissions
 from AccessControl import Unauthorized
-
 from Products.CMFCore.tests.base.testcase import WarningInterceptor
+from Products.PlonePAS.tests import base
 from plone.app.testing import TEST_USER_ID
 from plone.app.testing import TEST_USER_NAME
 
-from Products.PlonePAS.tests import base
-
 
 def sortTuple(t):
     l = list(t)
diff --git a/Products/PlonePAS/tests/test_groupstool.py b/Products/PlonePAS/tests/test_groupstool.py
index d0b4f18..cdac9c0 100644
--- a/Products/PlonePAS/tests/test_groupstool.py
+++ b/Products/PlonePAS/tests/test_groupstool.py
@@ -1,18 +1,14 @@
-import unittest
-
-from Acquisition import aq_base
-from Acquisition import aq_parent
+# -*- coding: utf-8 -*-
 from AccessControl import Permissions
 from AccessControl import Unauthorized
-
+from Acquisition import aq_base
+from Acquisition import aq_parent
 from Products.CMFCore.tests.base.testcase import WarningInterceptor
 from Products.CMFCore.utils import getToolByName
-from plone.app.testing import TEST_USER_ID
-from plone.app.testing import TEST_USER_NAME
-
-from Products.PlonePAS.tools.groupdata import GroupData
 from Products.PlonePAS.plugins.group import PloneGroup
 from Products.PlonePAS.tests import base
+from Products.PlonePAS.tools.groupdata import GroupData
+from plone.app.testing import TEST_USER_ID
 
 
 def sortTuple(t):
@@ -24,15 +20,18 @@ def sortTuple(t):
 class GroupsToolTest(base.TestCase):
 
     def afterSetUp(self):
-        self.gt = gt = getToolByName(self.portal, 'portal_groups')
-        self.gd = gd = getToolByName(self.portal, 'portal_groupdata')
+        self.gt = getToolByName(self.portal, 'portal_groups')
+        self.gd = getToolByName(self.portal, 'portal_groupdata')
 
         self.group_id = 'group1'
         # Create a new Group
         self.loginAsPortalOwner()
-        gt.addGroup(self.group_id, ['Reviewer'], [],
-                    {'email': 'group1@host.com',
-                     'title': 'Group #1'})
+        self.gt.addGroup(
+            self.group_id,
+            ['Reviewer'],
+            [],
+            {'email': 'group1@host.com', 'title': 'Group #1'}
+        )
 
     def test_get_group(self):
         # Use PAS (monkeypatched) API method to get a group by id.
@@ -61,8 +60,11 @@ def test_edit_group(self):
             'email': 'group1@host2.com',
             'title': 'Group #1 new title'
         }
-        self.gt.editGroup(self.group_id, roles=['Manager'],
-            **properties)
+        self.gt.editGroup(
+            self.group_id,
+            roles=['Manager'],
+            **properties
+        )
 
         # test edition of roles and properties
         group = self.gt.getGroupById(self.group_id)
@@ -75,8 +77,11 @@ def test_edit_group(self):
         self.assertTrue(group.has_role('Authenticated'))
 
         # test edition of group groups
-        self.gt.editGroup(self.group_id, groups=['Reviewers'],
-            **properties)
+        self.gt.editGroup(
+            self.group_id,
+            groups=['Reviewers'],
+            **properties
+        )
         group = self.gt.getGroupById(self.group_id)
         self.assertTrue('Reviewers' in group.getGroups())
 
diff --git a/Products/PlonePAS/tests/test_memberdatatool.py b/Products/PlonePAS/tests/test_memberdatatool.py
index 6b3c4f0..b7ae400 100644
--- a/Products/PlonePAS/tests/test_memberdatatool.py
+++ b/Products/PlonePAS/tests/test_memberdatatool.py
@@ -1,10 +1,9 @@
+# -*- coding: utf-8 -*-
 from DateTime import DateTime
 from OFS.Image import Image
-
-from plone.app.testing import TEST_USER_ID as default_user
-
 from Products.PlonePAS.tests import base
 from Products.PlonePAS.tests import dummy
+from plone.app.testing import TEST_USER_ID as default_user
 
 
 class TestMemberDataTool(base.TestCase):
@@ -69,4 +68,3 @@ def testFulltextMemberSearch(self):
         self.assertEqual(len(search('bambam.net')), 1)
         self.assertEqual(len(search('bedrock.com')), 2)
         self.assertEqual(len(search('brubble')), 1)
-
diff --git a/Products/PlonePAS/tests/test_membershiptool.py b/Products/PlonePAS/tests/test_membershiptool.py
index f3553b8..29d309d 100644
--- a/Products/PlonePAS/tests/test_membershiptool.py
+++ b/Products/PlonePAS/tests/test_membershiptool.py
@@ -1,49 +1,48 @@
-# coding=utf-8
-import os
-import unittest
-from cStringIO import StringIO
-
-from AccessControl.User import nobody
-from AccessControl import getSecurityManager
+# -*- coding: utf-8 -*-
 from AccessControl import Unauthorized
+from AccessControl import getSecurityManager
+from AccessControl.User import nobody
 from Acquisition import aq_base
 from Acquisition import aq_parent
 from DateTime import DateTime
 from OFS.Image import Image
-from zExceptions import BadRequest
-from zope.component import getUtility
-
-from Products.CMFCore.utils import getToolByName
-from Products.CMFCore.tests.base.testcase import WarningInterceptor
-
-from plone.app.testing import TEST_USER_ID
-from plone.app.testing import TEST_USER_NAME
-from plone.app.testing import TEST_USER_PASSWORD
-from plone.app.testing import SITE_OWNER_NAME
-from plone.app.testing import PLONE_SITE_ID
-
 from Products.CMFCore.interfaces import IPropertiesTool
-from Products.PlonePAS.interfaces.membership import IMembershipTool
+from Products.CMFCore.tests.base.testcase import WarningInterceptor
+from Products.CMFCore.utils import getToolByName
 from Products.PlonePAS.browser.member import PASMemberView
+from Products.PlonePAS.interfaces.membership import IMembershipTool
 from Products.PlonePAS.plugins.ufactory import PloneUser
 from Products.PlonePAS.tests import base
 from Products.PlonePAS.tests import dummy
 from Products.PlonePAS.tools.memberdata import MemberData
 from Products.PlonePAS.tools.membership import MembershipTool
 from Products.PlonePAS.utils import getGroupsForPrincipal
+from cStringIO import StringIO
+from plone.app.testing import PLONE_SITE_ID
+from plone.app.testing import SITE_OWNER_NAME
+from plone.app.testing import TEST_USER_ID
+from plone.app.testing import TEST_USER_NAME
+from plone.app.testing import TEST_USER_PASSWORD
+from zExceptions import BadRequest
+from zope.component import getUtility
+import os
 
 
 class MembershipToolTest(base.TestCase):
 
     def afterSetUp(self):
-        self.mt = mt = getToolByName(self.portal, 'portal_membership')
-        self.md = md = getToolByName(self.portal, 'portal_memberdata')
+        self.mt = getToolByName(self.portal, 'portal_membership')
+        self.md = getToolByName(self.portal, 'portal_memberdata')
 
         self.member_id = 'member1'
         # Create a new Member
-        mt.addMember(self.member_id, 'pw', ['Member'], [],
-                     {'email': 'member1@host.com',
-                      'title': 'Member #1'})
+        self.mt.addMember(
+            self.member_id,
+            'pw',
+            ['Member'],
+            [],
+            {'email': 'member1@host.com', 'title': 'Member #1'}
+        )
 
     def test_get_member(self):
         member = self.portal.acl_users.getUserById(self.member_id)
@@ -122,8 +121,8 @@ def test_id_clean(self):
 class MemberAreaTest(base.TestCase):
 
     def afterSetUp(self):
-        self.mt = mt = getToolByName(self.portal, 'portal_membership')
-        self.md = md = getToolByName(self.portal, 'portal_memberdata')
+        self.mt = getToolByName(self.portal, 'portal_membership')
+        self.md = getToolByName(self.portal, 'portal_memberdata')
         # Enable member-area creation
         self.mt.memberareaCreationFlag = 1
         # Those are all valid chars in Zope.
@@ -221,9 +220,13 @@ def testChangeOwnMemberPortrait(self):
 
     def testChangeOwnMemberPortraitWithEmailUsers(self):
         member_id = 'member2@host.com'
-        self.membership.addMember(member_id, 'pw', ['Member'], [],
-                     {'email': 'member2@host.com',
-                      'title': 'Member #2'})
+        self.membership.addMember(
+            member_id,
+            'pw',
+            ['Member'],
+            [],
+            {'email': 'member2@host.com', 'title': 'Member #2'}
+        )
 
         self.login(member_id)
         image = self.makeRealImage()
@@ -289,8 +292,10 @@ def testDeleteOtherPersonalPortraitAsManager(self):
         self.setRoles(['Manager'])
         self.membership.changeMemberPortrait(image, 'joe')
         self.membership.deletePersonalPortrait('joe')
-        self.assertEqual(self.membership.getPersonalPortrait('joe').getId(),
-                        'defaultUser.png')
+        self.assertEqual(
+            self.membership.getPersonalPortrait('joe').getId(),
+            'defaultUser.png'
+        )
 
     def testGetPersonalPortraitWithoutPassingId(self):
         # Should return the logged in users portrait if no id is given
@@ -348,8 +353,10 @@ def testPortraitForNonStandardUserId(self):
         self.assertEqual(self.membership.getPersonalPortrait(user_id).getId(),
                          safe_id)
         self.membership.deletePersonalPortrait(user_id)
-        self.assertEqual(self.membership.getPersonalPortrait(user_id).getId(),
-                        'defaultUser.png')
+        self.assertEqual(
+            self.membership.getPersonalPortrait(user_id).getId(),
+            'defaultUser.png'
+        )
 
     def testListMembers(self):
         # Should return the members list
@@ -418,15 +425,17 @@ def testSetPasswordAndKeepGroups(self):
         self.login(TEST_USER_NAME)  # Back to normal
         ugroups = self.portal.acl_users.getUserById(TEST_USER_ID).getGroups()
         self.membership.setPassword('geheim')
-        self.assertTrue(
-            self.portal.acl_users.getUserById(TEST_USER_ID).getGroups()
-                == ugroups)
+        t_groups = self.portal.acl_users.getUserById(TEST_USER_ID).getGroups()
+        self.assertTrue(t_groups == ugroups)
 
     def testGetMemberById(self):
         # This should work for portal users,
         self.assertNotEqual(self.membership.getMemberById(TEST_USER_ID), None)
         self.assertEqual(self.membership.getMemberById('foo'), None)
-        self.assertNotEqual(self.membership.getMemberById(SITE_OWNER_NAME), None)
+        self.assertNotEqual(
+            self.membership.getMemberById(SITE_OWNER_NAME),
+            None
+        )
 
     def testGetMemberByIdIsWrapped(self):
         member = self.membership.getMemberById(TEST_USER_ID)
@@ -623,8 +632,11 @@ def testGetBadMembers(self):
         # We should not have any bad images out of the box
         self.assertEqual(self.membership.getBadMembers(), [])
         # Let's add one
-        bad_file = Image(id=TEST_USER_ID, title='',
-                               file=StringIO('<div>This is a lie!!!</div>'))
+        bad_file = Image(
+            id=TEST_USER_ID,
+            title='',
+            file=StringIO('<div>This is a lie!!!</div>')
+        )
         # Manually set a bad image using private methods
         self.portal.portal_memberdata._setPortrait(bad_file, TEST_USER_ID)
         self.assertEqual(self.membership.getBadMembers(), [TEST_USER_ID])
@@ -649,8 +661,7 @@ def afterSetUp(self):
 
     def testCreateMemberarea(self):
         # Should create a memberarea for user2
-        if self.membership.memberareaCreationFlag == True:
-            members = self.membership.getMembersFolder()
+        if self.membership.memberareaCreationFlag is True:
             self.membership.createMemberarea('user2')
             memberfolder = self.membership.getHomeFolder('user2')
             self.assertTrue(memberfolder,
@@ -659,7 +670,7 @@ def testCreateMemberarea(self):
             self.assertTrue(self.membership.getMemberareaCreationFlag())
 
     def testCreatMemberareaUsesCurrentUser(self):
-        if self.membership.memberareaCreationFlag == True:
+        if self.membership.memberareaCreationFlag is True:
             # Should create a memberarea for user2
             self.login('user2')
             self.membership.createMemberarea()
@@ -667,7 +678,8 @@ def testCreatMemberareaUsesCurrentUser(self):
             self.assertTrue(
                 memberfolder,
                 'createMemberarea failed to create memberarea for current '
-                    'user')
+                'user'
+            )
         else:
             pass
 
@@ -676,8 +688,10 @@ def testNoMemberareaIfNoMembersFolder(self):
         self.portal._delObject('Members')
         self.membership.createMemberarea('user2')
         memberfolder = self.membership.getHomeFolder('user2')
-        self.assertFalse(memberfolder,
-                    'createMemberarea unexpectedly created a memberarea')
+        self.assertFalse(
+            memberfolder,
+            'createMemberarea unexpectedly created a memberarea'
+        )
 
     def testNoMemberareaIfMemberareaExists(self):
         # Should not attempt to create a memberarea if a memberarea already
@@ -688,15 +702,14 @@ def testNoMemberareaIfMemberareaExists(self):
 
     def testNotifyScriptIsCalled(self):
         # The notify script should be called
-        if self.membership.memberareaCreationFlag == True:
+        if self.membership.memberareaCreationFlag is True:
             self.portal.notifyMemberAreaCreated = dummy.Raiser(dummy.Error)
             self.assertRaises(dummy.Error, self.membership.createMemberarea,
                               'user2')
 
     def testCreateMemberareaAlternateName(self):
         # Alternate method name 'createMemberaArea' should work
-        if self.membership.memberareaCreationFlag == True:
-            members = self.membership.getMembersFolder()
+        if self.membership.memberareaCreationFlag is True:
             self.membership.createMemberArea('user2')
             memberfolder = self.membership.getHomeFolder('user2')
             self.assertTrue(memberfolder,
@@ -704,7 +717,7 @@ def testCreateMemberareaAlternateName(self):
 
     def testCreateMemberareaAlternateType(self):
         # Should be able to create another type instead of a normal Folder
-        if self.membership.memberareaCreationFlag == True:
+        if self.membership.memberareaCreationFlag is True:
             self.membership.setMemberAreaType('Document')
             self.membership.createMemberarea('user2')
             memberfolder = self.membership.getHomeFolder('user2')
@@ -716,8 +729,10 @@ def testCreateMemberareaWhenDisabled(self):
         self.assertFalse(self.membership.getMemberareaCreationFlag())
         self.membership.createMemberarea('user2')
         memberfolder = self.membership.getHomeFolder('user2')
-        self.assertFalse(memberfolder,
-                    'createMemberarea created memberarea despite flag')
+        self.assertFalse(
+            memberfolder,
+            'createMemberarea created memberarea despite flag'
+        )
 
 
 class TestMemberareaSetup(base.TestCase):
@@ -729,13 +744,13 @@ def afterSetUp(self):
         self.home = self.membership.getHomeFolder('user2')
 
     def testMemberareaIsFolder(self):
-        if self.membership.memberareaCreationFlag == True:
+        if self.membership.memberareaCreationFlag is True:
             # Memberarea should be a folder
             self.assertEqual(self.home.meta_type, 'ATFolder')
             self.assertEqual(self.home.portal_type, 'Folder')
 
     def testMemberareaIsOwnedByMember(self):
-        if self.membership.memberareaCreationFlag == True:
+        if self.membership.memberareaCreationFlag is True:
             # Memberarea should be owned by member
             try:
                 owner_info = self.home.getOwnerTuple()
@@ -748,7 +763,7 @@ def testMemberareaIsOwnedByMember(self):
                              ('Owner',))
 
     def testMemberareaIsCataloged(self):
-        if self.membership.memberareaCreationFlag == True:
+        if self.membership.memberareaCreationFlag is True:
             # Memberarea should be cataloged
             catalog = self.portal.portal_catalog
             self.assertTrue(catalog(id='user2', Type='Folder', Title="user2"),
@@ -756,7 +771,7 @@ def testMemberareaIsCataloged(self):
                             "catalog")
 
     def testHomePageNotExists(self):
-        if self.membership.memberareaCreationFlag == True:
+        if self.membership.memberareaCreationFlag is True:
             # Should not have an index_html document anymore
             self.assertFalse('index_html' in self.home)
 
@@ -855,7 +870,9 @@ def afterSetUp(self):
     def testDefaultUserAndPasswordUnchanged(self):
         member = self.membership.getAuthenticatedMember()
         self.assertEqual(member.getUserName(), TEST_USER_NAME)
-        self.assertTrue(self.membership.testCurrentPassword(TEST_USER_PASSWORD))
+        self.assertTrue(
+            self.membership.testCurrentPassword(TEST_USER_PASSWORD)
+        )
         self.assertFalse(self.membership.testCurrentPassword('geheim'))
 
 
@@ -936,7 +953,9 @@ def testSetGroupsWithUserNameIdDifference(self):
         self.setGroups(['Editors'], name=TEST_USER_ID)
         self.login(TEST_USER_NAME)
         user = getSecurityManager().getUser()
-        self.assertTrue('Editors' in getGroupsForPrincipal(user, pas['plugins']))
+        self.assertTrue(
+            'Editors' in getGroupsForPrincipal(user, pas['plugins'])
+        )
         self.login()
 
     def testSetGroupsWithSameUserNameAndId(self):
@@ -944,5 +963,6 @@ def testSetGroupsWithSameUserNameAndId(self):
         self.portal.portal_groups.addGroup('Editors', [], [])
         self.setGroups(['Editors'])
         user = getSecurityManager().getUser()
-        self.assertTrue('Editors' in getGroupsForPrincipal(user, pas['plugins']))
-
+        self.assertTrue(
+            'Editors' in getGroupsForPrincipal(user, pas['plugins'])
+        )
diff --git a/Products/PlonePAS/tests/test_properties.py b/Products/PlonePAS/tests/test_properties.py
index ec26262..d2e808f 100644
--- a/Products/PlonePAS/tests/test_properties.py
+++ b/Products/PlonePAS/tests/test_properties.py
@@ -1,11 +1,9 @@
-import unittest
-
+# -*- coding: utf-8 -*-
 from Products.CMFCore.utils import getToolByName
-from Products.PluggableAuthService.interfaces.plugins \
-    import IUserEnumerationPlugin
-
 from Products.PlonePAS.plugins.property import ZODBMutablePropertyProvider
 from Products.PlonePAS.tests import base
+from Products.PluggableAuthService.interfaces.plugins import \
+    IUserEnumerationPlugin
 
 
 class PropertiesTest(base.TestCase):
@@ -86,9 +84,12 @@ def test_group_properties(self):
         self.loginAsPortalOwner()
 
         # Create a new Group
-        gt.addGroup('group1', ['Reviewer'], [],
-                     {'email': 'group1@host.com',
-                      'title': 'Group #1'})
+        gt.addGroup(
+            'group1',
+            ['Reviewer'],
+            [],
+            {'email': 'group1@host.com', 'title': 'Group #1'}
+        )
         group = gt.getGroupById('group1')
         self.assertFalse(group is None)
 
@@ -192,15 +193,23 @@ def afterSetUp(self):
         self.gt = getToolByName(self.portal, 'portal_groups')
 
         # Create a new Member
-        self.mt.addMember('member1', 'pw', ['Member'], [],
-                     {'email': 'member1@host.com',
-                      'title': 'Member #1'})
+        self.mt.addMember(
+            'member1',
+            'pw',
+            ['Member'],
+            [],
+            {'email': 'member1@host.com', 'title': 'Member #1'}
+        )
         member = self.mt.getMemberById('member1')
         self.assertFalse(member is None)
 
-        self.mt.addMember('member2', 'pw', ['Member'], [],
-                     {'email': 'user2@otherhost.com',
-                      'fullname': 'User #2'})
+        self.mt.addMember(
+            'member2',
+            'pw',
+            ['Member'],
+            [],
+            {'email': 'user2@otherhost.com', 'fullname': 'User #2'}
+        )
         member = self.mt.getMemberById('member2')
         self.assertFalse(member is None)
 
@@ -276,4 +285,3 @@ def testCantSearchByIdOrLogin(self):
         # or login
         results = self.pas.searchUsers(login='member1')
         self.assertEqual(results, ())
-
diff --git a/Products/PlonePAS/tests/test_role_plugin.py b/Products/PlonePAS/tests/test_role_plugin.py
index 3c76941..00ec703 100644
--- a/Products/PlonePAS/tests/test_role_plugin.py
+++ b/Products/PlonePAS/tests/test_role_plugin.py
@@ -2,21 +2,21 @@
 # $Id$
 """Tests for Products.PlonePAS.plugins.role.GroupAwareRoleManager"""
 
-import unittest
-
-from Products.PluginRegistry.PluginRegistry import PluginRegistry
-from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
-from Products.PluggableAuthService.plugins.tests.helpers import (
-    FauxPAS, DummyUser, makeRequestAndResponse)
-from Products.PluggableAuthService.PluggableAuthService \
-    import _PLUGIN_TYPE_INFO
-from Products.PluggableAuthService.interfaces.plugins import IGroupsPlugin
 from Products.PlonePAS.tests import base
-from zope.interface import implements
+from Products.PluggableAuthService.PluggableAuthService import \
+    _PLUGIN_TYPE_INFO
+from Products.PluggableAuthService.interfaces.plugins import IGroupsPlugin
+from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from Products.PluggableAuthService.plugins.tests.helpers import DummyUser
+from Products.PluggableAuthService.plugins.tests.helpers import FauxPAS
+from Products.PluggableAuthService.plugins.tests.helpers import \
+    makeRequestAndResponse
+from Products.PluginRegistry.PluginRegistry import PluginRegistry
+from zope.interface import implementer
 
 
+@implementer(IGroupsPlugin)
 class FauxGroupsPlugin(BasePlugin):
-    implements(IGroupsPlugin)
 
     def getGroupsForPrincipal(self, principal, request=None):
         return principal._groups
@@ -84,4 +84,3 @@ def test_roles_for_control_panel(self):
         self.assertEqual(got, ('bar_role',))
 
         return
-
diff --git a/Products/PlonePAS/tests/test_views.py b/Products/PlonePAS/tests/test_views.py
index 6347c5b..d0a7f60 100644
--- a/Products/PlonePAS/tests/test_views.py
+++ b/Products/PlonePAS/tests/test_views.py
@@ -1,5 +1,4 @@
 # -*- encoding: utf-8 -*-
-
 from Products.PlonePAS.tests import base
 
 
@@ -18,4 +17,3 @@ def test_sort(self):
         self.assertEqual(sorted_values,
                          [{'title': u'anthropologie'}, {'title': u'Économie'},
                           {'title': u'Sociologie'}])
-
diff --git a/Products/PlonePAS/tools/__init__.py b/Products/PlonePAS/tools/__init__.py
index 4287ca8..40a96af 100644
--- a/Products/PlonePAS/tools/__init__.py
+++ b/Products/PlonePAS/tools/__init__.py
@@ -1 +1 @@
-#
\ No newline at end of file
+# -*- coding: utf-8 -*-
diff --git a/Products/PlonePAS/tools/groupdata.py b/Products/PlonePAS/tools/groupdata.py
index 74c3110..615223e 100644
--- a/Products/PlonePAS/tools/groupdata.py
+++ b/Products/PlonePAS/tools/groupdata.py
@@ -1,35 +1,33 @@
-from zope.interface import implements
-
-from Acquisition import aq_base
-from Acquisition import aq_inner
-from Acquisition import aq_parent
+# -*- coding: utf-8 -*-
 from AccessControl import ClassSecurityInfo
-from AccessControl import Unauthorized
 from AccessControl import Permissions
+from AccessControl import Unauthorized
 from AccessControl import getSecurityManager
 from AccessControl.requestmethod import postonly
-from BTrees.OOBTree import OOBTree
+from Acquisition import aq_base
+from Acquisition import aq_inner
+from Acquisition import aq_parent
 from App.class_init import InitializeClass
-from OFS.SimpleItem import SimpleItem
+from BTrees.OOBTree import OOBTree
 from OFS.PropertyManager import PropertyManager
-from ZPublisher.Converters import type_converters
-
+from OFS.SimpleItem import SimpleItem
+from Products.CMFCore.utils import UniqueObject
 from Products.CMFCore.utils import getToolByName
 from Products.CMFCore.utils import registerToolInterface
-from Products.CMFCore.utils import UniqueObject
-from Products.PluggableAuthService.interfaces.authservice \
-        import IPluggableAuthService
-from Products.PluggableAuthService.PluggableAuthService \
-        import _SWALLOWABLE_PLUGIN_EXCEPTIONS
-
-from Products.PlonePAS.interfaces.group import IGroupManagement
-from Products.PlonePAS.interfaces.group import IGroupDataTool
-from Products.PlonePAS.interfaces.group import IGroupData
-from Products.PlonePAS.interfaces.capabilities import IManageCapabilities
 from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
+from Products.PlonePAS.interfaces.capabilities import IManageCapabilities
+from Products.PlonePAS.interfaces.group import IGroupData
+from Products.PlonePAS.interfaces.group import IGroupDataTool
+from Products.PlonePAS.interfaces.group import IGroupManagement
 from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
 from Products.PlonePAS.tools.memberdata import MemberData
 from Products.PlonePAS.utils import CleanupTemp
+from Products.PluggableAuthService.PluggableAuthService import \
+    _SWALLOWABLE_PLUGIN_EXCEPTIONS
+from Products.PluggableAuthService.interfaces.authservice import \
+    IPluggableAuthService
+from ZPublisher.Converters import type_converters
+from zope.interface import implementer
 
 import logging
 
@@ -37,6 +35,7 @@
 _marker = object()
 
 
+@implementer(IGroupDataTool)
 class GroupDataTool(UniqueObject, SimpleItem, PropertyManager):
     """This tool wraps group objects, allowing transparent access to
     properties.
@@ -45,7 +44,6 @@ class GroupDataTool(UniqueObject, SimpleItem, PropertyManager):
     id = 'portal_groupdata'
     meta_type = "PlonePAS GroupData Tool"
     toolicon = 'tool.gif'
-    implements(IGroupDataTool)
 
     _v_temps = None
     _properties = ({'id': 'title', 'type': 'string', 'mode': 'wd'},)
@@ -60,30 +58,30 @@ def __init__(self):
     def wrapGroup(self, g):
         """Returns an object implementing the GroupData interface."""
 
-        id = g.getId()
+        gid = g.getId()
         members = self._members
-        if not id in members:
+        if gid not in members:
             # Get a temporary member that might be
             # registered later via registerMemberData().
             temps = self._v_temps
-            if temps is not None and id in temps:
-                portal_group = temps[id]
+            if temps is not None and gid in temps:
+                portal_group = temps[gid]
             else:
                 base = aq_base(self)
-                portal_group = GroupData(base, id)
+                portal_group = GroupData(base, gid)
                 if temps is None:
-                    self._v_temps = {id: portal_group}
+                    self._v_temps = {gid: portal_group}
                     if hasattr(self, 'REQUEST'):
                         self.REQUEST._hold(CleanupTemp(self))
                 else:
-                    temps[id] = portal_group
+                    temps[gid] = portal_group
         else:
-            portal_group = members[id]
+            portal_group = members[gid]
         # Return a wrapper with self as containment and
         # the user as context.
         return portal_group.__of__(self).__of__(g)
 
-    security.declarePrivate('registerGroupData')
+    @security.private
     def registerGroupData(self, g, id):
         '''
         Adds the given member data to the _members dict.
@@ -98,10 +96,9 @@ def registerGroupData(self, g, id):
 registerToolInterface('portal_groupdata', IGroupDataTool)
 
 
+@implementer(IGroupData, IManageCapabilities)
 class GroupData(SimpleItem):
 
-    implements(IGroupData, IManageCapabilities)
-
     security = ClassSecurityInfo()
 
     id = None
@@ -116,7 +113,7 @@ def __init__(self, tool, id):
     def _getGRUF(self,):
         return self.acl_users
 
-    security.declarePrivate('notifyModified')
+    @security.private
     def notifyModified(self):
         # Links self to parent for full persistence.
         tool = getattr(self, '_tool', None)
@@ -124,7 +121,7 @@ def notifyModified(self):
             del self._tool
             tool.registerGroupData(self, self.getId())
 
-    security.declarePublic('getGroup')
+    @security.public
     def getGroup(self):
         """ Returns the actual group implementation. Varies by group
         implementation (GRUF/Nux/et al). In GRUF this is a user object."""
@@ -142,21 +139,21 @@ def getGroup(self):
     def getTool(self):
         return aq_parent(aq_inner(self))
 
-    security.declarePublic("getGroupMemberIds")
+    @security.public
     def getGroupMemberIds(self):
         """
         Return a list of group member ids
         """
         return map(lambda x: x.getMemberId(), self.getGroupMembers())
 
-    security.declarePublic("getAllGroupMemberIds")
+    @security.public
     def getAllGroupMemberIds(self):
         """
         Return a list of group member ids
         """
         return map(lambda x: x.getMemberId(), self.getAllGroupMembers())
 
-    security.declarePublic('getGroupMembers')
+    @security.public
     def getGroupMembers(self):
         """
         Returns a list of the portal_memberdata-ish members of the group.
@@ -175,15 +172,16 @@ def getGroupMembers(self):
                 # getGroupById from Products.PlonePAS.pas
                 # The returned object is already wrapped
                 if not usr:
-                    logger.debug("Group has a non-existing principal %s"
-                                    % u_name)
+                    logger.debug(
+                        "Group has a non-existing principal {0}".format(u_name)
+                    )
                     continue
                 ret.append(usr)
             else:
                 ret.append(md.wrapUser(usr))
         return ret
 
-    security.declarePublic('getAllGroupMembers')
+    @security.public
     def getAllGroupMembers(self):
         """
         Returns a list of the portal_memberdata-ish members of the group.
@@ -196,8 +194,9 @@ def getAllGroupMembers(self):
             if not usr:
                 usr = self._getGRUF().getGroupById(u_name)
                 if not usr:
-                    logger.debug("Group has a non-existing principal %s"
-                                    % u_name)
+                    logger.debug(
+                        "Group has a non-existing principal {0}".format(u_name)
+                    )
                     continue
                 ret.append(usr)
             else:
@@ -210,7 +209,7 @@ def _getGroup(self):
         """
         return self.getGroup()
 
-    security.declarePrivate("canAdministrateGroup")
+    @security.private
     def canAdministrateGroup(self):
         """
         Return true if the #current# user can administrate this group
@@ -242,7 +241,7 @@ def canAdministrateGroup(self):
         # No right to edit this: we complain.
         return False
 
-    security.declarePublic('addMember')
+    @security.public
     @postonly
     def addMember(self, id, REQUEST=None):
         """ Add the existing member with the given id to the group"""
@@ -258,7 +257,7 @@ def addMember(self, id, REQUEST=None):
             except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
                 pass
 
-    security.declarePublic('removeMember')
+    @security.public
     @postonly
     def removeMember(self, id, REQUEST=None):
         """Remove the member with the provided id from the group.
@@ -275,7 +274,7 @@ def removeMember(self, id, REQUEST=None):
             except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
                 pass
 
-    security.declareProtected(Permissions.manage_users, 'setProperties')
+    @security.protected(Permissions.manage_users)
     def setProperties(self, properties=None, **kw):
         """Allows the manager group to set his/her own properties.
         Accepts either keyword arguments or a mapping for the "properties"
@@ -285,7 +284,7 @@ def setProperties(self, properties=None, **kw):
             properties = kw
         return self.setGroupProperties(properties)
 
-    security.declareProtected(Permissions.manage_users, 'setGroupProperties')
+    @security.protected(Permissions.manage_users)
     def setGroupProperties(self, mapping):
         """PAS-specific method to set the properties of a group.
         """
@@ -331,9 +330,9 @@ def _gruf_setGroupProperties(self, mapping):
         tool = self.getTool()
         for id in tool.propertyIds():
             if id in mapping:
-                if not id in self.__class__.__dict__:
+                if id not in self.__class__.__dict__:
                     value = mapping[id]
-                    if type(value) == type(''):
+                    if isinstance(value, str):
                         proptype = tool.getPropertyType(id) or 'string'
                         if proptype in type_converters:
                             value = type_converters[proptype](value)
@@ -342,7 +341,7 @@ def _gruf_setGroupProperties(self, mapping):
         # Hopefully we can later make notifyModified() implicit.
         self.notifyModified()
 
-    security.declarePublic('getProperties')
+    @security.public
     def getProperties(self):
         """ Return the properties of this group. Properties are as usual
             in Zope.
@@ -357,7 +356,7 @@ def getProperties(self):
                 continue
         return ret
 
-    security.declarePublic('getProperty')
+    @security.public
     def getProperty(self, id, default=None):
         """PAS-specific method to fetch a group's properties. Looks
         through the ordered property sheets.
@@ -394,7 +393,7 @@ def getProperty(self, id, default=None):
     def __str__(self):
         return self.getGroupId()
 
-    security.declarePublic("isGroup")
+    @security.public
     def isGroup(self):
         """
         isGroup(self,) => Return true if this is a group.
@@ -405,13 +404,13 @@ def isGroup(self):
         """
         return 1
 
-    ### Group object interface ###
+    # Group object interface ###
 
-    security.declarePublic('getGroupName')
+    @security.public
     def getGroupName(self):
         return self.getName()
 
-    security.declarePublic('getGroupId')
+    @security.public
     def getGroupId(self):
         """Get the ID of the group. The ID can be used, at least from
         Python, to get the user from the user's UserDatabase.
@@ -424,29 +423,29 @@ def getGroupTitleOrName(self):
         title = self.getProperty('title', None)
         return title or self.getGroupName()
 
-    security.declarePublic("getMemberId")
+    @security.public
     def getMemberId(self):
         """This exists only for a basic user/group API compatibility
         """
         return self.getGroupId()
 
-    security.declarePublic('getRoles')
+    @security.public
     def getRoles(self):
         """Return the list of roles assigned to a user."""
         return self.getGroup().getRoles()
 
-    security.declarePublic('getRolesInContext')
+    @security.public
     def getRolesInContext(self, object):
         """Return the list of roles assigned to the user,  including local
         roles assigned in context of the passed in object."""
         return self.getGroup().getRolesInContext(object)
 
-    security.declarePublic('getDomains')
+    @security.public
     def getDomains(self):
         """Return the list of domain restrictions for a user"""
         return self.getGroup().getDomains()
 
-    security.declarePublic('has_role')
+    @security.public
     def has_role(self, roles, object=None):
         """Check to see if a user has a given role or roles."""
         return self.getGroup().has_role(roles, object)
@@ -517,7 +516,7 @@ def canWriteProperty(self, prop_name):
 
     ## plugin getters
 
-    security.declarePrivate('_getPlugins')
+    @security.private
     def _getPlugins(self):
         return self.acl_users.plugins
 
diff --git a/Products/PlonePAS/tools/groups.py b/Products/PlonePAS/tools/groups.py
index c560e93..90be6f0 100644
--- a/Products/PlonePAS/tools/groups.py
+++ b/Products/PlonePAS/tools/groups.py
@@ -1,32 +1,27 @@
-import logging
-
-from zope.interface import implements
-
-from Acquisition import aq_base
+# -*- coding: utf-8 -*-
 from AccessControl import ClassSecurityInfo
-from AccessControl.requestmethod import postonly
 from AccessControl.User import nobody
+from AccessControl.requestmethod import postonly
+from Acquisition import aq_base
 from App.class_init import InitializeClass
 from OFS.SimpleItem import SimpleItem
-from ZODB.POSException import ConflictError
-
+from Products.CMFCore.utils import UniqueObject
 from Products.CMFCore.utils import getToolByName
 from Products.CMFCore.utils import registerToolInterface
-from Products.CMFCore.utils import UniqueObject
-
-from Products.PluggableAuthService.interfaces.plugins \
-    import IRoleAssignerPlugin
-from Products.PluggableAuthService.PluggableAuthService \
-    import _SWALLOWABLE_PLUGIN_EXCEPTIONS
-
 from Products.PlonePAS.interfaces import group as igroup
 from Products.PlonePAS.permissions import AddGroups
-from Products.PlonePAS.permissions import ManageGroups
 from Products.PlonePAS.permissions import DeleteGroups
-from Products.PlonePAS.permissions import ViewGroups
+from Products.PlonePAS.permissions import ManageGroups
 from Products.PlonePAS.permissions import SetGroupOwnership
+from Products.PlonePAS.permissions import ViewGroups
 from Products.PlonePAS.utils import getGroupsForPrincipal
-
+from Products.PluggableAuthService.PluggableAuthService import \
+    _SWALLOWABLE_PLUGIN_EXCEPTIONS
+from Products.PluggableAuthService.interfaces.plugins import \
+    IRoleAssignerPlugin
+from ZODB.POSException import ConflictError
+from zope.interface import implementer
+import logging
 
 logger = logging.getLogger('PluggableAuthService')
 
@@ -35,6 +30,7 @@ class NotSupported(Exception):
     pass
 
 
+@implementer(igroup.IGroupTool)
 class GroupsTool(UniqueObject, SimpleItem):
     """ This tool accesses group data through a acl_users object.
 
@@ -42,8 +38,6 @@ class GroupsTool(UniqueObject, SimpleItem):
     different way.
     """
 
-    implements(igroup.IGroupTool)
-
     id = 'portal_groups'
     meta_type = 'PlonePAS Groups Tool'
     security = ClassSecurityInfo()
@@ -53,7 +47,7 @@ class GroupsTool(UniqueObject, SimpleItem):
     # basic group mgmt
     ##
 
-    security.declareProtected(AddGroups, 'addGroup')
+    @security.protected(AddGroups)
     @postonly
     def addGroup(self, id, roles=[], groups=[], properties=None,
                  REQUEST=None, *args, **kw):
@@ -92,7 +86,7 @@ def addGroup(self, id, roles=[], groups=[], properties=None,
 
         return success
 
-    security.declareProtected(ManageGroups, 'editGroup')
+    @security.protected(ManageGroups)
     @postonly
     def editGroup(self, id, roles=None, groups=None, REQUEST=None,
                   *args, **kw):
@@ -115,8 +109,11 @@ def editGroup(self, id, roles=None, groups=None, REQUEST=None,
 
         for tid, tool in gTools:
             if id in tool.getGroupIds():
-                tool.updateGroup(id, title=kw.get('title'),
-                                     description=kw.get('description'))
+                tool.updateGroup(
+                    id,
+                    title=kw.get('title'),
+                    description=kw.get('description')
+                )
                 break
 
         if roles is not None:
@@ -135,7 +132,8 @@ def editGroup(self, id, roles=None, groups=None, REQUEST=None,
             # add groups
             try:
                 groupmanagers = self.acl_users.plugins.listPlugins(
-                                    igroup.IGroupManagement)
+                    igroup.IGroupManagement
+                )
             except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
                 logger.exception('Plugin listing error')
                 groupmanagers = ()
@@ -146,10 +144,11 @@ def editGroup(self, id, roles=None, groups=None, REQUEST=None,
                         if gm.addPrincipalToGroup(id, group):
                             break
                     except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-                        logger.exception('AuthenticationPlugin %s error'
-                                            % gm_id)
+                        logger.exception(
+                            'AuthenticationPlugin {0} error'.format(gm_id)
+                        )
 
-    security.declareProtected(DeleteGroups, 'removeGroup')
+    @security.protected(DeleteGroups)
     @postonly
     def removeGroup(self, group_id, REQUEST=None):
         """Remove a single group.
@@ -165,7 +164,7 @@ def removeGroup(self, group_id, REQUEST=None):
 
         return retval
 
-    security.declareProtected(DeleteGroups, 'removeGroups')
+    @security.protected(DeleteGroups)
     @postonly
     def removeGroups(self, ids, REQUEST=None):
         """Remove the group in the provided list (if possible).
@@ -173,13 +172,14 @@ def removeGroups(self, ids, REQUEST=None):
         for gid in ids:
             self.removeGroup(gid)
 
-    security.declareProtected(ManageGroups, 'setRolesForGroup')
+    @security.protected(ManageGroups)
     @postonly
     def setRolesForGroup(self, group_id, roles=(), REQUEST=None):
         rmanagers = self._getPlugins().listPlugins(IRoleAssignerPlugin)
         if not (rmanagers):
-            raise NotImplementedError('There is no plugin that can '
-                                      'assign roles to groups')
+            raise NotImplementedError(
+                'There is no plugin that can assign roles to groups'
+            )
         for rid, rmanager in rmanagers:
             rmanager.assignRolesToPrincipal(roles, group_id)
 
@@ -187,7 +187,7 @@ def setRolesForGroup(self, group_id, roles=(), REQUEST=None):
     # basic principal mgmt
     ##
 
-    security.declareProtected(ManageGroups, 'addPrincipalToGroup')
+    @security.protected(ManageGroups)
     @postonly
     def addPrincipalToGroup(self, principal_id, group_id, REQUEST=None):
         managers = self._getGroupManagers()
@@ -198,7 +198,7 @@ def addPrincipalToGroup(self, principal_id, group_id, REQUEST=None):
                 return True
         return False
 
-    security.declareProtected(ManageGroups, 'removePrincipalFromGroup')
+    @security.protected(ManageGroups)
     @postonly
     def removePrincipalFromGroup(self, principal_id, group_id, REQUEST=None):
         managers = self._getGroupManagers()
@@ -209,19 +209,18 @@ def removePrincipalFromGroup(self, principal_id, group_id, REQUEST=None):
                 return True
         return False
 
-
     ##
     # group getters
     ##
 
-    security.declareProtected(ViewGroups, 'getGroupById')
+    @security.protected(ViewGroups)
     def getGroupById(self, group_id):
         group = self.acl_users.getGroup(group_id)
         if group is not None:
             group = self.wrapGroup(group)
         return group
 
-    security.declareProtected(ManageGroups, 'searchGroups')
+    @security.protected(ManageGroups)
     def searchGroups(self, *args, **kw):
         return self.acl_users.searchGroups(*args, **kw)
 
@@ -285,7 +284,7 @@ def searchForGroups(self, REQUEST={}, **kw):
 
         return groups
 
-    security.declareProtected(ViewGroups, 'listGroups')
+    @security.protected(ViewGroups)
     def listGroups(self):
         # potentially not all groups may be found by this interface
         # if the underlying group source doesn't support introspection
@@ -295,7 +294,7 @@ def listGroups(self):
             groups.extend(introspector.getGroups())
         return [self.wrapGroup(elt) for elt in groups]
 
-    security.declareProtected(ViewGroups, 'getGroupIds')
+    @security.protected(ViewGroups)
     def getGroupIds(self):
         groups = []
         introspectors = self._getGroupIntrospectors()
@@ -305,7 +304,7 @@ def getGroupIds(self):
 
     listGroupIds = getGroupIds
 
-    security.declareProtected(ViewGroups, 'getGroupMembers')
+    @security.protected(ViewGroups)
     def getGroupMembers(self, group_id):
         members = set()
         introspectors = self._getGroupIntrospectors()
@@ -313,7 +312,7 @@ def getGroupMembers(self, group_id):
             members.update(introspector.getGroupMembers(group_id))
         return list(members)
 
-    security.declareProtected(ViewGroups, 'getGroupsForPrincipal')
+    @security.protected(ViewGroups)
     def getGroupsForPrincipal(self, principal):
         return getGroupsForPrincipal(principal, self._getPlugins())
 
@@ -321,34 +320,34 @@ def getGroupsForPrincipal(self, principal):
     # plugin getters
     ##
 
-    security.declarePrivate('_getPlugins')
+    @security.private
     def _getPlugins(self):
         return self.acl_users.plugins
 
-    security.declarePrivate('_getGroupManagers')
+    @security.private
     def _getGroupManagers(self):
         return self._getPlugins().listPlugins(
             igroup.IGroupManagement
             )
 
-    security.declarePrivate('_getGroupIntrospectors')
+    @security.private
     def _getGroupIntrospectors(self):
         return self._getPlugins().listPlugins(
             igroup.IGroupIntrospection
             )
 
-    security.declarePrivate('_getGroupTools')
+    @security.private
     def _getGroupTools(self):
         managers = self._getPlugins().listPlugins(
                         igroup.IGroupManagement)
         return [(id, manager) for (id, manager) in managers
-                             if igroup.IGroupIntrospection.providedBy(manager)]
+                if igroup.IGroupIntrospection.providedBy(manager)]
 
     ##
     # BBB
     ##
 
-    security.declarePublic('getGroupInfo')
+    @security.public
     def getGroupInfo(self, groupId):
         """
         Return default group info of any group
@@ -363,7 +362,7 @@ def getGroupInfo(self, groupId):
 
         return groupinfo
 
-    security.declareProtected(ViewGroups, 'getGroupsByUserId')
+    @security.protected(ViewGroups)
     def getGroupsByUserId(self, userid):
         """Return a list of the groups the user corresponding to 'userid'
         belongs to."""
@@ -374,13 +373,13 @@ def getGroupsByUserId(self, userid):
             groups = []
         return [self.getGroupById(elt) for elt in groups]
 
-    security.declareProtected(ViewGroups, 'listGroupNames')
+    @security.protected(ViewGroups)
     def listGroupNames(self):
         """Return a list of the available groups' ids as entered
         (without group prefixes)."""
         return self.acl_users.getGroupNames()
 
-    security.declarePublic("isGroup")
+    @security.public
     def isGroup(self, u):
         """Test if a user/group object is a group or not.
         You must pass an object you get earlier with wrapUser() or wrapGroup()
@@ -390,7 +389,7 @@ def isGroup(self, u):
             return 1
         return 0
 
-    security.declareProtected(SetGroupOwnership, 'setGroupOwnership')
+    @security.protected(SetGroupOwnership)
     @postonly
     def setGroupOwnership(self, group, object, REQUEST=None):
         """Make the object  'object' owned by group 'group'
@@ -403,7 +402,7 @@ def setGroupOwnership(self, group, object, REQUEST=None):
         object.changeOwnership(user)
         object.manage_setLocalRoles(user.getId(), ['Owner'])
 
-    security.declarePrivate('wrapGroup')
+    @security.private
     def wrapGroup(self, g, wrap_anon=0):
         ''' Sets up the correct acquisition wrappers for a group
         object and provides an opportunity for a portal_memberdata
@@ -427,7 +426,6 @@ def wrapGroup(self, g, wrap_anon=0):
             # Get portal_groupdata to do the wrapping.
             gd = getToolByName(parent, 'portal_groupdata')
             try:
-                #log("wrapping group %s" % g)
                 portal_group = gd.wrapGroup(g)
                 return portal_group
             except ConflictError:
diff --git a/Products/PlonePAS/tools/memberdata.py b/Products/PlonePAS/tools/memberdata.py
index 812b693..6d62f45 100644
--- a/Products/PlonePAS/tools/memberdata.py
+++ b/Products/PlonePAS/tools/memberdata.py
@@ -1,29 +1,27 @@
-from App.class_init import InitializeClass
-from Acquisition import aq_base
+# -*- coding: utf-8 -*-
 from AccessControl import ClassSecurityInfo
-
-from zope.interface import implements
-
+from AccessControl.requestmethod import postonly
+from Acquisition import aq_base
+from App.class_init import InitializeClass
 from Products.BTreeFolder2.BTreeFolder2 import BTreeFolder2
-from Products.CMFCore.permissions import ManagePortal
-from Products.CMFCore.utils import getToolByName
 from Products.CMFCore.MemberDataTool import MemberData as BaseMemberData
 from Products.CMFCore.MemberDataTool import MemberDataTool as BaseTool
-
-from Products.PluggableAuthService.interfaces.authservice \
-    import IPluggableAuthService
-from Products.PluggableAuthService.interfaces.plugins \
-    import IPropertiesPlugin, IRoleAssignerPlugin
-
-from Products.PlonePAS.interfaces.plugins import IUserManagement
+from Products.CMFCore.permissions import ManagePortal
+from Products.CMFCore.utils import getToolByName
+from Products.PlonePAS.interfaces.capabilities import IAssignRoleCapability
+from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
+from Products.PlonePAS.interfaces.capabilities import IGroupCapability
+from Products.PlonePAS.interfaces.capabilities import IManageCapabilities
+from Products.PlonePAS.interfaces.capabilities import IPasswordSetCapability
 from Products.PlonePAS.interfaces.group import IGroupManagement
+from Products.PlonePAS.interfaces.plugins import IUserManagement
 from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
-from Products.PlonePAS.interfaces.capabilities \
-    import IDeleteCapability, IPasswordSetCapability
-from Products.PlonePAS.interfaces.capabilities \
-    import IGroupCapability, IAssignRoleCapability
-from Products.PlonePAS.interfaces.capabilities import IManageCapabilities
-from AccessControl.requestmethod import postonly
+from Products.PluggableAuthService.interfaces.authservice import \
+    IPluggableAuthService
+from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
+from Products.PluggableAuthService.interfaces.plugins import \
+    IRoleAssignerPlugin
+from zope.interface import implementer
 
 _marker = object()
 
@@ -55,7 +53,7 @@ def _deletePortrait(self, member_id):
         if member_id in self.portraits:
             self.portraits._delObject(member_id)
 
-    security.declarePrivate('pruneMemberDataContents')
+    @security.private
     def pruneMemberDataContents(self):
         '''
         Compare the user IDs stored in the member data
@@ -72,7 +70,7 @@ def pruneMemberDataContents(self):
             if member_id not in user_list:
                 self.portraits._delObject(member_id)
 
-    security.declareProtected(ManagePortal, 'purgeMemberDataContents')
+    @security.protected(ManagePortal)
     def purgeMemberDataContents(self):
         '''
         Delete ALL MemberData information. This is required for us as we change
@@ -86,7 +84,7 @@ def purgeMemberDataContents(self):
 
         return "Done."
 
-    security.declarePrivate("updateMemberDataContents")
+    @security.private
     def updateMemberDataContents(self,):
         """Update former MemberData objects to new MemberData objects
         """
@@ -115,14 +113,15 @@ def updateMemberDataContents(self,):
             # Set its properties
             mbr = self._members.get(member_name, None)
             if not mbr:
-                raise RuntimeError("Error while upgrading user '%s'."
-                                        % (member_name, ))
+                raise RuntimeError(
+                    "Error while upgrading user '{0}'.".format(member_name)
+                )
             mbr.setProperties(values, force_local=1)
             count += 1
 
         return count
 
-    security.declarePrivate('searchMemberDataContents')
+    @security.private
     def searchMemberDataContents(self, search_param, search_term):
         """
         Search members.
@@ -151,7 +150,7 @@ def searchMemberDataContents(self, search_param, search_term):
                                     'email': memberProperty('email', '')})
         return res
 
-    security.declarePublic('searchFulltextForMembers')
+    @security.public
     def searchFulltextForMembers(self, s):
         """search for members which do have string 's' in name, email or full
         name (if defined)
@@ -165,13 +164,13 @@ def searchFulltextForMembers(self, s):
         for member in mu.listMembers():
             u = member.getUser()
             if u.getUserName().lower().find(s) != -1 \
-                or member.getProperty('fullname').lower().find(s) != -1 \
-                or member.getProperty('email').lower().find(s) != -1:
-                    res.append(member)
+               or member.getProperty('fullname').lower().find(s) != -1 \
+               or member.getProperty('email').lower().find(s) != -1:
+                res.append(member)
         return res
 
-    #### check to see if we can add users. Need to be careful here
-    #### so we do not write on read
+    # check to see if we can add users. Need to be careful here
+    # so we do not write on read
     def canAddMemberData(self):
         try:
             if self.REQUEST.REQUEST_METHOD != 'POST':
@@ -184,28 +183,28 @@ def canAddMemberData(self):
             pass
         return False
 
-    #### an exact copy from the base, so that we pick up the new MemberData.
-    #### wrapUser should have a MemberData factory method to over-ride (or even
-    #### set at run-time!) so that we don't have to do this.
+    # an exact copy from the base, so that we pick up the new MemberData.
+    # wrapUser should have a MemberData factory method to over-ride (or even
+    # set at run-time!) so that we don't have to do this.
     def wrapUser(self, u):
         '''
         If possible, returns the Member object that corresponds
         to the given User object.
         We override this to ensure OUR MemberData class is used
         '''
-        id = u.getId()
+        user_id = u.getId()
         members = self._members
-        if not id in members:
+        if user_id not in members:
             base = aq_base(self)
-            md = MemberData(base, id)
+            md = MemberData(base, user_id)
             if self.canAddMemberData():
                 # XXX do not write on read
-                members[id] = md
+                members[user_id] = md
             return md.__of__(self).__of__(u)
         else:
             # Return a wrapper with self as containment and
             # the user as context.
-            return members[id].__of__(self).__of__(u)
+            return members[user_id].__of__(self).__of__(u)
 
     @postonly
     def deleteMemberData(self, member_id, REQUEST=None):
@@ -232,19 +231,19 @@ def deleteMemberData(self, member_id, REQUEST=None):
         else:
             return 0
 
-    ## plugin getter
+    # plugin getter
     def _getPlugins(self):
         return self.acl_users.plugins
 
 InitializeClass(MemberDataTool)
 
 
+@implementer(IManageCapabilities)
 class MemberData(BaseMemberData):
 
     security = ClassSecurityInfo()
-    implements(IManageCapabilities)
 
-    ## setProperties uses setMemberProperties. no need to override.
+    # setProperties uses setMemberProperties. no need to override.
 
     def setMemberProperties(self, mapping, force_local=0):
         """PAS-specific method to set the properties of a
@@ -274,7 +273,7 @@ def setMemberProperties(self, mapping, force_local=0):
         # property routing?
         modified = False
         for k, v in mapping.items():
-            if v == None:
+            if v is None:
                 continue
             for sheet in sheets:
                 if not sheet.hasProperty(k):
@@ -284,8 +283,6 @@ def setMemberProperties(self, mapping, force_local=0):
                     modified = True
                 else:
                     break
-                    #raise RuntimeError, ("Mutable property provider "
-                    #                     "shadowed by read only provider")
         if modified:
             self.notifyModified()
 
@@ -328,7 +325,7 @@ def getPassword(self):
         """Returns None. Present to avoid NotImplementedError."""
         return None
 
-    ## IManageCapabilities methods
+    # IManageCapabilities methods
 
     def canDelete(self):
         """True iff user can be removed from the Plone UI."""
@@ -426,7 +423,7 @@ def canAssignRole(self, role_id):
                 return True
         return False
 
-    security.declarePrivate('setSecurityProfile')
+    @security.private
     def setSecurityProfile(self, password=None, roles=None, domains=None):
         """Set the user's basic security profile"""
         u = self.getUser()
@@ -441,9 +438,9 @@ def setSecurityProfile(self, password=None, roles=None, domains=None):
 
         u.userFolderEditUser(u.getUserId(), password, roles, domains)
 
-    ## plugin getters
+    # plugin getters
 
-    security.declarePrivate('_getPlugins')
+    @security.private
     def _getPlugins(self):
         return self.acl_users.plugins
 
diff --git a/Products/PlonePAS/tools/membership.py b/Products/PlonePAS/tools/membership.py
index 7d9459a..b684150 100644
--- a/Products/PlonePAS/tools/membership.py
+++ b/Products/PlonePAS/tools/membership.py
@@ -1,54 +1,49 @@
-import logging
-from cStringIO import StringIO
-
-import transaction
-from zope import event
-from zope.interface import implements
-
-from DateTime import DateTime
-from App.class_init import InitializeClass
-from App.special_dtml import DTMLFile
-from OFS.Image import Image
-
+# -*- coding: utf-8 -*-
 from AccessControl import ClassSecurityInfo
-from AccessControl import getSecurityManager
 from AccessControl import Unauthorized
+from AccessControl import getSecurityManager
 from AccessControl.SecurityManagement import noSecurityManager
 from AccessControl.requestmethod import postonly
 from Acquisition import aq_get
 from Acquisition import aq_inner
 from Acquisition import aq_parent
-from zExceptions import BadRequest
-from ZODB.POSException import ConflictError
-
-from Products.CMFDefault.utils import decode
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from DateTime import DateTime
+from OFS.Image import Image
+from Products.CMFCore.MembershipTool import MembershipTool as BaseTool
+from Products.CMFCore.permissions import ListPortalMembers
 from Products.CMFCore.permissions import ManagePortal
 from Products.CMFCore.permissions import ManageUsers
-from Products.CMFCore.permissions import SetOwnProperties
 from Products.CMFCore.permissions import SetOwnPassword
+from Products.CMFCore.permissions import SetOwnProperties
 from Products.CMFCore.permissions import View
-from Products.CMFCore.permissions import ListPortalMembers
 from Products.CMFCore.utils import _checkPermission
 from Products.CMFCore.utils import getToolByName
-from Products.CMFCore.MembershipTool import MembershipTool as BaseTool
-
-from Products.PlonePAS.events import UserLoggedInEvent
+from Products.CMFDefault.utils import decode
 from Products.PlonePAS.events import UserInitialLoginInEvent
+from Products.PlonePAS.events import UserLoggedInEvent
 from Products.PlonePAS.events import UserLoggedOutEvent
 from Products.PlonePAS.interfaces import membership
 from Products.PlonePAS.utils import cleanId
 from Products.PlonePAS.utils import scale_image
+from ZODB.POSException import ConflictError
+from cStringIO import StringIO
+from zExceptions import BadRequest
+from zope import event
+from zope.interface import implementer
+import logging
+import transaction
 
 default_portrait = 'defaultUser.png'
 logger = logging.getLogger('PlonePAS')
 
 
+@implementer(membership.IMembershipTool)
 class MembershipTool(BaseTool):
     """PAS-based customization of MembershipTool.
     """
 
-    implements(membership.IMembershipTool)
-
     meta_type = "PlonePAS Membership Tool"
     toolicon = 'tool.gif'
     personal_id = '.personal'
@@ -68,9 +63,9 @@ class MembershipTool(BaseTool):
                      'mode': 'rw',
                      },))
 
-    manage_options = (BaseTool.manage_options
-                        + ({'label': 'Portraits',
-                            'action': 'manage_portrait_fix'},))
+    manage_options = (BaseTool.manage_options +
+                      ({'label': 'Portraits',
+                        'action': 'manage_portrait_fix'},))
 
     # TODO I'm not quite sure why getPortalRoles is declared 'Managed'
     #    in CMFCore.MembershipTool - but in Plone we are not so anal ;-)
@@ -82,27 +77,31 @@ class MembershipTool(BaseTool):
     security.declareProtected(ManagePortal, 'manage_portrait_fix')
     manage_portrait_fix = DTMLFile('../zmi/portrait_fix', globals())
 
-    security.declareProtected(ManagePortal, 'manage_setMemberAreaType')
+    @security.protected(ManagePortal)
     def manage_setMemberAreaType(self, type_name, REQUEST=None):
         """ ZMI method to set the home folder type by its type name.
         """
         self.setMemberAreaType(type_name)
         if REQUEST is not None:
-            REQUEST['RESPONSE'].redirect(self.absolute_url()
-                    + '/manage_mapRoles'
-                    + '?manage_tabs_message=Member+area+type+changed.')
+            REQUEST['RESPONSE'].redirect(
+                self.absolute_url() +
+                '/manage_mapRoles'
+                '?manage_tabs_message=Member+area+type+changed.'
+            )
 
-    security.declareProtected(ManagePortal, 'manage_setMembersFolderById')
+    @security.protected(ManagePortal)
     def manage_setMembersFolderById(self, id, REQUEST=None):
         """ ZMI method to set the members folder object by its id.
         """
         self.setMembersFolderById(id)
         if REQUEST is not None:
-            REQUEST['RESPONSE'].redirect(self.absolute_url()
-                    + '/manage_mapRoles'
-                    + '?manage_tabs_message=Members+folder+id+changed.')
+            REQUEST['RESPONSE'].redirect(
+                self.absolute_url() +
+                '/manage_mapRoles'
+                '?manage_tabs_message=Members+folder+id+changed.'
+            )
 
-    security.declareProtected(ManagePortal, 'setMemberAreaType')
+    @security.protected(ManagePortal)
     def setMemberAreaType(self, type_name):
         """ Sets the portal type to use for new home folders.
         """
@@ -110,21 +109,21 @@ def setMemberAreaType(self, type_name):
         # members to have objects instead of folders as home "directory".
         self.memberarea_type = str(type_name).strip()
 
-    security.declareProtected(ManagePortal, 'setMembersFolderById')
+    @security.protected(ManagePortal)
     def setMembersFolderById(self, id=''):
         """ Set the members folder object by its id.
         """
         self.membersfolder_id = id.strip()
 
-    security.declarePublic('getMembersFolder')
+    @security.public
     def getMembersFolder(self):
         """ Get the members folder object.
         """
-        parent = aq_parent( aq_inner(self) )
+        parent = aq_parent(aq_inner(self))
         members = getattr(parent, self.membersfolder_id, None)
         return members
 
-    security.declarePrivate('addMember')
+    @security.private
     def addMember(self, id, password, roles, domains, properties=None):
         """Adds a new member to the user folder.
 
@@ -140,7 +139,7 @@ def addMember(self, id, password, roles, domains, properties=None):
             member = self.getMemberById(id)
             member.setMemberProperties(properties)
 
-    security.declareProtected(ListPortalMembers, 'searchForMembers')
+    @security.protected(ListPortalMembers)
     def searchForMembers(self, REQUEST=None, **kw):
         """Hacked up version of Plone searchForMembers.
 
@@ -159,8 +158,6 @@ def searchForMembers(self, REQUEST=None, **kw):
         logger.debug('searchForMembers: started.')
 
         acl_users = getToolByName(self, "acl_users")
-        md = getToolByName(self, "portal_memberdata")
-        groups_tool = getToolByName(self, "portal_groups")
 
         if REQUEST is not None:
             searchmap = REQUEST
@@ -177,8 +174,10 @@ def searchForMembers(self, REQUEST=None, **kw):
             searchmap['fullname'] = searchmap['name']
             del searchmap['name']
 
-        user_search = dict([x for x in searchmap.items()
-                               if x[0] in self.user_search_keywords and x[1]])
+        user_search = dict(
+            [x for x in searchmap.items()
+             if x[0] in self.user_search_keywords and x[1]]
+        )
 
         fullname = searchmap.get('fullname', None)
         email = searchmap.get('email', None)
@@ -202,13 +201,11 @@ def searchForMembers(self, REQUEST=None, **kw):
             'searchForMembers: searching PAS '
             'with arguments %r.' % user_search)
         for user in acl_users.searchUsers(**user_search):
-            uid = user['userid']
-            uf_users.append(uid)
+            uf_users.append(user['userid'])
 
         if not uf_users:
             return []
 
-        wrap = self.wrapUser
         getUserById = acl_users.getUserById
 
         def dedupe(seq):
@@ -216,17 +213,13 @@ def dedupe(seq):
             seen = set()
             seen_add = seen.add
             # nice trick! set.add() does always return None
-            return [ x for x in seq if x not in seen and not seen_add(x)]
+            return [x for x in seq if x not in seen and not seen_add(x)]
 
         uf_users = dedupe(uf_users)
         members = [getUserById(userid) for userid in uf_users]
         members = [member for member in members if member is not None]
 
-        if (not email and
-            not fullname and
-            not roles and
-            not groupname and
-            not last_login_time):
+        if not (email or fullname or roles or groupname or last_login_time):
             logger.debug(
                 'searchForMembers: searching users '
                 'with no extra filter, immediate return.')
@@ -234,7 +227,6 @@ def dedupe(seq):
 
         # Now perform individual checks on each user
         res = []
-        portal = getToolByName(self, 'portal_url').getPortalObject()
 
         for member in members:
             if groupname and groupname not in member.getGroupIds():
@@ -268,10 +260,10 @@ def dedupe(seq):
         logger.debug('searchForMembers: finished.')
         return res
 
-    #############
-    ## sanitize home folders (we may get URL-illegal ids)
+    ############
+    # sanitize home folders (we may get URL-illegal ids)
 
-    security.declarePublic('createMemberarea')
+    @security.public
     def createMemberarea(self, member_id=None, minimal=None):
         """
         Create a member area for 'member_id' or the authenticated
@@ -279,7 +271,6 @@ def createMemberarea(self, member_id=None, minimal=None):
         """
         if not self.getMemberareaCreationFlag():
             return None
-        catalog = getToolByName(self, 'portal_catalog')
         membership = getToolByName(self, 'portal_membership')
         members = self.getMembersFolder()
 
@@ -311,8 +302,9 @@ def createMemberarea(self, member_id=None, minimal=None):
             # - cleanId made a empty string out of member_id
             logger.debug(
                 'createMemberarea: empty member id '
-                '(%r, %r), skipping member area creation.' % (
-                member_id, safe_member_id))
+                '(%r, %r), skipping member area creation.' %
+                (member_id, safe_member_id)
+            )
             return
 
         # Create member area without security checks
@@ -334,7 +326,7 @@ def createMemberarea(self, member_id=None, minimal=None):
 
         member_object = self.getMemberById(member_id)
 
-        ## Modify member folder
+        # Modify member folder
         member_folder = self.getHomeFolder(member_id)
         # Grant Ownership and Owner role to Member
         member_folder.changeOwnership(user)
@@ -345,16 +337,16 @@ def createMemberarea(self, member_id=None, minimal=None):
         member_folder.setTitle(fullname or member_id)
         member_folder.reindexObject()
 
-        ## Hook to allow doing other things after memberarea creation.
+        # Hook to allow doing other things after memberarea creation.
         notify_script = getattr(member_folder, 'notifyMemberAreaCreated', None)
         if notify_script is not None:
             notify_script()
 
-     # deal with ridiculous API change in CMF
+    # deal with ridiculous API change in CMF
     security.declarePublic('createMemberArea')
     createMemberArea = createMemberarea
 
-    security.declarePublic('getMemberInfo')
+    @security.public
     def getMemberInfo(self, memberId=None):
         # Return 'harmless' Memberinfo of any member, such as Full name,
         # Location, etc
@@ -366,14 +358,15 @@ def getMemberInfo(self, memberId=None):
         if member is None:
             return None
 
-        memberinfo = {'fullname'    : member.getProperty('fullname'),
-                      'description' : member.getProperty('description'),
-                      'location'    : member.getProperty('location'),
-                      'language'    : member.getProperty('language'),
-                      'home_page'   : member.getProperty('home_page'),
-                      'username'    : member.getUserName(),
-                      'has_email'   : bool(member.getProperty('email')),
-                     }
+        memberinfo = {
+            'fullname': member.getProperty('fullname'),
+            'description': member.getProperty('description'),
+            'location': member.getProperty('location'),
+            'language': member.getProperty('language'),
+            'home_page': member.getProperty('home_page'),
+            'username': member.getUserName(),
+            'has_email': bool(member.getProperty('email')),
+        }
 
         return memberinfo
 
@@ -391,7 +384,7 @@ def _getSafeMemberId(self, id=None):
 
         return cleanId(id)
 
-    security.declarePublic('getHomeFolder')
+    @security.public
     def getHomeFolder(self, id=None, verifyPermission=0):
         """ Return a member's home folder object, or None.
 
@@ -426,7 +419,7 @@ def getHomeUrl(self, id=None, verifyPermission=0):
         else:
             return None
 
-    security.declarePublic('getPersonalFolder')
+    @security.public
     def getPersonalFolder(self, member_id=None):
         """
         returns the Personal Item folder for a member
@@ -438,7 +431,7 @@ def getPersonalFolder(self, member_id=None):
             personal = getattr(home, self.personal_id, None)
         return personal
 
-    security.declarePublic('getPersonalPortrait')
+    @security.public
     def getPersonalPortrait(self, id=None, verifyPermission=0):
         """Return a members personal portait.
 
@@ -461,7 +454,7 @@ def getPersonalPortrait(self, id=None, verifyPermission=0):
 
         return portrait
 
-    security.declareProtected(SetOwnProperties, 'deletePersonalPortrait')
+    @security.protected(SetOwnProperties)
     def deletePersonalPortrait(self, id=None):
         """deletes the Portait of a member.
         """
@@ -476,7 +469,7 @@ def deletePersonalPortrait(self, id=None):
         membertool = getToolByName(self, 'portal_memberdata')
         return membertool._deletePortrait(safe_id)
 
-    security.declareProtected(SetOwnProperties, 'changeMemberPortrait')
+    @security.protected(SetOwnProperties)
     def changeMemberPortrait(self, portrait, id=None):
         """update the portait of a member.
 
@@ -503,7 +496,7 @@ def changeMemberPortrait(self, portrait, id=None):
             membertool = getToolByName(self, 'portal_memberdata')
             membertool._setPortrait(portrait, safe_id)
 
-    security.declareProtected(ManageUsers, 'listMembers')
+    @security.protected(ManageUsers)
     def listMembers(self):
         '''Gets the list of all members.
         THIS METHOD MIGHT BE VERY EXPENSIVE ON LARGE USER FOLDERS AND MUST
@@ -514,7 +507,7 @@ def listMembers(self):
         '''
         return BaseTool.listMembers(self)
 
-    security.declareProtected(ManageUsers, 'listMemberIds')
+    @security.protected(ManageUsers)
     def listMemberIds(self):
         '''Lists the ids of all members.  This may eventually be
         replaced with a set of methods for querying pieces of the
@@ -522,7 +515,7 @@ def listMemberIds(self):
         '''
         return self.acl_users.getUserIds()
 
-    security.declareProtected(SetOwnPassword, 'testCurrentPassword')
+    @security.protected(SetOwnPassword)
     def testCurrentPassword(self, password):
         """ test to see if password is current """
         REQUEST = getattr(self, 'REQUEST', {})
@@ -546,14 +539,13 @@ def _findUsersAclHome(self, userid):
         else:
             return None
 
-    security.declareProtected(SetOwnPassword, 'setPassword')
+    @security.protected(SetOwnPassword)
     def setPassword(self, password, domains=None, REQUEST=None):
         '''Allows the authenticated member to set his/her own password.
         '''
         registration = getToolByName(self, 'portal_registration', None)
         if not self.isAnonymousUser():
             member = self.getAuthenticatedMember()
-            #self.acl_users
             acl_users = self._findUsersAclHome(member.getUserId())
             if not acl_users:
                 # should not possibly ever happen
@@ -581,7 +573,7 @@ def setPassword(self, password, domains=None, REQUEST=None):
             raise BadRequest('Not logged in.')
     setPassword = postonly(setPassword)
 
-    security.declareProtected(View, 'getCandidateLocalRoles')
+    @security.protected(View)
     def getCandidateLocalRoles(self, obj):
         """ What local roles can I assign?
             Override the CMFCore version so that we can see the local roles on
@@ -592,14 +584,14 @@ def getCandidateLocalRoles(self, obj):
         if 'Manager' in member.getRolesInContext(obj):
             # Use valid_roles as we may want roles defined only on a subobject
             local_roles = [r for r in obj.valid_roles() if r not in
-                            ('Anonymous', 'Authenticated', 'Shared')]
+                           ('Anonymous', 'Authenticated', 'Shared')]
         else:
             local_roles = [role for role in member.getRolesInContext(obj)
-                                if role not in ('Member', 'Authenticated')]
+                           if role not in ('Member', 'Authenticated')]
         local_roles.sort()
         return tuple(local_roles)
 
-    security.declareProtected(View, 'loginUser')
+    @security.protected(View)
     def loginUser(self, REQUEST=None):
         """ Handle a login for the current user.
 
@@ -638,7 +630,7 @@ def loginUser(self, REQUEST=None):
             # The cookie plugin may not be present
             pass
 
-    security.declareProtected(View, 'logoutUser')
+    @security.protected(View)
     def logoutUser(self, REQUEST=None):
         """Process a user logout.
 
@@ -679,13 +671,13 @@ def logoutUser(self, REQUEST=None):
         if user is not None:
             event.notify(UserLoggedOutEvent(user))
 
-    security.declareProtected(View, 'immediateLogout')
+    @security.protected(View)
     def immediateLogout(self):
         """ Log the current user out immediately.  Used by logout.py so that
             we do not have to do a redirect to show the logged out status. """
         noSecurityManager()
 
-    security.declarePublic('setLoginTimes')
+    @security.public
     def setLoginTimes(self):
         """ Called by logged_in to set the login time properties
             even if members lack the "Set own properties" permission.
@@ -705,7 +697,7 @@ def setLoginTimes(self):
                                  last_login_time=login_time)
         return res
 
-    security.declareProtected(ManagePortal, 'getBadMembers')
+    @security.protected(ManagePortal)
     def getBadMembers(self):
         """Will search for members with bad images in the portal_memberdata
         delete their portraits and return their member ids"""
@@ -724,10 +716,12 @@ def getBadMembers(self):
             try:
                 import PIL
             except ImportError:
-                raise RuntimeError('No Python Imaging Libraries (PIL) found. '
-                    'Unable to validate profile image.')
+                raise RuntimeError(
+                    'No Python Imaging Libraries (PIL) found. '
+                    'Unable to validate profile image.'
+                )
             try:
-                img = PIL.Image.open(StringIO(portrait_data))
+                PIL.Image.open(StringIO(portrait_data))
             except ConflictError:
                 pass
             except:
diff --git a/Products/PlonePAS/utils.py b/Products/PlonePAS/utils.py
index 57c6799..c204a65 100644
--- a/Products/PlonePAS/utils.py
+++ b/Products/PlonePAS/utils.py
@@ -1,10 +1,10 @@
+# -*- coding: utf-8 -*-
+from Products.PlonePAS.config import IMAGE_SCALE_PARAMS
+from Products.PluggableAuthService.interfaces.plugins import IGroupsPlugin
 from cStringIO import StringIO
 from urllib import quote as url_quote
 from urllib import unquote as url_unquote
 
-from Products.PlonePAS.config import IMAGE_SCALE_PARAMS
-from Products.PluggableAuthService.interfaces.plugins import IGroupsPlugin
-
 
 def unique(iterable):
     d = {}
@@ -143,7 +143,7 @@ def scale_image(image_file, max_size=None, default_format=None):
     # When might image.format not be true?
     format = image.format
     mimetype = 'image/%s' % format.lower()
-    cur_size = image.size
+
     # from Archetypes ImageField
     # consider image mode when scaling
     # source images can be mode '1','L,','P','RGB(A)'
diff --git a/Products/__init__.py b/Products/__init__.py
index f48ad10..68c04af 100644
--- a/Products/__init__.py
+++ b/Products/__init__.py
@@ -1,6 +1,2 @@
-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages
-try:
-    __import__('pkg_resources').declare_namespace(__name__)
-except ImportError:
-    from pkgutil import extend_path
-    __path__ = extend_path(__path__, __name__)
+# -*- coding: utf-8 -*-
+__import__('pkg_resources').declare_namespace(__name__)
diff --git a/README.rst b/README.rst
new file mode 100644
index 0000000..925cae2
--- /dev/null
+++ b/README.rst
@@ -0,0 +1,74 @@
+Overview
+========
+
+This product adapts the
+"PluggableAuthService":http://svn.zope.org/PluggableAuthService/
+for use by Plone.
+
+Notes
+-----
+
+Why doesn't the title of my group, that I set in the ZODB, show up?
+The title for a group comes from the properties plugin. The info
+in the groups plugin isn't used, except for the name.
+
+The value of the 'title' property on the portal_groupdata or
+portal_memberdata tools themselves (as opposed to the group or
+member data records within them) will not be used as a default for
+the title of the group or member. This is to prevent UI confusion if
+a title is set without realizing the implications. To remove this
+special case, see 'plugins.property._getDefaultValues'.
+
+If PAS caching is enabled (see the "Cache" tab) and the cache
+manager does not have a 'cleanup' method (RAMCacheManager has one),
+then changes to the memberdata schema will not effect users already
+cached. In this case, restart the server or clear the cache (if
+possible) for the changes to take effect.
+
+Similarly, changes to the memberdata schema will not propagate to
+member objects already in use. If you have a memberdata object and
+change the memberdata properties you must re-construct the member by
+saying portal_membership.getMemberById again.  See
+'tests.test_properties.test_user_properties' for example.
+
+By default, logout from users signed in under HTTP Basic Auth cannot
+log out.  If you enable the "Credentials Reset" plugin for the HTTP
+Basic plugin, the logout for cookies will no longer work. However,
+this is not a problem if you're not using cookies.
+
+Implementation
+--------------
+
+In some places, PlonePAS acts as an adaptor to make PAS provide
+enough of GRUF's interface to satisfy Plone. All the monkey patches
+in pas.py, for instance, extend PAS with expected methods.
+
+PlonePAS also modifies Plone to work with PAS by providing
+partially-new implementations of several tools.  In the tools/
+directory you can see new tools for groups and members, as well as
+the utils tool.
+
+It also provides extra capabilities for PAS needed by plone, such as
+mutable property sheets, local role calculation, creation of group
+objects, and more.
+
+Authorship
+----------
+
+Initial creation: The PAS CIGNEX Sprint Team [ Anders, Bob, Ben,
+Chad, Gautham, Joel, Kapil, Michel, Micheal ]
+
+Post-sprint work: J Cameron Cooper, Leo, Sidnei, Mark at "Enfold
+Systems":http://enfoldsystems.com
+
+Basic setAuthCookie support (to mimick CookieCrumbler):
+Rocky Burt at "ServerZen Software":http://www.serverzen.com
+
+Synced login process with Plone:
+Dorneles Tremea at "PloneSolutions":http://plonesolutions.com
+
+Bugfixes, various development and merging with Plone:
+Wichert Akkerman at Simplon
+
+Bugfixes, improvements to membership and property lookups:
+Eric Steele and Erik Rose
diff --git a/README.txt b/README.txt
deleted file mode 100644
index 925cae2..0000000
--- a/README.txt
+++ /dev/null
@@ -1,74 +0,0 @@
-Overview
-========
-
-This product adapts the
-"PluggableAuthService":http://svn.zope.org/PluggableAuthService/
-for use by Plone.
-
-Notes
------
-
-Why doesn't the title of my group, that I set in the ZODB, show up?
-The title for a group comes from the properties plugin. The info
-in the groups plugin isn't used, except for the name.
-
-The value of the 'title' property on the portal_groupdata or
-portal_memberdata tools themselves (as opposed to the group or
-member data records within them) will not be used as a default for
-the title of the group or member. This is to prevent UI confusion if
-a title is set without realizing the implications. To remove this
-special case, see 'plugins.property._getDefaultValues'.
-
-If PAS caching is enabled (see the "Cache" tab) and the cache
-manager does not have a 'cleanup' method (RAMCacheManager has one),
-then changes to the memberdata schema will not effect users already
-cached. In this case, restart the server or clear the cache (if
-possible) for the changes to take effect.
-
-Similarly, changes to the memberdata schema will not propagate to
-member objects already in use. If you have a memberdata object and
-change the memberdata properties you must re-construct the member by
-saying portal_membership.getMemberById again.  See
-'tests.test_properties.test_user_properties' for example.
-
-By default, logout from users signed in under HTTP Basic Auth cannot
-log out.  If you enable the "Credentials Reset" plugin for the HTTP
-Basic plugin, the logout for cookies will no longer work. However,
-this is not a problem if you're not using cookies.
-
-Implementation
---------------
-
-In some places, PlonePAS acts as an adaptor to make PAS provide
-enough of GRUF's interface to satisfy Plone. All the monkey patches
-in pas.py, for instance, extend PAS with expected methods.
-
-PlonePAS also modifies Plone to work with PAS by providing
-partially-new implementations of several tools.  In the tools/
-directory you can see new tools for groups and members, as well as
-the utils tool.
-
-It also provides extra capabilities for PAS needed by plone, such as
-mutable property sheets, local role calculation, creation of group
-objects, and more.
-
-Authorship
-----------
-
-Initial creation: The PAS CIGNEX Sprint Team [ Anders, Bob, Ben,
-Chad, Gautham, Joel, Kapil, Michel, Micheal ]
-
-Post-sprint work: J Cameron Cooper, Leo, Sidnei, Mark at "Enfold
-Systems":http://enfoldsystems.com
-
-Basic setAuthCookie support (to mimick CookieCrumbler):
-Rocky Burt at "ServerZen Software":http://www.serverzen.com
-
-Synced login process with Plone:
-Dorneles Tremea at "PloneSolutions":http://plonesolutions.com
-
-Bugfixes, various development and merging with Plone:
-Wichert Akkerman at Simplon
-
-Bugfixes, improvements to membership and property lookups:
-Eric Steele and Erik Rose
diff --git a/setup.py b/setup.py
index 01a9a83..27865ad 100644
--- a/setup.py
+++ b/setup.py
@@ -1,8 +1,10 @@
-from setuptools import setup, find_packages
+# -*- coding: utf-8 -*-
+from setuptools import setup
+from setuptools import find_packages
 
 version = '5.0.1.dev0'
 
-install_requires=[
+install_requires = [
         'setuptools',
         'plone.memoize',
         'plone.session',
@@ -15,29 +17,33 @@
       ]
 
 try:
-    from collections import OrderedDict
+    from collections import OrderedDict  # noqa
 except ImportError:
     install_requires.append('ordereddict')
 
-setup(name='Products.PlonePAS',
-      version=version,
-      description="PlonePAS adapts the PluggableAuthService for use by Plone.",
-      long_description=open("README.txt").read() + "\n" + \
-                       open("CHANGES.txt").read(),
-      classifiers=[
+longdescription = open("README.rst").read()
+longdescription += '\n'
+longdescription += open("CHANGES.rst").read()
+
+setup(
+    name='Products.PlonePAS',
+    version=version,
+    description="PlonePAS adapts the PluggableAuthService for use by Plone.",
+    long_description=longdescription,
+    classifiers=[
         "Framework :: Plone",
         "Framework :: Zope2",
-      ],
-      keywords='Zope CMF Plone PAS authentication',
-      author='Kapil Thangavelu, Wichert Akkerman',
-      author_email='plone-developers@lists.sourceforge.net',
-      url='http://pypi.python.org/pypi/Products.PlonePAS',
-      license='ZPL',
-      packages=find_packages(exclude=['ez_setup']),
-      namespace_packages=['Products'],
-      include_package_data=True,
-      zip_safe=False,
-      extras_require=dict(
+    ],
+    keywords='Zope CMF Plone PAS authentication',
+    author='Kapil Thangavelu, Wichert Akkerman',
+    author_email='plone-developers@lists.sourceforge.net',
+    url='http://pypi.python.org/pypi/Products.PlonePAS',
+    license='ZPL',
+    packages=find_packages(exclude=['ez_setup']),
+    namespace_packages=['Products'],
+    clude_package_data=True,
+    zip_safe=False,
+    extras_require=dict(
         test=[
             'plone.app.testing',
             'plone.testing',
@@ -46,6 +52,6 @@
         atstorage=[
             'Products.Archetypes',
         ]
-      ),
-      install_requires=install_requires,
+    ),
+    install_requires=install_requires,
 )


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:36:18+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/6f34326ea365c01dcba9b51b5ac46c8f9cff2a83

cleanup patches, make them better readable, add deprecation and merge gruf_support in pas to reduce complexicty

Files changed:
M Products/PlonePAS/__init__.py
M Products/PlonePAS/config.py
M Products/PlonePAS/pas.py
M Products/PlonePAS/patch.py
M setup.py
D Products/PlonePAS/gruf_support.py

diff --git a/Products/PlonePAS/__init__.py b/Products/PlonePAS/__init__.py
index 1911708..ba29fa7 100644
--- a/Products/PlonePAS/__init__.py
+++ b/Products/PlonePAS/__init__.py
@@ -30,11 +30,6 @@
 else:
     from Products.PlonePAS import  ldapmp
 
-#################################
-# pas monkies 2 play w/ gruf
-if config.PAS_INSIDE_GRUF:
-    from Products.PlonePAS import gruf_support
-
 
 ####################################
 # monkey patch pas, the evil happens
diff --git a/Products/PlonePAS/config.py b/Products/PlonePAS/config.py
index 1d4e134..0b202aa 100644
--- a/Products/PlonePAS/config.py
+++ b/Products/PlonePAS/config.py
@@ -2,7 +2,7 @@
 PROJECTNAME = 'PlonePAS'
 GLOBALS = globals()
 
-PAS_INSIDE_GRUF = True
+PAS_INSIDE_GRUF = False
 
 DEFAULT_CHALLENGE_PROTOCOL = ['http']
 DEFAULT_PROTO_MAPPING = {
diff --git a/Products/PlonePAS/gruf_support.py b/Products/PlonePAS/gruf_support.py
deleted file mode 100644
index 37a0fe5..0000000
--- a/Products/PlonePAS/gruf_support.py
+++ /dev/null
@@ -1,143 +0,0 @@
-# -*- coding: utf-8 -*-
-# gruf specific hacks to pas, to make it play well in gruf
-from Products.CMFCore.utils import getToolByName
-from Products.PlonePAS.interfaces.group import IGroupManagement
-from Products.PlonePAS.interfaces.plugins import IUserIntrospection
-from Products.PluggableAuthService.PluggableAuthService import \
-    PluggableAuthService
-from Products.PluggableAuthService.PluggableAuthService import \
-    _SWALLOWABLE_PLUGIN_EXCEPTIONS
-from Products.PluggableAuthService.interfaces.plugins import \
-    IAuthenticationPlugin
-import logging
-
-logger = logging.getLogger('PlonePAS')
-
-
-def authenticate(self, name, password, request):
-    """See AccessControl.User.BasicUserFolder.authenticate
-
-    Products.PluggableAuthService.PluggableAuthService does not provide this
-    method, BasicUserFolder documents it as "Private UserFolder object
-    interface". GRUF does provide the method, so not marked as private.
-    """
-
-    plugins = self.plugins
-
-    try:
-        authenticators = plugins.listPlugins(IAuthenticationPlugin)
-    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
-        authenticators = ()
-
-    credentials = {'login': name,
-                   'password': password}
-
-    user_id = None
-
-    for authenticator_id, auth in authenticators:
-        try:
-            uid_and_name = auth.authenticateCredentials(credentials)
-            if uid_and_name is not None:
-                user_id, name = uid_and_name
-                break
-        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-            logger.info(
-                    'PluggableAuthService: AuthenticationPlugin %s error',
-                    authenticator_id, exc_info=1)
-            continue
-
-    if not user_id:
-        return
-
-    return self._findUser(plugins, user_id, name, request)
-
-PluggableAuthService.authenticate = authenticate
-PluggableAuthService.authenticate__roles__ = ()
-
-
-#################################
-# compat code galore
-def userSetGroups(self, id, groupnames):
-    plugins = self.plugins
-    gtool = getToolByName(self, "portal_groups")
-
-    member = self.getUserById(id)
-    groupnameset = set(groupnames)
-
-    # remove absent groups
-    groups = set(gtool.getGroupsForPrincipal(member))
-    rmgroups = groups - groupnameset
-    for gid in rmgroups:
-        try:
-            gtool.removePrincipalFromGroup(id, gid)
-        except KeyError:
-            # We could hit a group which does not allow user removal, such as
-            # created by our AutoGroup plugin.
-            pass
-
-    # add groups
-    try:
-        groupmanagers = plugins.listPlugins(IGroupManagement)
-    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
-        groupmanagers = ()
-
-    for group in groupnames:
-        for gm_id, gm in groupmanagers:
-            try:
-                if gm.addPrincipalToGroup(id, group):
-                    break
-            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-                logger.info('PluggableAuthService: GroupManagement %s error',
-                            gm_id, exc_info=1)
-
-PluggableAuthService.userSetGroups = userSetGroups
-
-#################################
-# monkies for the diehard introspection.. all these should die, imho - kt
-
-
-def getUserIds(self):
-    plugins = self.plugins
-
-    try:
-        introspectors = plugins.listPlugins(IUserIntrospection)
-    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
-        introspectors = ()
-
-    results = []
-    for introspector_id, introspector in introspectors:
-        try:
-            results.extend(introspector.getUserIds())
-        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-            logger.info(
-                    'PluggableAuthService: UserIntrospection %s error',
-                    introspector_id, exc_info=1)
-
-    return results
-
-
-def getUserNames(self):
-    plugins = self.plugins
-
-    try:
-        introspectors = plugins.listPlugins(IUserIntrospection)
-    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
-        introspectors = ()
-
-    results = []
-    for introspector_id, introspector in introspectors:
-        try:
-            results.extend(introspector.getUserNames())
-        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-            logger.info(
-                'PluggableAuthService: UserIntroSpection plugin %s error',
-                introspector_id, exc_info=1)
-
-    return results
-
-PluggableAuthService.getUserIds = getUserIds
-PluggableAuthService.getUserNames = getUserNames
diff --git a/Products/PlonePAS/pas.py b/Products/PlonePAS/pas.py
index a8c3145..1cd10bf 100644
--- a/Products/PlonePAS/pas.py
+++ b/Products/PlonePAS/pas.py
@@ -11,9 +11,12 @@
 from Products.CMFCore.utils import getToolByName
 from Products.CMFCore.utils import registerToolInterface
 from Products.PlonePAS.interfaces.group import IGroupIntrospection
+from Products.PlonePAS.interfaces.group import IGroupManagement
 from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
 from Products.PlonePAS.interfaces.plugins import IUserIntrospection
 from Products.PlonePAS.interfaces.plugins import IUserManagement
+from Products.PlonePAS.patch import wrap_method
+from Products.PlonePAS.patch import ORIG_NAME
 from Products.PluggableAuthService.PluggableAuthService import \
     PluggableAuthService
 from Products.PluggableAuthService.PluggableAuthService import \
@@ -22,26 +25,80 @@
 from Products.PluggableAuthService.interfaces.authservice import \
     IPluggableAuthService
 from Products.PluggableAuthService.interfaces.plugins import \
+    IAuthenticationPlugin
+from Products.PluggableAuthService.interfaces.plugins import \
     IGroupEnumerationPlugin
 from Products.PluggableAuthService.interfaces.plugins import \
     IRoleAssignerPlugin
 from Products.PluggableAuthService.interfaces.plugins import \
     IUserEnumerationPlugin
 from zope.event import notify
+import logging
+
+logger = logging.getLogger('PlonePAS')
 
 registerToolInterface('acl_users', IPluggableAuthService)
 
+
 #################################
-# pas folder monkies - standard zope user folder api
+# helper functions
+
+def _userSetGroups(pas, user_id, groupnames):
+    """method was used at GRUF level, but is used inside this monkies at several
+    places too.
+
+    We no longer provide it on PAS to clean up patches
+
+    """
+    plugins = pas.plugins
+    gtool = getToolByName(pas, "portal_groups")
+
+    member = pas.getUserById(user_id)
+    groupnameset = set(groupnames)
+
+    # remove absent groups
+    groups = set(gtool.getGroupsForPrincipal(member))
+    rmgroups = groups - groupnameset
+    for gid in rmgroups:
+        try:
+            gtool.removePrincipalFromGroup(user_id, gid)
+        except KeyError:
+            # We could hit a group which does not allow user removal, such as
+            # created by our AutoGroup plugin.
+            pass
 
-_old_doAddUser = PluggableAuthService._doAddUser
+    # add groups
+    try:
+        groupmanagers = plugins.listPlugins(IGroupManagement)
+    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+        logger.info(
+            'PluggableAuthService: Plugin listing error',
+            exc_info=1
+        )
+        groupmanagers = ()
+
+    for group in groupnames:
+        for gm_id, gm in groupmanagers:
+            try:
+                if gm.addPrincipalToGroup(user_id, group):
+                    break
+            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+                logger.info(
+                    'PluggableAuthService: GroupManagement %s error',
+                    gm_id,
+                    exc_info=1
+                )
+
+#################################
+# pas folder monkies - standard zope user folder api or GRUF
 
 
 def _doAddUser(self, login, password, roles, domains, groups=None, **kw):
     """Masking of PAS._doAddUser to add groups param."""
-    retval = _old_doAddUser(self, login, password, roles, domains)
+    _old_doAddUser = getattr(self, getattr(_doAddUser, ORIG_NAME))
+    retval = _old_doAddUser(login, password, roles, domains)
     if groups is not None:
-        self.userSetGroups(login, groups)
+        _userSetGroups(self, login, groups)
     return retval
 
 
@@ -98,7 +155,7 @@ def _doChangeUser(self, principal_id, password, roles, domains=(), groups=None,
         rmanager.assignRolesToPrincipal(roles, principal_id)
 
     if groups is not None:
-        self.userSetGroups(principal_id, groups)
+        _userSetGroups(self, principal_id, groups)
 
     return True
 
@@ -107,7 +164,7 @@ def userFolderAddUser(self, login, password, roles, domains,
                       groups=None, REQUEST=None, **kw):
     self._doAddUser(login, password, roles, domains, **kw)
     if groups is not None:
-        self.userSetGroups(login, groups)
+        _userSetGroups(self, login, groups)
 
 
 def _doAddGroup(self, id, roles, groups=None, **kw):
@@ -358,107 +415,325 @@ def _getAllLocalRoles(self, context):
     return roles
 
 
-def patch_all():
-    PluggableAuthService._doAddUser = _doAddUser
-    PluggableAuthService._doDelUsers = _doDelUsers
-
-    PluggableAuthService._doDelUser = _doDelUser
-
-    PluggableAuthService.userFolderDelUsers = postonly(
-        PluggableAuthService._doDelUsers
-    )
-    PluggableAuthService.userFolderDelUsers__roles__ = PermissionRole(
-        ManageUsers,
-        ('Manager',)
-    )
-    PluggableAuthService._doChangeUser = _doChangeUser
-
-    PluggableAuthService.userFolderEditUser = postonly(
-        PluggableAuthService._doChangeUser
-    )
-    PluggableAuthService.userFolderEditUser__roles__ = PermissionRole(
-        ManageUsers,
-        ('Manager',)
-    )
-    PluggableAuthService.userFolderAddUser = postonly(userFolderAddUser)
-    PluggableAuthService.userFolderAddUser__roles__ = \
-        PermissionRole(ManageUsers, ('Manager',))
+def authenticate(self, name, password, request):
+    """See AccessControl.User.BasicUserFolder.authenticate
 
-    PluggableAuthService._doAddGroup = _doAddGroup
+    Products.PluggableAuthService.PluggableAuthService does not provide this
+    method, BasicUserFolder documents it as "Private UserFolder object
+    interface". GRUF does provide the method, so not marked as private.
 
-    PluggableAuthService._doDelGroups = _doDelGroups
-
-    PluggableAuthService.userFolderDelGroups = \
-        postonly(PluggableAuthService._doDelGroups)
-    PluggableAuthService.userFolderDelGroups__roles__ = \
-        PermissionRole(ManageUsers, ('Manager',))
+    should be deprecated in future!
+    """
 
-    PluggableAuthService._doChangeGroup = _doChangeGroup
+    plugins = self.plugins
 
-    PluggableAuthService._updateGroup = _updateGroup
+    try:
+        authenticators = plugins.listPlugins(IAuthenticationPlugin)
+    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
+        authenticators = ()
 
-    PluggableAuthService.userFolderEditGroup = \
-        postonly(PluggableAuthService._doChangeGroup)
-    PluggableAuthService.userFolderEditGroup__roles__ = \
-        PermissionRole(ManageUsers, ('Manager',))
+    credentials = {'login': name,
+                   'password': password}
 
-    PluggableAuthService.getGroups = getGroups
-    PluggableAuthService.getGroups__roles__ = \
-        PermissionRole(ManageUsers, ('Manager',))
+    user_id = None
 
-    PluggableAuthService.getGroupNames = getGroupNames
-    PluggableAuthService.getGroupNames__roles__ = \
-        PermissionRole(ManageUsers, ('Manager',))
+    for authenticator_id, auth in authenticators:
+        try:
+            uid_and_name = auth.authenticateCredentials(credentials)
+            if uid_and_name is not None:
+                user_id, name = uid_and_name
+                break
+        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+            logger.info(
+                    'PluggableAuthService: AuthenticationPlugin %s error',
+                    authenticator_id, exc_info=1)
+            continue
 
-    PluggableAuthService.getGroupIds = getGroupIds
-    PluggableAuthService.getGroupIds__roles__ = \
-        PermissionRole(ManageUsers, ('Manager',))
+    if not user_id:
+        return
 
-    PluggableAuthService.getGroup = getGroup
-    PluggableAuthService.getGroup__roles__ = \
-        PermissionRole(ManageUsers, ('Manager',))
+    return self._findUser(plugins, user_id, name, request)
 
-    PluggableAuthService.getGroupByName = getGroupByName
-    PluggableAuthService.getGroupByName__roles__ = \
-        PermissionRole(ManageUsers, ('Manager',))
 
-    PluggableAuthService.getGroupById = getGroupById
-    PluggableAuthService.getGroupById__roles__ = \
-        PermissionRole(ManageUsers, ('Manager',))
+def getUserIds(self):
+    """method was used at GRUF and is here for bbb. Not good for many users!
+    DEPRECATED
+    """
+    plugins = self.plugins
 
-    PluggableAuthService.getLocalRolesForDisplay = getLocalRolesForDisplay
-    PluggableAuthService._getLocalRolesForDisplay = _getLocalRolesForDisplay
+    try:
+        introspectors = plugins.listPlugins(IUserIntrospection)
+    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
+        introspectors = ()
 
-    PluggableAuthService.getUsers = getUsers
-    PluggableAuthService.getUsers__roles__ = \
-        PermissionRole(ManageUsers, ('Manager',))
+    results = []
+    for introspector_id, introspector in introspectors:
+        try:
+            results.extend(introspector.getUserIds())
+        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+            logger.info(
+                    'PluggableAuthService: UserIntrospection %s error',
+                    introspector_id, exc_info=1)
 
-    # this'll make listMembers work
-    PluggableAuthService.getPureUsers = getUsers
-    PluggableAuthService.getPureUsers__roles__ = \
-        PermissionRole(ManageUsers, ('Manager',))
+    return results
 
-    PluggableAuthService.canListAllUsers = canListAllUsers
-    PluggableAuthService.canListAllUsers__roles__ = \
-        PermissionRole(ManageUsers, ('Manager',))
 
-    PluggableAuthService.canListAllGroups = canListAllGroups
-    PluggableAuthService.canListAllGroups__roles__ = \
-        PermissionRole(ManageUsers, ('Manager',))
+def getUserNames(self):
+    """method was used at GRUF and is here for bbb. Not good for many users!
+    DEPRECATED
+    """
+    plugins = self.plugins
 
-    PluggableAuthService.userSetPassword = userSetPassword
-    PluggableAuthService.userSetPassword__roles__ = \
-        PermissionRole(ManageUsers, ('Manager',))
+    try:
+        introspectors = plugins.listPlugins(IUserIntrospection)
+    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
+        introspectors = ()
 
-    PluggableAuthService.credentialsChanged = credentialsChanged
-    PluggableAuthService.credentialsChanged__roles__ = \
-        PermissionRole(ManageUsers, ('Manager',))
+    results = []
+    for introspector_id, introspector in introspectors:
+        try:
+            results.extend(introspector.getUserNames())
+        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+            logger.info(
+                'PluggableAuthService: UserIntroSpection plugin %s error',
+                introspector_id, exc_info=1)
 
-    PluggableAuthService._delOb = _delOb
+    return results
 
-    PluggableAuthService.addRole = addRole
-    PluggableAuthService.addRole__roles__ = \
-        PermissionRole(ManageUsers, ('Manager',))
 
-    PluggableAuthService.getAllLocalRoles = getAllLocalRoles
-    PluggableAuthService._getAllLocalRoles = _getAllLocalRoles
+def patch_all():
+    # sort alphabetically by patched/added method name
+    wrap_method(
+        PluggableAuthService,
+        '_delOb',
+        _delOb
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_getAllLocalRoles',
+        _getAllLocalRoles,
+        add=True,
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doAddGroup',
+        _doAddGroup,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doAddUser',
+        _doAddUser
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doChangeGroup',
+        _doChangeGroup,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doChangeUser',
+        _doChangeUser,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doDelGroups',
+        _doDelGroups,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doDelUser',
+        _doDelUser,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doDelUsers',
+        _doDelUsers,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_getLocalRolesForDisplay',
+        _getLocalRolesForDisplay,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_updateGroup',
+        _updateGroup,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        'addRole',
+        addRole,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'authenticate',
+        authenticate,
+        add=True,
+        roles=(),
+    )
+    wrap_method(
+        PluggableAuthService,
+        'canListAllGroups',
+        canListAllGroups,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'canListAllUsers',
+        canListAllUsers,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'credentialsChanged',
+        credentialsChanged,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getAllLocalRoles',
+        getAllLocalRoles,
+        add=True,
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getGroup',
+        getGroup,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getGroupById',
+        getGroupById,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getGroupByName',
+        getGroupByName,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getGroupIds',
+        getGroupIds,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getGroupNames',
+        getGroupNames,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getGroups',
+        getGroups,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getLocalRolesForDisplay',
+        getLocalRolesForDisplay,
+        add=True,
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getUserIds',
+        getUserIds,
+        add=True,
+        deprecated="Inefficient GRUF wrapper, use IUserIntrospection instead."
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getUserNames',
+        getUserNames,
+        add=True,
+        deprecated="Inefficient GRUF wrapper, use IUserIntrospection instead."
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getUsers',
+        getUsers,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getPureUsers',
+        getUsers,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userFolderAddUser',
+        postonly(userFolderAddUser),
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userFolderDelUsers',
+        postonly(_doDelUsers),
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userFolderEditGroup',
+        postonly(_doChangeGroup),
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userFolderEditUser',
+        postonly(_doChangeUser),
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userFolderDelGroups',
+        postonly(_doDelGroups),
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userSetGroups',
+        _userSetGroups,
+        add=True,
+        deprecated="Method from GRUF was removed."
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userSetPassword',
+        userSetPassword,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
diff --git a/Products/PlonePAS/patch.py b/Products/PlonePAS/patch.py
index 9fafd1c..5458676 100644
--- a/Products/PlonePAS/patch.py
+++ b/Products/PlonePAS/patch.py
@@ -1,5 +1,6 @@
 # -*- coding: utf-8 -*-
 import logging
+from zope.deprecation import deprecation
 
 logger = logging.getLogger('PlonePAS')
 
@@ -11,29 +12,54 @@ def call(self, __name__, *args, **kw):
 
 
 WRAPPER = '__PlonePAS_is_wrapper_method__'
+ADDED = '__PlonePAS_is_added_method__'
 ORIG_NAME = '__PlonePAS_original_method_name__'
 
+_marker = dict()
+
 
 def isWrapperMethod(meth):
     return getattr(meth, WRAPPER, False)
 
 
-def wrap_method(klass, name, method, pattern=PATTERN):
-    old_method = getattr(klass, name)
-    if isWrapperMethod(old_method):
+def wrap_method(klass, name, method,
+                pattern=PATTERN, add=False, roles=None, deprecated=False):
+    """takes a method and set it to a class. Annotates with hints what happened.
+    """
+    new_name = pattern % name
+    if not add:
+        old_method = getattr(klass, name)
+        if isWrapperMethod(old_method):
+            logger.info(
+                'PlonePAS: *NOT* wrapping already wrapped method at '
+                '{0}.{1}'.format(
+                    klass.__name__, name)
+                )
+
+            return
+        logger.info('PlonePAS: Wrapping method at %s.%s', klass.__name__, name)
+        setattr(klass, new_name, old_method)
+        setattr(method, ORIG_NAME, new_name)
+        setattr(method, WRAPPER, True)
+        setattr(method, ADDED, False)
+    else:
+        logger.info('PlonePAS: Adding method at %s.%s', klass.__name__, name)
+        setattr(method, WRAPPER, False)
+        setattr(method, ADDED, True)
+
+    if deprecated:
+        setattr(klass, name, deprecation.deprecated(method, deprecated))
+    else:
+        setattr(klass, name, method)
+
+    if roles is not None:
+        roles_attr = '{0}__roles__'.format(name)
         logger.info(
-            'PlonePAS: *NOT* wrapping already wrapped method at '
-            '{0}.{1}'.format(
-                klass.__name__, name)
+            'PlonePAS: Setting new permission roles at {0}.{1}'.format(
+                klass.__name__, name
             )
-
-        return
-    logger.info('PlonePAS: Wrapping method at %s.%s', klass.__name__, name)
-    new_name = pattern % name
-    setattr(klass, new_name, old_method)
-    setattr(method, ORIG_NAME, new_name)
-    setattr(method, WRAPPER, True)
-    setattr(klass, name, method)
+        )
+        setattr(klass, roles_attr, roles)
 
 
 def unwrap_method(klass, name):
diff --git a/setup.py b/setup.py
index 27865ad..91a12d9 100644
--- a/setup.py
+++ b/setup.py
@@ -5,15 +5,16 @@
 version = '5.0.1.dev0'
 
 install_requires = [
-        'setuptools',
-        'plone.memoize',
-        'plone.session',
-        'plone.i18n',
         'Products.CMFCore',
         'Products.CMFDefault',
         'Products.GenericSetup',
         'Products.PluggableAuthService',
         'Zope2 > 2.12.4',
+        'plone.i18n',
+        'plone.memoize',
+        'plone.session',
+        'setuptools',
+        'zope.deprecation',
       ]
 
 try:


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:36:18+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/04d7dfbf22e04254178151db6653df61d5d8d938

more pep8 (forgotten ones)

Files changed:
M CHANGES.rst
M Products/PlonePAS/interfaces/__init__.py
M Products/PlonePAS/interfaces/browser.py
M Products/PlonePAS/interfaces/capabilities.py
M Products/PlonePAS/interfaces/events.py
M Products/PlonePAS/interfaces/group.py
M Products/PlonePAS/interfaces/membership.py
M Products/PlonePAS/interfaces/plugins.py
M Products/PlonePAS/interfaces/propertysheets.py
M Products/PlonePAS/plugins/__init__.py
M Products/PlonePAS/plugins/autogroup.py
M Products/PlonePAS/plugins/cookie_handler.py
M Products/PlonePAS/plugins/crumbler.py
M Products/PlonePAS/plugins/group.py
M Products/PlonePAS/plugins/local_role.py
M Products/PlonePAS/plugins/passwordpolicy.py
M Products/PlonePAS/plugins/property.py
M Products/PlonePAS/plugins/role.py
M Products/PlonePAS/plugins/ufactory.py
M Products/PlonePAS/plugins/user.py

diff --git a/CHANGES.rst b/CHANGES.rst
index e7e5990..a89ca7e 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,6 +4,11 @@ Changelog
 5.0.1 (unreleased)
 ------------------
 
+- Cleanup patches, allow introspection by using wrap_method, add roles using wrap_method, 
+  add deprecation and merge ``gruf_support.py`` in ``pas,py`` to have a better overview
+  what is patched.
+  [jensens]
+
 - Cleanup: PEP8 et all, zca decorators, rough code review
   [jensens]
 
diff --git a/Products/PlonePAS/interfaces/__init__.py b/Products/PlonePAS/interfaces/__init__.py
index 4287ca8..40a96af 100644
--- a/Products/PlonePAS/interfaces/__init__.py
+++ b/Products/PlonePAS/interfaces/__init__.py
@@ -1 +1 @@
-#
\ No newline at end of file
+# -*- coding: utf-8 -*-
diff --git a/Products/PlonePAS/interfaces/browser.py b/Products/PlonePAS/interfaces/browser.py
index c27eee5..6f2b5cb 100644
--- a/Products/PlonePAS/interfaces/browser.py
+++ b/Products/PlonePAS/interfaces/browser.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from zope.interface import Interface
 
 
diff --git a/Products/PlonePAS/interfaces/capabilities.py b/Products/PlonePAS/interfaces/capabilities.py
index 5d31c25..92b1286 100644
--- a/Products/PlonePAS/interfaces/capabilities.py
+++ b/Products/PlonePAS/interfaces/capabilities.py
@@ -1,6 +1,6 @@
+# -*- coding: utf-8 -*-
 # Define certain interfaces that a plugin must meet if it is to allow
 # certain operations to be done by the Plone UI.
-
 from Products.PluggableAuthService.interfaces.plugins import Interface
 
 
diff --git a/Products/PlonePAS/interfaces/events.py b/Products/PlonePAS/interfaces/events.py
index 88c68be..500ca8d 100644
--- a/Products/PlonePAS/interfaces/events.py
+++ b/Products/PlonePAS/interfaces/events.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from Products.PluggableAuthService.interfaces.events import IUserLoggedInEvent
 
 
diff --git a/Products/PlonePAS/interfaces/group.py b/Products/PlonePAS/interfaces/group.py
index 49acfac..537eca1 100644
--- a/Products/PlonePAS/interfaces/group.py
+++ b/Products/PlonePAS/interfaces/group.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from zope.interface import Interface
 from Products.PluggableAuthService.interfaces import plugins
 
diff --git a/Products/PlonePAS/interfaces/membership.py b/Products/PlonePAS/interfaces/membership.py
index 4f3b3af..1f8a757 100644
--- a/Products/PlonePAS/interfaces/membership.py
+++ b/Products/PlonePAS/interfaces/membership.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from Products.CMFCore import interfaces
 
 
diff --git a/Products/PlonePAS/interfaces/plugins.py b/Products/PlonePAS/interfaces/plugins.py
index 76bbe74..a1f78a3 100644
--- a/Products/PlonePAS/interfaces/plugins.py
+++ b/Products/PlonePAS/interfaces/plugins.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from Products.PluggableAuthService.interfaces import plugins
 from Products.PluggableAuthService.interfaces.plugins import Interface
 
diff --git a/Products/PlonePAS/interfaces/propertysheets.py b/Products/PlonePAS/interfaces/propertysheets.py
index 195d0a6..8ff7ab3 100644
--- a/Products/PlonePAS/interfaces/propertysheets.py
+++ b/Products/PlonePAS/interfaces/propertysheets.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from Products.PluggableAuthService.interfaces.propertysheets \
     import IPropertySheet
 
diff --git a/Products/PlonePAS/plugins/__init__.py b/Products/PlonePAS/plugins/__init__.py
index 4287ca8..40a96af 100644
--- a/Products/PlonePAS/plugins/__init__.py
+++ b/Products/PlonePAS/plugins/__init__.py
@@ -1 +1 @@
-#
\ No newline at end of file
+# -*- coding: utf-8 -*-
diff --git a/Products/PlonePAS/plugins/autogroup.py b/Products/PlonePAS/plugins/autogroup.py
index 2f3654e..4b21b79 100644
--- a/Products/PlonePAS/plugins/autogroup.py
+++ b/Products/PlonePAS/plugins/autogroup.py
@@ -1,15 +1,14 @@
-from zope.interface import implements
-
+# -*- coding: utf-8 -*-
 from App.class_init import InitializeClass
+from Products.PageTemplates.PageTemplateFile import PageTemplateFile
+from Products.PlonePAS.interfaces.group import IGroupIntrospection
 from Products.PluggableAuthService.PropertiedUser import PropertiedUser
+from Products.PluggableAuthService.interfaces.plugins import \
+    IGroupEnumerationPlugin
+from Products.PluggableAuthService.interfaces.plugins import IGroupsPlugin
+from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
 from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
-from Products.PluggableAuthService.interfaces.plugins \
-    import IGroupEnumerationPlugin
-from Products.PluggableAuthService.interfaces.plugins \
-    import IGroupsPlugin, IPropertiesPlugin
-from Products.PlonePAS.interfaces.group import IGroupIntrospection
-
-from Products.PageTemplates.PageTemplateFile import PageTemplateFile
+from zope.interface import implementer
 
 manage_addAutoGroupForm = PageTemplateFile("../zmi/AutoGroupForm", globals())
 
@@ -24,7 +23,7 @@ def manage_addAutoGroup(self, id, title='', group='', description='',
     if RESPONSE is not None:
         return RESPONSE.redirect(
             "%s/manage_workspace?manage_tabs_message=AutoGroup+plugin+added"
-                % self.absolute_url())
+            % self.absolute_url())
 
 
 class VirtualGroup(PropertiedUser):
@@ -62,28 +61,29 @@ def isGroup(self):
         return True
 
 
+@implementer(
+        IGroupEnumerationPlugin,
+        IGroupsPlugin,
+        IGroupIntrospection,
+        IPropertiesPlugin
+)
 class AutoGroup(BasePlugin):
     meta_type = "Automatic Group Plugin"
 
-    implements(IGroupEnumerationPlugin, IGroupsPlugin, IGroupIntrospection,
-               IPropertiesPlugin)
-
     _properties = (
-            {'id': 'title',
-             'label': 'Title',
-             'type': 'string',
-             'mode': 'w',
-            },
-            {'id': 'group',
-             'label': 'Group',
-             'type': 'string',
-             'mode': 'w',
-            },
-            {'id': 'description',
-             'label': 'Description',
-             'type': 'string',
-             'mode': 'w',
-            },)
+        {'id': 'title',
+         'label': 'Title',
+         'type': 'string',
+         'mode': 'w'},
+        {'id': 'group',
+         'label': 'Group',
+         'type': 'string',
+         'mode': 'w'},
+        {'id': 'description',
+         'label': 'Description',
+         'type': 'string',
+         'mode': 'w'},
+    )
 
     def __init__(self, id, title='', group=None, description=''):
         self._setId(id)
diff --git a/Products/PlonePAS/plugins/cookie_handler.py b/Products/PlonePAS/plugins/cookie_handler.py
index ee8639a..9c65297 100644
--- a/Products/PlonePAS/plugins/cookie_handler.py
+++ b/Products/PlonePAS/plugins/cookie_handler.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 """ Class: ExtendedCookieAuthHelper
 
 Simply extends the standard CookieAuthHelper provided via regular
@@ -5,25 +6,27 @@
 provide similar functionality as CookieCrumbler does... by giving
 the portal the ability to provide a setAuthCookie method.
 """
-
-from base64 import encodestring
-from urllib import quote
-
-from zope.interface import implements
-
+from AccessControl.SecurityInfo import ClassSecurityInfo
 from AccessControl.SecurityManagement import getSecurityManager
 from Acquisition import aq_base
 from Acquisition import aq_parent
-from AccessControl.SecurityInfo import ClassSecurityInfo
 from App.class_init import InitializeClass
 from App.special_dtml import DTMLFile
+from Products.PluggableAuthService.interfaces.authservice import \
+    IPluggableAuthService
+from Products.PluggableAuthService.interfaces.plugins \
+    import IChallengePlugin
+from Products.PluggableAuthService.interfaces.plugins \
+    import ICredentialsResetPlugin
+from Products.PluggableAuthService.interfaces.plugins \
+    import ICredentialsUpdatePlugin
+from Products.PluggableAuthService.interfaces.plugins \
+    import ILoginPasswordHostExtractionPlugin
 from Products.PluggableAuthService.plugins.CookieAuthHelper \
     import CookieAuthHelper as BasePlugin
-from Products.PluggableAuthService.interfaces.authservice \
-        import IPluggableAuthService
-from Products.PluggableAuthService.interfaces.plugins import \
-        ILoginPasswordHostExtractionPlugin, IChallengePlugin,  \
-        ICredentialsUpdatePlugin, ICredentialsResetPlugin
+from base64 import encodestring
+from urllib import quote
+from zope.interface import implementer
 
 
 def manage_addExtendedCookieAuthHelper(self, id, title='',
@@ -40,10 +43,18 @@ def manage_addExtendedCookieAuthHelper(self, id, title='',
     if RESPONSE is not None:
         RESPONSE.redirect('manage_workspace')
 
-manage_addExtendedCookieAuthHelperForm = \
-    DTMLFile("../zmi/ExtendedCookieAuthHelperForm", globals())
+manage_addExtendedCookieAuthHelperForm = DTMLFile(
+    "../zmi/ExtendedCookieAuthHelperForm",
+    globals()
+)
 
 
+@implementer(
+    ILoginPasswordHostExtractionPlugin,
+    IChallengePlugin,
+    ICredentialsUpdatePlugin,
+    ICredentialsResetPlugin
+)
 class ExtendedCookieAuthHelper(BasePlugin):
     """Multi-plugin which adds ability to override the updating of cookie via
     a setAuthCookie method/script.
@@ -52,10 +63,7 @@ class ExtendedCookieAuthHelper(BasePlugin):
     meta_type = 'Extended Cookie Auth Helper'
     security = ClassSecurityInfo()
 
-    implements(ILoginPasswordHostExtractionPlugin, IChallengePlugin,
-               ICredentialsUpdatePlugin, ICredentialsResetPlugin)
-
-    security.declarePrivate('updateCredentials')
+    @security.private
     def updateCredentials(self, request, response, login, new_password):
         """Override standard updateCredentials method
         """
@@ -69,7 +77,7 @@ def updateCredentials(self, request, response, login, new_password):
             BasePlugin.updateCredentials(self, request, response, login,
                                          new_password)
 
-    security.declarePublic('login')
+    @security.public
     def login(self):
         """Set a cookie and redirect to the url that we tried to
         authenticate against originally.
diff --git a/Products/PlonePAS/plugins/crumbler.py b/Products/PlonePAS/plugins/crumbler.py
index 8173136..9838693 100644
--- a/Products/PlonePAS/plugins/crumbler.py
+++ b/Products/PlonePAS/plugins/crumbler.py
@@ -1,23 +1,21 @@
+# -*- coding: utf-8 -*-
 """ Class: CookieCrumblingPlugin
 
 Acts as auth plugin, but injects cookie form credentials as HTTPBasicAuth.
 This allows form logins to fall through to parent user folders.
 
 """
-from zope.interface import implements
-
-from Acquisition import aq_base
 from AccessControl.SecurityInfo import ClassSecurityInfo
+from Acquisition import aq_base
 from App.class_init import InitializeClass
 from App.special_dtml import DTMLFile
 from OFS.Folder import Folder
-
-from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
-from Products.PluggableAuthService.interfaces.plugins import IExtractionPlugin
-
 from Products.CMFCore.CookieCrumbler import manage_addCC
-
+from Products.PluggableAuthService.interfaces.plugins import IExtractionPlugin
+from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from zope.interface import implementer
 import logging
+
 logger = logging.getLogger('PlonePAS')
 
 CC_ID = 'cookie_auth'
@@ -43,6 +41,7 @@ def manage_addCookieCrumblingPlugin(self, id, title='',
     DTMLFile("../zmi/CookieCrumblingPluginForm", globals())
 
 
+@implementer(IExtractionPlugin)
 class CookieCrumblingPlugin(Folder, BasePlugin):
     """Multi-plugin for injecting HTTP Basic Authentication
     credentials from form credentials.
@@ -51,8 +50,6 @@ class CookieCrumblingPlugin(Folder, BasePlugin):
 
     security = ClassSecurityInfo()
 
-    implements(IExtractionPlugin)
-
     def __init__(self, id, title=None):
         self._setId(id)
         self.title = title
@@ -60,7 +57,7 @@ def __init__(self, id, title=None):
     def _getCC(self):
         return getattr(aq_base(self), CC_ID, None)
 
-    security.declarePrivate('extractCredentials')
+    @security.private
     def extractCredentials(self, request):
         """ Extract basic auth credentials from 'request'.
         """
diff --git a/Products/PlonePAS/plugins/group.py b/Products/PlonePAS/plugins/group.py
index 79d08de..cb46c5d 100644
--- a/Products/PlonePAS/plugins/group.py
+++ b/Products/PlonePAS/plugins/group.py
@@ -3,30 +3,26 @@
 management (ie. rw) capabilities.
 
 """
-
-import logging
-from BTrees.OOBTree import OOBTree, OOSet
-from App.special_dtml import DTMLFile
-from App.class_init import InitializeClass
 from AccessControl import ClassSecurityInfo
-
-from zope.interface import implements
-
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from BTrees.OOBTree import OOBTree, OOSet
+from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
+from Products.PlonePAS.interfaces.capabilities import IGroupCapability
+from Products.PlonePAS.interfaces.group import IGroupIntrospection
+from Products.PlonePAS.interfaces.group import IGroupManagement
 from Products.PluggableAuthService.PluggableAuthService \
     import _SWALLOWABLE_PLUGIN_EXCEPTIONS
-from Products.PluggableAuthService.plugins.ZODBGroupManager \
-    import ZODBGroupManager
 from Products.PluggableAuthService.interfaces.plugins \
     import IGroupEnumerationPlugin
-from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
+from Products.PluggableAuthService.interfaces.plugins \
+    import IPropertiesPlugin
 from Products.PluggableAuthService.interfaces.plugins import IRolesPlugin
-from Products.PluggableAuthService.utils import createViewName
-
-from Products.PlonePAS.interfaces.group \
-    import IGroupManagement, IGroupIntrospection
-from Products.PlonePAS.interfaces.capabilities import IGroupCapability
-from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
+from Products.PluggableAuthService.plugins.ZODBGroupManager \
+    import ZODBGroupManager
 from ufactory import PloneUser
+from zope.interface import implementer
+import logging
 
 manage_addGroupManagerForm = DTMLFile("../zmi/GroupManagerForm", globals())
 logger = logging.getLogger('PlonePAS')
@@ -45,14 +41,17 @@ def manage_addGroupManager(self, id, title='', RESPONSE=None):
         return RESPONSE.redirect('manage_workspace')
 
 
+@implementer(
+    IGroupManagement,
+    IGroupIntrospection,
+    IGroupCapability,
+    IDeleteCapability
+)
 class GroupManager(ZODBGroupManager):
 
     meta_type = "Group Manager"
     security = ClassSecurityInfo()
 
-    implements(IGroupManagement, IGroupIntrospection, IGroupCapability,
-               IDeleteCapability)
-
     def __init__(self, *args, **kw):
         ZODBGroupManager.__init__(self, *args, **kw)
         # reverse index of groups->principal
@@ -114,7 +113,7 @@ def getGroupMembers(self, group_id):
     #################################
     # capabilties interface impls.
 
-    security.declarePublic('allowDeletePrincipal')
+    @security.public
     def allowDeletePrincipal(self, principal_id):
         """True iff this plugin can delete a certain group.
         This is true if this plugin manages the group.
@@ -155,7 +154,7 @@ def allowGroupRemove(self, user_id, group_id):
     #################################
     # group wrapping mechanics
 
-    security.declarePrivate('_createGroup')
+    @security.private
     def _createGroup(self, plugins, group_id, name):
         """ Create group object. For users, this can be done with a
         plugin, but I don't care to define one for that now. Just uses
@@ -164,15 +163,11 @@ def _createGroup(self, plugins, group_id, name):
         """
         return PloneGroup(group_id, name).__of__(self)
 
-    security.declarePrivate('_findGroup')
+    @security.private
     def _findGroup(self, plugins, group_id, title=None, request=None):
         """ group_id -> decorated_group
         This method based on PluggableAuthService._findGroup
         """
-
-        view_name = '_findGroup-%s' % group_id
-        keywords = {'group_id': group_id, 'title': title}
-
         group = self._createGroup(plugins, group_id, title)
 
         propfinders = plugins.listPlugins(IPropertiesPlugin)
@@ -197,7 +192,7 @@ def _findGroup(self, plugins, group_id, title=None, request=None):
 
         return group.__of__(self)
 
-    security.declarePrivate('_verifyGroup')
+    @security.private
     def _verifyGroup(self, plugins, group_id=None, title=None):
 
         """ group_id -> boolean
@@ -213,7 +208,6 @@ def _verifyGroup(self, plugins, group_id=None, title=None):
             criteria['title'] = title
 
         if criteria:
-            view_name = createViewName('_verifyGroup', group_id)
             enumerators = plugins.listPlugins(IGroupEnumerationPlugin)
 
             for enumerator_id, enumerator in enumerators:
@@ -248,7 +242,7 @@ def getId(self, unprefixed=None):
         """
         return self._id
 
-    security.declarePrivate("getMemberIds")
+    @security.private
     def getMemberIds(self, transitive=1):
         """Return member ids of this group, including or not
         transitive groups.
@@ -268,26 +262,25 @@ def getMemberIds(self, transitive=1):
 
         return members
 
-
-    security.declarePublic('addMember')
+    @security.public
     def addMember(self, id):
         """Add the existing member with the given id to the group
         """
         self.addPrincipalToGroup(id, self.getId())
 
-    security.declarePublic('removeMember')
+    @security.public
     def removeMember(self, id):
         """Remove the member with the provided id from the group.
         """
         self.removePrincipalFromGroup(id, self.getId())
 
-    security.declarePublic('getRolesInContext')
+    @security.public
     def getRolesInContext(self, object):
         """Since groups can't actually log in, do nothing.
         """
         return []
 
-    security.declarePublic('allowed')
+    @security.public
     def allowed(self, object, object_roles=None):
         """Since groups can't actually log in, do nothing.
         """
diff --git a/Products/PlonePAS/plugins/local_role.py b/Products/PlonePAS/plugins/local_role.py
index 10cac29..7748ece 100644
--- a/Products/PlonePAS/plugins/local_role.py
+++ b/Products/PlonePAS/plugins/local_role.py
@@ -5,17 +5,14 @@
 roles from their containment structure.
 
 """
-
 from AccessControl import ClassSecurityInfo
 from Acquisition import aq_inner, aq_parent
 from App.class_init import InitializeClass
 from App.special_dtml import DTMLFile
-
-from zope.interface import implements
-
+from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
 from Products.PluggableAuthService.plugins.LocalRolePlugin \
     import LocalRolePlugin
-from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
+from zope.interface import implementer
 
 
 def manage_addLocalRolesManager(dispatcher, id, title=None, RESPONSE=None):
@@ -32,6 +29,7 @@ def manage_addLocalRolesManager(dispatcher, id, title=None, RESPONSE=None):
     DTMLFile('../zmi/LocalRolesManagerForm', globals())
 
 
+@implementer(ILocalRolesPlugin)
 class LocalRolesManager(LocalRolePlugin):
     """Class incorporating local role storage with
     PlonePAS-specific local role permission checking.
@@ -40,8 +38,6 @@ class LocalRolesManager(LocalRolePlugin):
     meta_type = "Local Roles Manager"
     security = ClassSecurityInfo()
 
-    implements(ILocalRolesPlugin)
-
     def __init__(self, id, title=None):
         self._id = self.id = id
         self.title = title
@@ -162,7 +158,7 @@ def getAllLocalRolesInContext(self, context):
                 dict = local_roles
 
                 for principal, localroles in dict.items():
-                    if not principal in roles:
+                    if principal not in roles:
                         roles[principal] = set()
 
                     roles[principal].update(localroles)
diff --git a/Products/PlonePAS/plugins/passwordpolicy.py b/Products/PlonePAS/plugins/passwordpolicy.py
index 4d940c4..b0eee47 100644
--- a/Products/PlonePAS/plugins/passwordpolicy.py
+++ b/Products/PlonePAS/plugins/passwordpolicy.py
@@ -2,27 +2,24 @@
 Password Validation plugin (IValidationPlugin)
 Mutable Property Provider
 """
-import copy
-
-from zope.interface import implements
 from AccessControl import ClassSecurityInfo
 from App.class_init import InitializeClass
-from BTrees.OOBTree import OOBTree
-from ZODB.PersistentMapping import PersistentMapping
-
-from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from Products.PageTemplates.PageTemplateFile import PageTemplateFile
 from Products.PluggableAuthService.interfaces.plugins import IValidationPlugin
+from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
 from zope.i18nmessageid import MessageFactory
+from zope.interface import implementer
 
 _ = MessageFactory('plone')
 
-from Products.PageTemplates.PageTemplateFile import PageTemplateFile
-
-manage_addPasswordPolicyForm = PageTemplateFile("../zmi/PasswordPolicyForm", globals())
+manage_addPasswordPolicyForm = PageTemplateFile(
+    "../zmi/PasswordPolicyForm",
+    globals()
+)
 
 
 def manage_addPasswordPolicyPlugin(self, id, title='',
-                                          RESPONSE=None, schema=None, **kw):
+                                   RESPONSE=None, schema=None, **kw):
     """
     Create an instance of a password validation plugin.
     """
@@ -30,17 +27,20 @@ def manage_addPasswordPolicyPlugin(self, id, title='',
     self._setObject(o.getId(), o)
 
     if RESPONSE is not None:
-        return RESPONSE.redirect("%s/manage_workspace?manage_tabs_message=DefaultPasswordPlugin+plugin+added" %
-                self.absolute_url())
+        return RESPONSE.redirect(
+            "%s/manage_workspace?"
+            "manage_tabs_message=DefaultPasswordPlugin+plugin+added" %
+            self.absolute_url()
+        )
+
 
+@implementer(IValidationPlugin)
 class PasswordPolicyPlugin(BasePlugin):
     """Simple Password Policy to ensure password is 5 chars long.
     """
 
     meta_type = 'Default Plone Password Policy'
 
-    implements(IValidationPlugin)
-
     security = ClassSecurityInfo()
 
     def __init__(self, id, title=''):
@@ -49,8 +49,8 @@ def __init__(self, id, title=''):
         self.id = id
         self.title = title
 
-    security.declarePrivate('validateUserInfo')
-    def validateUserInfo(self, user, set_id, set_info ):
+    @security.private
+    def validateUserInfo(self, user, set_id, set_info):
         """ See IValidationPlugin. Used to validate password property
         """
 
@@ -60,12 +60,17 @@ def validateUserInfo(self, user, set_id, set_info ):
         if password is None:
             return []
         elif password == '':
-            return [{'id':'password','error':_(u'Minimum 5 characters.')}]
+            return [{'id': 'password', 'error': _(u'Minimum 5 characters.')}]
         elif len(password) < 5:
-            return [{'id':'password','error':
-                _(u'Your password must contain at least 5 characters.')}]
+            return [
+                {
+                    'id': 'password',
+                    'error': _(
+                        u'Your password must contain at least 5 characters.'
+                    )
+                }
+            ]
         else:
             return []
 
 InitializeClass(PasswordPolicyPlugin)
-
diff --git a/Products/PlonePAS/plugins/property.py b/Products/PlonePAS/plugins/property.py
index 0bd9963..3d6cb6b 100644
--- a/Products/PlonePAS/plugins/property.py
+++ b/Products/PlonePAS/plugins/property.py
@@ -1,25 +1,24 @@
+# -*- coding: utf-8 -*-
 """
 Mutable Property Provider
 """
-import copy
-
-from zope.interface import implements
 from AccessControl import ClassSecurityInfo
 from App.class_init import InitializeClass
 from App.special_dtml import DTMLFile
 from BTrees.OOBTree import OOBTree
-from ZODB.PersistentMapping import PersistentMapping
 from Products.CMFCore.utils import getToolByName
-
-from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from Products.PlonePAS.interfaces.plugins import IMutablePropertiesPlugin
+from Products.PlonePAS.sheet import MutablePropertySheet, validateValue
+from Products.PlonePAS.utils import safe_unicode
+from Products.PluggableAuthService.UserPropertySheet import _guessSchema
 from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
 from Products.PluggableAuthService.interfaces.plugins \
     import IUserEnumerationPlugin
-from Products.PluggableAuthService.UserPropertySheet import _guessSchema
-from Products.PlonePAS.sheet import MutablePropertySheet, validateValue
-from Products.PlonePAS.interfaces.plugins import IMutablePropertiesPlugin
-from Products.PlonePAS.utils import safe_unicode
+from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from ZODB.PersistentMapping import PersistentMapping
 from zope.i18nmessageid import MessageFactory
+from zope.interface import implementer
+import copy
 
 _ = MessageFactory('plone')
 
@@ -43,6 +42,11 @@ def isStringType(data):
     return isinstance(data, str) or isinstance(data, unicode)
 
 
+@implementer(
+    IPropertiesPlugin,
+    IUserEnumerationPlugin,
+    IMutablePropertiesPlugin
+)
 class ZODBMutablePropertyProvider(BasePlugin):
     """Storage for mutable properties in the ZODB for users/groups.
 
@@ -51,9 +55,6 @@ class ZODBMutablePropertyProvider(BasePlugin):
 
     meta_type = 'ZODB Mutable Property Provider'
 
-    implements(IPropertiesPlugin, IUserEnumerationPlugin,
-               IMutablePropertiesPlugin)
-
     security = ClassSecurityInfo()
 
     def __init__(self, id, title='', schema=None, **kw):
@@ -140,7 +141,7 @@ def _getDefaultValues(self, isgroup=None):
                 defaultvalues["title"] = ""
         return defaultvalues
 
-    security.declarePrivate('getPropertiesForUser')
+    @security.private
     def getPropertiesForUser(self, user, request=None):
         """Get property values for a user or group.
         Returns a dictionary of values or a PropertySheet.
@@ -159,13 +160,13 @@ def getPropertiesForUser(self, user, request=None):
         if not data:
             data = {}
         for key, val in defaults.items():
-            if not key in data:
+            if key not in data:
                 data[key] = val
 
         return MutablePropertySheet(self.id,
                                     schema=self._getSchema(isGroup), **data)
 
-    security.declarePrivate('setPropertiesForUser')
+    @security.private
     def setPropertiesForUser(self, user, propertysheet):
         """Set the properties of a user or group based on the contents of a
         property sheet.
@@ -175,10 +176,14 @@ def setPropertiesForUser(self, user, propertysheet):
         properties = dict(propertysheet.propertyItems())
 
         for name, property_type in self._getSchema(isGroup) or ():
-            if (name in properties and not
-                validateValue(property_type, properties[name])):
-                raise ValueError('Invalid value: %s does not conform '
-                                   'to %s' % (name, property_type))
+            if (
+                name in properties and not
+                validateValue(property_type, properties[name])
+            ):
+                raise ValueError(
+                    'Invalid value: %s does not conform to %s' %
+                    (name, property_type)
+                )
 
         allowed_prop_keys = [pn for pn, pt in self._getSchema(isGroup) or ()]
         if allowed_prop_keys:
@@ -196,7 +201,7 @@ def setPropertiesForUser(self, user, propertysheet):
         else:
             self._storage.insert(user.getId(), properties)
 
-    security.declarePrivate('deleteUser')
+    @security.private
     def deleteUser(self, user_id):
         """Delete all user properties
         """
@@ -206,7 +211,7 @@ def deleteUser(self, user_id):
         except KeyError:
             pass
 
-    security.declarePrivate('testMemberData')
+    @security.private
     def testMemberData(self, memberdata, criteria, exact_match=False):
         """Test if a memberdata matches the search criteria.
         """
@@ -235,7 +240,7 @@ def testMemberData(self, memberdata, criteria, exact_match=False):
 
         return True
 
-    security.declarePrivate('enumerateUsers')
+    @security.private
     def enumerateUsers(self, id=None, login=None,
                        exact_match=False, **kw):
         """ See IUserEnumerationPlugin.
@@ -251,8 +256,8 @@ def enumerateUsers(self, id=None, login=None,
         criteria = copy.copy(kw)
 
         users = [(user, data) for (user, data) in self._storage.items()
-                    if self.testMemberData(data, criteria, exact_match)
-                        and not data.get('isGroup', False)]
+                 if self.testMemberData(data, criteria, exact_match)
+                 and not data.get('isGroup', False)]
 
         user_info = [{'id': self.prefix + user_id,
                       'login': user_id,
@@ -271,7 +276,6 @@ def updateUser(self, user_id, login_name):
         """
         pass
 
-
     def updateEveryLoginName(self, quit_on_first_error=True):
         """Update login names of all users to their canonical value.
 
diff --git a/Products/PlonePAS/plugins/role.py b/Products/PlonePAS/plugins/role.py
index 65142ca..5684ed3 100644
--- a/Products/PlonePAS/plugins/role.py
+++ b/Products/PlonePAS/plugins/role.py
@@ -1,24 +1,23 @@
+# -*- coding: utf-8 -*-
 """
 group aware role manager, returns roles assigned to group a principal
 is a member of, in addition to the explicit roles assigned directly
 to the principal.
 
 """
-
 from AccessControl import ClassSecurityInfo
 from AccessControl.requestmethod import postonly
-from Acquisition import aq_parent, aq_inner, aq_get
+from Acquisition import aq_parent
+from Acquisition import aq_inner
+from Acquisition import aq_get
 from App.class_init import InitializeClass
 from App.special_dtml import DTMLFile
-
-from zope.interface import implements
-
-from Products.PluggableAuthService.plugins.ZODBRoleManager \
-     import ZODBRoleManager
-
-from Products.PlonePAS.utils import getGroupsForPrincipal
 from Products.PlonePAS.interfaces.capabilities import IAssignRoleCapability
+from Products.PlonePAS.utils import getGroupsForPrincipal
 from Products.PluggableAuthService.permissions import ManageUsers
+from Products.PluggableAuthService.plugins.ZODBRoleManager \
+    import ZODBRoleManager
+from zope.interface import implementer
 
 
 def manage_addGroupAwareRoleManager(self, id, title='', RESPONSE=None):
@@ -35,11 +34,11 @@ def manage_addGroupAwareRoleManager(self, id, title='', RESPONSE=None):
     '../zmi/GroupAwareRoleManagerForm', globals())
 
 
+@implementer(IAssignRoleCapability)
 class GroupAwareRoleManager(ZODBRoleManager):
 
     meta_type = "Group Aware Role Manager"
     security = ClassSecurityInfo()
-    implements(IAssignRoleCapability)
 
     def updateRolesList(self):
         role_holder = aq_parent(aq_inner(self._getPAS()))
@@ -61,7 +60,7 @@ def manage_afterAdd(self, item, container):
         if item is self:
             self.updateRolesList()
 
-    security.declareProtected(ManageUsers, 'assignRoleToPrincipal')
+    @security.protected(ManageUsers)
     def assignRoleToPrincipal(self, role_id, principal_id, REQUEST=None):
         try:
             return ZODBRoleManager.assignRoleToPrincipal(
@@ -72,7 +71,7 @@ def assignRoleToPrincipal(self, role_id, principal_id, REQUEST=None):
             return ZODBRoleManager.assignRoleToPrincipal(
                                         self, role_id, principal_id)
 
-    security.declareProtected(ManageUsers, 'assignRolesToPrincipal')
+    @security.protected(ManageUsers)
     def assignRolesToPrincipal(self, roles, principal_id, REQUEST=None):
         """ Assign a specific set of roles, and only those roles, to a
         principal.
@@ -85,20 +84,20 @@ def assignRolesToPrincipal(self, roles, principal_id, REQUEST=None):
             if role_id not in ('Authenticated', 'Anonymous', 'Owner'):
                 try:
                     # raise KeyError if unknown!
-                    role_info = self._roles[role_id]
+                    self._roles[role_id]
                 except KeyError:
                     # Lazily update our roles list and try again
                     self.updateRolesList()
                     if role_id in self._roles:
                         # check if this role is managed by this plugin, and
                         # set it
-                        role_info = self._roles[role_id]
+                        self._roles[role_id]
 
         self._principal_roles[principal_id] = tuple(roles)
 
     assignRolesToPrincipal = postonly(assignRolesToPrincipal)
 
-    security.declarePrivate('getRolesForPrincipal')
+    @security.private
     def getRolesForPrincipal(self, principal, request=None):
         """ See IRolesPlugin.
         """
@@ -108,8 +107,8 @@ def getRolesForPrincipal(self, principal, request=None):
         # while excluding the directly assigned roles.  In this case
         # '__ignore_direct_roles__' = True should be pushed in the request.
         request = aq_get(self, 'REQUEST', None)
-        if request is None or \
-            not request.get('__ignore_direct_roles__', False):
+        if request is None \
+           or not request.get('__ignore_direct_roles__', False):
             principal_ids.add(principal.getId())
 
         # Some services may need the real roles of an user but **not**
@@ -117,15 +116,16 @@ def getRolesForPrincipal(self, principal, request=None):
         # '__ignore_group_roles__'= True should be previously pushed
         # in the request.
         plugins = self._getPAS()['plugins']
-        if request is None or \
-            not request.get('__ignore_group_roles__', False):
-            principal_ids.update(getGroupsForPrincipal(principal, plugins,
-                                                       request))
+        if request is None \
+           or not request.get('__ignore_group_roles__', False):
+            principal_ids.update(
+                getGroupsForPrincipal(principal, plugins, request)
+            )
         for pid in principal_ids:
             roles.update(self._principal_roles.get(pid, ()))
         return tuple(roles)
 
-    ## implement IAssignRoleCapability
+    # implement IAssignRoleCapability
 
     def allowRoleAssign(self, user_id, role_id):
         """True iff this plugin will allow assigning a certain user a
diff --git a/Products/PlonePAS/plugins/ufactory.py b/Products/PlonePAS/plugins/ufactory.py
index 2a27bdf..b4e6b16 100644
--- a/Products/PlonePAS/plugins/ufactory.py
+++ b/Products/PlonePAS/plugins/ufactory.py
@@ -1,20 +1,19 @@
-from zope.interface import implements
-
+# -*- coding: utf-8 -*-
 from AccessControl import ClassSecurityInfo
 from AccessControl.PermissionRole import _what_not_even_god_should_do
 from App.class_init import InitializeClass
 from App.special_dtml import DTMLFile
-
+from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
+from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
 from Products.PluggableAuthService.PropertiedUser import PropertiedUser
 from Products.PluggableAuthService.UserPropertySheet import UserPropertySheet
+from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
 from Products.PluggableAuthService.interfaces.plugins import IUserFactoryPlugin
 from Products.PluggableAuthService.interfaces.propertysheets \
     import IPropertySheet
-from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
 from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from zope.interface import implementer
 
-from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
-from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
 try:
     from collections import OrderedDict
 except ImportError:
@@ -38,17 +37,17 @@ def manage_addPloneUserFactory(self, id, title='', RESPONSE=None):
         return RESPONSE.redirect('manage_workspace')
 
 
+@implementer(IUserFactoryPlugin)
 class PloneUserFactory(BasePlugin):
 
     security = ClassSecurityInfo()
     meta_type = 'Plone User Factory'
-    implements(IUserFactoryPlugin)
 
     def __init__(self, id, title=''):
         self.id = id
         self.title = title or self.meta_type
 
-    security.declarePrivate('createUser')
+    @security.private
     def createUser(self, user_id, name):
         return PloneUser(user_id, name)
 
@@ -76,26 +75,26 @@ def _getPlugins(self):
         # XXX This is not very optimal *at all*
         return self._getPAS().plugins
 
-    security.declarePublic('isGroup')
+    @security.public
     def isGroup(self):
         """Return 1 if this user is a group abstraction"""
         return self._isGroup
 
-    security.declarePublic('getName')
+    @security.public
     def getName(self):
         """Get user's or group's name.
         This is the id. PAS doesn't do prefixes and such like GRUF.
         """
         return self.getId()
 
-    security.declarePublic('getName')
+    @security.public
     def getUserId(self):
         """Get user's or group's name.
         This is the id. PAS doesn't do prefixes and such like GRUF.
         """
         return self.getId()
 
-    security.declarePublic('getGroupNames')
+    @security.public
     def getGroupNames(self):
         """Return ids of this user's groups. GRUF compat."""
         return self.getGroups()
@@ -106,7 +105,7 @@ def getGroupNames(self):
     #################################
     # acquisition aware
 
-    security.declarePublic('getPropertysheet')
+    @security.public
     def getPropertysheet(self, id):
         """ -> propertysheet (wrapped if supported)
         """
@@ -116,7 +115,7 @@ def getPropertysheet(self, id):
         except AttributeError:
             return sheet
 
-    security.declarePrivate('addPropertysheet')
+    @security.private
     def addPropertysheet(self, id, data):
         """ -> add a prop sheet, given data which is either
         a property sheet or a raw mapping.
@@ -134,7 +133,7 @@ def addPropertysheet(self, id, data):
     def _getPropertyPlugins(self):
         return self._getPAS().plugins.listPlugins(IPropertiesPlugin)
 
-    security.declarePrivate('getOrderedPropertySheets')
+    @security.private
     def getOrderedPropertySheets(self):
         return self._propertysheets.values()
 
@@ -162,8 +161,8 @@ def allowed(self, object, object_roles=None):
 
         # Provide short-cut access if object is protected by 'Authenticated'
         # role and user is not nobody
-        if 'Authenticated' in object_roles and (
-            self.getUserName() != 'Anonymous User'):
+        if 'Authenticated' in object_roles \
+           and self.getUserName() != 'Anonymous User':
             return 1
 
         # Check for ancient role data up front, convert if found.
diff --git a/Products/PlonePAS/plugins/user.py b/Products/PlonePAS/plugins/user.py
index bfc65b4..79ee8f0 100644
--- a/Products/PlonePAS/plugins/user.py
+++ b/Products/PlonePAS/plugins/user.py
@@ -1,25 +1,22 @@
+# -*- coding: utf-8 -*-
 """
 ZODB based user manager with introspection and management interfaces.
 """
-
-from zope.interface import implements
-
-from AccessControl import ClassSecurityInfo, AuthEncoding
+from AccessControl import AuthEncoding
+from AccessControl import ClassSecurityInfo
 from AccessControl.Permissions import manage_users as ManageUsers
 from App.class_init import InitializeClass
 from App.special_dtml import DTMLFile
-from Products.PluggableAuthService.utils import createViewName
-
 from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
 from Products.PlonePAS.interfaces.capabilities import IPasswordSetCapability
-from Products.PlonePAS.interfaces.plugins import IUserManagement
 from Products.PlonePAS.interfaces.plugins import IUserIntrospection
+from Products.PlonePAS.interfaces.plugins import IUserManagement
+from Products.PluggableAuthService.plugins.ZODBUserManager \
+    import ZODBUserManager as BasePlugin
+from Products.PluggableAuthService.utils import createViewName
+from zope.interface import implementer
 
-from Products.PluggableAuthService.plugins.ZODBUserManager import \
-    ZODBUserManager as BasePlugin
-
-manage_addUserManagerForm = DTMLFile('../zmi/UserManagerForm',
-                                          globals())
+manage_addUserManagerForm = DTMLFile('../zmi/UserManagerForm', globals())
 
 
 def manage_addUserManager(dispatcher, id, title=None, REQUEST=None):
@@ -36,16 +33,20 @@ def manage_addUserManager(dispatcher, id, title=None, REQUEST=None):
             % dispatcher.absolute_url())
 
 
+@implementer(
+    IUserManagement,
+    IUserIntrospection,
+    IDeleteCapability,
+    IPasswordSetCapability
+)
 class UserManager(BasePlugin):
     """PAS plugin for managing users. (adds write API)
     """
 
     meta_type = 'User Manager'
     security = ClassSecurityInfo()
-    implements(IUserManagement, IUserIntrospection, IDeleteCapability,
-               IPasswordSetCapability)
 
-    security.declareProtected(ManageUsers, 'addUser')
+    @security.protected(ManageUsers)
     def addUser(self, user_id, login_name, password):
         """Original ZODBUserManager.addUser, modified to check if
         incoming password is already encypted.
@@ -69,15 +70,15 @@ def addUser(self, user_id, login_name, password):
         view_name = createViewName('enumerateUsers')
         self.ZCacheable_invalidate(view_name=view_name)
 
-    ## User Management interface
+    # User Management interface
 
-    security.declarePrivate('doDeleteUser')
+    @security.private
     def doDeleteUser(self, userid):
         """Given a user id, delete that user
         """
         return self.removeUser(userid)
 
-    security.declarePrivate('doChangeUser')
+    @security.private
     def doChangeUser(self, principal_id, password):
         """Change a user's password
         """
@@ -87,7 +88,7 @@ def doChangeUser(self, principal_id, password):
 
     # implement interfaces IDeleteCapability, IPasswordSetCapability
 
-    security.declarePublic('allowDeletePrincipal')
+    @security.public
     def allowDeletePrincipal(self, principal_id):
         """True iff this plugin can delete a certain user/group.
         This is true if this plugin manages the user.
@@ -96,30 +97,30 @@ def allowDeletePrincipal(self, principal_id):
             return 1
         return 0
 
-    security.declarePublic('allowPasswordSet')
+    @security.public
     def allowPasswordSet(self, principal_id):
         """True iff this plugin can set the password a certain user.
         This is true if this plugin manages the user.
         """
         return self.allowDeletePrincipal(principal_id)
 
-    ## User Introspection interface
+    # User Introspection interface
 
-    security.declareProtected(ManageUsers, 'getUserIds')
+    @security.protected(ManageUsers)
     def getUserIds(self):
         """
         Return a list of user ids
         """
         return self.listUserIds()
 
-    security.declareProtected(ManageUsers, 'getUserNames')
+    @security.protected(ManageUsers)
     def getUserNames(self):
         """
         Return a list of usernames
         """
         return [x['login_name'] for x in self.listUserInfo()]
 
-    security.declareProtected(ManageUsers, 'getUsers')
+    @security.protected(ManageUsers)
     def getUsers(self):
         """
         Return a list of users


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:36:18+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/93c0b87125fdef8193ccac84506ea112977e490a

remove dependency to CMFDefault

Files changed:
M CHANGES.rst
M Products/PlonePAS/tools/membership.py

diff --git a/CHANGES.rst b/CHANGES.rst
index a89ca7e..d10d9cd 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -1,10 +1,13 @@
 Changelog
 =========
 
-5.0.1 (unreleased)
+5.1 (unreleased)
 ------------------
 
-- Cleanup patches, allow introspection by using wrap_method, add roles using wrap_method, 
+- Remove nasty dependency to Products.CMFDefault.
+  [jensens]
+
+- Cleanup patches, allow introspection by using wrap_method, add roles using wrap_method,
   add deprecation and merge ``gruf_support.py`` in ``pas,py`` to have a better overview
   what is patched.
   [jensens]
diff --git a/Products/PlonePAS/tools/membership.py b/Products/PlonePAS/tools/membership.py
index b684150..80af29d 100644
--- a/Products/PlonePAS/tools/membership.py
+++ b/Products/PlonePAS/tools/membership.py
@@ -12,6 +12,7 @@
 from DateTime import DateTime
 from OFS.Image import Image
 from Products.CMFCore.MembershipTool import MembershipTool as BaseTool
+from Products.CMFCore.interfaces import IPropertiesTool
 from Products.CMFCore.permissions import ListPortalMembers
 from Products.CMFCore.permissions import ManagePortal
 from Products.CMFCore.permissions import ManageUsers
@@ -20,7 +21,6 @@
 from Products.CMFCore.permissions import View
 from Products.CMFCore.utils import _checkPermission
 from Products.CMFCore.utils import getToolByName
-from Products.CMFDefault.utils import decode
 from Products.PlonePAS.events import UserInitialLoginInEvent
 from Products.PlonePAS.events import UserLoggedInEvent
 from Products.PlonePAS.events import UserLoggedOutEvent
@@ -31,6 +31,7 @@
 from cStringIO import StringIO
 from zExceptions import BadRequest
 from zope import event
+from zope.component import getUtility
 from zope.interface import implementer
 import logging
 import transaction
@@ -38,6 +39,28 @@
 default_portrait = 'defaultUser.png'
 logger = logging.getLogger('PlonePAS')
 
+_marker = dict()
+
+
+def _unicodify_structure(value, charset=_marker):
+    """ Convert value to unicode.
+    """
+    if charset is _marker:
+        ptool = getUtility(IPropertiesTool)
+        charset = ptool.getProperty('default_charset', None)
+
+    if isinstance(value, str):
+        return charset and unicode(value, charset) or unicode(value)
+    if isinstance(value, list):
+        return [_unicodify_structure(val, charset) for val in value]
+    if isinstance(value, tuple):
+        return tuple([_unicodify_structure(entry, charset) for entry in value])
+    if isinstance(value, dict):
+        for key, val in value.items():
+            value[key] = _unicodify_structure(val, charset)
+        return value
+    return value
+
 
 @implementer(membership.IMembershipTool)
 class MembershipTool(BaseTool):
@@ -162,8 +185,8 @@ def searchForMembers(self, REQUEST=None, **kw):
         if REQUEST is not None:
             searchmap = REQUEST
             for key, value in searchmap.items():
-                if isinstance(value, basestring):
-                    searchmap[key] = decode(value, self)
+                if isinstance(value, str):
+                    searchmap[key] = _unicodify_structure(value)
         else:
             searchmap = kw
 


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:36:18+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/528382028b791e7e5e54d86f39046661d321f73d

Expect Python 2.7 with collections. Closes #8

Files changed:
M CHANGES.rst
M Products/PlonePAS/plugins/ufactory.py
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index d10d9cd..faca514 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,6 +4,9 @@ Changelog
 5.1 (unreleased)
 ------------------
 
+- Expect Python 2.7 with collections.
+  [jensens]
+
 - Remove nasty dependency to Products.CMFDefault.
   [jensens]
 
diff --git a/Products/PlonePAS/plugins/ufactory.py b/Products/PlonePAS/plugins/ufactory.py
index b4e6b16..db24491 100644
--- a/Products/PlonePAS/plugins/ufactory.py
+++ b/Products/PlonePAS/plugins/ufactory.py
@@ -12,13 +12,9 @@
 from Products.PluggableAuthService.interfaces.propertysheets \
     import IPropertySheet
 from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from collections import OrderedDict
 from zope.interface import implementer
 
-try:
-    from collections import OrderedDict
-except ImportError:
-    from ordereddict import OrderedDict
-
 manage_addPloneUserFactoryForm = DTMLFile('../zmi/PloneUserFactoryForm',
                                           globals())
 
diff --git a/setup.py b/setup.py
index 91a12d9..acea2fb 100644
--- a/setup.py
+++ b/setup.py
@@ -4,24 +4,6 @@
 
 version = '5.0.1.dev0'
 
-install_requires = [
-        'Products.CMFCore',
-        'Products.CMFDefault',
-        'Products.GenericSetup',
-        'Products.PluggableAuthService',
-        'Zope2 > 2.12.4',
-        'plone.i18n',
-        'plone.memoize',
-        'plone.session',
-        'setuptools',
-        'zope.deprecation',
-      ]
-
-try:
-    from collections import OrderedDict  # noqa
-except ImportError:
-    install_requires.append('ordereddict')
-
 longdescription = open("README.rst").read()
 longdescription += '\n'
 longdescription += open("CHANGES.rst").read()
@@ -44,6 +26,18 @@
     namespace_packages=['Products'],
     clude_package_data=True,
     zip_safe=False,
+    install_requires=[
+        'Products.CMFCore',
+        'Products.CMFDefault',
+        'Products.GenericSetup',
+        'Products.PluggableAuthService',
+        'Zope2 > 2.13.22',
+        'plone.i18n',
+        'plone.memoize',
+        'plone.session',
+        'setuptools',
+        'zope.deprecation',
+    ],
     extras_require=dict(
         test=[
             'plone.app.testing',
@@ -54,5 +48,4 @@
             'Products.Archetypes',
         ]
     ),
-    install_requires=install_requires,
 )


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:36:18+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/f214814b56becd2dcf54abb6545ee7bfec8b5093

more leftovers cleaned up (pep8 et al)

Files changed:
M Products/PlonePAS/browser/configure.zcml
M Products/PlonePAS/browser/info.py
M Products/PlonePAS/browser/member.py
M Products/PlonePAS/browser/search.py
M Products/PlonePAS/config.py
M Products/PlonePAS/sheet.py
M Products/PlonePAS/tools/membership.py

diff --git a/Products/PlonePAS/browser/configure.zcml b/Products/PlonePAS/browser/configure.zcml
index a18f818..f8e6749 100644
--- a/Products/PlonePAS/browser/configure.zcml
+++ b/Products/PlonePAS/browser/configure.zcml
@@ -1,34 +1,36 @@
-<configure xmlns="http://namespaces.zope.org/zope"
-           xmlns:browser="http://namespaces.zope.org/browser"
-           xmlns:five="http://namespaces.zope.org/five"
-           i18n_domain="Five">
+<configure
+    i18n_domain="Five"
+    xmlns="http://namespaces.zope.org/zope"
+    xmlns:browser="http://namespaces.zope.org/browser"
+    xmlns:five="http://namespaces.zope.org/five">
 
   <permission
-     id="PAS.SearchPrincipals"
-     title="Search for principals" />
+      id="PAS.SearchPrincipals"
+      title="Search for principals"
+  />
 
   <browser:page
+      allowed_interface="Products.PlonePAS.interfaces.browser.IPASInfoView"
+      class=".info.PASInfoView"
       for="*"
       name="pas_info"
-      class=".info.PASInfoView"
       permission="zope2.View"
-      allowed_interface="Products.PlonePAS.interfaces.browser.IPASInfoView"
-      />
+  />
 
   <browser:page
+      allowed_interface="Products.PlonePAS.interfaces.browser.IPASMemberView"
+      class=".member.PASMemberView"
       for="*"
       name="pas_member"
-      class=".member.PASMemberView"
       permission="zope2.View"
-      allowed_interface="Products.PlonePAS.interfaces.browser.IPASMemberView"
-      />
+  />
 
   <browser:page
+      allowed_interface="Products.PlonePAS.interfaces.browser.IPASSearchView"
+      class=".search.PASSearchView"
       for="*"
       name="pas_search"
-      class=".search.PASSearchView"
       permission="zope2.View"
-      allowed_interface="Products.PlonePAS.interfaces.browser.IPASSearchView"
-      />
+  />
 
 </configure>
diff --git a/Products/PlonePAS/browser/info.py b/Products/PlonePAS/browser/info.py
index 68b70f6..353228f 100644
--- a/Products/PlonePAS/browser/info.py
+++ b/Products/PlonePAS/browser/info.py
@@ -1,16 +1,17 @@
-from zope.interface import implements
+# -*- coding: utf-8 -*-
+from zope.interface import implementer
 from plone.memoize.instance import memoize
-
 from Acquisition import aq_inner
 from Products.PlonePAS.interfaces.browser import IPASInfoView
+from Products.PluggableAuthService.interfaces.plugins import IExtractionPlugin
 from Products.PluggableAuthService.interfaces.plugins \
-                import IExtractionPlugin, ILoginPasswordExtractionPlugin
+    import ILoginPasswordExtractionPlugin
 from Products.CMFCore.utils import getToolByName
 from Products.Five import BrowserView
 
 
+@implementer(IPASInfoView)
 class PASInfoView(BrowserView):
-    implements(IPASInfoView)
 
     def checkExtractorForInterface(self, interface):
         acl = getToolByName(aq_inner(self.context), "acl_users")
diff --git a/Products/PlonePAS/browser/member.py b/Products/PlonePAS/browser/member.py
index cc71fd2..b0fcfa6 100644
--- a/Products/PlonePAS/browser/member.py
+++ b/Products/PlonePAS/browser/member.py
@@ -1,14 +1,13 @@
-from plone.memoize.instance import memoize
-from zope.interface import implements
-from zope.publisher.browser import BrowserView
-
+# -*- coding: utf-8 -*-
 from Products.CMFCore.utils import getToolByName
-
 from Products.PlonePAS.interfaces.browser import IPASMemberView
+from plone.memoize.instance import memoize
+from zope.interface import implementer
+from zope.publisher.browser import BrowserView
 
 
+@implementer(IPASMemberView)
 class PASMemberView(BrowserView):
-    implements(IPASMemberView)
 
     @memoize
     def info(self, userid=None):
@@ -16,9 +15,15 @@ def info(self, userid=None):
         result = pm.getMemberInfo(memberId=userid)
         if result is None:
             # No such member: removed?  We return something useful anyway.
-            return {'username': userid, 'description': '', 'language': '',
-                    'home_page': '', 'name_or_id': userid, 'location': '',
-                    'fullname': ''}
+            return {
+                'username': userid,
+                'description': '',
+                'language': '',
+                'home_page': '',
+                'name_or_id': userid,
+                'location': '',
+                'fullname': ''
+            }
         result['name_or_id'] = result.get('fullname') or \
             result.get('username') or userid
         return result
diff --git a/Products/PlonePAS/browser/search.py b/Products/PlonePAS/browser/search.py
index e19d64d..b2d0b00 100644
--- a/Products/PlonePAS/browser/search.py
+++ b/Products/PlonePAS/browser/search.py
@@ -1,13 +1,14 @@
-from zope.interface import implements
-from zope.component import queryUtility
-from Products.Five import BrowserView
+# -*- coding: utf-8 -*-
 from Products.CMFCore.utils import getToolByName
-from plone.i18n.normalizer.interfaces import IIDNormalizer
+from Products.Five import BrowserView
 from Products.PlonePAS.interfaces.browser import IPASSearchView
+from plone.i18n.normalizer.interfaces import IIDNormalizer
+from zope.component import queryUtility
+from zope.interface import implementer
 
 
+@implementer(IPASSearchView)
 class PASSearchView(BrowserView):
-    implements(IPASSearchView)
 
     @staticmethod
     def extractCriteriaFromRequest(request):
diff --git a/Products/PlonePAS/config.py b/Products/PlonePAS/config.py
index 0b202aa..87c86cc 100644
--- a/Products/PlonePAS/config.py
+++ b/Products/PlonePAS/config.py
@@ -12,11 +12,13 @@
 }
 
 # Settings for member image resize quality
+HAS_PIL = True
 try:
     from PIL import Image
     PIL_SCALING_ALGO = Image.ANTIALIAS
 except ImportError:
     PIL_SCALING_ALGO = None
+    HAS_PIL = False
 
 PIL_QUALITY = 88
 MEMBER_IMAGE_SCALE = (75, 100)
diff --git a/Products/PlonePAS/sheet.py b/Products/PlonePAS/sheet.py
index 77d4e17..8b05083 100644
--- a/Products/PlonePAS/sheet.py
+++ b/Products/PlonePAS/sheet.py
@@ -1,22 +1,16 @@
+# -*- coding: utf-8 -*-
 """
 Add Mutable Property Sheets and Schema Mutable Property Sheets to PAS
 
 also a property schema type registry which is extensible.
 
 """
-
-from types import StringTypes, IntType
-from types import LongType, FloatType, InstanceType
-
-from zope.component import getUtility
-from zope.interface import implements
-
-from DateTime.DateTime import DateTime
 from Products.CMFCore.interfaces import ISiteRoot
-
-from Products.PluggableAuthService.UserPropertySheet import _SequenceTypes
-from Products.PluggableAuthService.UserPropertySheet import UserPropertySheet
 from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
+from Products.PluggableAuthService.UserPropertySheet import UserPropertySheet
+from Products.PluggableAuthService.UserPropertySheet import _SequenceTypes
+from zope.component import getUtility
+from zope.interface import implementer
 
 
 class PropertyValueError(ValueError):
@@ -48,38 +42,62 @@ def validate(self, property_type, value):
         return inspector(value)
 
 PropertySchema = PropertySchemaTypeMap()
-PropertySchema.addType('string', lambda x: x is None or type(x) in StringTypes)
-PropertySchema.addType('text', lambda x: x is None or type(x) in StringTypes)
-PropertySchema.addType('boolean', lambda x: 1)  # anything can be boolean
-PropertySchema.addType('int', lambda x:  x is None or type(x) is IntType)
-PropertySchema.addType('long', lambda x:  x is None or type(x) is LongType)
-PropertySchema.addType('float', lambda x:  x is None or type(x) is FloatType)
-PropertySchema.addType('lines',
-                       lambda x:  x is None or type(x) in _SequenceTypes)
-PropertySchema.addType('selection',
-                       lambda x:  x is None or type(x) in StringTypes)
-PropertySchema.addType('multiple selection',
-                       lambda x:  x is None or type(x) in _SequenceTypes)
-PropertySchema.addType('date',
-                       lambda x: 1 or x is None \
-                                 or type(x) is InstanceType \
-                                 and isinstance(x, DateTime))
+PropertySchema.addType(
+    'string',
+    lambda x: x is None or isinstance(x, basestring)
+)
+PropertySchema.addType(
+    'text',
+    lambda x: x is None or isinstance(x, basestring)
+)
+PropertySchema.addType(
+    'boolean',
+    lambda x: 1  # anything can be boolean
+)
+PropertySchema.addType(
+    'int',
+    lambda x:  x is None or isinstance(x, int)
+)
+PropertySchema.addType(
+    'long',
+    lambda x:  x is None or isinstance(x, long)
+)
+PropertySchema.addType(
+    'float',
+    lambda x:  x is None or isinstance(x, float)
+)
+PropertySchema.addType(
+    'lines',
+    lambda x:  x is None or isinstance(x, _SequenceTypes)
+)
+PropertySchema.addType(
+    'selection',
+    lambda x: x is None or isinstance(x, basestring)
+)
+PropertySchema.addType(
+    'multiple selection',
+    lambda x:  x is None or isinstance(x, _SequenceTypes)
+)
+PropertySchema.addType(
+    'date',
+    lambda x: 1
+)
 validateValue = PropertySchema.validate
 
 
+@implementer(IMutablePropertySheet)
 class MutablePropertySheet(UserPropertySheet):
 
-    implements(IMutablePropertySheet)
-
     def validateProperty(self, id, value):
-        if not id in self._properties:
+        if id not in self._properties:
             raise PropertyValueError('No such property found on this schema')
 
         proptype = self.getPropertyType(id)
         if not validateValue(proptype, value):
-            raise PropertyValueError("Invalid value (%s) for "
-                                     "property '%s' of type %s"
-                                        % (value, id, proptype))
+            raise PropertyValueError(
+                "Invalid value (%s) for property '%s' of type %s" %
+                (value, id, proptype)
+            )
 
     def setProperty(self, user, id, value):
         self.validateProperty(id, value)
diff --git a/Products/PlonePAS/tools/membership.py b/Products/PlonePAS/tools/membership.py
index 80af29d..4fe629f 100644
--- a/Products/PlonePAS/tools/membership.py
+++ b/Products/PlonePAS/tools/membership.py
@@ -21,6 +21,7 @@
 from Products.CMFCore.permissions import View
 from Products.CMFCore.utils import _checkPermission
 from Products.CMFCore.utils import getToolByName
+from Products.PlonePAS.config import HAS_PIL
 from Products.PlonePAS.events import UserInitialLoginInEvent
 from Products.PlonePAS.events import UserLoggedInEvent
 from Products.PlonePAS.events import UserLoggedOutEvent
@@ -736,14 +737,13 @@ def getBadMembers(self):
             portrait_data = str(portrait.data)
             if portrait_data == '':
                 continue
-            try:
-                import PIL
-            except ImportError:
+            if not HAS_PIL:
                 raise RuntimeError(
                     'No Python Imaging Libraries (PIL) found. '
-                    'Unable to validate profile image.'
+                    'Unable to validate profile image. '
                 )
             try:
+                import PIL
                 PIL.Image.open(StringIO(portrait_data))
             except ConflictError:
                 pass


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:36:18+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/4f80b188f086f5a33d76be30d2a4820282631511

Moved Extensions/Install.py fucntions to setuphandlers, kept BBB import for activatePluginInterfaces since this is imported by borg.localrole.

Files changed:
M CHANGES.rst
M Products/PlonePAS/Extensions/Install.py
M Products/PlonePAS/setuphandlers.py

diff --git a/CHANGES.rst b/CHANGES.rst
index faca514..857a813 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,7 +4,11 @@ Changelog
 5.1 (unreleased)
 ------------------
 
-- Expect Python 2.7 with collections.
+- Moved ``Extensions/Install.py`` fucntions to setuphandlers, kept BBB import
+  for ``activatePluginInterfaces`` since this is imported by ``borg.localrole``.
+  [jensens]
+
+- Expect Python 2.7 with ``collections.OrderedDict``.
   [jensens]
 
 - Remove nasty dependency to Products.CMFDefault.
diff --git a/Products/PlonePAS/Extensions/Install.py b/Products/PlonePAS/Extensions/Install.py
index 2251b91..3f02911 100644
--- a/Products/PlonePAS/Extensions/Install.py
+++ b/Products/PlonePAS/Extensions/Install.py
@@ -1,396 +1,18 @@
-from Products.CMFCore.utils import getToolByName
-
-from Products.PluggableAuthService.interfaces.authservice \
-        import IPluggableAuthService
-from Products.PluggableAuthService.interfaces.plugins \
-     import ICredentialsResetPlugin
-from Products.PluggableAuthService.interfaces.plugins \
-     import IChallengePlugin
-from Products.PluggableAuthService.Extensions.upgrade \
-     import replace_acl_users
-from Products.PluggableAuthService.plugins.RecursiveGroupsPlugin \
-     import addRecursiveGroupsPlugin
-
-from Products.PlonePAS import config
-from Products.PlonePAS.interfaces.plugins import IUserManagement
-from Products.PlonePAS.interfaces.plugins import IUserIntrospection
-from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
-from Products.PlonePAS.interfaces import group as igroup
-
-from plone.session.plugins.session import manage_addSessionPlugin
-
-import logging
-logger = logging.getLogger('PlonePAS setup')
-
-
-def activatePluginInterfaces(portal, plugin, disable=None):
-    if disable is None:
-        disable=[]
-    pas = portal.acl_users
-    plugin_obj = pas[plugin]
-
-    activatable = []
-
-    for info in plugin_obj.plugins.listPluginTypeInfo():
-        interface = info['interface']
-        interface_name = info['id']
-        if plugin_obj.testImplements(interface):
-            if interface_name in disable:
-                disable.append(interface_name)
-                logger.debug("Disabling: " + info['title'])
-            else:
-                activatable.append(interface_name)
-                logger.debug("Activating: " + info['title'])
-    plugin_obj.manage_activateInterfaces(activatable)
-    logger.debug(plugin + " activated.")
-
-
-def setupRoles(portal):
-    rmanager = portal.acl_users.role_manager
-    rmanager.addRole('Member', title="Portal Member")
-    rmanager.addRole('Reviewer', title="Content Reviewer")
-
-
-def registerPluginType(pas, plugin_type, plugin_info):
-    # Make sure there's no dupes in _plugin_types, otherwise your PAS
-    # will *CRAWL*
-    plugin_types = list(set(pas.plugins._plugin_types))
-    if not plugin_type in plugin_types:
-        plugin_types.append(plugin_type)
-
-    # Order doesn't seem to matter, but let's store it ordered.
-    plugin_types.sort()
-
-    # Re-assign to the object, because this is a non-persistent list.
-    pas.plugins._plugin_types = plugin_types
-
-    # It's safe to assign over a existing key here.
-    pas.plugins._plugin_type_info[plugin_type] = plugin_info
-
-
-def registerPluginTypes(pas):
-
-    PluginInfo = {
-        'id': 'IUserManagement',
-        'title': 'user_management',
-        'description': ("The User Management plugins allow the "
-                        "Pluggable Auth Service to add/delete/modify users")
-        }
-
-    registerPluginType(pas, IUserManagement, PluginInfo)
-
-    PluginInfo = {
-        'id': 'IUserIntrospection',
-        'title': 'user_introspection',
-        'description': ("The User Introspection plugins allow the "
-                        "Pluggable Auth Service to provide lists of users")
-        }
-
-    registerPluginType(pas, IUserIntrospection, PluginInfo)
-
-    PluginInfo = {
-        'id': 'IGroupManagement',
-        'title': 'group_management',
-        'description': ("Group Management provides add/write/deletion "
-                        "of groups and member management")
-        }
-
-    registerPluginType(pas, igroup.IGroupManagement, PluginInfo)
-
-    PluginInfo = {
-        'id': 'IGroupIntrospection',
-        'title': 'group_introspection',
-        'description': ("Group Introspection provides listings "
-                        "of groups and membership")
-        }
-
-    registerPluginType(pas, igroup.IGroupIntrospection, PluginInfo)
-
-    PluginInfo = {
-        'id': 'ILocalRolesPlugin',
-        'title': 'local_roles',
-        'description': "Defines Policy for getting Local Roles"
-        }
-
-    registerPluginType(pas, ILocalRolesPlugin, PluginInfo)
-
-
-def setupPlugins(portal):
-    uf = portal.acl_users
-    logger.debug("\nPlugin setup")
-
-    pas = uf.manage_addProduct['PluggableAuthService']
-    plone_pas = uf.manage_addProduct['PlonePAS']
-
-    setupAuthPlugins(portal, pas, plone_pas)
-
-    found = uf.objectIds(['User Manager'])
-    if not found:
-        plone_pas.manage_addUserManager('source_users')
-        logger.debug("Added User Manager.")
-    activatePluginInterfaces(portal, 'source_users')
-
-    found = uf.objectIds(['Group Aware Role Manager'])
-    if not found:
-        plone_pas.manage_addGroupAwareRoleManager('portal_role_manager')
-        logger.debug("Added Group Aware Role Manager.")
-        activatePluginInterfaces(portal, 'portal_role_manager')
-
-    found = uf.objectIds(['Local Roles Manager'])
-    if not found:
-        plone_pas.manage_addLocalRolesManager('local_roles')
-        logger.debug("Added Group Aware Role Manager.")
-        activatePluginInterfaces(portal, 'local_roles')
-
-    found = uf.objectIds(['Group Manager'])
-    if not found:
-        plone_pas.manage_addGroupManager('source_groups')
-        logger.debug("Added ZODB Group Manager.")
-        activatePluginInterfaces(portal, 'source_groups')
-
-    found = uf.objectIds(['Plone User Factory'])
-    if not found:
-        plone_pas.manage_addPloneUserFactory('user_factory')
-        logger.debug("Added Plone User Factory.")
-        activatePluginInterfaces(portal, "user_factory")
-
-    found = uf.objectIds(['ZODB Mutable Property Provider'])
-    if not found:
-        plone_pas.manage_addZODBMutablePropertyProvider('mutable_properties')
-        logger.debug("Added Mutable Property Manager.")
-        activatePluginInterfaces(portal, "mutable_properties")
-
-    found = uf.objectIds(['Automatic Group Plugin'])
-    if not found:
-        plone_pas.manage_addAutoGroup(
-                "auto_group", "Authenticated Users (Virtual Group)",
-                "AuthenticatedUsers", "Automatic Group Provider")
-        logger.debug("Added Automatic Group.")
-        activatePluginInterfaces(portal, "auto_group")
-
-    found = uf.objectIds(['Plone Session Plugin'])
-    if not found:
-        manage_addSessionPlugin(plone_pas, 'session')
-        logger.debug("Added Plone Session Plugin.")
-        activatePluginInterfaces(portal, "session")
-
-    found = uf.objectIds(['Recursive Groups Plugin'])
-    if not found:
-        addRecursiveGroupsPlugin(plone_pas, 'recursive_groups',
-                                 "Recursive Groups Plugin")
-        activatePluginInterfaces(portal, 'recursive_groups')
-        logger.debug("Added Recursive Groups plugin.")
-
-    setupPasswordPolicyPlugin(portal)
-
-
-def setupAuthPlugins(portal, pas, plone_pas,
-                     deactivate_basic_reset=True,
-                     deactivate_cookie_challenge=False):
-    uf = portal.acl_users
-    logger.debug("Cookie plugin setup")
-
-    login_path = 'login_form'
-    logout_path = 'logged_out'
-    cookie_name = '__ac'
-
-    crumbler = getToolByName(portal, 'cookie_authentication', None)
-    if crumbler is not None:
-        login_path = crumbler.auto_login_page
-        logout_path = crumbler.logout_page
-        cookie_name = crumbler.auth_cookie
-
-    found = uf.objectIds(['Extended Cookie Auth Helper'])
-    if not found:
-        plone_pas.manage_addExtendedCookieAuthHelper('credentials_cookie_auth',
-                                                     cookie_name=cookie_name)
-    logger.debug("Added Extended Cookie Auth Helper.")
-    if deactivate_basic_reset:
-        disable = ['ICredentialsResetPlugin', 'ICredentialsUpdatePlugin']
-    else:
-        disable = []
-    activatePluginInterfaces(portal, 'credentials_cookie_auth',
-            disable=disable)
-
-    credentials_cookie_auth = uf._getOb('credentials_cookie_auth')
-    if 'login_form' in credentials_cookie_auth:
-        credentials_cookie_auth.manage_delObjects(ids=['login_form'])
-        logger.debug("Removed default login_form from credentials cookie "
-                     "auth.")
-    credentials_cookie_auth.cookie_name = cookie_name
-    credentials_cookie_auth.login_path = login_path
-
-    # remove cookie crumbler(s)
-    if 'cookie_authentication' in portal:
-        portal.manage_delObjects(['cookie_authentication'])
-    logger.debug("Removed old Cookie Crumbler")
-
-    found = uf.objectIds(['HTTP Basic Auth Helper'])
-    if not found:
-        pas.addHTTPBasicAuthHelper('credentials_basic_auth',
-                               title="HTTP Basic Auth")
-    logger.debug("Added Basic Auth Helper.")
-    activatePluginInterfaces(portal, 'credentials_basic_auth')
-
-    if deactivate_basic_reset:
-        uf.plugins.deactivatePlugin(ICredentialsResetPlugin,
-                                     'credentials_basic_auth')
-    if deactivate_cookie_challenge:
-        uf.plugins.deactivatePlugin(IChallengePlugin,
-                                     'credentials_cookie_auth')
-
-
-def updateProperties(tool, properties):
-    propsWithNoDeps = [prop for prop in properties
-                            if prop['type']
-                                not in ('selection', 'multiple selection')]
-    propsWithDeps = [prop for prop in properties
-                          if prop['type']
-                              in ('selection', 'multiple selection')]
-    for prop in propsWithNoDeps:
-        updateProp(tool, prop)
-    for prop in propsWithDeps:
-        updateProp(tool, prop)
-
-
-def updateProp(prop_manager, prop_dict):
-    """Provided a PropertyManager and a property dict of {id, value,
-    type}, set or update that property as applicable.
-
-    Doesn't deal with existing properties changing type.
-    """
-    id = prop_dict['id']
-    value = prop_dict['value']
-    type = prop_dict['type']
-    if type in ('selection', 'multiple selection'):
-        value = prop_dict['select_variable']
-    if prop_manager.hasProperty(id):
-        prop_manager._updateProperty(id, value)
-    else:
-        prop_manager._setProperty(id, value, type)
-    if type in ('selection', 'multiple selection'):
-        prop_manager._updateProperty(id, prop_dict['value'])
-
-
-def addPAS(portal):
-    logger.debug("Adding PAS user folder")
-    portal.manage_addProduct['PluggableAuthService'].addPluggableAuthService()
-
-
-def migrate_root_uf(self):
-    # Acquire parent user folder.
-    parent = self.getPhysicalRoot()
-    uf = getToolByName(parent, 'acl_users')
-    if IPluggableAuthService.providedBy(uf):
-        # It's a PAS already, fixup if needed.
-        pas_fixup(parent)
-
-        # Configure Challenge Chooser plugin if available
-        challenge_chooser_setup(parent)
-        return
-
-    if not uf.meta_type == 'User Folder':
-        # It's not a standard User Folder at the root. Nothing we can do.
-        return
-
-    # It's a standard User Folder, replace it.
-    replace_acl_users(parent)
-
-    # Get the new uf
-    uf = getToolByName(parent, 'acl_users')
-
-    pas = uf.manage_addProduct['PluggableAuthService']
-    plone_pas = uf.manage_addProduct['PlonePAS']
-    # Setup authentication plugins
-    setupAuthPlugins(parent, pas, plone_pas,
-                     deactivate_basic_reset=False,
-                     deactivate_cookie_challenge=True)
-
-    # Activate *all* interfaces for user manager. IUserAdder is not
-    # activated for some reason by default.
-    activatePluginInterfaces(parent, 'users')
-
-    # Configure Challenge Chooser plugin if available
-    challenge_chooser_setup(parent)
-
-
-def pas_fixup(self):
-    from Products.PluggableAuthService.PluggableAuthService \
-         import _PLUGIN_TYPE_INFO
-
-    pas = getToolByName(self, 'acl_users')
-    if not IPluggableAuthService.providedBy(pas):
-        logger.debug('PAS UF not found, skipping PAS fixup.')
-        return
-
-    plugins = pas['plugins']
-
-    plugin_types = list(set(plugins._plugin_types))
-    for key, id, title, description in _PLUGIN_TYPE_INFO:
-        if key in plugin_types:
-            logger.debug("Plugin type '%s' already registered." % id)
-            continue
-        logger.debug("Plugin type '%s' was not registered." % id)
-        plugin_types.append(key)
-        plugins._plugin_type_info[key] = {
-            'id': id,
-            'title': title,
-            'description': description,
-            }
-    # Make it ordered
-    plugin_types.sort()
-
-    # Re-assign because it's a non-persistent property.
-    plugins._plugin_types = plugin_types
-
-
-def challenge_chooser_setup(self):
-    uf = getToolByName(self, 'acl_users')
-    plugins = uf['plugins']
-    pas = uf.manage_addProduct['PluggableAuthService']
-
-    # Only install plugins if available
-    req = ('addChallengeProtocolChooserPlugin',
-           'addRequestTypeSnifferPlugin')
-    for m in req:
-        if getattr(pas, m, None) is None:
-            logger.debug('Needed plugins have not been found, ignoring')
-            return
-
-    found = uf.objectIds(['Challenge Protocol Chooser Plugin'])
-    if not found:
-        logger.debug('Adding Challenge Protocol Chooser Plugin.')
-        pas.addChallengeProtocolChooserPlugin(
-            'chooser',
-            mapping=config.DEFAULT_PROTO_MAPPING)
-        activatePluginInterfaces(self, 'chooser')
-    else:
-        assert len(found) == 1, 'Found extra plugins %s' % found
-        logger.debug('Found existing Challenge Protocol Chooser Plugin.')
-        plugin = uf[found[0]]
-        plugin.manage_updateProtocolMapping(
-            mapping=config.DEFAULT_PROTO_MAPPING)
-        activatePluginInterfaces(self, found[0])
-
-    found = uf.objectIds(['Request Type Sniffer Plugin'])
-    if not found:
-        logger.debug('Adding Request Type Sniffer Plugin.')
-        pas.addRequestTypeSnifferPlugin('sniffer')
-        activatePluginInterfaces(self, 'sniffer')
-    else:
-        assert len(found) == 1, 'Found extra plugins %s' % found
-        logger.debug('Found existing Request Type Sniffer Plugin.')
-        activatePluginInterfaces(self, found[0])
-
-
-def setupPasswordPolicyPlugin(portal):
-    uf = portal.acl_users
-    plone_pas = uf.manage_addProduct['PlonePAS']
-
-    found = uf.objectIds(['Default Plone Password Policy'])
-    logger.debug("\nDefault Password Ploicy Plugin setup")
-    if not found:
-        plone_pas.manage_addPasswordPolicyPlugin('password_policy',
-                               title="Default Plone Password Policy")
-        logger.debug("Added Default Plone Password Policy.")
-        activatePluginInterfaces(portal, 'password_policy')
+# -*- coding: utf-8 -*-
+# BBB
+
+# imported at least by borg.localrole.utils
+from Products.PlonePAS.setuphandlers import activatePluginInterfaces  # noqa
+
+# used by plone.app.upgrade/plone/app/upgrade/v43/final.py
+from Products.PlonePAS.setuphandlers import setupPasswordPolicyPlugin  # noqa
+
+# seems this is not needed anywhere outside setuphandlers
+# from Products.PlonePAS.setuphandlers import setupRoles
+# from Products.PlonePAS.setuphandlers import registerPluginType
+# from Products.PlonePAS.setuphandlers import registerPluginTypes
+# from Products.PlonePAS.setuphandlers import setupAuthPlugins
+# from Products.PlonePAS.setuphandlers import updateProperties
+# from Products.PlonePAS.setuphandlers import updateProp
+# from Products.PlonePAS.setuphandlers import addPAS
+# from Products.PlonePAS.setuphandlers import challenge_chooser_setup
diff --git a/Products/PlonePAS/setuphandlers.py b/Products/PlonePAS/setuphandlers.py
index 9a68362..4e3637f 100644
--- a/Products/PlonePAS/setuphandlers.py
+++ b/Products/PlonePAS/setuphandlers.py
@@ -1,10 +1,403 @@
 # -*- coding: utf-8 -*-
 from Acquisition import aq_parent
 from Products.CMFCore.utils import getToolByName
-from Products.PlonePAS.Extensions.Install import challenge_chooser_setup
-from Products.PlonePAS.Extensions.Install import migrate_root_uf
-from Products.PlonePAS.Extensions.Install import registerPluginTypes
-from Products.PlonePAS.Extensions.Install import setupPlugins
+from Products.PlonePAS import config
+from Products.PlonePAS.interfaces import group as igroup
+from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
+from Products.PlonePAS.interfaces.plugins import IUserIntrospection
+from Products.PlonePAS.interfaces.plugins import IUserManagement
+from Products.PluggableAuthService.Extensions.upgrade import replace_acl_users
+from Products.PluggableAuthService.interfaces.authservice \
+    import IPluggableAuthService
+from Products.PluggableAuthService.interfaces.plugins import IChallengePlugin
+from Products.PluggableAuthService.interfaces.plugins \
+    import ICredentialsResetPlugin
+from Products.PluggableAuthService.plugins.RecursiveGroupsPlugin \
+    import addRecursiveGroupsPlugin
+from plone.session.plugins.session import manage_addSessionPlugin
+import logging
+
+logger = logging.getLogger('PlonePAS setup')
+
+
+def activatePluginInterfaces(portal, plugin, disable=None):
+    if disable is None:
+        disable = []
+    pas = portal.acl_users
+    plugin_obj = pas[plugin]
+
+    activatable = []
+
+    for info in plugin_obj.plugins.listPluginTypeInfo():
+        interface = info['interface']
+        interface_name = info['id']
+        if plugin_obj.testImplements(interface):
+            if interface_name in disable:
+                disable.append(interface_name)
+                logger.debug("Disabling: " + info['title'])
+            else:
+                activatable.append(interface_name)
+                logger.debug("Activating: " + info['title'])
+    plugin_obj.manage_activateInterfaces(activatable)
+    logger.debug(plugin + " activated.")
+
+
+def setupRoles(portal):
+    rmanager = portal.acl_users.role_manager
+    rmanager.addRole('Member', title="Portal Member")
+    rmanager.addRole('Reviewer', title="Content Reviewer")
+
+
+def registerPluginType(pas, plugin_type, plugin_info):
+    # Make sure there's no dupes in _plugin_types, otherwise your PAS
+    # will *CRAWL*
+    plugin_types = list(set(pas.plugins._plugin_types))
+    if plugin_type not in plugin_types:
+        plugin_types.append(plugin_type)
+
+    # Order doesn't seem to matter, but let's store it ordered.
+    plugin_types.sort()
+
+    # Re-assign to the object, because this is a non-persistent list.
+    pas.plugins._plugin_types = plugin_types
+
+    # It's safe to assign over a existing key here.
+    pas.plugins._plugin_type_info[plugin_type] = plugin_info
+
+
+def registerPluginTypes(pas):
+
+    PluginInfo = {
+        'id': 'IUserManagement',
+        'title': 'user_management',
+        'description': ("The User Management plugins allow the "
+                        "Pluggable Auth Service to add/delete/modify users")
+        }
+
+    registerPluginType(pas, IUserManagement, PluginInfo)
+
+    PluginInfo = {
+        'id': 'IUserIntrospection',
+        'title': 'user_introspection',
+        'description': ("The User Introspection plugins allow the "
+                        "Pluggable Auth Service to provide lists of users")
+        }
+
+    registerPluginType(pas, IUserIntrospection, PluginInfo)
+
+    PluginInfo = {
+        'id': 'IGroupManagement',
+        'title': 'group_management',
+        'description': ("Group Management provides add/write/deletion "
+                        "of groups and member management")
+        }
+
+    registerPluginType(pas, igroup.IGroupManagement, PluginInfo)
+
+    PluginInfo = {
+        'id': 'IGroupIntrospection',
+        'title': 'group_introspection',
+        'description': ("Group Introspection provides listings "
+                        "of groups and membership")
+        }
+
+    registerPluginType(pas, igroup.IGroupIntrospection, PluginInfo)
+
+    PluginInfo = {
+        'id': 'ILocalRolesPlugin',
+        'title': 'local_roles',
+        'description': "Defines Policy for getting Local Roles"
+        }
+
+    registerPluginType(pas, ILocalRolesPlugin, PluginInfo)
+
+
+def setupPlugins(portal):
+    uf = portal.acl_users
+    logger.debug("\nPlugin setup")
+
+    pas = uf.manage_addProduct['PluggableAuthService']
+    plone_pas = uf.manage_addProduct['PlonePAS']
+
+    setupAuthPlugins(portal, pas, plone_pas)
+
+    found = uf.objectIds(['User Manager'])
+    if not found:
+        plone_pas.manage_addUserManager('source_users')
+        logger.debug("Added User Manager.")
+    activatePluginInterfaces(portal, 'source_users')
+
+    found = uf.objectIds(['Group Aware Role Manager'])
+    if not found:
+        plone_pas.manage_addGroupAwareRoleManager('portal_role_manager')
+        logger.debug("Added Group Aware Role Manager.")
+        activatePluginInterfaces(portal, 'portal_role_manager')
+
+    found = uf.objectIds(['Local Roles Manager'])
+    if not found:
+        plone_pas.manage_addLocalRolesManager('local_roles')
+        logger.debug("Added Group Aware Role Manager.")
+        activatePluginInterfaces(portal, 'local_roles')
+
+    found = uf.objectIds(['Group Manager'])
+    if not found:
+        plone_pas.manage_addGroupManager('source_groups')
+        logger.debug("Added ZODB Group Manager.")
+        activatePluginInterfaces(portal, 'source_groups')
+
+    found = uf.objectIds(['Plone User Factory'])
+    if not found:
+        plone_pas.manage_addPloneUserFactory('user_factory')
+        logger.debug("Added Plone User Factory.")
+        activatePluginInterfaces(portal, "user_factory")
+
+    found = uf.objectIds(['ZODB Mutable Property Provider'])
+    if not found:
+        plone_pas.manage_addZODBMutablePropertyProvider('mutable_properties')
+        logger.debug("Added Mutable Property Manager.")
+        activatePluginInterfaces(portal, "mutable_properties")
+
+    found = uf.objectIds(['Automatic Group Plugin'])
+    if not found:
+        plone_pas.manage_addAutoGroup(
+                "auto_group", "Authenticated Users (Virtual Group)",
+                "AuthenticatedUsers", "Automatic Group Provider")
+        logger.debug("Added Automatic Group.")
+        activatePluginInterfaces(portal, "auto_group")
+
+    found = uf.objectIds(['Plone Session Plugin'])
+    if not found:
+        manage_addSessionPlugin(plone_pas, 'session')
+        logger.debug("Added Plone Session Plugin.")
+        activatePluginInterfaces(portal, "session")
+
+    found = uf.objectIds(['Recursive Groups Plugin'])
+    if not found:
+        addRecursiveGroupsPlugin(plone_pas, 'recursive_groups',
+                                 "Recursive Groups Plugin")
+        activatePluginInterfaces(portal, 'recursive_groups')
+        logger.debug("Added Recursive Groups plugin.")
+
+    setupPasswordPolicyPlugin(portal)
+
+
+def setupAuthPlugins(portal, pas, plone_pas,
+                     deactivate_basic_reset=True,
+                     deactivate_cookie_challenge=False):
+    uf = portal.acl_users
+    logger.debug("Cookie plugin setup")
+
+    login_path = 'login_form'
+    cookie_name = '__ac'
+
+    crumbler = getToolByName(portal, 'cookie_authentication', None)
+    if crumbler is not None:
+        login_path = crumbler.auto_login_page
+        cookie_name = crumbler.auth_cookie
+
+    found = uf.objectIds(['Extended Cookie Auth Helper'])
+    if not found:
+        plone_pas.manage_addExtendedCookieAuthHelper('credentials_cookie_auth',
+                                                     cookie_name=cookie_name)
+    logger.debug("Added Extended Cookie Auth Helper.")
+    if deactivate_basic_reset:
+        disable = ['ICredentialsResetPlugin', 'ICredentialsUpdatePlugin']
+    else:
+        disable = []
+    activatePluginInterfaces(
+        portal,
+        'credentials_cookie_auth',
+        disable=disable
+    )
+
+    credentials_cookie_auth = uf._getOb('credentials_cookie_auth')
+    if 'login_form' in credentials_cookie_auth:
+        credentials_cookie_auth.manage_delObjects(ids=['login_form'])
+        logger.debug("Removed default login_form from credentials cookie "
+                     "auth.")
+    credentials_cookie_auth.cookie_name = cookie_name
+    credentials_cookie_auth.login_path = login_path
+
+    # remove cookie crumbler(s)
+    if 'cookie_authentication' in portal:
+        portal.manage_delObjects(['cookie_authentication'])
+    logger.debug("Removed old Cookie Crumbler")
+
+    found = uf.objectIds(['HTTP Basic Auth Helper'])
+    if not found:
+        pas.addHTTPBasicAuthHelper(
+            'credentials_basic_auth',
+            title="HTTP Basic Auth"
+        )
+    logger.debug("Added Basic Auth Helper.")
+    activatePluginInterfaces(portal, 'credentials_basic_auth')
+
+    if deactivate_basic_reset:
+        uf.plugins.deactivatePlugin(
+            ICredentialsResetPlugin,
+            'credentials_basic_auth'
+        )
+    if deactivate_cookie_challenge:
+        uf.plugins.deactivatePlugin(
+            IChallengePlugin,
+            'credentials_cookie_auth'
+        )
+
+
+def updateProperties(tool, properties):
+    dependency_keys = ('selection', 'multiple selection')
+    propsWithNoDeps = [prop for prop in properties
+                       if prop['type'] not in dependency_keys]
+    propsWithDeps = [prop for prop in properties
+                     if prop['type'] in dependency_keys]
+    for prop in propsWithNoDeps:
+        updateProp(tool, prop)
+    for prop in propsWithDeps:
+        updateProp(tool, prop)
+
+
+def updateProp(prop_manager, prop_dict):
+    """Provided a PropertyManager and a property dict of {id, value,
+    type}, set or update that property as applicable.
+
+    Doesn't deal with existing properties changing type.
+    """
+    id = prop_dict['id']
+    value = prop_dict['value']
+    type = prop_dict['type']
+    if type in ('selection', 'multiple selection'):
+        value = prop_dict['select_variable']
+    if prop_manager.hasProperty(id):
+        prop_manager._updateProperty(id, value)
+    else:
+        prop_manager._setProperty(id, value, type)
+    if type in ('selection', 'multiple selection'):
+        prop_manager._updateProperty(id, prop_dict['value'])
+
+
+def addPAS(portal):
+    logger.debug("Adding PAS user folder")
+    portal.manage_addProduct['PluggableAuthService'].addPluggableAuthService()
+
+
+def migrate_root_uf(self):
+    # Acquire parent user folder.
+    parent = self.getPhysicalRoot()
+    uf = getToolByName(parent, 'acl_users')
+    if IPluggableAuthService.providedBy(uf):
+        # It's a PAS already, fixup if needed.
+        pas_fixup(parent)
+
+        # Configure Challenge Chooser plugin if available
+        challenge_chooser_setup(parent)
+        return
+
+    if not uf.meta_type == 'User Folder':
+        # It's not a standard User Folder at the root. Nothing we can do.
+        return
+
+    # It's a standard User Folder, replace it.
+    replace_acl_users(parent)
+
+    # Get the new uf
+    uf = getToolByName(parent, 'acl_users')
+
+    pas = uf.manage_addProduct['PluggableAuthService']
+    plone_pas = uf.manage_addProduct['PlonePAS']
+    # Setup authentication plugins
+    setupAuthPlugins(parent, pas, plone_pas,
+                     deactivate_basic_reset=False,
+                     deactivate_cookie_challenge=True)
+
+    # Activate *all* interfaces for user manager. IUserAdder is not
+    # activated for some reason by default.
+    activatePluginInterfaces(parent, 'users')
+
+    # Configure Challenge Chooser plugin if available
+    challenge_chooser_setup(parent)
+
+
+def pas_fixup(self):
+    from Products.PluggableAuthService.PluggableAuthService \
+         import _PLUGIN_TYPE_INFO
+
+    pas = getToolByName(self, 'acl_users')
+    if not IPluggableAuthService.providedBy(pas):
+        logger.debug('PAS UF not found, skipping PAS fixup.')
+        return
+
+    plugins = pas['plugins']
+
+    plugin_types = list(set(plugins._plugin_types))
+    for key, id, title, description in _PLUGIN_TYPE_INFO:
+        if key in plugin_types:
+            logger.debug("Plugin type '%s' already registered." % id)
+            continue
+        logger.debug("Plugin type '%s' was not registered." % id)
+        plugin_types.append(key)
+        plugins._plugin_type_info[key] = {
+            'id': id,
+            'title': title,
+            'description': description,
+            }
+    # Make it ordered
+    plugin_types.sort()
+
+    # Re-assign because it's a non-persistent property.
+    plugins._plugin_types = plugin_types
+
+
+def challenge_chooser_setup(self):
+    uf = getToolByName(self, 'acl_users')
+    pas = uf.manage_addProduct['PluggableAuthService']
+
+    # Only install plugins if available
+    req = ('addChallengeProtocolChooserPlugin',
+           'addRequestTypeSnifferPlugin')
+    for m in req:
+        if getattr(pas, m, None) is None:
+            logger.debug('Needed plugins have not been found, ignoring')
+            return
+
+    found = uf.objectIds(['Challenge Protocol Chooser Plugin'])
+    if not found:
+        logger.debug('Adding Challenge Protocol Chooser Plugin.')
+        pas.addChallengeProtocolChooserPlugin(
+            'chooser',
+            mapping=config.DEFAULT_PROTO_MAPPING)
+        activatePluginInterfaces(self, 'chooser')
+    else:
+        assert len(found) == 1, 'Found extra plugins %s' % found
+        logger.debug('Found existing Challenge Protocol Chooser Plugin.')
+        plugin = uf[found[0]]
+        plugin.manage_updateProtocolMapping(
+            mapping=config.DEFAULT_PROTO_MAPPING)
+        activatePluginInterfaces(self, found[0])
+
+    found = uf.objectIds(['Request Type Sniffer Plugin'])
+    if not found:
+        logger.debug('Adding Request Type Sniffer Plugin.')
+        pas.addRequestTypeSnifferPlugin('sniffer')
+        activatePluginInterfaces(self, 'sniffer')
+    else:
+        assert len(found) == 1, 'Found extra plugins %s' % found
+        logger.debug('Found existing Request Type Sniffer Plugin.')
+        activatePluginInterfaces(self, found[0])
+
+
+def setupPasswordPolicyPlugin(portal):
+    uf = portal.acl_users
+    plone_pas = uf.manage_addProduct['PlonePAS']
+
+    found = uf.objectIds(['Default Plone Password Policy'])
+    logger.debug("\nDefault Password Ploicy Plugin setup")
+    if not found:
+        plone_pas.manage_addPasswordPolicyPlugin(
+            'password_policy',
+            title="Default Plone Password Policy"
+        )
+        logger.debug("Added Default Plone Password Policy.")
+        activatePluginInterfaces(portal, 'password_policy')
 
 
 def setLoginFormInCookieAuth(context):


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:36:18+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/88e52a6272eb0b5a6ee876d381c8d12edfc8ac02

improve readability of canListAllUsers and canListAllGroups

Files changed:
M Products/PlonePAS/pas.py

diff --git a/Products/PlonePAS/pas.py b/Products/PlonePAS/pas.py
index 1cd10bf..51f8866 100644
--- a/Products/PlonePAS/pas.py
+++ b/Products/PlonePAS/pas.py
@@ -306,22 +306,18 @@ def getUsers(self):
 
 def canListAllUsers(self):
     plugins = self._getOb('plugins')
-
     # Do we have multiple user plugins?
-    if len(plugins.listPlugins(IUserEnumerationPlugin)) \
-            != len(plugins.listPlugins(IUserIntrospection)):
-        return False
-    return True
+    num_enumeration_plugins = plugins.listPlugins(IUserEnumerationPlugin)
+    num_introspection_plugins = plugins.listPlugins(IUserEnumerationPlugin)
+    return num_enumeration_plugins == num_introspection_plugins
 
 
 def canListAllGroups(self):
     plugins = self._getOb('plugins')
-
-    # Do we have multiple user plugins?
-    if len(plugins.listPlugins(IGroupEnumerationPlugin)) \
-            != len(plugins.listPlugins(IGroupIntrospection)):
-        return False
-    return True
+    # Do we have multiple group plugins?
+    num_enumeration_plugins = plugins.listPlugins(IGroupEnumerationPlugin)
+    num_introspection_plugins = plugins.listPlugins(IGroupEnumerationPlugin)
+    return num_enumeration_plugins == num_introspection_plugins
 
 
 def userSetPassword(self, userid, password):
@@ -330,7 +326,7 @@ def userSetPassword(self, userid, password):
     plugins = self._getOb('plugins')
     managers = plugins.listPlugins(IUserManagement)
 
-    if not (managers):
+    if not managers:
         raise NotImplementedError("There is no plugin that can modify users")
 
     modified = False
@@ -388,7 +384,7 @@ def addRole(self, role):
     for plugin_id, plugin in roles:
         try:
             plugin.addRole(role)
-            return
+            break
         except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
             pass
 


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:36:18+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/54a1bce15b88a367db411fc753951e27a1a80c29

Removed (optional) Archetypes Storage used in past with CMFMember

Files changed:
M CHANGES.rst
M setup.py
D Products/PlonePAS/storage.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 857a813..69ace57 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,6 +4,12 @@ Changelog
 5.1 (unreleased)
 ------------------
 
+- Removed (optional) Archetypes Storage (used in past with CMFMember, which
+  itself was long time ago superseeded by Membrane). Probably dead code. If
+  theres someone out there needing it in Plone 5 please copy the code from
+  git/Plone4 in your addon/project.
+  [jensens]
+
 - Moved ``Extensions/Install.py`` fucntions to setuphandlers, kept BBB import
   for ``activatePluginInterfaces`` since this is imported by ``borg.localrole``.
   [jensens]
diff --git a/Products/PlonePAS/storage.py b/Products/PlonePAS/storage.py
deleted file mode 100644
index 28bb9b6..0000000
--- a/Products/PlonePAS/storage.py
+++ /dev/null
@@ -1,36 +0,0 @@
-# -*- coding: utf-8 -*-
-"""
-an archetypes storage that delegates to a pas property provider.
-
-main use.. cmfmember integration w/ properties providers
-
-"""
-from AccessControl import ClassSecurityInfo
-from Products.Archetypes.public import IStorage
-from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
-from zope.interface import implementer
-
-
-@implementer(IStorage)
-class PASStorage(object):
-
-    security = ClassSecurityInfo()
-
-    def get(self, name, instance, **kwargs):
-        user = instance.getUser()
-        sheets = user.getOrderedSheets()
-        for sheet in sheets:
-            if sheet.hasProperty(name):
-                return sheet.getProperty(name)
-        raise AttributeError(name)
-
-    def set(self, name, instance, value, **kwargs):
-        user = instance.getUser()
-        sheets = user.getOrderedSheets()
-        for sheet in sheets:
-            if sheet.hasProperty(name):
-                if IMutablePropertySheet.providedBy(sheet):
-                    sheet.setProperty(name, value)
-                else:
-                    raise RuntimeError("mutable property provider shadowed by"
-                                       "read only provider")
diff --git a/setup.py b/setup.py
index acea2fb..3ff7d05 100644
--- a/setup.py
+++ b/setup.py
@@ -28,7 +28,6 @@
     zip_safe=False,
     install_requires=[
         'Products.CMFCore',
-        'Products.CMFDefault',
         'Products.GenericSetup',
         'Products.PluggableAuthService',
         'Zope2 > 2.13.22',
@@ -42,10 +41,6 @@
         test=[
             'plone.app.testing',
             'plone.testing',
-            'Products.Archetypes',
         ],
-        atstorage=[
-            'Products.Archetypes',
-        ]
     ),
 )


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:36:18+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/d5166c4017616cf3fb230df4f664cea4030e1b9b

require a zope suitable for plone5, but not a future one...

Files changed:
M setup.py

diff --git a/setup.py b/setup.py
index 3ff7d05..3c5cd2d 100644
--- a/setup.py
+++ b/setup.py
@@ -30,7 +30,7 @@
         'Products.CMFCore',
         'Products.GenericSetup',
         'Products.PluggableAuthService',
-        'Zope2 > 2.13.22',
+        'Zope2 >=2.13.22',
         'plone.i18n',
         'plone.memoize',
         'plone.session',


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:36:18+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/f399186eb88392f697474eb1b615c44a320279c9

remove dead code

Files changed:
M Products/PlonePAS/utils.py

diff --git a/Products/PlonePAS/utils.py b/Products/PlonePAS/utils.py
index c204a65..4a7d55c 100644
--- a/Products/PlonePAS/utils.py
+++ b/Products/PlonePAS/utils.py
@@ -13,13 +13,6 @@ def unique(iterable):
     return d.keys()
 
 
-# XXX this can probably be removed
-def getCharset(context):
-    """Returns the site default charset, or utf-8.
-    """
-    return 'utf-8'
-
-
 def cleanId(id):
     """'url_quote' turns strange chars into '%xx', which is not a valid char
     for ObjectManager. Here we encode '%' into '-' (and '-' into '--' as


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:36:18+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/6666fc914f97cf31ea476904383a57da4517a854

according to semantic versioning a major increase is needed.

Files changed:
M CHANGES.rst
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 69ace57..15ba44c 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -1,7 +1,7 @@
 Changelog
 =========
 
-5.1 (unreleased)
+6.0 (unreleased)
 ------------------
 
 - Removed (optional) Archetypes Storage (used in past with CMFMember, which
diff --git a/setup.py b/setup.py
index 3c5cd2d..f9c0a3d 100644
--- a/setup.py
+++ b/setup.py
@@ -2,7 +2,7 @@
 from setuptools import setup
 from setuptools import find_packages
 
-version = '5.0.1.dev0'
+version = '6.0.dev0'
 
 longdescription = open("README.rst").read()
 longdescription += '\n'
@@ -11,7 +11,7 @@
 setup(
     name='Products.PlonePAS',
     version=version,
-    description="PlonePAS adapts the PluggableAuthService for use by Plone.",
+    description="PlonePAS modifies the PluggableAuthService for use by Plone.",
     long_description=longdescription,
     classifiers=[
         "Framework :: Plone",


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:36:18+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/ac1ea2306cefd9b45b8c5a315e6c96a5c6b20b40

Make patching of LDAPMultiPlugin explizit. See also #5

Files changed:
M CHANGES.rst
M Products/PlonePAS/__init__.py
M Products/PlonePAS/ldapmp.py
M Products/PlonePAS/pas.py
M Products/PlonePAS/patch.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 15ba44c..8d42c4a 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,13 +4,18 @@ Changelog
 6.0 (unreleased)
 ------------------
 
+- Make patching of LDAPMultiPlugin explizit. Code using those must call
+  ``Products.PlonePAS.ldapmp.patch_ldapmp`` with no parameters in order
+  to activate the patches.
+  [jensens]
+
 - Removed (optional) Archetypes Storage (used in past with CMFMember, which
   itself was long time ago superseeded by Membrane). Probably dead code. If
   theres someone out there needing it in Plone 5 please copy the code from
   git/Plone4 in your addon/project.
   [jensens]
 
-- Moved ``Extensions/Install.py`` fucntions to setuphandlers, kept BBB import
+- Moved ``Extensions/Install.py`` functions to setuphandlers, kept BBB import
   for ``activatePluginInterfaces`` since this is imported by ``borg.localrole``.
   [jensens]
 
diff --git a/Products/PlonePAS/__init__.py b/Products/PlonePAS/__init__.py
index ba29fa7..46ebe11 100644
--- a/Products/PlonePAS/__init__.py
+++ b/Products/PlonePAS/__init__.py
@@ -1,8 +1,7 @@
 # -*- coding: utf-8 -*-
 from AccessControl.Permissions import add_user_folders
 from Products.CMFCore.utils import ToolInit
-from Products.PlonePAS import config
-from Products.PlonePAS import pas
+from Products.PlonePAS.pas import patch_pas
 from Products.PlonePAS.plugins import autogroup
 from Products.PlonePAS.plugins import cookie_handler
 from Products.PlonePAS.plugins import crumbler
@@ -19,21 +18,9 @@
 from Products.PlonePAS.tools.membership import MembershipTool
 from Products.PluggableAuthService import registerMultiPlugin
 
-#################################
-# ldapmp monkies if available
-# quite dirty, must be moved to PloneLDAP
-try:
-    from Products import LDAPMultiPlugins
-    from Products import LDAPUserFolder
-except ImportError:
-    pass
-else:
-    from Products.PlonePAS import  ldapmp
-
-
 ####################################
 # monkey patch pas, the evil happens
-pas.patch_all()
+patch_pas()
 
 #################################
 # new groups tool
diff --git a/Products/PlonePAS/ldapmp.py b/Products/PlonePAS/ldapmp.py
index 751bacb..dd25b1a 100644
--- a/Products/PlonePAS/ldapmp.py
+++ b/Products/PlonePAS/ldapmp.py
@@ -1,6 +1,4 @@
 # -*- coding: utf-8 -*-
-from Products.LDAPMultiPlugins.LDAPMultiPlugin import LDAPMultiPlugin
-from Products.LDAPMultiPlugins.LDAPPluginBase import LDAPPluginBase
 from Products.PlonePAS.patch import call
 from Products.PlonePAS.patch import wrap_method
 from Products.PlonePAS.plugins.group import PloneGroup
@@ -45,8 +43,6 @@ def getPropertiesForUser(self, user, request=None):
 
     return properties
 
-wrap_method(LDAPPluginBase, 'getPropertiesForUser', getPropertiesForUser)
-
 
 def getGroupsForPrincipal(self, user, request=None, attr=None):
     """ Fulfill GroupsPlugin requirements, but don't return any groups for
@@ -59,4 +55,18 @@ def getGroupsForPrincipal(self, user, request=None, attr=None):
 
     return ()
 
-wrap_method(LDAPMultiPlugin, 'getGroupsForPrincipal', getGroupsForPrincipal)
+
+def patch_ldapmp():
+    from Products.LDAPMultiPlugins.LDAPPluginBase import LDAPPluginBase
+    wrap_method(
+        LDAPPluginBase,
+        'getPropertiesForUser',
+        getPropertiesForUser
+    )
+
+    from Products.LDAPMultiPlugins.LDAPMultiPlugin import LDAPMultiPlugin
+    wrap_method(
+        LDAPMultiPlugin,
+        'getGroupsForPrincipal',
+        getGroupsForPrincipal
+    )
diff --git a/Products/PlonePAS/pas.py b/Products/PlonePAS/pas.py
index 51f8866..52ba319 100644
--- a/Products/PlonePAS/pas.py
+++ b/Products/PlonePAS/pas.py
@@ -500,7 +500,7 @@ def getUserNames(self):
     return results
 
 
-def patch_all():
+def patch_pas():
     # sort alphabetically by patched/added method name
     wrap_method(
         PluggableAuthService,
diff --git a/Products/PlonePAS/patch.py b/Products/PlonePAS/patch.py
index 5458676..0c95d31 100644
--- a/Products/PlonePAS/patch.py
+++ b/Products/PlonePAS/patch.py
@@ -63,6 +63,7 @@ def wrap_method(klass, name, method,
 
 
 def unwrap_method(klass, name):
+    # seems to be dead code, nowwhere used nor tested
     old_method = getattr(klass, name)
     if not isWrapperMethod(old_method):
         raise ValueError('Trying to unwrap non-wrapped '


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:36:18+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/aca38e3d7d94bce78e1c57ca3e6abd626a0a0946

removed superfluos

Files changed:
M Products/PlonePAS/config.py

diff --git a/Products/PlonePAS/config.py b/Products/PlonePAS/config.py
index 87c86cc..99ae0bc 100644
--- a/Products/PlonePAS/config.py
+++ b/Products/PlonePAS/config.py
@@ -2,8 +2,6 @@
 PROJECTNAME = 'PlonePAS'
 GLOBALS = globals()
 
-PAS_INSIDE_GRUF = False
-
 DEFAULT_CHALLENGE_PROTOCOL = ['http']
 DEFAULT_PROTO_MAPPING = {
     'WebDAV': DEFAULT_CHALLENGE_PROTOCOL,


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:36:18+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/085824dfc9b20883fc9b16318186f8eddfe5af58

overhaul README

Files changed:
M README.rst

diff --git a/README.rst b/README.rst
index 925cae2..41d0403 100644
--- a/README.rst
+++ b/README.rst
@@ -1,56 +1,52 @@
 Overview
 ========
 
-This product adapts the
-"PluggableAuthService":http://svn.zope.org/PluggableAuthService/
-for use by Plone.
-
-Notes
------
-
-Why doesn't the title of my group, that I set in the ZODB, show up?
-The title for a group comes from the properties plugin. The info
-in the groups plugin isn't used, except for the name.
-
-The value of the 'title' property on the portal_groupdata or
-portal_memberdata tools themselves (as opposed to the group or
-member data records within them) will not be used as a default for
-the title of the group or member. This is to prevent UI confusion if
-a title is set without realizing the implications. To remove this
-special case, see 'plugins.property._getDefaultValues'.
-
-If PAS caching is enabled (see the "Cache" tab) and the cache
-manager does not have a 'cleanup' method (RAMCacheManager has one),
-then changes to the memberdata schema will not effect users already
-cached. In this case, restart the server or clear the cache (if
-possible) for the changes to take effect.
-
-Similarly, changes to the memberdata schema will not propagate to
-member objects already in use. If you have a memberdata object and
-change the memberdata properties you must re-construct the member by
-saying portal_membership.getMemberById again.  See
-'tests.test_properties.test_user_properties' for example.
-
-By default, logout from users signed in under HTTP Basic Auth cannot
-log out.  If you enable the "Credentials Reset" plugin for the HTTP
-Basic plugin, the logout for cookies will no longer work. However,
-this is not a problem if you're not using cookies.
-
-Implementation
---------------
-
-In some places, PlonePAS acts as an adaptor to make PAS provide
-enough of GRUF's interface to satisfy Plone. All the monkey patches
-in pas.py, for instance, extend PAS with expected methods.
-
-PlonePAS also modifies Plone to work with PAS by providing
-partially-new implementations of several tools.  In the tools/
-directory you can see new tools for groups and members, as well as
-the utils tool.
-
-It also provides extra capabilities for PAS needed by plone, such as
-mutable property sheets, local role calculation, creation of group
-objects, and more.
+This product extends "PluggableAuthService":http://svn.zope.org/PluggableAuthService/ (PAS) for use in Plone.
+
+It adds
+
+- group support
+- auto group assignment
+- support for mutable properties
+- cookie based login
+- local role support
+- password policy support
+- enhanced user objects
+- enhanced cmf tools (groups, members)
+- simple passwordpolicy
+- new event for users initial log in
+
+PlonePAS also adds the API of the old GroupUserFolder (GRUF) to PAS.
+GRUF was used in Plone 2.5.x and earlier as the default user folder.
+
+Lots of this changes are done with monkey patches to PAS itself.
+This is not ideal, but was done in past this way, even if we now would do it better.
+
+PlonePAS does not depend on Plone itself, just on Zope2, PAS and CMF and some low level libraries.
+
+FAQ
+---
+
+Why doesn't the title of my group, that I set in the ZMI, show up?
+    The title for a group comes from the properties plugin.
+    The info in the groups plugin isn't used, except for the name.
+
+    The value of the ``title``property on the ``portal_groupdata`` or ``portal_memberdata tools`` themselves (as opposed to the group or member data records within them) will not be used as a default for the title of the group or member.
+    This is to prevent UI confusion if a title is set without realizing the implications.
+    To remove this special case, see ``plugins.property._getDefaultValues``.
+
+Why are my schema changes ignored?
+    If PAS caching is enabled (see the ``Cache`` tab) and the cache manager does not have a *cleanup* method (RAMCacheManager has one), then changes to the memberdata schema will not effect users already cached.
+    In this case, restart the server or clear the cache (if possible) for the changes to take effect.
+
+    Similarly, changes to the memberdata schema will not propagate to member objects already in use.
+    If you have a memberdata object and change the memberdata properties you must re-construct the member by saying ``portal_membership.getMemberById`` again.
+    See ``tests.test_properties.test_user_properties`` for example.
+
+Why can't I logout?
+    By default, logout from users signed in under HTTP Basic Auth cannot log out.
+    If you enable the ``Credentials Reset`` plugin for the HTTP Basic plugin, the logout for cookies will no longer work.
+    However, this is not a problem if you're not using cookies.
 
 Authorship
 ----------
@@ -58,17 +54,27 @@ Authorship
 Initial creation: The PAS CIGNEX Sprint Team [ Anders, Bob, Ben,
 Chad, Gautham, Joel, Kapil, Michel, Micheal ]
 
-Post-sprint work: J Cameron Cooper, Leo, Sidnei, Mark at "Enfold
-Systems":http://enfoldsystems.com
+Post-sprint work: J Cameron Cooper, Leo, Sidnei, Mark at `Enfold
+Systems <http://enfoldsystems.com>`_
 
 Basic setAuthCookie support (to mimick CookieCrumbler):
-Rocky Burt at "ServerZen Software":http://www.serverzen.com
+Rocky Burt at `ServerZen Software <http://www.serverzen.com>`_
 
 Synced login process with Plone:
-Dorneles Tremea at "PloneSolutions":http://plonesolutions.com
+Dorneles Tremea at `PloneSolutions <http://plonesolutions.com>`_
 
 Bugfixes, various development and merging with Plone:
 Wichert Akkerman at Simplon
 
 Bugfixes, improvements to membership and property lookups:
 Eric Steele and Erik Rose
+
+Review, cleanup, modernize code, adressing Plone 5:
+Jens Klein, BlueDynamics Alliance - `Klein & Partner KG <http://kleinundpartner.at>`_
+
+Source Code
+===========
+
+Contributors please read the document `Process for Plone core's development <http://docs.plone.org/develop/plone-coredev/index.html>`_
+
+Sources are at the `Plone code repository hosted at Github <https://github.com/plone/Products.PlonePAS>`_.


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:36:18+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/2357947787a663ecc80bee8c8aad9eab6c99e390

increase chapter level

Files changed:
M README.rst

diff --git a/README.rst b/README.rst
index 41d0403..ced3638 100644
--- a/README.rst
+++ b/README.rst
@@ -73,7 +73,7 @@ Review, cleanup, modernize code, adressing Plone 5:
 Jens Klein, BlueDynamics Alliance - `Klein & Partner KG <http://kleinundpartner.at>`_
 
 Source Code
-===========
+-----------
 
 Contributors please read the document `Process for Plone core's development <http://docs.plone.org/develop/plone-coredev/index.html>`_
 


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:36:18+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/930e1dc14ecb938ab156748ac0cca8b4c5bf4d62

prepare to test isolated with travis as well

Files changed:
A .travis.yml
A travis.cfg
M .gitignore
M setup.py

diff --git a/.gitignore b/.gitignore
index 937f590..d9b87c1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,11 +1,19 @@
 *.pyc
-/bin/
+/bin
+/devsrc/
 /parts/
 /var/
 /*.egg-info
+.mrsd
 /*eggs/
 .*.cfg
 /coverage/
 /.project
 /.pydevproject
 /.settings/
+/local/
+/lib/
+/include/
+/dist/
+/.Python
+/buildout-cache/
diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 0000000..875913a
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,7 @@
+language: python
+python: 2.7
+install:
+  - mkdir -p buildout-cache/downloads
+  - pip install zc.buildout
+  - buildout -c travis.cfg -N -q -t 3
+script: bin/test
diff --git a/setup.py b/setup.py
index f9c0a3d..c7da31c 100644
--- a/setup.py
+++ b/setup.py
@@ -24,7 +24,7 @@
     license='ZPL',
     packages=find_packages(exclude=['ez_setup']),
     namespace_packages=['Products'],
-    clude_package_data=True,
+    include_package_data=True,
     zip_safe=False,
     install_requires=[
         'Products.CMFCore',
diff --git a/travis.cfg b/travis.cfg
new file mode 100644
index 0000000..2330dff
--- /dev/null
+++ b/travis.cfg
@@ -0,0 +1,11 @@
+[buildout]
+extends =
+    https://raw.githubusercontent.com/collective/buildout.plonetest/master/qa.cfg
+    https://raw.githubusercontent.com/collective/buildout.plonetest/master/travis-5.x.cfg
+
+package-name = Products.PlonePAS
+package-extras = [test]
+
+[versions]
+setuptools =
+zc.buildout =


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:44:14+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/f39c848ebd8070567b28dc7614e2cf795b20af92

add src directory and move Products into it to make qa.cfg defaults happy

Files changed:
A src/Products/PlonePAS/Extensions/Install.py
A src/Products/PlonePAS/Extensions/__init__.py
A src/Products/PlonePAS/__init__.py
A src/Products/PlonePAS/browser/__init__.py
A src/Products/PlonePAS/browser/configure.zcml
A src/Products/PlonePAS/browser/info.py
A src/Products/PlonePAS/browser/member.py
A src/Products/PlonePAS/browser/search.py
A src/Products/PlonePAS/config.py
A src/Products/PlonePAS/configure.zcml
A src/Products/PlonePAS/events.py
A src/Products/PlonePAS/exportimport.zcml
A src/Products/PlonePAS/interfaces/__init__.py
A src/Products/PlonePAS/interfaces/browser.py
A src/Products/PlonePAS/interfaces/capabilities.py
A src/Products/PlonePAS/interfaces/events.py
A src/Products/PlonePAS/interfaces/group.py
A src/Products/PlonePAS/interfaces/membership.py
A src/Products/PlonePAS/interfaces/plugins.py
A src/Products/PlonePAS/interfaces/propertysheets.py
A src/Products/PlonePAS/ldapmp.py
A src/Products/PlonePAS/pas.py
A src/Products/PlonePAS/patch.py
A src/Products/PlonePAS/permissions.py
A src/Products/PlonePAS/plugins/__init__.py
A src/Products/PlonePAS/plugins/autogroup.py
A src/Products/PlonePAS/plugins/cookie_handler.py
A src/Products/PlonePAS/plugins/crumbler.py
A src/Products/PlonePAS/plugins/group.py
A src/Products/PlonePAS/plugins/local_role.py
A src/Products/PlonePAS/plugins/passwordpolicy.py
A src/Products/PlonePAS/plugins/property.py
A src/Products/PlonePAS/plugins/role.py
A src/Products/PlonePAS/plugins/ufactory.py
A src/Products/PlonePAS/plugins/user.py
A src/Products/PlonePAS/profiles.zcml
A src/Products/PlonePAS/profiles/default/metadata.xml
A src/Products/PlonePAS/profiles/default/plone-pas.txt
A src/Products/PlonePAS/setuphandlers.py
A src/Products/PlonePAS/sheet.py
A src/Products/PlonePAS/tests/__init__.py
A src/Products/PlonePAS/tests/base.py
A src/Products/PlonePAS/tests/cookie_auth.rst
A src/Products/PlonePAS/tests/dummy.py
A src/Products/PlonePAS/tests/images/test.gif
A src/Products/PlonePAS/tests/images/test.jpg
A src/Products/PlonePAS/tests/images/test.png
A src/Products/PlonePAS/tests/test_basic_ops.py
A src/Products/PlonePAS/tests/test_doctests.py
A src/Products/PlonePAS/tests/test_groupdatatool.py
A src/Products/PlonePAS/tests/test_groupstool.py
A src/Products/PlonePAS/tests/test_memberdatatool.py
A src/Products/PlonePAS/tests/test_membershiptool.py
A src/Products/PlonePAS/tests/test_properties.py
A src/Products/PlonePAS/tests/test_role_plugin.py
A src/Products/PlonePAS/tests/test_views.py
A src/Products/PlonePAS/tool.gif
A src/Products/PlonePAS/tools/__init__.py
A src/Products/PlonePAS/tools/groupdata.py
A src/Products/PlonePAS/tools/groups.py
A src/Products/PlonePAS/tools/memberdata.py
A src/Products/PlonePAS/tools/membership.py
A src/Products/PlonePAS/tools/plonetool.py
A src/Products/PlonePAS/utils.py
A src/Products/PlonePAS/zmi/AutoGroupForm.zpt
A src/Products/PlonePAS/zmi/CookieCrumblingPluginForm.dtml
A src/Products/PlonePAS/zmi/ExtendedCookieAuthHelperForm.dtml
A src/Products/PlonePAS/zmi/GroupAwareRoleManagerForm.dtml
A src/Products/PlonePAS/zmi/GroupManagerForm.dtml
A src/Products/PlonePAS/zmi/LocalRolesManagerForm.dtml
A src/Products/PlonePAS/zmi/MutablePropertyProviderForm.dtml
A src/Products/PlonePAS/zmi/PasswordPolicyForm.zpt
A src/Products/PlonePAS/zmi/PloneUserFactoryForm.dtml
A src/Products/PlonePAS/zmi/UserManagerForm.dtml
A src/Products/PlonePAS/zmi/membershipRolemapping.dtml
A src/Products/PlonePAS/zmi/portrait_fix.dtml
A src/Products/__init__.py
M .gitignore
M CHANGES.rst
M setup.py
D Products/PlonePAS/Extensions/Install.py
D Products/PlonePAS/Extensions/__init__.py
D Products/PlonePAS/__init__.py
D Products/PlonePAS/browser/__init__.py
D Products/PlonePAS/browser/configure.zcml
D Products/PlonePAS/browser/info.py
D Products/PlonePAS/browser/member.py
D Products/PlonePAS/browser/search.py
D Products/PlonePAS/config.py
D Products/PlonePAS/configure.zcml
D Products/PlonePAS/events.py
D Products/PlonePAS/exportimport.zcml
D Products/PlonePAS/interfaces/__init__.py
D Products/PlonePAS/interfaces/browser.py
D Products/PlonePAS/interfaces/capabilities.py
D Products/PlonePAS/interfaces/events.py
D Products/PlonePAS/interfaces/group.py
D Products/PlonePAS/interfaces/membership.py
D Products/PlonePAS/interfaces/plugins.py
D Products/PlonePAS/interfaces/propertysheets.py
D Products/PlonePAS/ldapmp.py
D Products/PlonePAS/pas.py
D Products/PlonePAS/patch.py
D Products/PlonePAS/permissions.py
D Products/PlonePAS/plugins/__init__.py
D Products/PlonePAS/plugins/autogroup.py
D Products/PlonePAS/plugins/cookie_handler.py
D Products/PlonePAS/plugins/crumbler.py
D Products/PlonePAS/plugins/group.py
D Products/PlonePAS/plugins/local_role.py
D Products/PlonePAS/plugins/passwordpolicy.py
D Products/PlonePAS/plugins/property.py
D Products/PlonePAS/plugins/role.py
D Products/PlonePAS/plugins/ufactory.py
D Products/PlonePAS/plugins/user.py
D Products/PlonePAS/profiles.zcml
D Products/PlonePAS/profiles/default/metadata.xml
D Products/PlonePAS/profiles/default/plone-pas.txt
D Products/PlonePAS/setuphandlers.py
D Products/PlonePAS/sheet.py
D Products/PlonePAS/tests/__init__.py
D Products/PlonePAS/tests/base.py
D Products/PlonePAS/tests/cookie_auth.rst
D Products/PlonePAS/tests/dummy.py
D Products/PlonePAS/tests/images/test.gif
D Products/PlonePAS/tests/images/test.jpg
D Products/PlonePAS/tests/images/test.png
D Products/PlonePAS/tests/test_basic_ops.py
D Products/PlonePAS/tests/test_doctests.py
D Products/PlonePAS/tests/test_groupdatatool.py
D Products/PlonePAS/tests/test_groupstool.py
D Products/PlonePAS/tests/test_memberdatatool.py
D Products/PlonePAS/tests/test_membershiptool.py
D Products/PlonePAS/tests/test_properties.py
D Products/PlonePAS/tests/test_role_plugin.py
D Products/PlonePAS/tests/test_views.py
D Products/PlonePAS/tool.gif
D Products/PlonePAS/tools/__init__.py
D Products/PlonePAS/tools/groupdata.py
D Products/PlonePAS/tools/groups.py
D Products/PlonePAS/tools/memberdata.py
D Products/PlonePAS/tools/membership.py
D Products/PlonePAS/tools/plonetool.py
D Products/PlonePAS/utils.py
D Products/PlonePAS/zmi/AutoGroupForm.zpt
D Products/PlonePAS/zmi/CookieCrumblingPluginForm.dtml
D Products/PlonePAS/zmi/ExtendedCookieAuthHelperForm.dtml
D Products/PlonePAS/zmi/GroupAwareRoleManagerForm.dtml
D Products/PlonePAS/zmi/GroupManagerForm.dtml
D Products/PlonePAS/zmi/LocalRolesManagerForm.dtml
D Products/PlonePAS/zmi/MutablePropertyProviderForm.dtml
D Products/PlonePAS/zmi/PasswordPolicyForm.zpt
D Products/PlonePAS/zmi/PloneUserFactoryForm.dtml
D Products/PlonePAS/zmi/UserManagerForm.dtml
D Products/PlonePAS/zmi/membershipRolemapping.dtml
D Products/PlonePAS/zmi/portrait_fix.dtml
D Products/__init__.py

diff --git a/.gitignore b/.gitignore
index d9b87c1..0c6cba1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,7 +3,7 @@
 /devsrc/
 /parts/
 /var/
-/*.egg-info
+/src/*.egg-info
 .mrsd
 /*eggs/
 .*.cfg
diff --git a/CHANGES.rst b/CHANGES.rst
index 8d42c4a..271f321 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,6 +4,11 @@ Changelog
 6.0 (unreleased)
 ------------------
 
+- Add a integrated test setup with codeanalysis and travis. For this moved
+  ``Products`` folder to a ``src`` folder in order to follow the package
+  structure expected by ``buildout.plonetest``'s ``qa.cfg``.
+  [jensens]
+
 - Make patching of LDAPMultiPlugin explizit. Code using those must call
   ``Products.PlonePAS.ldapmp.patch_ldapmp`` with no parameters in order
   to activate the patches.
diff --git a/Products/PlonePAS/Extensions/Install.py b/Products/PlonePAS/Extensions/Install.py
deleted file mode 100644
index 3f02911..0000000
--- a/Products/PlonePAS/Extensions/Install.py
+++ /dev/null
@@ -1,18 +0,0 @@
-# -*- coding: utf-8 -*-
-# BBB
-
-# imported at least by borg.localrole.utils
-from Products.PlonePAS.setuphandlers import activatePluginInterfaces  # noqa
-
-# used by plone.app.upgrade/plone/app/upgrade/v43/final.py
-from Products.PlonePAS.setuphandlers import setupPasswordPolicyPlugin  # noqa
-
-# seems this is not needed anywhere outside setuphandlers
-# from Products.PlonePAS.setuphandlers import setupRoles
-# from Products.PlonePAS.setuphandlers import registerPluginType
-# from Products.PlonePAS.setuphandlers import registerPluginTypes
-# from Products.PlonePAS.setuphandlers import setupAuthPlugins
-# from Products.PlonePAS.setuphandlers import updateProperties
-# from Products.PlonePAS.setuphandlers import updateProp
-# from Products.PlonePAS.setuphandlers import addPAS
-# from Products.PlonePAS.setuphandlers import challenge_chooser_setup
diff --git a/Products/PlonePAS/Extensions/__init__.py b/Products/PlonePAS/Extensions/__init__.py
deleted file mode 100644
index 691ba77..0000000
--- a/Products/PlonePAS/Extensions/__init__.py
+++ /dev/null
@@ -1 +0,0 @@
-# poof!
diff --git a/Products/PlonePAS/__init__.py b/Products/PlonePAS/__init__.py
deleted file mode 100644
index 46ebe11..0000000
--- a/Products/PlonePAS/__init__.py
+++ /dev/null
@@ -1,146 +0,0 @@
-# -*- coding: utf-8 -*-
-from AccessControl.Permissions import add_user_folders
-from Products.CMFCore.utils import ToolInit
-from Products.PlonePAS.pas import patch_pas
-from Products.PlonePAS.plugins import autogroup
-from Products.PlonePAS.plugins import cookie_handler
-from Products.PlonePAS.plugins import crumbler
-from Products.PlonePAS.plugins import group
-from Products.PlonePAS.plugins import local_role
-from Products.PlonePAS.plugins import passwordpolicy
-from Products.PlonePAS.plugins import property
-from Products.PlonePAS.plugins import role
-from Products.PlonePAS.plugins import ufactory
-from Products.PlonePAS.plugins import user
-from Products.PlonePAS.tools.groupdata import GroupDataTool
-from Products.PlonePAS.tools.groups import GroupsTool
-from Products.PlonePAS.tools.memberdata import MemberDataTool
-from Products.PlonePAS.tools.membership import MembershipTool
-from Products.PluggableAuthService import registerMultiPlugin
-
-####################################
-# monkey patch pas, the evil happens
-patch_pas()
-
-#################################
-# new groups tool
-
-#################################
-# register plugins with pas
-try:
-    registerMultiPlugin(user.UserManager.meta_type)
-    registerMultiPlugin(group.GroupManager.meta_type)
-    registerMultiPlugin(role.GroupAwareRoleManager.meta_type)
-    registerMultiPlugin(local_role.LocalRolesManager.meta_type)
-    registerMultiPlugin(ufactory.PloneUserFactory.meta_type)
-    registerMultiPlugin(property.ZODBMutablePropertyProvider.meta_type)
-    registerMultiPlugin(crumbler.CookieCrumblingPlugin.meta_type)
-    registerMultiPlugin(cookie_handler.ExtendedCookieAuthHelper.meta_type)
-    registerMultiPlugin(autogroup.AutoGroup.meta_type)
-    registerMultiPlugin(passwordpolicy.PasswordPolicyPlugin.meta_type)
-except RuntimeError:
-    # make refresh users happy
-    pass
-
-
-def initialize(context):
-
-    tools = (GroupsTool, GroupDataTool, MembershipTool, MemberDataTool)
-
-    ToolInit(
-        'PlonePAS Tool',
-        tools=tools,
-        icon='tool.gif',
-    ).initialize(context)
-
-    context.registerClass(
-        role.GroupAwareRoleManager,
-        permission=add_user_folders,
-        constructors=(
-            role.manage_addGroupAwareRoleManagerForm,
-            role.manage_addGroupAwareRoleManager),
-        visibility=None
-    )
-
-    context.registerClass(
-        user.UserManager,
-        permission=add_user_folders,
-        constructors=(
-            user.manage_addUserManagerForm,
-            user.manage_addUserManager),
-        visibility=None
-    )
-
-    context.registerClass(
-        group.GroupManager,
-        permission=add_user_folders,
-        constructors=(
-            group.manage_addGroupManagerForm,
-            group.manage_addGroupManager
-        ),
-        visibility=None
-    )
-
-    context.registerClass(
-        ufactory.PloneUserFactory,
-        permission=add_user_folders,
-        constructors=(
-            ufactory.manage_addPloneUserFactoryForm,
-            ufactory.manage_addPloneUserFactory),
-        visibility=None
-    )
-
-    context.registerClass(
-        local_role.LocalRolesManager,
-        permission=add_user_folders,
-        constructors=(
-            local_role.manage_addLocalRolesManagerForm,
-            local_role.manage_addLocalRolesManager),
-        visibility=None
-    )
-
-    context.registerClass(
-        property.ZODBMutablePropertyProvider,
-        permission=add_user_folders,
-        constructors=(
-            property.manage_addZODBMutablePropertyProviderForm,
-            property.manage_addZODBMutablePropertyProvider),
-        visibility=None
-    )
-
-    context.registerClass(
-        crumbler.CookieCrumblingPlugin,
-        permission=add_user_folders,
-        constructors=(
-            crumbler.manage_addCookieCrumblingPluginForm,
-            crumbler.manage_addCookieCrumblingPlugin),
-        visibility=None
-    )
-
-    context.registerClass(
-        cookie_handler.ExtendedCookieAuthHelper,
-        permission=add_user_folders,
-        constructors=(
-            cookie_handler.manage_addExtendedCookieAuthHelperForm,
-            cookie_handler.manage_addExtendedCookieAuthHelper),
-        visibility=None
-    )
-
-    context.registerClass(
-        autogroup.AutoGroup,
-        permission=add_user_folders,
-        constructors=(
-            autogroup.manage_addAutoGroupForm,
-            autogroup.manage_addAutoGroup),
-        visibility=None
-    )
-
-    context.registerClass(
-        passwordpolicy.PasswordPolicyPlugin,
-        permission=add_user_folders,
-        constructors=(
-            passwordpolicy.manage_addPasswordPolicyForm,
-            passwordpolicy.manage_addPasswordPolicyPlugin
-        ),
-        visibility=None
-    )
diff --git a/Products/PlonePAS/browser/__init__.py b/Products/PlonePAS/browser/__init__.py
deleted file mode 100644
index 792d600..0000000
--- a/Products/PlonePAS/browser/__init__.py
+++ /dev/null
@@ -1 +0,0 @@
-#
diff --git a/Products/PlonePAS/browser/configure.zcml b/Products/PlonePAS/browser/configure.zcml
deleted file mode 100644
index f8e6749..0000000
--- a/Products/PlonePAS/browser/configure.zcml
+++ /dev/null
@@ -1,36 +0,0 @@
-<configure
-    i18n_domain="Five"
-    xmlns="http://namespaces.zope.org/zope"
-    xmlns:browser="http://namespaces.zope.org/browser"
-    xmlns:five="http://namespaces.zope.org/five">
-
-  <permission
-      id="PAS.SearchPrincipals"
-      title="Search for principals"
-  />
-
-  <browser:page
-      allowed_interface="Products.PlonePAS.interfaces.browser.IPASInfoView"
-      class=".info.PASInfoView"
-      for="*"
-      name="pas_info"
-      permission="zope2.View"
-  />
-
-  <browser:page
-      allowed_interface="Products.PlonePAS.interfaces.browser.IPASMemberView"
-      class=".member.PASMemberView"
-      for="*"
-      name="pas_member"
-      permission="zope2.View"
-  />
-
-  <browser:page
-      allowed_interface="Products.PlonePAS.interfaces.browser.IPASSearchView"
-      class=".search.PASSearchView"
-      for="*"
-      name="pas_search"
-      permission="zope2.View"
-  />
-
-</configure>
diff --git a/Products/PlonePAS/browser/info.py b/Products/PlonePAS/browser/info.py
deleted file mode 100644
index 353228f..0000000
--- a/Products/PlonePAS/browser/info.py
+++ /dev/null
@@ -1,41 +0,0 @@
-# -*- coding: utf-8 -*-
-from zope.interface import implementer
-from plone.memoize.instance import memoize
-from Acquisition import aq_inner
-from Products.PlonePAS.interfaces.browser import IPASInfoView
-from Products.PluggableAuthService.interfaces.plugins import IExtractionPlugin
-from Products.PluggableAuthService.interfaces.plugins \
-    import ILoginPasswordExtractionPlugin
-from Products.CMFCore.utils import getToolByName
-from Products.Five import BrowserView
-
-
-@implementer(IPASInfoView)
-class PASInfoView(BrowserView):
-
-    def checkExtractorForInterface(self, interface):
-        acl = getToolByName(aq_inner(self.context), "acl_users")
-        plugins = acl.plugins.listPlugins(IExtractionPlugin)
-
-        for plugin in plugins:
-            if interface.providedBy(plugin[1]):
-                return True
-
-        return False
-
-    @memoize
-    def hasLoginPasswordExtractor(self):
-        return self.checkExtractorForInterface(ILoginPasswordExtractionPlugin)
-
-    @memoize
-    def hasOpenIDExtractor(self):
-        try:
-            from plone.openid.interfaces import IOpenIdExtractionPlugin
-        except ImportError:
-            return False
-
-        return self.checkExtractorForInterface(IOpenIdExtractionPlugin)
-
-    def hasOpenIDdExtractor(self):
-        # BBB Keeping method name with typo for backwards compatibility.
-        return self.hasOpenIDExtractor()
diff --git a/Products/PlonePAS/browser/member.py b/Products/PlonePAS/browser/member.py
deleted file mode 100644
index b0fcfa6..0000000
--- a/Products/PlonePAS/browser/member.py
+++ /dev/null
@@ -1,29 +0,0 @@
-# -*- coding: utf-8 -*-
-from Products.CMFCore.utils import getToolByName
-from Products.PlonePAS.interfaces.browser import IPASMemberView
-from plone.memoize.instance import memoize
-from zope.interface import implementer
-from zope.publisher.browser import BrowserView
-
-
-@implementer(IPASMemberView)
-class PASMemberView(BrowserView):
-
-    @memoize
-    def info(self, userid=None):
-        pm = getToolByName(self.context, 'portal_membership')
-        result = pm.getMemberInfo(memberId=userid)
-        if result is None:
-            # No such member: removed?  We return something useful anyway.
-            return {
-                'username': userid,
-                'description': '',
-                'language': '',
-                'home_page': '',
-                'name_or_id': userid,
-                'location': '',
-                'fullname': ''
-            }
-        result['name_or_id'] = result.get('fullname') or \
-            result.get('username') or userid
-        return result
diff --git a/Products/PlonePAS/browser/search.py b/Products/PlonePAS/browser/search.py
deleted file mode 100644
index b2d0b00..0000000
--- a/Products/PlonePAS/browser/search.py
+++ /dev/null
@@ -1,76 +0,0 @@
-# -*- coding: utf-8 -*-
-from Products.CMFCore.utils import getToolByName
-from Products.Five import BrowserView
-from Products.PlonePAS.interfaces.browser import IPASSearchView
-from plone.i18n.normalizer.interfaces import IIDNormalizer
-from zope.component import queryUtility
-from zope.interface import implementer
-
-
-@implementer(IPASSearchView)
-class PASSearchView(BrowserView):
-
-    @staticmethod
-    def extractCriteriaFromRequest(request):
-        criteria = request.form.copy()
-
-        for key in ["form.submitted", "submit", 'b_start', 'b_size']:
-            if key in criteria:
-                del criteria[key]
-
-        for (key, value) in criteria.items():
-            if not value:
-                del criteria[key]
-
-        return criteria
-
-    @staticmethod
-    def merge(results, key):
-        output = {}
-        for entry in results:
-            id = entry[key]
-            if id not in output:
-                output[id] = entry.copy()
-            else:
-                buf = entry.copy()
-                buf.update(output[id])
-                output[id] = buf
-
-        return output.values()
-
-    def sort(self, results, sort_key):
-        idnormalizer = queryUtility(IIDNormalizer)
-
-        def key_func(a):
-            return idnormalizer.normalize(a.get(sort_key, a))
-        return sorted(results, key=key_func)
-
-    def searchUsers(self, sort_by=None, **criteria):
-        self.pas = getToolByName(self.context, "acl_users")
-        results = self.merge(self.pas.searchUsers(**criteria), "userid")
-        if sort_by is not None:
-            results = self.sort(results, sort_by)
-        return results
-
-    def searchUsersByRequest(self, request, sort_by=None):
-        criteria = self.extractCriteriaFromRequest(request)
-        return self.searchUsers(sort_by=sort_by, **criteria)
-
-    def searchGroups(self, sort_by=None, **criteria):
-        self.pas = getToolByName(self.context, "acl_users")
-        results = self.merge(self.pas.searchGroups(**criteria), "groupid")
-        if sort_by is not None:
-            results = self.sort(results, sort_by)
-        return results
-
-    def searchGroupsByRequest(self, request):
-        criteria = self.extractCriteriaFromRequest(request)
-        return self.searchGroups(**criteria)
-
-    def getPhysicalPath(self):
-        # We call various PAS methods which can be ZCached. The ZCache
-        # infrastructure relies on getPhysicalPath on the context being
-        # available, which this view does not have, it not being a
-        # persistent object. So we fake things and return the physical path
-        # for our context.
-        return self.context.getPhysicalPath()
diff --git a/Products/PlonePAS/config.py b/Products/PlonePAS/config.py
deleted file mode 100644
index 99ae0bc..0000000
--- a/Products/PlonePAS/config.py
+++ /dev/null
@@ -1,28 +0,0 @@
-# -*- coding: utf-8 -*-
-PROJECTNAME = 'PlonePAS'
-GLOBALS = globals()
-
-DEFAULT_CHALLENGE_PROTOCOL = ['http']
-DEFAULT_PROTO_MAPPING = {
-    'WebDAV': DEFAULT_CHALLENGE_PROTOCOL,
-    'FTP': DEFAULT_CHALLENGE_PROTOCOL,
-    'XML-RPC': DEFAULT_CHALLENGE_PROTOCOL
-}
-
-# Settings for member image resize quality
-HAS_PIL = True
-try:
-    from PIL import Image
-    PIL_SCALING_ALGO = Image.ANTIALIAS
-except ImportError:
-    PIL_SCALING_ALGO = None
-    HAS_PIL = False
-
-PIL_QUALITY = 88
-MEMBER_IMAGE_SCALE = (75, 100)
-IMAGE_SCALE_PARAMS = {
-    'scale': MEMBER_IMAGE_SCALE,
-    'quality': PIL_QUALITY,
-    'algorithm': PIL_SCALING_ALGO,
-    'default_format': 'PNG'
-}
diff --git a/Products/PlonePAS/configure.zcml b/Products/PlonePAS/configure.zcml
deleted file mode 100644
index f326d9e..0000000
--- a/Products/PlonePAS/configure.zcml
+++ /dev/null
@@ -1,26 +0,0 @@
-<configure
-    i18n_domain="plone"
-    xmlns="http://namespaces.zope.org/zope"
-    xmlns:five="http://namespaces.zope.org/five"
-    xmlns:genericsetup="http://namespaces.zope.org/genericsetup"
-    xmlns:i18n="http://namespaces.zope.org/i18n">
-
-  <include package=".browser" />
-  <include file="profiles.zcml" />
-  <include file="exportimport.zcml" />
-
-  <genericsetup:importStep
-      description="Configure PlonePas"
-      handler="Products.PlonePAS.setuphandlers.setupPlonePAS"
-      name="plonepas"
-      title="PlonePAS setup">
-    <depends name="componentregistry" />
-    <depends name="controlpanel" />
-    <depends name="memberdata-properties" />
-    <depends name="rolemap" />
-  </genericsetup:importStep>
-
-  <five:deprecatedManageAddDelete class=".plugins.cookie_handler.ExtendedCookieAuthHelper" />
-  <five:deprecatedManageAddDelete class=".plugins.role.GroupAwareRoleManager" />
-
-</configure>
diff --git a/Products/PlonePAS/events.py b/Products/PlonePAS/events.py
deleted file mode 100644
index 79c2433..0000000
--- a/Products/PlonePAS/events.py
+++ /dev/null
@@ -1,30 +0,0 @@
-# -*- coding: utf-8 -*-
-from Products.PlonePAS.interfaces.events import IUserInitialLoginInEvent
-from Products.PluggableAuthService.events import PASEvent
-from Products.PluggableAuthService.interfaces.events import IUserLoggedInEvent
-from Products.PluggableAuthService.interfaces.events import IUserLoggedOutEvent
-from zope.interface import implementer
-
-
-@implementer(IUserLoggedInEvent)
-class UserLoggedInEvent(PASEvent):
-    """Plone Implementation of the logged in event
-
-    PAS Event
-    """
-
-
-@implementer(IUserInitialLoginInEvent)
-class UserInitialLoginInEvent(UserLoggedInEvent):
-    """Implementation of the initial logged in event
-
-    Plone only event!
-    """
-
-
-@implementer(IUserLoggedOutEvent)
-class UserLoggedOutEvent(PASEvent):
-    """Plone Implementation of the logged out event
-
-    PAS Event
-    """
diff --git a/Products/PlonePAS/exportimport.zcml b/Products/PlonePAS/exportimport.zcml
deleted file mode 100644
index ae6fa67..0000000
--- a/Products/PlonePAS/exportimport.zcml
+++ /dev/null
@@ -1,26 +0,0 @@
-<configure xmlns="http://namespaces.zope.org/zope">
-
-  <adapter
-      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
-      for="Products.PluggableAuthService.interfaces.plugins.IUserFactoryPlugin"
-      provides="Products.GenericSetup.interfaces.IFilesystemExporter"
-  />
-  <adapter
-      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
-      for="Products.PluggableAuthService.interfaces.plugins.IUserFactoryPlugin"
-      provides="Products.GenericSetup.interfaces.IFilesystemImporter"
-  />
-
-  <!-- XXX This should point to an own export/import class! TitleOnly is far not enough -->
-  <adapter
-      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
-      for="Products.PlonePAS.interfaces.plugins.IMutablePropertiesPlugin"
-      provides="Products.GenericSetup.interfaces.IFilesystemExporter"
-  />
-  <adapter
-      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
-      for="Products.PlonePAS.interfaces.plugins.IMutablePropertiesPlugin"
-      provides="Products.GenericSetup.interfaces.IFilesystemImporter"
-  />
-
-</configure>
diff --git a/Products/PlonePAS/interfaces/__init__.py b/Products/PlonePAS/interfaces/__init__.py
deleted file mode 100644
index 40a96af..0000000
--- a/Products/PlonePAS/interfaces/__init__.py
+++ /dev/null
@@ -1 +0,0 @@
-# -*- coding: utf-8 -*-
diff --git a/Products/PlonePAS/interfaces/browser.py b/Products/PlonePAS/interfaces/browser.py
deleted file mode 100644
index 6f2b5cb..0000000
--- a/Products/PlonePAS/interfaces/browser.py
+++ /dev/null
@@ -1,89 +0,0 @@
-# -*- coding: utf-8 -*-
-from zope.interface import Interface
-
-
-class IPASInfoView(Interface):
-
-    def hasLoginPasswordExtractor():
-        """Check if a login & password extraction plugin is active.
-
-        Check if there is a plugin with an enabled
-        ILoginPasswordExtractionPlugin interface. This can be used to
-        conditionally show username & password logins.
-        """
-
-    def hasOpenIDExtractor():
-        """Check if an OpenID extraction plugin is active.
-        """
-
-    def hasOpenIDdExtractor():
-        """Check if an OpenID extraction plugin is active.
-
-        BBB Keeping method name with typo for backwards compatibility.
-        """
-
-
-class IPASMemberView(Interface):
-
-    def info(userid=None):
-        """Return 'harmless' member info of any user, such as full name,
-        location, etc.
-        """
-
-
-class IPASSearchView(Interface):
-
-    def searchUsers(sort_by=None, any_field=None, **criteria):
-        """Search for users matching a set of criteria.
-
-        The criteria are a dictionary mapping user properties to values and
-        have the semantics declared by IPluggableAuthService.searchUsers().
-        Duplicate results returned by PAS are filtered so only the first
-        result remains in the result set. The results can be sorted on
-        sort_bys (case insensitive).
-
-        In addition, a single search string can be sought in multiple
-        fields at a time by passing any_field='your-string'. The fields
-        that will be searched are not explicitly enumerated but will be the
-        user-facing ones a user would expect to search, such as login name
-        and full name. (Perhaps any_field should/could be moved into PAS
-        proper. This could be done without breaking code that depends on
-        this interface.)
-
-        If you specify both any_field and other criteria that include a
-        field that any_field would typically search (such as login name),
-        the other criteria will be enforced at the expense of any_field.
-        """
-
-    def searchUsersByRequest(request, sort_by=None):
-        """Search for users matching a set of criteria found in a request.
-
-        This method will look remove any obvious values from the request
-        which are not search criteria. It will also remove any fields
-        which have an empty string value.
-        Duplicate results returned by PAS are filtered so only the first
-        result remains in the result set. The results can be sorted on
-        sort_by (case insensitive).
-        """
-
-    def searchGroups(**criteria):
-        """Search for groups matching a set of criteria.
-
-        The criteria are a dictionary mapping group properties
-        to values and have the semantics declared by
-        IPluggableAuthService.searchGroups().
-        """
-
-    def searchGroupsByRequest(request):
-        """Search for groups matching a set of criteria found in a request.
-
-        This method will look remove any obvious values from the request
-        which are not search criteria. It will also remove any fields
-        which have an empty string value.
-        """
-
-    def merge(results, key):
-        """merge two search results based on key as the unique criterion"""
-
-    def sort(results, key):
-        """sort results on a key"""
diff --git a/Products/PlonePAS/interfaces/capabilities.py b/Products/PlonePAS/interfaces/capabilities.py
deleted file mode 100644
index 92b1286..0000000
--- a/Products/PlonePAS/interfaces/capabilities.py
+++ /dev/null
@@ -1,78 +0,0 @@
-# -*- coding: utf-8 -*-
-# Define certain interfaces that a plugin must meet if it is to allow
-# certain operations to be done by the Plone UI.
-from Products.PluggableAuthService.interfaces.plugins import Interface
-
-
-class IDeleteCapability(Interface):
-    """Interface for plugin to say if it allows for deletion of a user.
-    Expected to be found on IUserManagement plugins.
-    For Plone UI.
-    """
-
-    def allowDeletePrincipal(id):
-        """True iff this plugin can delete a certain user/group."""
-
-
-class IPasswordSetCapability(Interface):
-    """Interface for plugin to say if it allows for setting the password of a
-    user.
-    Expected to be found on IUserManagement plugins.
-    For Plone UI.
-    """
-
-    def allowPasswordSet(id):
-        """True iff this plugin can set the password of a certain user."""
-
-
-class IGroupCapability(Interface):
-    """Interface for plugin to say if it allows for deletion of a user.
-    For Plone UI.
-    """
-
-    def allowGroupAdd(principal_id, group_id):
-        """True iff this plugin will allow adding a certain principal to a
-        certain group."""
-
-    def allowGroupRemove(principal_id, group_id):
-        """True iff this plugin will allow removing a certain principal from a
-        certain group."""
-
-
-class IAssignRoleCapability(Interface):
-    """Interface for plugin to say if it allows for deletion of a user.
-    For Plone UI.
-    """
-
-    def allowRoleAssign(id, role):
-        """True iff this plugin will allow assigning a certain principal a
-        certain role."""
-
-
-class IManageCapabilities(Interface):
-    """Interface for MemberData/GroupData to provide information as to whether
-    or not the member can be deleted, reset password, modify a property.
-    """
-
-    def canDelete():
-        """True iff user can be removed from the Plone UI."""
-
-    def canPasswordSet():
-        """True iff user can change password."""
-
-    def passwordInClear():
-        """True iff password can be retrieved in the clear (not hashed.)"""
-
-    def canWriteProperty(prop_name):
-        """True iff the member/group property named in 'prop_name'
-        can be changed.
-        """
-
-    def canAddToGroup(group_id):
-        """True iff member can be added to group."""
-
-    def canRemoveFromGroup(group_id):
-        """True iff member can be removed from group."""
-
-    def canAssignRole(role):
-        """True iff member can be assigned role."""
diff --git a/Products/PlonePAS/interfaces/events.py b/Products/PlonePAS/interfaces/events.py
deleted file mode 100644
index 500ca8d..0000000
--- a/Products/PlonePAS/interfaces/events.py
+++ /dev/null
@@ -1,7 +0,0 @@
-# -*- coding: utf-8 -*-
-from Products.PluggableAuthService.interfaces.events import IUserLoggedInEvent
-
-
-class IUserInitialLoginInEvent(IUserLoggedInEvent):
-    """A user logs in for the first time in the portal.
-    """
diff --git a/Products/PlonePAS/interfaces/group.py b/Products/PlonePAS/interfaces/group.py
deleted file mode 100644
index 537eca1..0000000
--- a/Products/PlonePAS/interfaces/group.py
+++ /dev/null
@@ -1,140 +0,0 @@
-# -*- coding: utf-8 -*-
-from zope.interface import Interface
-from Products.PluggableAuthService.interfaces import plugins
-
-
-class IGroupManagement(Interface):
-
-    def addGroup(id, **kw):
-        """
-        Create a group with the supplied id, roles, and groups.
-        return True if the operation suceeded
-        """
-
-    def addPrincipalToGroup(principal_id, group_id):
-        """
-        Add a given principal to the group.
-        return True on success
-        """
-
-    def updateGroup(id, **kw):
-        """
-        Edit the given group. plugin specific
-        return True on success
-        """
-
-    def setRolesForGroup(group_id, roles=()):
-        """
-        set roles for group
-        return True on success
-        """
-
-    def removeGroup(group_id):
-        """
-        Remove the given group
-        return True on success
-        """
-
-    def removePrincipalFromGroup(principal_id, group_id):
-        """
-        remove the given principal from the group
-        return True on success
-        """
-
-
-class IGroupIntrospection(Interface):
-
-    def getGroupById(group_id):
-        """
-        Returns the portal_groupdata-ish object for a group
-        corresponding to this id.
-        """
-
-    #################################
-    # these interface methods are suspect for scalability.
-    #################################
-
-    def getGroups():
-        """
-        Returns an iteration of the available groups
-        """
-
-    def getGroupIds():
-        """
-        Returns a list of the available groups
-        """
-
-    def getGroupMembers(group_id):
-        """
-        return the members of the given group
-        """
-
-
-class IGroupDataTool(Interface):
-
-    def wrapGroup(group):
-        """
-        decorate a group with property management capabilities if needed
-        """
-
-
-class IGroupTool(IGroupIntrospection,
-                  IGroupManagement,
-                  plugins.IGroupsPlugin):
-
-    """
-    Defines an interface for managing and introspecting and
-    groups and group membership.
-    """
-
-
-class IGroupData(Interface):
-    """ An abstract interface for accessing properties on a group object"""
-
-    def setProperties(properties=None, **kw):
-        """Allows setting of group properties en masse.
-        Properties can be given either as a dict or a keyword parameters
-        list"""
-
-    def getProperty(id):
-        """ Return the value of the property specified by 'id' """
-
-    def getProperties():
-        """ Return the properties of this group. Properties are as usual in
-        Zope."""
-
-    def getGroupId():
-        """ Return the string id of this group, WITHOUT group prefix."""
-
-    def getMemberId():
-        """This exists only for a basic user/group API compatibility
-        """
-
-    def getGroupName():
-        """ Return the name of the group."""
-
-    def getGroupMembers():
-        """ Return a list of the portal_memberdata-ish members of the group."""
-
-    def getAllGroupMembers():
-        """ Return a list of the portal_memberdata-ish members of the group
-        including transitive ones (ie. users or groups of a group in that
-        group)."""
-
-    def getGroupMemberIds():
-        """ Return a list of the user ids of the group."""
-
-    def getAllGroupMemberIds():
-        """ Return a list of the user ids of the group.
-        including transitive ones (ie. users or groups of a group in that
-        group)."""
-
-    def addMember(id):
-        """ Add the existing member with the given id to the group"""
-
-    def removeMember(id):
-        """ Remove the member with the provided id from the group """
-
-    def getGroup():
-        """ Returns the actual group implementation. Varies by group
-        implementation (GRUF/Nux/et al)."""
diff --git a/Products/PlonePAS/interfaces/membership.py b/Products/PlonePAS/interfaces/membership.py
deleted file mode 100644
index 1f8a757..0000000
--- a/Products/PlonePAS/interfaces/membership.py
+++ /dev/null
@@ -1,12 +0,0 @@
-# -*- coding: utf-8 -*-
-from Products.CMFCore import interfaces
-
-
-class IMembershipTool(interfaces.IMembershipTool):
-
-    def getMemberInfo(memberId=None):
-        """Return 'harmless' Memberinfo of any member, such as full name,
-        location, etc
-        """
-
-__all__ = (IMembershipTool, )
diff --git a/Products/PlonePAS/interfaces/plugins.py b/Products/PlonePAS/interfaces/plugins.py
deleted file mode 100644
index a1f78a3..0000000
--- a/Products/PlonePAS/interfaces/plugins.py
+++ /dev/null
@@ -1,127 +0,0 @@
-# -*- coding: utf-8 -*-
-from Products.PluggableAuthService.interfaces import plugins
-from Products.PluggableAuthService.interfaces.plugins import Interface
-
-
-class IUserIntrospection(Interface):
-    """
-    Introspect users in a user source, api users need to be careful as
-    all sources may or not support this interface.
-
-    Realistically this can only be done by authentication sources, or
-    plugins which have intimate knowledge of such.
-    """
-
-    def getUserIds():
-        """
-        Return a list of user ids
-        """
-
-    def getUserNames():
-        """
-        Return a list of usernames
-        """
-
-    def getUsers():
-        """
-        Return a list of users
-        """
-
-
-class ILocalRolesPlugin(Interface):
-    """
-    Plugin for determining a user's local roles and object access
-    based on local roles.
-    """
-
-    def getRolesInContext(user, object):
-        """
-        Return the list of roles assigned to the user.
-
-        o Include local roles assigned in context of the passed-in object.
-
-        o Include *both* local roles assigned directly to us *and* those
-          assigned to our groups.
-
-        o Ripped off from AccessControl.User.BasicUser, which provides
-          no other extension mechanism. :(
-        """
-
-    def checkLocalRolesAllowed(user, object, object_roles):
-        """
-        Check whether the user has access to object based
-        on local roles. access is determined by a user's local roles
-        including one of the object roles.
-        """
-
-    def getAllLocalRolesInContext(object):
-        """
-        Return active all local roles in a context.
-
-        The roles are returned in a dictionary mapping a principal (a
-        user or a group) to the set of roles assigned to it.
-        """
-
-
-class IUserManagement(plugins.IUserAdderPlugin):
-    """
-    Manage users
-    """
-
-    def doChangeUser(user_id, password, **kw):
-        """
-        Change a user's password (differs from role) roles are set in
-        the pas engine api for the same but are set via a role
-        manager)
-        """
-
-    def doDeleteUser(login):
-        """
-        Remove a user record from a User Manager, with the given login
-        and password
-
-        o Return a Boolean indicating whether a user was removed or
-          not
-        """
-
-
-class IMutablePropertiesPlugin(Interface):
-    """
-    Return a property set for a user. Property set can either an
-    object conforming to the IMutable property sheet interface or a
-    dictionary (in which case the properties are not persistently
-    mutable).
-    """
-
-    def getPropertiesForUser(user, request=None):
-        """
-        User -> IMutablePropertySheet || {}
-
-        o User will implement IPropertiedUser.
-
-        o Plugin may scribble on the user, if needed (but must still
-          return a mapping, even if empty).
-
-        o May assign properties based on values in the REQUEST object, if
-          present
-        """
-
-    def setPropertiesForUser(user, propertysheet):
-        """
-        Set modified properties on the user persistently.
-
-        Raise a ValueError if the property or property value is invalid
-        """
-
-    def deleteUser(user_id):
-        """
-        Remove properties stored for a user
-        """
-
-
-class ISchemaMutablePropertiesPlugin(Interface):
-
-    def addProperty(property_type, property_name, default=None):
-        """
-        Add a new property to a property provider.
-        """
diff --git a/Products/PlonePAS/interfaces/propertysheets.py b/Products/PlonePAS/interfaces/propertysheets.py
deleted file mode 100644
index 8ff7ab3..0000000
--- a/Products/PlonePAS/interfaces/propertysheets.py
+++ /dev/null
@@ -1,22 +0,0 @@
-# -*- coding: utf-8 -*-
-from Products.PluggableAuthService.interfaces.propertysheets \
-    import IPropertySheet
-
-
-class IMutablePropertySheet(IPropertySheet):
-
-    def canWriteProperty(object, id):
-        """ Check if a property can be modified.
-        """
-
-    def setProperty(object, id, value):
-        """
-        """
-
-    def setProperties(object, mapping):
-        """
-        """
-
-
-class ISchemaMutablePropertySheet(IMutablePropertySheet):
-    pass
diff --git a/Products/PlonePAS/ldapmp.py b/Products/PlonePAS/ldapmp.py
deleted file mode 100644
index dd25b1a..0000000
--- a/Products/PlonePAS/ldapmp.py
+++ /dev/null
@@ -1,72 +0,0 @@
-# -*- coding: utf-8 -*-
-from Products.PlonePAS.patch import call
-from Products.PlonePAS.patch import wrap_method
-from Products.PlonePAS.plugins.group import PloneGroup
-
-GROUP_PROPERTY_MAP = {
-    # target property: (possible key, ...)
-    'title': ('name',
-              'displayName',
-              'cn',),
-    'description': ('description', ),
-    'email': ('mail', ),
-    }
-
-KNOWN_ATTRS = []
-for attrs in GROUP_PROPERTY_MAP.values():
-    for attr in attrs:
-        KNOWN_ATTRS.append(attr)
-KNOWN_ATTRS = set(KNOWN_ATTRS)
-
-
-def getPropertiesForUser(self, user, request=None):
-    """Fullfill PropertiesPlugin requirements
-    """
-
-    if not isinstance(user, PloneGroup):
-        # It's not a PloneGroup, continue as usual
-        return call(self, 'getPropertiesForUser', user=user, request=request)
-
-    # We've got a PloneGroup.
-    # Search for groups instead of users
-    groups = self.enumerateGroups(id=user.getId(), exact_match=True)
-    # XXX Should we assert there's only one group?
-    properties = {}
-    for group in groups:
-        for pname, attrs in GROUP_PROPERTY_MAP.items():
-            for attr in attrs:
-                value = group.get(attr)
-                if value:
-                    # Break on first found
-                    properties[pname] = value
-                    break
-
-    return properties
-
-
-def getGroupsForPrincipal(self, user, request=None, attr=None):
-    """ Fulfill GroupsPlugin requirements, but don't return any groups for
-    groups """
-
-    if not isinstance(user, PloneGroup):
-        # It's not a PloneGroup, continue as usual
-        return call(self, 'getGroupsForPrincipal', user,
-                    request=request, attr=attr)
-
-    return ()
-
-
-def patch_ldapmp():
-    from Products.LDAPMultiPlugins.LDAPPluginBase import LDAPPluginBase
-    wrap_method(
-        LDAPPluginBase,
-        'getPropertiesForUser',
-        getPropertiesForUser
-    )
-
-    from Products.LDAPMultiPlugins.LDAPMultiPlugin import LDAPMultiPlugin
-    wrap_method(
-        LDAPMultiPlugin,
-        'getGroupsForPrincipal',
-        getGroupsForPrincipal
-    )
diff --git a/Products/PlonePAS/pas.py b/Products/PlonePAS/pas.py
deleted file mode 100644
index 52ba319..0000000
--- a/Products/PlonePAS/pas.py
+++ /dev/null
@@ -1,735 +0,0 @@
-# -*- coding: utf-8 -*-
-# pas alterations and monkies
-from AccessControl import Unauthorized
-from AccessControl import getSecurityManager
-from AccessControl.PermissionRole import PermissionRole
-from AccessControl.Permissions import change_permissions
-from AccessControl.Permissions import manage_properties
-from AccessControl.Permissions import manage_users as ManageUsers
-from AccessControl.requestmethod import postonly
-from OFS.Folder import Folder
-from Products.CMFCore.utils import getToolByName
-from Products.CMFCore.utils import registerToolInterface
-from Products.PlonePAS.interfaces.group import IGroupIntrospection
-from Products.PlonePAS.interfaces.group import IGroupManagement
-from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
-from Products.PlonePAS.interfaces.plugins import IUserIntrospection
-from Products.PlonePAS.interfaces.plugins import IUserManagement
-from Products.PlonePAS.patch import wrap_method
-from Products.PlonePAS.patch import ORIG_NAME
-from Products.PluggableAuthService.PluggableAuthService import \
-    PluggableAuthService
-from Products.PluggableAuthService.PluggableAuthService import \
-    _SWALLOWABLE_PLUGIN_EXCEPTIONS
-from Products.PluggableAuthService.events import PrincipalDeleted
-from Products.PluggableAuthService.interfaces.authservice import \
-    IPluggableAuthService
-from Products.PluggableAuthService.interfaces.plugins import \
-    IAuthenticationPlugin
-from Products.PluggableAuthService.interfaces.plugins import \
-    IGroupEnumerationPlugin
-from Products.PluggableAuthService.interfaces.plugins import \
-    IRoleAssignerPlugin
-from Products.PluggableAuthService.interfaces.plugins import \
-    IUserEnumerationPlugin
-from zope.event import notify
-import logging
-
-logger = logging.getLogger('PlonePAS')
-
-registerToolInterface('acl_users', IPluggableAuthService)
-
-
-#################################
-# helper functions
-
-def _userSetGroups(pas, user_id, groupnames):
-    """method was used at GRUF level, but is used inside this monkies at several
-    places too.
-
-    We no longer provide it on PAS to clean up patches
-
-    """
-    plugins = pas.plugins
-    gtool = getToolByName(pas, "portal_groups")
-
-    member = pas.getUserById(user_id)
-    groupnameset = set(groupnames)
-
-    # remove absent groups
-    groups = set(gtool.getGroupsForPrincipal(member))
-    rmgroups = groups - groupnameset
-    for gid in rmgroups:
-        try:
-            gtool.removePrincipalFromGroup(user_id, gid)
-        except KeyError:
-            # We could hit a group which does not allow user removal, such as
-            # created by our AutoGroup plugin.
-            pass
-
-    # add groups
-    try:
-        groupmanagers = plugins.listPlugins(IGroupManagement)
-    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-        logger.info(
-            'PluggableAuthService: Plugin listing error',
-            exc_info=1
-        )
-        groupmanagers = ()
-
-    for group in groupnames:
-        for gm_id, gm in groupmanagers:
-            try:
-                if gm.addPrincipalToGroup(user_id, group):
-                    break
-            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-                logger.info(
-                    'PluggableAuthService: GroupManagement %s error',
-                    gm_id,
-                    exc_info=1
-                )
-
-#################################
-# pas folder monkies - standard zope user folder api or GRUF
-
-
-def _doAddUser(self, login, password, roles, domains, groups=None, **kw):
-    """Masking of PAS._doAddUser to add groups param."""
-    _old_doAddUser = getattr(self, getattr(_doAddUser, ORIG_NAME))
-    retval = _old_doAddUser(login, password, roles, domains)
-    if groups is not None:
-        _userSetGroups(self, login, groups)
-    return retval
-
-
-def _doDelUsers(self, names, REQUEST=None):
-    """
-    Delete users given by a list of user ids.
-    Has no return value, like the original (GRUF).
-    """
-    for name in names:
-        self._doDelUser(name)
-
-
-def _doDelUser(self, id):
-    """
-    Given a user id, hand off to a deleter plugin if available.
-    """
-    plugins = self._getOb('plugins')
-    userdeleters = plugins.listPlugins(IUserManagement)
-
-    if not userdeleters:
-        raise NotImplementedError(
-            "There is no plugin that can delete users."
-        )
-
-    for userdeleter_id, userdeleter in userdeleters:
-        try:
-            userdeleter.doDeleteUser(id)
-        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-            pass
-        else:
-            notify(PrincipalDeleted(id))
-
-
-def _doChangeUser(self, principal_id, password, roles, domains=(), groups=None,
-                  REQUEST=None, **kw):
-    """
-    Given a principal id, change its password, roles, domains, if
-    respective plugins for such exist.
-
-    XXX domains are currently ignored.
-    """
-    # Might be called with 'None' as password from the Plone UI, in
-    # prefs_users_overview when resetPassword is not set.
-    if password is not None:
-        self.userSetPassword(principal_id, password)
-
-    plugins = self._getOb('plugins')
-    rmanagers = plugins.listPlugins(IRoleAssignerPlugin)
-
-    if not (rmanagers):
-        raise NotImplementedError("There is no plugin that can modify roles")
-
-    for rid, rmanager in rmanagers:
-        rmanager.assignRolesToPrincipal(roles, principal_id)
-
-    if groups is not None:
-        _userSetGroups(self, principal_id, groups)
-
-    return True
-
-
-def userFolderAddUser(self, login, password, roles, domains,
-                      groups=None, REQUEST=None, **kw):
-    self._doAddUser(login, password, roles, domains, **kw)
-    if groups is not None:
-        _userSetGroups(self, login, groups)
-
-
-def _doAddGroup(self, id, roles, groups=None, **kw):
-    gtool = getToolByName(self, 'portal_groups')
-    return gtool.addGroup(id, roles, groups, **kw)
-
-
-# for prefs_group_manage compatibility. really should be using tool.
-def _doDelGroups(self, names, REQUEST=None):
-    gtool = getToolByName(self, 'portal_groups')
-    for group_id in names:
-        gtool.removeGroup(group_id)
-
-
-def _doChangeGroup(self, principal_id, roles, groups=None, REQUEST=None, **kw):
-    """
-    Given a group's id, change its roles, domains, if respective
-    plugins for such exist. Domains are currently ignored.
-
-    See also _doChangeUser
-    """
-    gtool = getToolByName(self, 'portal_groups')
-    gtool.editGroup(principal_id, roles, groups, **kw)
-    return True
-
-
-def _updateGroup(self, principal_id, roles=None, groups=None, **kw):
-    """
-    Given a group's id, change its roles, groups, if respective
-    plugins for such exist. Domains are ignored.
-
-    This is not an alias to _doChangeGroup because its params are different
-    (slightly).
-    """
-    return self._doChangeGroup(principal_id, roles, groups, **kw)
-
-
-def getGroups(self):
-    gtool = getToolByName(self, 'portal_groups')
-    return gtool.listGroups()
-
-
-def getGroupNames(self):
-    gtool = getToolByName(self, 'portal_groups')
-    return gtool.getGroupIds()
-
-
-def getGroupIds(self):
-    gtool = getToolByName(self, 'portal_groups')
-    return gtool.getGroupIds()
-
-
-def getGroup(self, group_id):
-    """Like getGroupById in groups tool, but doesn't wrap.
-    """
-    group = None
-    introspectors = self.plugins.listPlugins(IGroupIntrospection)
-
-    if not introspectors:
-        raise ValueError('No plugins allow for group management')
-    for iid, introspector in introspectors:
-        group = introspector.getGroupById(group_id)
-        if group is not None:
-            break
-    return group
-
-
-def getGroupByName(self, name, default=None):
-    ret = self.getGroup(name)
-    if ret is None:
-        return default
-    return ret
-
-
-def getGroupById(self, id, default=None):
-    gtool = getToolByName(self, "portal_groups")
-    ret = gtool.getGroupById(id)
-    if ret is None:
-        return default
-    else:
-        return ret
-
-
-def getLocalRolesForDisplay(self, object):
-    """This is used for plone's local roles display
-
-    This method returns a tuple (massagedUsername, roles, userType,
-    actualUserName).  This method is protected by the 'access content
-    information' permission. We may change that if it's too
-    permissive...
-
-    A GRUF method originally.
-    """
-    # Perform security check on destination object
-    if not getSecurityManager().checkPermission(manage_properties, object):
-        raise Unauthorized(name="getLocalRolesForDisplay")
-
-    return self._getLocalRolesForDisplay(object)
-
-
-def _getLocalRolesForDisplay(self, object):
-    result = []
-    # we don't have a PAS-side way to get this
-    local_roles = object.get_local_roles()
-    for one_user in local_roles:
-        username = userid = one_user[0]
-        roles = one_user[1]
-        userType = 'user'
-        if self.getGroup(userid):
-            userType = 'group'
-        else:
-            user = self.getUserById(userid) or self.getUser(username)
-            if user:
-                username = user.getUserName()
-                userid = user.getId()
-        result.append((username, roles, userType, userid))
-    return tuple(result)
-
-
-def getUsers(self):
-    """
-    Return a list of all users from plugins that implement the user
-    introspection interface.
-
-    Could potentially be very long.
-    """
-    # We should have a method that's cheap about returning number of users.
-    retval = []
-    try:
-        introspectors = self.plugins.listPlugins(IUserIntrospection)
-    except KeyError:
-        return retval
-
-    for iid, introspector in introspectors:
-        retval += introspector.getUsers()
-
-    return retval
-
-
-def canListAllUsers(self):
-    plugins = self._getOb('plugins')
-    # Do we have multiple user plugins?
-    num_enumeration_plugins = plugins.listPlugins(IUserEnumerationPlugin)
-    num_introspection_plugins = plugins.listPlugins(IUserEnumerationPlugin)
-    return num_enumeration_plugins == num_introspection_plugins
-
-
-def canListAllGroups(self):
-    plugins = self._getOb('plugins')
-    # Do we have multiple group plugins?
-    num_enumeration_plugins = plugins.listPlugins(IGroupEnumerationPlugin)
-    num_introspection_plugins = plugins.listPlugins(IGroupEnumerationPlugin)
-    return num_enumeration_plugins == num_introspection_plugins
-
-
-def userSetPassword(self, userid, password):
-    """Emulate GRUF 3 call for password set, for use with PwRT."""
-    # used by _doChangeUser
-    plugins = self._getOb('plugins')
-    managers = plugins.listPlugins(IUserManagement)
-
-    if not managers:
-        raise NotImplementedError("There is no plugin that can modify users")
-
-    modified = False
-    for mid, manager in managers:
-        try:
-            manager.doChangeUser(userid, password)
-        except RuntimeError:
-            # XXX: why silent ignore this Error?
-            pass
-        else:
-            modified = True
-
-    if not modified:
-        raise RuntimeError("No user management plugins were able "
-                           "to successfully modify the user")
-
-
-def credentialsChanged(self, user, name, new_password):
-    """Notifies the authentication mechanism that this user has changed
-    passwords.  This can be used to update the authentication cookie.
-    Note that this call should *not* cause any change at all to user
-    databases.
-
-    For use by CMFCore.MembershipTool.credentialsChanged
-    """
-    request = self.REQUEST
-    response = request.RESPONSE
-    login = name
-
-    self.updateCredentials(request, response, login, new_password)
-
-
-# for ZopeVersionControl, we need to check 'plugins' for more than
-# existence, since it replaces objects (like 'plugins') with SimpleItems
-# and calls _delOb, which tries to use special methods of 'plugins'
-def _delOb(self, id):
-    #
-    #   Override ObjectManager's version to clean up any plugin
-    #   registrations for the deleted object
-    #
-    # XXX imo this is a evil one
-    #
-    plugins = self._getOb('plugins', None)
-
-    if getattr(plugins, 'removePluginById', None) is not None:
-        plugins.removePluginById(id)
-
-    Folder._delOb(self, id)
-
-
-def addRole(self, role):
-    plugins = self._getOb('plugins')
-    roles = plugins.listPlugins(IRoleAssignerPlugin)
-
-    for plugin_id, plugin in roles:
-        try:
-            plugin.addRole(role)
-            break
-        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-            pass
-
-
-def getAllLocalRoles(self, context):
-    # Perform security check on destination object
-    if not getSecurityManager().checkPermission(change_permissions, context):
-        raise Unauthorized(name="getAllLocalRoles")
-    return self._getAllLocalRoles(context)
-
-
-def _getAllLocalRoles(self, context):
-    plugins = self._getOb('plugins')
-    lrmanagers = plugins.listPlugins(ILocalRolesPlugin)
-
-    roles = {}
-    for lrid, lrmanager in lrmanagers:
-        newroles = lrmanager.getAllLocalRolesInContext(context)
-        for k, v in newroles.items():
-            if k not in roles:
-                roles[k] = set()
-            roles[k].update(v)
-
-    return roles
-
-
-def authenticate(self, name, password, request):
-    """See AccessControl.User.BasicUserFolder.authenticate
-
-    Products.PluggableAuthService.PluggableAuthService does not provide this
-    method, BasicUserFolder documents it as "Private UserFolder object
-    interface". GRUF does provide the method, so not marked as private.
-
-    should be deprecated in future!
-    """
-
-    plugins = self.plugins
-
-    try:
-        authenticators = plugins.listPlugins(IAuthenticationPlugin)
-    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
-        authenticators = ()
-
-    credentials = {'login': name,
-                   'password': password}
-
-    user_id = None
-
-    for authenticator_id, auth in authenticators:
-        try:
-            uid_and_name = auth.authenticateCredentials(credentials)
-            if uid_and_name is not None:
-                user_id, name = uid_and_name
-                break
-        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-            logger.info(
-                    'PluggableAuthService: AuthenticationPlugin %s error',
-                    authenticator_id, exc_info=1)
-            continue
-
-    if not user_id:
-        return
-
-    return self._findUser(plugins, user_id, name, request)
-
-
-def getUserIds(self):
-    """method was used at GRUF and is here for bbb. Not good for many users!
-    DEPRECATED
-    """
-    plugins = self.plugins
-
-    try:
-        introspectors = plugins.listPlugins(IUserIntrospection)
-    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
-        introspectors = ()
-
-    results = []
-    for introspector_id, introspector in introspectors:
-        try:
-            results.extend(introspector.getUserIds())
-        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-            logger.info(
-                    'PluggableAuthService: UserIntrospection %s error',
-                    introspector_id, exc_info=1)
-
-    return results
-
-
-def getUserNames(self):
-    """method was used at GRUF and is here for bbb. Not good for many users!
-    DEPRECATED
-    """
-    plugins = self.plugins
-
-    try:
-        introspectors = plugins.listPlugins(IUserIntrospection)
-    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
-        introspectors = ()
-
-    results = []
-    for introspector_id, introspector in introspectors:
-        try:
-            results.extend(introspector.getUserNames())
-        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-            logger.info(
-                'PluggableAuthService: UserIntroSpection plugin %s error',
-                introspector_id, exc_info=1)
-
-    return results
-
-
-def patch_pas():
-    # sort alphabetically by patched/added method name
-    wrap_method(
-        PluggableAuthService,
-        '_delOb',
-        _delOb
-    )
-    wrap_method(
-        PluggableAuthService,
-        '_getAllLocalRoles',
-        _getAllLocalRoles,
-        add=True,
-    )
-    wrap_method(
-        PluggableAuthService,
-        '_doAddGroup',
-        _doAddGroup,
-        add=True
-    )
-    wrap_method(
-        PluggableAuthService,
-        '_doAddUser',
-        _doAddUser
-    )
-    wrap_method(
-        PluggableAuthService,
-        '_doChangeGroup',
-        _doChangeGroup,
-        add=True
-    )
-    wrap_method(
-        PluggableAuthService,
-        '_doChangeUser',
-        _doChangeUser,
-        add=True
-    )
-    wrap_method(
-        PluggableAuthService,
-        '_doDelGroups',
-        _doDelGroups,
-        add=True
-    )
-    wrap_method(
-        PluggableAuthService,
-        '_doDelUser',
-        _doDelUser,
-        add=True
-    )
-    wrap_method(
-        PluggableAuthService,
-        '_doDelUsers',
-        _doDelUsers,
-        add=True,
-        roles=PermissionRole(ManageUsers, ('Manager',))
-    )
-    wrap_method(
-        PluggableAuthService,
-        '_getLocalRolesForDisplay',
-        _getLocalRolesForDisplay,
-        add=True
-    )
-    wrap_method(
-        PluggableAuthService,
-        '_updateGroup',
-        _updateGroup,
-        add=True
-    )
-    wrap_method(
-        PluggableAuthService,
-        'addRole',
-        addRole,
-        add=True,
-        roles=PermissionRole(ManageUsers, ('Manager',))
-    )
-    wrap_method(
-        PluggableAuthService,
-        'authenticate',
-        authenticate,
-        add=True,
-        roles=(),
-    )
-    wrap_method(
-        PluggableAuthService,
-        'canListAllGroups',
-        canListAllGroups,
-        add=True,
-        roles=PermissionRole(ManageUsers, ('Manager',))
-    )
-    wrap_method(
-        PluggableAuthService,
-        'canListAllUsers',
-        canListAllUsers,
-        add=True,
-        roles=PermissionRole(ManageUsers, ('Manager',))
-    )
-    wrap_method(
-        PluggableAuthService,
-        'credentialsChanged',
-        credentialsChanged,
-        add=True,
-        roles=PermissionRole(ManageUsers, ('Manager',))
-    )
-    wrap_method(
-        PluggableAuthService,
-        'getAllLocalRoles',
-        getAllLocalRoles,
-        add=True,
-    )
-    wrap_method(
-        PluggableAuthService,
-        'getGroup',
-        getGroup,
-        add=True,
-        roles=PermissionRole(ManageUsers, ('Manager',))
-    )
-    wrap_method(
-        PluggableAuthService,
-        'getGroupById',
-        getGroupById,
-        add=True,
-        roles=PermissionRole(ManageUsers, ('Manager',))
-    )
-    wrap_method(
-        PluggableAuthService,
-        'getGroupByName',
-        getGroupByName,
-        add=True,
-        roles=PermissionRole(ManageUsers, ('Manager',))
-    )
-    wrap_method(
-        PluggableAuthService,
-        'getGroupIds',
-        getGroupIds,
-        add=True,
-        roles=PermissionRole(ManageUsers, ('Manager',))
-    )
-    wrap_method(
-        PluggableAuthService,
-        'getGroupNames',
-        getGroupNames,
-        add=True,
-        roles=PermissionRole(ManageUsers, ('Manager',))
-    )
-    wrap_method(
-        PluggableAuthService,
-        'getGroups',
-        getGroups,
-        add=True,
-        roles=PermissionRole(ManageUsers, ('Manager',))
-    )
-    wrap_method(
-        PluggableAuthService,
-        'getLocalRolesForDisplay',
-        getLocalRolesForDisplay,
-        add=True,
-    )
-    wrap_method(
-        PluggableAuthService,
-        'getUserIds',
-        getUserIds,
-        add=True,
-        deprecated="Inefficient GRUF wrapper, use IUserIntrospection instead."
-    )
-    wrap_method(
-        PluggableAuthService,
-        'getUserNames',
-        getUserNames,
-        add=True,
-        deprecated="Inefficient GRUF wrapper, use IUserIntrospection instead."
-    )
-    wrap_method(
-        PluggableAuthService,
-        'getUsers',
-        getUsers,
-        add=True,
-        roles=PermissionRole(ManageUsers, ('Manager',))
-    )
-    wrap_method(
-        PluggableAuthService,
-        'getPureUsers',
-        getUsers,
-        add=True,
-        roles=PermissionRole(ManageUsers, ('Manager',))
-    )
-    wrap_method(
-        PluggableAuthService,
-        'userFolderAddUser',
-        postonly(userFolderAddUser),
-        add=True,
-        roles=PermissionRole(ManageUsers, ('Manager',))
-    )
-    wrap_method(
-        PluggableAuthService,
-        'userFolderDelUsers',
-        postonly(_doDelUsers),
-        add=True,
-        roles=PermissionRole(ManageUsers, ('Manager',))
-    )
-    wrap_method(
-        PluggableAuthService,
-        'userFolderEditGroup',
-        postonly(_doChangeGroup),
-        add=True,
-        roles=PermissionRole(ManageUsers, ('Manager',))
-    )
-    wrap_method(
-        PluggableAuthService,
-        'userFolderEditUser',
-        postonly(_doChangeUser),
-        add=True,
-        roles=PermissionRole(ManageUsers, ('Manager',))
-    )
-    wrap_method(
-        PluggableAuthService,
-        'userFolderDelGroups',
-        postonly(_doDelGroups),
-        add=True,
-        roles=PermissionRole(ManageUsers, ('Manager',))
-    )
-    wrap_method(
-        PluggableAuthService,
-        'userSetGroups',
-        _userSetGroups,
-        add=True,
-        deprecated="Method from GRUF was removed."
-    )
-    wrap_method(
-        PluggableAuthService,
-        'userSetPassword',
-        userSetPassword,
-        add=True,
-        roles=PermissionRole(ManageUsers, ('Manager',))
-    )
diff --git a/Products/PlonePAS/patch.py b/Products/PlonePAS/patch.py
deleted file mode 100644
index 0c95d31..0000000
--- a/Products/PlonePAS/patch.py
+++ /dev/null
@@ -1,74 +0,0 @@
-# -*- coding: utf-8 -*-
-import logging
-from zope.deprecation import deprecation
-
-logger = logging.getLogger('PlonePAS')
-
-PATTERN = '__PlonePAS_%s__'
-
-
-def call(self, __name__, *args, **kw):
-    return getattr(self, PATTERN % __name__)(*args, **kw)
-
-
-WRAPPER = '__PlonePAS_is_wrapper_method__'
-ADDED = '__PlonePAS_is_added_method__'
-ORIG_NAME = '__PlonePAS_original_method_name__'
-
-_marker = dict()
-
-
-def isWrapperMethod(meth):
-    return getattr(meth, WRAPPER, False)
-
-
-def wrap_method(klass, name, method,
-                pattern=PATTERN, add=False, roles=None, deprecated=False):
-    """takes a method and set it to a class. Annotates with hints what happened.
-    """
-    new_name = pattern % name
-    if not add:
-        old_method = getattr(klass, name)
-        if isWrapperMethod(old_method):
-            logger.info(
-                'PlonePAS: *NOT* wrapping already wrapped method at '
-                '{0}.{1}'.format(
-                    klass.__name__, name)
-                )
-
-            return
-        logger.info('PlonePAS: Wrapping method at %s.%s', klass.__name__, name)
-        setattr(klass, new_name, old_method)
-        setattr(method, ORIG_NAME, new_name)
-        setattr(method, WRAPPER, True)
-        setattr(method, ADDED, False)
-    else:
-        logger.info('PlonePAS: Adding method at %s.%s', klass.__name__, name)
-        setattr(method, WRAPPER, False)
-        setattr(method, ADDED, True)
-
-    if deprecated:
-        setattr(klass, name, deprecation.deprecated(method, deprecated))
-    else:
-        setattr(klass, name, method)
-
-    if roles is not None:
-        roles_attr = '{0}__roles__'.format(name)
-        logger.info(
-            'PlonePAS: Setting new permission roles at {0}.{1}'.format(
-                klass.__name__, name
-            )
-        )
-        setattr(klass, roles_attr, roles)
-
-
-def unwrap_method(klass, name):
-    # seems to be dead code, nowwhere used nor tested
-    old_method = getattr(klass, name)
-    if not isWrapperMethod(old_method):
-        raise ValueError('Trying to unwrap non-wrapped '
-                         'method at %s.%s' % (klass.__name__, name))
-    orig_name = getattr(old_method, ORIG_NAME)
-    new_method = getattr(klass, orig_name)
-    delattr(klass, orig_name)
-    setattr(klass, name, new_method)
diff --git a/Products/PlonePAS/permissions.py b/Products/PlonePAS/permissions.py
deleted file mode 100644
index 126932a..0000000
--- a/Products/PlonePAS/permissions.py
+++ /dev/null
@@ -1,17 +0,0 @@
-# -*- coding: utf-8 -*-
-from Products.CMFCore.permissions import setDefaultRoles
-
-AddGroups = 'Add Groups'
-setDefaultRoles(AddGroups, ('Manager',))
-
-ManageGroups = 'Manage Groups'
-setDefaultRoles(ManageGroups, ('Manager',))
-
-ViewGroups = 'View Groups'
-setDefaultRoles(ViewGroups, ('Manager', 'Owner', 'Member'))
-
-DeleteGroups = 'Delete Groups'
-setDefaultRoles(DeleteGroups, ('Manager', ))
-
-SetGroupOwnership = 'Set Group Ownership'
-setDefaultRoles(SetGroupOwnership, ('Manager', 'Owner'))
diff --git a/Products/PlonePAS/plugins/__init__.py b/Products/PlonePAS/plugins/__init__.py
deleted file mode 100644
index 40a96af..0000000
--- a/Products/PlonePAS/plugins/__init__.py
+++ /dev/null
@@ -1 +0,0 @@
-# -*- coding: utf-8 -*-
diff --git a/Products/PlonePAS/plugins/autogroup.py b/Products/PlonePAS/plugins/autogroup.py
deleted file mode 100644
index 4b21b79..0000000
--- a/Products/PlonePAS/plugins/autogroup.py
+++ /dev/null
@@ -1,148 +0,0 @@
-# -*- coding: utf-8 -*-
-from App.class_init import InitializeClass
-from Products.PageTemplates.PageTemplateFile import PageTemplateFile
-from Products.PlonePAS.interfaces.group import IGroupIntrospection
-from Products.PluggableAuthService.PropertiedUser import PropertiedUser
-from Products.PluggableAuthService.interfaces.plugins import \
-    IGroupEnumerationPlugin
-from Products.PluggableAuthService.interfaces.plugins import IGroupsPlugin
-from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
-from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
-from zope.interface import implementer
-
-manage_addAutoGroupForm = PageTemplateFile("../zmi/AutoGroupForm", globals())
-
-
-def manage_addAutoGroup(self, id, title='', group='', description='',
-                        RESPONSE=None):
-    """Add an Auto Group plugin."""
-
-    plugin = AutoGroup(id, title, group, description)
-    self._setObject(id, plugin)
-
-    if RESPONSE is not None:
-        return RESPONSE.redirect(
-            "%s/manage_workspace?manage_tabs_message=AutoGroup+plugin+added"
-            % self.absolute_url())
-
-
-class VirtualGroup(PropertiedUser):
-    def __init__(self, id, title='', description=''):
-        super(VirtualGroup, self).__init__(id)
-        self.id = id
-        self.title = title
-        self.description = description
-
-    def getId(self):
-        return self.id
-
-    def getUserName(self):
-        return self.id
-
-    def getName(self):
-        return self.id
-
-    def getMemberIds(self, transitive=1):
-        return []
-
-    def getRolesInContext(self, context):
-        return []
-
-    def getRoles(self):
-        return []
-
-    def allowed(self, object, object_roles=None):
-        return 0
-
-    def getDomains(self):
-        return []
-
-    def isGroup(self):
-        return True
-
-
-@implementer(
-        IGroupEnumerationPlugin,
-        IGroupsPlugin,
-        IGroupIntrospection,
-        IPropertiesPlugin
-)
-class AutoGroup(BasePlugin):
-    meta_type = "Automatic Group Plugin"
-
-    _properties = (
-        {'id': 'title',
-         'label': 'Title',
-         'type': 'string',
-         'mode': 'w'},
-        {'id': 'group',
-         'label': 'Group',
-         'type': 'string',
-         'mode': 'w'},
-        {'id': 'description',
-         'label': 'Description',
-         'type': 'string',
-         'mode': 'w'},
-    )
-
-    def __init__(self, id, title='', group=None, description=''):
-        self._setId(id)
-        self.title = title
-        self.group = group
-        self.description = description
-
-    # IGroupEnumerationPlugin implementation
-    def enumerateGroups(self, id=None, exact_match=False, sort_by=None,
-                        max_results=None, **kw):
-        if kw:
-            return []
-
-        if id:
-            id = id.lower()
-            mygroup = self.group.lower()
-
-            if exact_match and id != mygroup:
-                return []
-
-            if not exact_match and id not in mygroup:
-                return []
-
-        return [{'id': self.group,
-                 'groupid': self.group,
-                 'title': self.title,
-                 'pluginid': self.getId()}]
-
-    # IGroupsPlugin implementation
-    def getGroupsForPrincipal(self, principal, request=None):
-        if principal.getUserName() == self.group:
-            return ()
-
-        return (self.group,)
-
-    # IGroupIntrospection implementation
-    def getGroupById(self, group_id):
-        if group_id != self.group:
-            return None
-
-        return VirtualGroup(self.group, title=self.title,
-                            description=self.description)
-
-    def getGroups(self):
-        return [self.getGroupById(id) for id in self.getGroupIds()]
-
-    def getGroupIds(self):
-        return [self.group]
-
-    def getGroupMembers(self, group_id):
-        return ()
-
-    # IPropertiesPlugin:
-    def getPropertiesForUser(self, user, request=None):
-        if user == self.group:
-            return {'title': self.title,
-                    'description': self.description}
-        else:
-            return {}
-
-
-InitializeClass(AutoGroup)
diff --git a/Products/PlonePAS/plugins/cookie_handler.py b/Products/PlonePAS/plugins/cookie_handler.py
deleted file mode 100644
index 9c65297..0000000
--- a/Products/PlonePAS/plugins/cookie_handler.py
+++ /dev/null
@@ -1,113 +0,0 @@
-# -*- coding: utf-8 -*-
-""" Class: ExtendedCookieAuthHelper
-
-Simply extends the standard CookieAuthHelper provided via regular
-PluggableAuthService but overrides the updateCookie mechanism to
-provide similar functionality as CookieCrumbler does... by giving
-the portal the ability to provide a setAuthCookie method.
-"""
-from AccessControl.SecurityInfo import ClassSecurityInfo
-from AccessControl.SecurityManagement import getSecurityManager
-from Acquisition import aq_base
-from Acquisition import aq_parent
-from App.class_init import InitializeClass
-from App.special_dtml import DTMLFile
-from Products.PluggableAuthService.interfaces.authservice import \
-    IPluggableAuthService
-from Products.PluggableAuthService.interfaces.plugins \
-    import IChallengePlugin
-from Products.PluggableAuthService.interfaces.plugins \
-    import ICredentialsResetPlugin
-from Products.PluggableAuthService.interfaces.plugins \
-    import ICredentialsUpdatePlugin
-from Products.PluggableAuthService.interfaces.plugins \
-    import ILoginPasswordHostExtractionPlugin
-from Products.PluggableAuthService.plugins.CookieAuthHelper \
-    import CookieAuthHelper as BasePlugin
-from base64 import encodestring
-from urllib import quote
-from zope.interface import implementer
-
-
-def manage_addExtendedCookieAuthHelper(self, id, title='',
-                                       RESPONSE=None, **kw):
-    """Create an instance of a extended cookie auth helper.
-    """
-
-    self = self.this()
-
-    o = ExtendedCookieAuthHelper(id, title, **kw)
-    self._setObject(o.getId(), o)
-    o = getattr(aq_base(self), id)
-
-    if RESPONSE is not None:
-        RESPONSE.redirect('manage_workspace')
-
-manage_addExtendedCookieAuthHelperForm = DTMLFile(
-    "../zmi/ExtendedCookieAuthHelperForm",
-    globals()
-)
-
-
-@implementer(
-    ILoginPasswordHostExtractionPlugin,
-    IChallengePlugin,
-    ICredentialsUpdatePlugin,
-    ICredentialsResetPlugin
-)
-class ExtendedCookieAuthHelper(BasePlugin):
-    """Multi-plugin which adds ability to override the updating of cookie via
-    a setAuthCookie method/script.
-    """
-
-    meta_type = 'Extended Cookie Auth Helper'
-    security = ClassSecurityInfo()
-
-    @security.private
-    def updateCredentials(self, request, response, login, new_password):
-        """Override standard updateCredentials method
-        """
-
-        setAuthCookie = getattr(self, 'setAuthCookie', None)
-        if setAuthCookie:
-            cookie_val = encodestring('%s:%s' % (login, new_password))
-            cookie_val = cookie_val.rstrip()
-            setAuthCookie(response, self.cookie_name, quote(cookie_val))
-        else:
-            BasePlugin.updateCredentials(self, request, response, login,
-                                         new_password)
-
-    @security.public
-    def login(self):
-        """Set a cookie and redirect to the url that we tried to
-        authenticate against originally.
-
-        Override standard login method to avoid calling
-        'return response.redirect(came_from)' as there is additional
-        processing to ignore known bad come_from templates at
-        login_next.cpy script.
-        """
-        request = self.REQUEST
-        response = request['RESPONSE']
-
-        password = request.get('__ac_password', '')
-
-        user = getSecurityManager().getUser()
-        login = user.getUserName()
-        user_pas = aq_parent(user)
-
-        if IPluggableAuthService.providedBy(user_pas):
-            # Delegate to the users own PAS if possible
-            user_pas.updateCredentials(request, response, login, password)
-        else:
-            # User does not originate from a PAS user folder, so lets try
-            # to do our own thing.
-            # XXX Perhaps we should do nothing here; test with pure User
-            # Folder!
-            pas_instance = self._getPAS()
-            if pas_instance is not None:
-                pas_instance.updateCredentials(request, response, login,
-                                               password)
-
-
-InitializeClass(ExtendedCookieAuthHelper)
diff --git a/Products/PlonePAS/plugins/crumbler.py b/Products/PlonePAS/plugins/crumbler.py
deleted file mode 100644
index 9838693..0000000
--- a/Products/PlonePAS/plugins/crumbler.py
+++ /dev/null
@@ -1,73 +0,0 @@
-# -*- coding: utf-8 -*-
-""" Class: CookieCrumblingPlugin
-
-Acts as auth plugin, but injects cookie form credentials as HTTPBasicAuth.
-This allows form logins to fall through to parent user folders.
-
-"""
-from AccessControl.SecurityInfo import ClassSecurityInfo
-from Acquisition import aq_base
-from App.class_init import InitializeClass
-from App.special_dtml import DTMLFile
-from OFS.Folder import Folder
-from Products.CMFCore.CookieCrumbler import manage_addCC
-from Products.PluggableAuthService.interfaces.plugins import IExtractionPlugin
-from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
-from zope.interface import implementer
-import logging
-
-logger = logging.getLogger('PlonePAS')
-
-CC_ID = 'cookie_auth'
-
-
-def manage_addCookieCrumblingPlugin(self, id, title='',
-                                    RESPONSE=None, **kw):
-    """
-    Create an instance of a cookie crumbling plugin.
-    """
-    self = self.this()
-
-    o = CookieCrumblingPlugin(id, title, **kw)
-    self._setObject(o.getId(), o)
-    o = getattr(aq_base(self), id)
-
-    manage_addCC(o, CC_ID)
-
-    if RESPONSE is not None:
-        RESPONSE.redirect('manage_workspace')
-
-manage_addCookieCrumblingPluginForm = \
-    DTMLFile("../zmi/CookieCrumblingPluginForm", globals())
-
-
-@implementer(IExtractionPlugin)
-class CookieCrumblingPlugin(Folder, BasePlugin):
-    """Multi-plugin for injecting HTTP Basic Authentication
-    credentials from form credentials.
-    """
-    meta_type = 'Cookie Crumbling Plugin'
-
-    security = ClassSecurityInfo()
-
-    def __init__(self, id, title=None):
-        self._setId(id)
-        self.title = title
-
-    def _getCC(self):
-        return getattr(aq_base(self), CC_ID, None)
-
-    @security.private
-    def extractCredentials(self, request):
-        """ Extract basic auth credentials from 'request'.
-        """
-
-        try:
-            self._getCC().modifyRequest(request, request.RESPONSE)
-
-        except Exception, e:
-            logger.error("PlonePAS error: %s", e, exc_info=1)
-
-        return {}
-
-InitializeClass(CookieCrumblingPlugin)
diff --git a/Products/PlonePAS/plugins/group.py b/Products/PlonePAS/plugins/group.py
deleted file mode 100644
index cb46c5d..0000000
--- a/Products/PlonePAS/plugins/group.py
+++ /dev/null
@@ -1,289 +0,0 @@
-"""
-ZODB Group Implementation with basic introspection and
-management (ie. rw) capabilities.
-
-"""
-from AccessControl import ClassSecurityInfo
-from App.class_init import InitializeClass
-from App.special_dtml import DTMLFile
-from BTrees.OOBTree import OOBTree, OOSet
-from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
-from Products.PlonePAS.interfaces.capabilities import IGroupCapability
-from Products.PlonePAS.interfaces.group import IGroupIntrospection
-from Products.PlonePAS.interfaces.group import IGroupManagement
-from Products.PluggableAuthService.PluggableAuthService \
-    import _SWALLOWABLE_PLUGIN_EXCEPTIONS
-from Products.PluggableAuthService.interfaces.plugins \
-    import IGroupEnumerationPlugin
-from Products.PluggableAuthService.interfaces.plugins \
-    import IPropertiesPlugin
-from Products.PluggableAuthService.interfaces.plugins import IRolesPlugin
-from Products.PluggableAuthService.plugins.ZODBGroupManager \
-    import ZODBGroupManager
-from ufactory import PloneUser
-from zope.interface import implementer
-import logging
-
-manage_addGroupManagerForm = DTMLFile("../zmi/GroupManagerForm", globals())
-logger = logging.getLogger('PlonePAS')
-
-
-def manage_addGroupManager(self, id, title='', RESPONSE=None):
-    """
-    Add a zodb group manager with management and introspection
-    capabilities to pas.
-    """
-    grum = GroupManager(id, title)
-
-    self._setObject(grum.getId(), grum)
-
-    if RESPONSE is not None:
-        return RESPONSE.redirect('manage_workspace')
-
-
-@implementer(
-    IGroupManagement,
-    IGroupIntrospection,
-    IGroupCapability,
-    IDeleteCapability
-)
-class GroupManager(ZODBGroupManager):
-
-    meta_type = "Group Manager"
-    security = ClassSecurityInfo()
-
-    def __init__(self, *args, **kw):
-        ZODBGroupManager.__init__(self, *args, **kw)
-        # reverse index of groups->principal
-        self._group_principal_map = OOBTree()
-
-    #################################
-    # overrides to ease group principal lookups for introspection api
-
-    def addGroup(self, group_id, *args, **kw):
-        ZODBGroupManager.addGroup(self, group_id, *args, **kw)
-        self._group_principal_map[group_id] = OOSet()
-        return True
-
-    def removeGroup(self, group_id):
-        ZODBGroupManager.removeGroup(self, group_id)
-        del self._group_principal_map[group_id]
-        return True
-
-    def addPrincipalToGroup(self, principal_id, group_id):
-        ZODBGroupManager.addPrincipalToGroup(self, principal_id, group_id)
-        self._group_principal_map[group_id].insert(principal_id)
-        return True
-
-    def removePrincipalFromGroup(self, principal_id, group_id):
-        already = ZODBGroupManager.removePrincipalFromGroup(self, principal_id,
-                                                            group_id)
-        if already:
-            self._group_principal_map[group_id].remove(principal_id)
-        return True
-
-    #################################
-    # overrides for api matching/massage
-
-    def updateGroup(self, group_id, title=None, description=None):
-        ZODBGroupManager.updateGroup(self, group_id, title=title,
-                                     description=description)
-        return True
-
-    #################################
-    # introspection interface
-
-    def getGroupById(self, group_id, default=None):
-        plugins = self._getPAS()._getOb('plugins')
-        title = None
-        if group_id not in self.getGroupIds():
-            return default
-
-        return self._findGroup(plugins, group_id, title)
-
-    def getGroups(self):
-        return map(self.getGroupById, self.getGroupIds())
-
-    def getGroupIds(self):
-        return self.listGroupIds()
-
-    def getGroupMembers(self, group_id):
-        return tuple(self._group_principal_map.get(group_id, ()))
-
-    #################################
-    # capabilties interface impls.
-
-    @security.public
-    def allowDeletePrincipal(self, principal_id):
-        """True iff this plugin can delete a certain group.
-        This is true if this plugin manages the group.
-        """
-        if self._groups.get(principal_id) is not None:
-            return 1
-        return 0
-
-    def getGroupInfo(self, group_id):
-        """Over-ride parent to not explode when getting group info dict by
-        group id."""
-        return self._groups.get(group_id, None)
-
-    def allowGroupAdd(self, user_id, group_id):
-        """True iff this plugin will allow adding a certain user to a
-        certain group."""
-        present = self.getGroupInfo(group_id)
-        # if we have a group, we can add users to it
-        # slightly naive, but should be okay.
-        if present:
-            return 1
-
-        return 0
-
-    def allowGroupRemove(self, user_id, group_id):
-        """True iff this plugin will allow removing a certain user from a
-        certain group."""
-        present = self.getGroupInfo(group_id)
-        # if we don't have a group, we can't do anything
-        if not present:
-            return 0
-
-        group_members = self.getGroupMembers(group_id)
-        if user_id in group_members:
-            return 1
-        return 0
-
-    #################################
-    # group wrapping mechanics
-
-    @security.private
-    def _createGroup(self, plugins, group_id, name):
-        """ Create group object. For users, this can be done with a
-        plugin, but I don't care to define one for that now. Just uses
-        PloneGroup.  But, the code's still here, just commented out.
-        This method based on PluggableAuthervice._createUser
-        """
-        return PloneGroup(group_id, name).__of__(self)
-
-    @security.private
-    def _findGroup(self, plugins, group_id, title=None, request=None):
-        """ group_id -> decorated_group
-        This method based on PluggableAuthService._findGroup
-        """
-        group = self._createGroup(plugins, group_id, title)
-
-        propfinders = plugins.listPlugins(IPropertiesPlugin)
-        for propfinder_id, propfinder in propfinders:
-
-            data = propfinder.getPropertiesForUser(group, request)
-            if data:
-                group.addPropertysheet(propfinder_id, data)
-
-        groups = self._getPAS()._getGroupsForPrincipal(group, request,
-                                                       plugins=plugins)
-        group._addGroups(groups)
-
-        rolemakers = plugins.listPlugins(IRolesPlugin)
-
-        for rolemaker_id, rolemaker in rolemakers:
-            roles = rolemaker.getRolesForPrincipal(group, request)
-            if roles:
-                group._addRoles(roles)
-
-        group._addRoles(['Authenticated'])
-
-        return group.__of__(self)
-
-    @security.private
-    def _verifyGroup(self, plugins, group_id=None, title=None):
-
-        """ group_id -> boolean
-        This method based on PluggableAuthService._verifyUser
-        """
-        criteria = {}
-
-        if group_id is not None:
-            criteria['id'] = group_id
-            criteria['exact_match'] = True
-
-        if title is not None:
-            criteria['title'] = title
-
-        if criteria:
-            enumerators = plugins.listPlugins(IGroupEnumerationPlugin)
-
-            for enumerator_id, enumerator in enumerators:
-                try:
-                    info = enumerator.enumerateGroups(**criteria)
-
-                    if info:
-                        return info[0]['id']
-
-                except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-                    logger.info(
-                       'PluggableAuthService: GroupEnumerationPlugin %s error',
-                       enumerator_id, exc_info=1)
-
-        return 0
-
-
-InitializeClass(GroupManager)
-
-
-class PloneGroup(PloneUser):
-    """Plone expects a user to come, with approximately the same
-    behavior as a user.
-    """
-
-    security = ClassSecurityInfo()
-    _isGroup = True
-
-    def getId(self, unprefixed=None):
-        """ -> user ID
-        Modified to accept silly GRUF param.
-        """
-        return self._id
-
-    @security.private
-    def getMemberIds(self, transitive=1):
-        """Return member ids of this group, including or not
-        transitive groups.
-        """
-        # acquired from the groups_source
-        plugins = self._getPAS().plugins
-        introspectors = plugins.listPlugins(IGroupIntrospection)
-        members = []
-        for iid, introspector in introspectors:
-            try:
-                members.extend(
-                    list(introspector.getGroupMembers(self.getId())))
-            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-                logger.info(
-                    'PluggableAuthService: getGroupMembers %s error',
-                    iid, exc_info=1)
-
-        return members
-
-    @security.public
-    def addMember(self, id):
-        """Add the existing member with the given id to the group
-        """
-        self.addPrincipalToGroup(id, self.getId())
-
-    @security.public
-    def removeMember(self, id):
-        """Remove the member with the provided id from the group.
-        """
-        self.removePrincipalFromGroup(id, self.getId())
-
-    @security.public
-    def getRolesInContext(self, object):
-        """Since groups can't actually log in, do nothing.
-        """
-        return []
-
-    @security.public
-    def allowed(self, object, object_roles=None):
-        """Since groups can't actually log in, do nothing.
-        """
-        return 0
-
-InitializeClass(PloneGroup)
diff --git a/Products/PlonePAS/plugins/local_role.py b/Products/PlonePAS/plugins/local_role.py
deleted file mode 100644
index 7748ece..0000000
--- a/Products/PlonePAS/plugins/local_role.py
+++ /dev/null
@@ -1,186 +0,0 @@
-"""
-A Local Roles Plugin Implementation that respects Black Listing markers.
-
-ie. containers/objects which denote that they do not wish to acquire local
-roles from their containment structure.
-
-"""
-from AccessControl import ClassSecurityInfo
-from Acquisition import aq_inner, aq_parent
-from App.class_init import InitializeClass
-from App.special_dtml import DTMLFile
-from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
-from Products.PluggableAuthService.plugins.LocalRolePlugin \
-    import LocalRolePlugin
-from zope.interface import implementer
-
-
-def manage_addLocalRolesManager(dispatcher, id, title=None, RESPONSE=None):
-    """
-    add a local roles manager
-    """
-    lrm = LocalRolesManager(id, title)
-    dispatcher._setObject(lrm.getId(), lrm)
-
-    if RESPONSE is not None:
-        RESPONSE.redirect('manage_workspace')
-
-manage_addLocalRolesManagerForm = \
-    DTMLFile('../zmi/LocalRolesManagerForm', globals())
-
-
-@implementer(ILocalRolesPlugin)
-class LocalRolesManager(LocalRolePlugin):
-    """Class incorporating local role storage with
-    PlonePAS-specific local role permission checking.
-    """
-
-    meta_type = "Local Roles Manager"
-    security = ClassSecurityInfo()
-
-    def __init__(self, id, title=None):
-        self._id = self.id = id
-        self.title = title
-
-    #security.declarePrivate( 'getRolesInContext' )
-    def getRolesInContext(self, user, object):
-        user_id = user.getId()
-        group_ids = user.getGroups()
-
-        principal_ids = list(group_ids)
-        principal_ids.insert(0, user_id)
-
-        local = {}
-        object = aq_inner(object)
-
-        while 1:
-            local_roles = getattr(object, '__ac_local_roles__', None)
-
-            if local_roles and callable(local_roles):
-                local_roles = local_roles()
-
-            if local_roles:
-                dict = local_roles
-
-                for principal_id in principal_ids:
-                    for role in dict.get(principal_id, []):
-                        local[role] = 1
-
-            inner = aq_inner(object)
-            parent = aq_parent(inner)
-
-            if getattr(object, '__ac_local_roles_block__', None):
-                break
-
-            if parent is not None:
-                object = parent
-                continue
-
-            new = getattr(object, 'im_self', None)
-
-            if new is not None:
-                object = aq_inner(new)
-                continue
-
-            break
-
-        return local.keys()
-
-    #security.declarePrivate( 'checkLocalRolesAllowed' )
-    def checkLocalRolesAllowed(self, user, object, object_roles):
-        # Still have not found a match, so check local roles. We do
-        # this manually rather than call getRolesInContext so that
-        # we can incur only the overhead required to find a match.
-        inner_obj = aq_inner(object)
-        user_id = user.getId()
-        group_ids = user.getGroups()
-
-        principal_ids = list(group_ids)
-        principal_ids.insert(0, user_id)
-
-        while 1:
-
-            local_roles = getattr(inner_obj, '__ac_local_roles__', None)
-
-            if local_roles and callable(local_roles):
-                local_roles = local_roles()
-
-            if local_roles:
-                dict = local_roles
-
-                for principal_id in principal_ids:
-                    local_roles = dict.get(principal_id, [])
-
-                    # local_roles is empty most of the time, where as
-                    # object_roles is usually not.
-                    if not local_roles:
-                        continue
-
-                    for role in object_roles:
-                        if role in local_roles:
-                            if user._check_context(object):
-                                return 1
-                            return 0
-
-            inner = aq_inner(inner_obj)
-            parent = aq_parent(inner)
-
-            if getattr(inner_obj, '__ac_local_roles_block__', None):
-                break
-
-            if parent is not None:
-                inner_obj = parent
-                continue
-
-            new = getattr(inner_obj, 'im_self', None)
-
-            if new is not None:
-                inner_obj = aq_inner(new)
-                continue
-
-            break
-
-        return None
-
-    def getAllLocalRolesInContext(self, context):
-        roles = {}
-        object = aq_inner(context)
-
-        while True:
-
-            local_roles = getattr(object, '__ac_local_roles__', None)
-
-            if local_roles and callable(local_roles):
-                local_roles = local_roles()
-
-            if local_roles:
-
-                dict = local_roles
-
-                for principal, localroles in dict.items():
-                    if principal not in roles:
-                        roles[principal] = set()
-
-                    roles[principal].update(localroles)
-
-            inner = aq_inner(object)
-            parent = aq_parent(inner)
-
-            if getattr(object, '__ac_local_roles_block__', None):
-                break
-
-            if parent is not None:
-                object = parent
-                continue
-
-            new = getattr(object, 'im_self', None)
-
-            if new is not None:
-                object = aq_inner(new)
-                continue
-
-            break
-
-        return roles
-
-InitializeClass(LocalRolesManager)
diff --git a/Products/PlonePAS/plugins/passwordpolicy.py b/Products/PlonePAS/plugins/passwordpolicy.py
deleted file mode 100644
index b0eee47..0000000
--- a/Products/PlonePAS/plugins/passwordpolicy.py
+++ /dev/null
@@ -1,76 +0,0 @@
-"""
-Password Validation plugin (IValidationPlugin)
-Mutable Property Provider
-"""
-from AccessControl import ClassSecurityInfo
-from App.class_init import InitializeClass
-from Products.PageTemplates.PageTemplateFile import PageTemplateFile
-from Products.PluggableAuthService.interfaces.plugins import IValidationPlugin
-from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
-from zope.i18nmessageid import MessageFactory
-from zope.interface import implementer
-
-_ = MessageFactory('plone')
-
-manage_addPasswordPolicyForm = PageTemplateFile(
-    "../zmi/PasswordPolicyForm",
-    globals()
-)
-
-
-def manage_addPasswordPolicyPlugin(self, id, title='',
-                                   RESPONSE=None, schema=None, **kw):
-    """
-    Create an instance of a password validation plugin.
-    """
-    o = PasswordPolicyPlugin(id, title)
-    self._setObject(o.getId(), o)
-
-    if RESPONSE is not None:
-        return RESPONSE.redirect(
-            "%s/manage_workspace?"
-            "manage_tabs_message=DefaultPasswordPlugin+plugin+added" %
-            self.absolute_url()
-        )
-
-
-@implementer(IValidationPlugin)
-class PasswordPolicyPlugin(BasePlugin):
-    """Simple Password Policy to ensure password is 5 chars long.
-    """
-
-    meta_type = 'Default Plone Password Policy'
-
-    security = ClassSecurityInfo()
-
-    def __init__(self, id, title=''):
-        """Create a default plone password policy to ensure 5 char passwords
-        """
-        self.id = id
-        self.title = title
-
-    @security.private
-    def validateUserInfo(self, user, set_id, set_info):
-        """ See IValidationPlugin. Used to validate password property
-        """
-
-        if not set_info:
-            return []
-        password = set_info.get('password', None)
-        if password is None:
-            return []
-        elif password == '':
-            return [{'id': 'password', 'error': _(u'Minimum 5 characters.')}]
-        elif len(password) < 5:
-            return [
-                {
-                    'id': 'password',
-                    'error': _(
-                        u'Your password must contain at least 5 characters.'
-                    )
-                }
-            ]
-        else:
-            return []
-
-InitializeClass(PasswordPolicyPlugin)
diff --git a/Products/PlonePAS/plugins/property.py b/Products/PlonePAS/plugins/property.py
deleted file mode 100644
index 3d6cb6b..0000000
--- a/Products/PlonePAS/plugins/property.py
+++ /dev/null
@@ -1,292 +0,0 @@
-# -*- coding: utf-8 -*-
-"""
-Mutable Property Provider
-"""
-from AccessControl import ClassSecurityInfo
-from App.class_init import InitializeClass
-from App.special_dtml import DTMLFile
-from BTrees.OOBTree import OOBTree
-from Products.CMFCore.utils import getToolByName
-from Products.PlonePAS.interfaces.plugins import IMutablePropertiesPlugin
-from Products.PlonePAS.sheet import MutablePropertySheet, validateValue
-from Products.PlonePAS.utils import safe_unicode
-from Products.PluggableAuthService.UserPropertySheet import _guessSchema
-from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
-from Products.PluggableAuthService.interfaces.plugins \
-    import IUserEnumerationPlugin
-from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
-from ZODB.PersistentMapping import PersistentMapping
-from zope.i18nmessageid import MessageFactory
-from zope.interface import implementer
-import copy
-
-_ = MessageFactory('plone')
-
-
-def manage_addZODBMutablePropertyProvider(self, id, title='',
-                                          RESPONSE=None, schema=None, **kw):
-    """
-    Create an instance of a mutable property manager.
-    """
-    o = ZODBMutablePropertyProvider(id, title, schema, **kw)
-    self._setObject(o.getId(), o)
-
-    if RESPONSE is not None:
-        RESPONSE.redirect('manage_workspace')
-
-manage_addZODBMutablePropertyProviderForm = DTMLFile(
-    "../zmi/MutablePropertyProviderForm", globals())
-
-
-def isStringType(data):
-    return isinstance(data, str) or isinstance(data, unicode)
-
-
-@implementer(
-    IPropertiesPlugin,
-    IUserEnumerationPlugin,
-    IMutablePropertiesPlugin
-)
-class ZODBMutablePropertyProvider(BasePlugin):
-    """Storage for mutable properties in the ZODB for users/groups.
-
-    API sounds like it's only for users, but groups work as well.
-    """
-
-    meta_type = 'ZODB Mutable Property Provider'
-
-    security = ClassSecurityInfo()
-
-    def __init__(self, id, title='', schema=None, **kw):
-        """Create in-ZODB mutable property provider.
-
-        Provide a schema either as a list of (name,type,value) tuples
-        in the 'schema' parameter or as a series of keyword parameters
-        'name=value'. Types will be guessed in this case.
-
-        The 'value' is meant as the default value, and will be used
-        unless the user provides data.
-
-        If no schema is provided by constructor, the properties of the
-        portal_memberdata object will be used.
-
-        Types available: string, text, boolean, int, long, float, lines, date
-        """
-        self.id = id
-        self.title = title
-        self._storage = OOBTree()
-
-        # calculate schema and default values
-        defaultvalues = {}
-        if not schema and not kw:
-            schema = ()
-        elif not schema and kw:
-            schema = _guessSchema(kw)
-            defaultvalues = kw
-        else:
-            valuetuples = [(name, value) for name, type, value in schema]
-            schema = [(name, type) for name, type, value in schema]
-            for name, value in valuetuples:
-                defaultvalues[name] = value
-        self._schema = tuple(schema)
-        self._defaultvalues = defaultvalues
-
-    def _getSchema(self, isgroup=None):
-        # this could probably stand to be cached
-        datatool = isgroup and "portal_groupdata" or "portal_memberdata"
-
-        schema = self._schema
-        if not schema:
-            # if no schema is provided, use portal_memberdata properties
-            schema = ()
-            mdtool = getToolByName(self, datatool, None)
-            # Don't fail badly if tool is not available.
-            if mdtool is not None:
-                mdschema = mdtool.propertyMap()
-                schema = [(elt['id'], elt['type']) for elt in mdschema]
-        return schema
-
-    def _getDefaultValues(self, isgroup=None):
-        """Returns a dictionary mapping of property names to default values.
-        Defaults to portal_*data tool if necessary.
-        """
-        datatool = isgroup and "portal_groupdata" or "portal_memberdata"
-
-        defaultvalues = self._defaultvalues
-        if not self._schema:
-            # if no schema is provided, use portal_*data properties
-            defaultvalues = {}
-            mdtool = getToolByName(self, datatool, None)
-            # Don't fail badly if tool is not available.
-            if mdtool is not None:
-                # we rely on propertyMap and propertyItems mapping
-                mdvalues = mdtool.propertyItems()
-                for name, value in mdvalues:
-                    # For selection types the default value is the name of a
-                    # method which returns the possible values. There is no way
-                    # to set a default value for those types.
-                    ptype = mdtool.getPropertyType(name)
-                    if ptype == "selection":
-                        defaultvalues[name] = ""
-                    elif ptype == "multiple selection":
-                        defaultvalues[name] = []
-                    else:
-                        defaultvalues[name] = value
-
-            # ALERT! if someone gives their *_data tool a title, and want a
-            #        title as a property of the user/group (and groups do by
-            #        default) we don't want them all to have this title, since
-            #        a title is used in the UI if it exists
-            if defaultvalues.get("title"):
-                defaultvalues["title"] = ""
-        return defaultvalues
-
-    @security.private
-    def getPropertiesForUser(self, user, request=None):
-        """Get property values for a user or group.
-        Returns a dictionary of values or a PropertySheet.
-
-        This implementation will always return a MutablePropertySheet.
-
-        NOTE: Must always return something, or else the property sheet
-        won't get created and this will screw up portal_memberdata.
-        """
-        isGroup = getattr(user, 'isGroup', lambda: None)()
-
-        data = self._storage.get(user.getId())
-        defaults = self._getDefaultValues(isGroup)
-
-        # provide default values where missing
-        if not data:
-            data = {}
-        for key, val in defaults.items():
-            if key not in data:
-                data[key] = val
-
-        return MutablePropertySheet(self.id,
-                                    schema=self._getSchema(isGroup), **data)
-
-    @security.private
-    def setPropertiesForUser(self, user, propertysheet):
-        """Set the properties of a user or group based on the contents of a
-        property sheet.
-        """
-        isGroup = getattr(user, 'isGroup', lambda: None)()
-
-        properties = dict(propertysheet.propertyItems())
-
-        for name, property_type in self._getSchema(isGroup) or ():
-            if (
-                name in properties and not
-                validateValue(property_type, properties[name])
-            ):
-                raise ValueError(
-                    'Invalid value: %s does not conform to %s' %
-                    (name, property_type)
-                )
-
-        allowed_prop_keys = [pn for pn, pt in self._getSchema(isGroup) or ()]
-        if allowed_prop_keys:
-            prop_names = set(properties.keys()) - set(allowed_prop_keys)
-            if prop_names:
-                raise ValueError('Unknown Properties: %r' % prop_names)
-
-        userid = user.getId()
-        userprops = self._storage.get(userid)
-        properties.update({'isGroup': isGroup})
-        if userprops is not None:
-            userprops.update(properties)
-            # notify persistence machinery of change
-            self._storage[userid] = self._storage[userid]
-        else:
-            self._storage.insert(user.getId(), properties)
-
-    @security.private
-    def deleteUser(self, user_id):
-        """Delete all user properties
-        """
-        # Do nothing if an unknown user_id is given
-        try:
-            del self._storage[user_id]
-        except KeyError:
-            pass
-
-    @security.private
-    def testMemberData(self, memberdata, criteria, exact_match=False):
-        """Test if a memberdata matches the search criteria.
-        """
-        for (key, value) in criteria.items():
-            testvalue = memberdata.get(key, None)
-            if testvalue is None:
-                return False
-
-            if isStringType(testvalue):
-                testvalue = safe_unicode(testvalue.lower())
-            if isStringType(value):
-                value = safe_unicode(value.lower())
-
-            if exact_match:
-                if value != testvalue:
-                    return False
-            else:
-                try:
-                    if value not in testvalue:
-                        return False
-                except TypeError:
-                    # Fall back to exact match if we can check for
-                    # sub-component
-                    if value != testvalue:
-                        return False
-
-        return True
-
-    @security.private
-    def enumerateUsers(self, id=None, login=None,
-                       exact_match=False, **kw):
-        """ See IUserEnumerationPlugin.
-        """
-        plugin_id = self.getId()
-
-        # This plugin can't search for a user by id or login, because there is
-        # no such keys in the storage (data dict in the comprehensive list)
-        # If kw is empty or not, we continue the search.
-        if id is not None or login is not None:
-            return ()
-
-        criteria = copy.copy(kw)
-
-        users = [(user, data) for (user, data) in self._storage.items()
-                 if self.testMemberData(data, criteria, exact_match)
-                 and not data.get('isGroup', False)]
-
-        user_info = [{'id': self.prefix + user_id,
-                      'login': user_id,
-                      'title': data.get('fullname', user_id),
-                      'description': data.get('fullname', user_id),
-                      'email': data.get('email', ''),
-                      'pluginid': plugin_id} for (user_id, data) in users]
-
-        return tuple(user_info)
-
-    def updateUser(self, user_id, login_name):
-        """ Update the login name of the user with id user_id.
-
-        This is a new part of the IUserEnumerationPlugin interface, but
-        not interesting for us.
-        """
-        pass
-
-    def updateEveryLoginName(self, quit_on_first_error=True):
-        """Update login names of all users to their canonical value.
-
-        This is a new part of the IUserEnumerationPlugin interface, but
-        not interesting for us.
-        """
-        pass
-
-
-InitializeClass(ZODBMutablePropertyProvider)
-
-
-class PersistentProperties(PersistentMapping):
-    pass
diff --git a/Products/PlonePAS/plugins/role.py b/Products/PlonePAS/plugins/role.py
deleted file mode 100644
index 5684ed3..0000000
--- a/Products/PlonePAS/plugins/role.py
+++ /dev/null
@@ -1,161 +0,0 @@
-# -*- coding: utf-8 -*-
-"""
-group aware role manager, returns roles assigned to group a principal
-is a member of, in addition to the explicit roles assigned directly
-to the principal.
-
-"""
-from AccessControl import ClassSecurityInfo
-from AccessControl.requestmethod import postonly
-from Acquisition import aq_parent
-from Acquisition import aq_inner
-from Acquisition import aq_get
-from App.class_init import InitializeClass
-from App.special_dtml import DTMLFile
-from Products.PlonePAS.interfaces.capabilities import IAssignRoleCapability
-from Products.PlonePAS.utils import getGroupsForPrincipal
-from Products.PluggableAuthService.permissions import ManageUsers
-from Products.PluggableAuthService.plugins.ZODBRoleManager \
-    import ZODBRoleManager
-from zope.interface import implementer
-
-
-def manage_addGroupAwareRoleManager(self, id, title='', RESPONSE=None):
-    """
-    this is a doc string
-    """
-    garm = GroupAwareRoleManager(id, title)
-    self._setObject(garm.getId(), garm)
-
-    if RESPONSE is not None:
-        RESPONSE.redirect('manage_workspace')
-
-manage_addGroupAwareRoleManagerForm = DTMLFile(
-    '../zmi/GroupAwareRoleManagerForm', globals())
-
-
-@implementer(IAssignRoleCapability)
-class GroupAwareRoleManager(ZODBRoleManager):
-
-    meta_type = "Group Aware Role Manager"
-    security = ClassSecurityInfo()
-
-    def updateRolesList(self):
-        role_holder = aq_parent(aq_inner(self._getPAS()))
-        for role in getattr(role_holder, '__ac_roles__', ()):
-            if role not in ('Anonymous', 'Authenticated') and \
-                    role not in self._roles:
-                try:
-                    self.addRole(role)
-                except KeyError:
-                    pass
-
-    # don't blow up if manager already exists; mostly for ZopeVersionControl
-    def manage_afterAdd(self, item, container):
-        try:
-            self.addRole('Manager')
-        except KeyError:
-            pass
-
-        if item is self:
-            self.updateRolesList()
-
-    @security.protected(ManageUsers)
-    def assignRoleToPrincipal(self, role_id, principal_id, REQUEST=None):
-        try:
-            return ZODBRoleManager.assignRoleToPrincipal(
-                                        self, role_id, principal_id)
-        except KeyError:
-            # Lazily update our roles list and try again
-            self.updateRolesList()
-            return ZODBRoleManager.assignRoleToPrincipal(
-                                        self, role_id, principal_id)
-
-    @security.protected(ManageUsers)
-    def assignRolesToPrincipal(self, roles, principal_id, REQUEST=None):
-        """ Assign a specific set of roles, and only those roles, to a
-        principal.
-
-        o no return value
-
-        o Raise KeyError if a role_id is unknown.
-        """
-        for role_id in roles:
-            if role_id not in ('Authenticated', 'Anonymous', 'Owner'):
-                try:
-                    # raise KeyError if unknown!
-                    self._roles[role_id]
-                except KeyError:
-                    # Lazily update our roles list and try again
-                    self.updateRolesList()
-                    if role_id in self._roles:
-                        # check if this role is managed by this plugin, and
-                        # set it
-                        self._roles[role_id]
-
-        self._principal_roles[principal_id] = tuple(roles)
-
-    assignRolesToPrincipal = postonly(assignRolesToPrincipal)
-
-    @security.private
-    def getRolesForPrincipal(self, principal, request=None):
-        """ See IRolesPlugin.
-        """
-        roles = set([])
-        principal_ids = set([])
-        # Some services need to determine the roles obtained from groups
-        # while excluding the directly assigned roles.  In this case
-        # '__ignore_direct_roles__' = True should be pushed in the request.
-        request = aq_get(self, 'REQUEST', None)
-        if request is None \
-           or not request.get('__ignore_direct_roles__', False):
-            principal_ids.add(principal.getId())
-
-        # Some services may need the real roles of an user but **not**
-        # the ones he got through his groups. In this case, the
-        # '__ignore_group_roles__'= True should be previously pushed
-        # in the request.
-        plugins = self._getPAS()['plugins']
-        if request is None \
-           or not request.get('__ignore_group_roles__', False):
-            principal_ids.update(
-                getGroupsForPrincipal(principal, plugins, request)
-            )
-        for pid in principal_ids:
-            roles.update(self._principal_roles.get(pid, ()))
-        return tuple(roles)
-
-    # implement IAssignRoleCapability
-
-    def allowRoleAssign(self, user_id, role_id):
-        """True iff this plugin will allow assigning a certain user a
-        certain role.
-
-        Note that at least currently this only checks if the role_id
-        exists.  If it exists, this method returns True.  Nothing is
-        done with the user_id parameter.  This might be wrong.  See
-        http://dev.plone.org/plone/ticket/7762
-        """
-        present = self.getRoleInfo(role_id)
-        if present:
-            # if we have a role, we can assign it
-            # slightly naive, but should be okay.
-            return 1
-
-        return 0
-
-    def listRoleIds(self):
-        self.updateRolesList()
-        return ZODBRoleManager.listRoleIds(self)
-
-    def listRoleInfo(self):
-        self.updateRolesList()
-        return ZODBRoleManager.listRoleInfo(self)
-
-    def getRoleInfo(self, role_id):
-        if role_id not in self._roles:
-            self.updateRolesList()
-        return ZODBRoleManager.getRoleInfo(self, role_id)
-
-
-InitializeClass(GroupAwareRoleManager)
diff --git a/Products/PlonePAS/plugins/ufactory.py b/Products/PlonePAS/plugins/ufactory.py
deleted file mode 100644
index db24491..0000000
--- a/Products/PlonePAS/plugins/ufactory.py
+++ /dev/null
@@ -1,235 +0,0 @@
-# -*- coding: utf-8 -*-
-from AccessControl import ClassSecurityInfo
-from AccessControl.PermissionRole import _what_not_even_god_should_do
-from App.class_init import InitializeClass
-from App.special_dtml import DTMLFile
-from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
-from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
-from Products.PluggableAuthService.PropertiedUser import PropertiedUser
-from Products.PluggableAuthService.UserPropertySheet import UserPropertySheet
-from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
-from Products.PluggableAuthService.interfaces.plugins import IUserFactoryPlugin
-from Products.PluggableAuthService.interfaces.propertysheets \
-    import IPropertySheet
-from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
-from collections import OrderedDict
-from zope.interface import implementer
-
-manage_addPloneUserFactoryForm = DTMLFile('../zmi/PloneUserFactoryForm',
-                                          globals())
-
-_marker = object()
-
-
-def manage_addPloneUserFactory(self, id, title='', RESPONSE=None):
-    """
-    Add a plone user factory
-    """
-
-    puf = PloneUserFactory(id, title)
-    self._setObject(puf.getId(), puf)
-
-    if RESPONSE is not None:
-        return RESPONSE.redirect('manage_workspace')
-
-
-@implementer(IUserFactoryPlugin)
-class PloneUserFactory(BasePlugin):
-
-    security = ClassSecurityInfo()
-    meta_type = 'Plone User Factory'
-
-    def __init__(self, id, title=''):
-        self.id = id
-        self.title = title or self.meta_type
-
-    @security.private
-    def createUser(self, user_id, name):
-        return PloneUser(user_id, name)
-
-
-InitializeClass(PloneUserFactory)
-
-
-class PloneUser(PropertiedUser):
-
-    security = ClassSecurityInfo()
-
-    #################################
-    # GRUF API
-    _isGroup = False
-
-    def __init__(self, id, login=None):
-        super(PloneUser, self).__init__(id, login)
-        self._propertysheets = OrderedDict()
-
-    def _getPAS(self):
-        # XXX This is not very optimal *at all*
-        return self.acl_users
-
-    def _getPlugins(self):
-        # XXX This is not very optimal *at all*
-        return self._getPAS().plugins
-
-    @security.public
-    def isGroup(self):
-        """Return 1 if this user is a group abstraction"""
-        return self._isGroup
-
-    @security.public
-    def getName(self):
-        """Get user's or group's name.
-        This is the id. PAS doesn't do prefixes and such like GRUF.
-        """
-        return self.getId()
-
-    @security.public
-    def getUserId(self):
-        """Get user's or group's name.
-        This is the id. PAS doesn't do prefixes and such like GRUF.
-        """
-        return self.getId()
-
-    @security.public
-    def getGroupNames(self):
-        """Return ids of this user's groups. GRUF compat."""
-        return self.getGroups()
-
-    security.declarePublic('getGroupIds')
-    getGroupIds = getGroupNames
-
-    #################################
-    # acquisition aware
-
-    @security.public
-    def getPropertysheet(self, id):
-        """ -> propertysheet (wrapped if supported)
-        """
-        sheet = self._propertysheets[id]
-        try:
-            return sheet.__of__(self)
-        except AttributeError:
-            return sheet
-
-    @security.private
-    def addPropertysheet(self, id, data):
-        """ -> add a prop sheet, given data which is either
-        a property sheet or a raw mapping.
-        """
-        if IPropertySheet.providedBy(data):
-            sheet = data
-        else:
-            sheet = UserPropertySheet(id, **data)
-
-        if self._propertysheets.get(id) is not None:
-            raise KeyError('Duplicate property sheet: %s' % id)
-
-        self._propertysheets[id] = sheet
-
-    def _getPropertyPlugins(self):
-        return self._getPAS().plugins.listPlugins(IPropertiesPlugin)
-
-    @security.private
-    def getOrderedPropertySheets(self):
-        return self._propertysheets.values()
-
-    #################################
-    # local roles plugin type delegation
-
-    def _getLocalRolesPlugins(self):
-        return self._getPAS().plugins.listPlugins(ILocalRolesPlugin)
-
-    def getRolesInContext(self, object):
-        lrmanagers = self._getLocalRolesPlugins()
-        roles = set([])
-        for lrid, lrmanager in lrmanagers:
-            roles.update(lrmanager.getRolesInContext(self, object))
-        roles.update(self.getRoles())
-        return list(roles)
-
-    def allowed(self, object, object_roles=None):
-        if object_roles is _what_not_even_god_should_do:
-            return 0
-
-        # Short-circuit the common case of anonymous access.
-        if object_roles is None or 'Anonymous' in object_roles:
-            return 1
-
-        # Provide short-cut access if object is protected by 'Authenticated'
-        # role and user is not nobody
-        if 'Authenticated' in object_roles \
-           and self.getUserName() != 'Anonymous User':
-            return 1
-
-        # Check for ancient role data up front, convert if found.
-        # This should almost never happen, and should probably be
-        # deprecated at some point.
-        if 'Shared' in object_roles:
-            object_roles = self._shared_roles(object)
-            if object_roles is None or 'Anonymous' in object_roles:
-                return 1
-
-        # Check for a role match with the normal roles given to
-        # the user, then with local roles only if necessary. We
-        # want to avoid as much overhead as possible.
-        user_roles = self.getRoles()
-        for role in object_roles:
-            if role in user_roles:
-                if self._check_context(object):
-                    return 1
-                return None
-
-        # check for local roles
-        lrmanagers = self._getLocalRolesPlugins()
-
-        for lrid, lrm in lrmanagers:
-            allowed = lrm.checkLocalRolesAllowed(self, object, object_roles)
-            # return values
-            # 0, 1, None
-            # - 1 success
-            # - 0 object context violation
-            # - None - failure
-            if allowed is None:
-                continue
-            return allowed
-        return None
-
-    def setProperties(self, properties=None, **kw):
-        """ Set properties on a given user.
-
-        Accepts either keyword arguments or a mapping for the ``properties``
-        argument. The ``properties`` argument will take precedence over
-        keyword arguments if both are provided; no merging will occur.
-        """
-        if properties is None:
-            properties = kw
-
-        for sheet in self.getOrderedPropertySheets():
-            if not IMutablePropertySheet.providedBy(sheet):
-                continue
-
-            update = {}
-            for (key, value) in properties.items():
-                if sheet.hasProperty(key):
-                    update[key] = value
-                    del properties[key]
-
-            if update:
-                sheet.setProperties(self, update)
-
-    def getProperty(self, id, default=_marker):
-        for sheet in self.getOrderedPropertySheets():
-            if sheet.hasProperty(id):
-                value = sheet.getProperty(id)
-                if isinstance(value, unicode):
-                    # XXX Temporarily work around the fact that
-                    # property sheets blindly store and return
-                    # unicode. This is sub-optimal and should be
-                    # dealed with at the property sheets level by
-                    # using Zope's converters.
-                    return value.encode('utf-8')
-                return value
-
-        return default
-
-InitializeClass(PloneUser)
diff --git a/Products/PlonePAS/plugins/user.py b/Products/PlonePAS/plugins/user.py
deleted file mode 100644
index 79ee8f0..0000000
--- a/Products/PlonePAS/plugins/user.py
+++ /dev/null
@@ -1,132 +0,0 @@
-# -*- coding: utf-8 -*-
-"""
-ZODB based user manager with introspection and management interfaces.
-"""
-from AccessControl import AuthEncoding
-from AccessControl import ClassSecurityInfo
-from AccessControl.Permissions import manage_users as ManageUsers
-from App.class_init import InitializeClass
-from App.special_dtml import DTMLFile
-from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
-from Products.PlonePAS.interfaces.capabilities import IPasswordSetCapability
-from Products.PlonePAS.interfaces.plugins import IUserIntrospection
-from Products.PlonePAS.interfaces.plugins import IUserManagement
-from Products.PluggableAuthService.plugins.ZODBUserManager \
-    import ZODBUserManager as BasePlugin
-from Products.PluggableAuthService.utils import createViewName
-from zope.interface import implementer
-
-manage_addUserManagerForm = DTMLFile('../zmi/UserManagerForm', globals())
-
-
-def manage_addUserManager(dispatcher, id, title=None, REQUEST=None):
-    """ Add a UserManager to a Pluggable Auth Service. """
-
-    pum = UserManager(id, title)
-    dispatcher._setObject(pum.getId(), pum)
-
-    if REQUEST is not None:
-        REQUEST['RESPONSE'].redirect(
-            '%s/manage_workspace'
-            '?manage_tabs_message='
-            'UserManager+added.'
-            % dispatcher.absolute_url())
-
-
-@implementer(
-    IUserManagement,
-    IUserIntrospection,
-    IDeleteCapability,
-    IPasswordSetCapability
-)
-class UserManager(BasePlugin):
-    """PAS plugin for managing users. (adds write API)
-    """
-
-    meta_type = 'User Manager'
-    security = ClassSecurityInfo()
-
-    @security.protected(ManageUsers)
-    def addUser(self, user_id, login_name, password):
-        """Original ZODBUserManager.addUser, modified to check if
-        incoming password is already encypted.
-
-        This support clean migration from default user source.
-        Should go into PAS.
-        """
-        if self._user_passwords.get(user_id) is not None:
-            raise KeyError('Duplicate user ID: %s' % user_id)
-
-        if self._login_to_userid.get(login_name) is not None:
-            raise KeyError('Duplicate login name: %s' % login_name)
-
-        if not AuthEncoding.is_encrypted(password):
-            password = AuthEncoding.pw_encrypt(password)
-        self._user_passwords[user_id] = password
-        self._login_to_userid[login_name] = user_id
-        self._userid_to_login[user_id] = login_name
-
-        # enumerateUsers return value has changed
-        view_name = createViewName('enumerateUsers')
-        self.ZCacheable_invalidate(view_name=view_name)
-
-    # User Management interface
-
-    @security.private
-    def doDeleteUser(self, userid):
-        """Given a user id, delete that user
-        """
-        return self.removeUser(userid)
-
-    @security.private
-    def doChangeUser(self, principal_id, password):
-        """Change a user's password
-        """
-        if self._user_passwords.get(principal_id) is None:
-            raise RuntimeError("User does not exist: %s" % principal_id)
-        self._user_passwords[principal_id] = AuthEncoding.pw_encrypt(password)
-
-    # implement interfaces IDeleteCapability, IPasswordSetCapability
-
-    @security.public
-    def allowDeletePrincipal(self, principal_id):
-        """True iff this plugin can delete a certain user/group.
-        This is true if this plugin manages the user.
-        """
-        if self._user_passwords.get(principal_id) is not None:
-            return 1
-        return 0
-
-    @security.public
-    def allowPasswordSet(self, principal_id):
-        """True iff this plugin can set the password a certain user.
-        This is true if this plugin manages the user.
-        """
-        return self.allowDeletePrincipal(principal_id)
-
-    # User Introspection interface
-
-    @security.protected(ManageUsers)
-    def getUserIds(self):
-        """
-        Return a list of user ids
-        """
-        return self.listUserIds()
-
-    @security.protected(ManageUsers)
-    def getUserNames(self):
-        """
-        Return a list of usernames
-        """
-        return [x['login_name'] for x in self.listUserInfo()]
-
-    @security.protected(ManageUsers)
-    def getUsers(self):
-        """
-        Return a list of users
-        """
-        uf = self.acl_users
-        return [uf.getUserById(x) for x in self.getUserIds()]
-
-
-InitializeClass(UserManager)
diff --git a/Products/PlonePAS/profiles.zcml b/Products/PlonePAS/profiles.zcml
deleted file mode 100644
index 8410395..0000000
--- a/Products/PlonePAS/profiles.zcml
+++ /dev/null
@@ -1,14 +0,0 @@
-<configure
-    xmlns="http://namespaces.zope.org/zope"
-    xmlns:genericsetup="http://namespaces.zope.org/genericsetup"
-    i18n_domain="plonepas">
-
-  <genericsetup:registerProfile
-      name="PlonePAS"
-      title="PlonePAS"
-      directory="profiles/default"
-      description="Extension profile for default PlonePAS setup."
-      provides="Products.GenericSetup.interfaces.EXTENSION"
-      />
-
-</configure>
diff --git a/Products/PlonePAS/profiles/default/metadata.xml b/Products/PlonePAS/profiles/default/metadata.xml
deleted file mode 100644
index dab4dc0..0000000
--- a/Products/PlonePAS/profiles/default/metadata.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<metadata>
-  <version>4</version>
-</metadata>
diff --git a/Products/PlonePAS/profiles/default/plone-pas.txt b/Products/PlonePAS/profiles/default/plone-pas.txt
deleted file mode 100644
index 9b080f9..0000000
--- a/Products/PlonePAS/profiles/default/plone-pas.txt
+++ /dev/null
@@ -1 +0,0 @@
-The plone-pas step is run if this file is present in the profile
diff --git a/Products/PlonePAS/setuphandlers.py b/Products/PlonePAS/setuphandlers.py
deleted file mode 100644
index 4e3637f..0000000
--- a/Products/PlonePAS/setuphandlers.py
+++ /dev/null
@@ -1,496 +0,0 @@
-# -*- coding: utf-8 -*-
-from Acquisition import aq_parent
-from Products.CMFCore.utils import getToolByName
-from Products.PlonePAS import config
-from Products.PlonePAS.interfaces import group as igroup
-from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
-from Products.PlonePAS.interfaces.plugins import IUserIntrospection
-from Products.PlonePAS.interfaces.plugins import IUserManagement
-from Products.PluggableAuthService.Extensions.upgrade import replace_acl_users
-from Products.PluggableAuthService.interfaces.authservice \
-    import IPluggableAuthService
-from Products.PluggableAuthService.interfaces.plugins import IChallengePlugin
-from Products.PluggableAuthService.interfaces.plugins \
-    import ICredentialsResetPlugin
-from Products.PluggableAuthService.plugins.RecursiveGroupsPlugin \
-    import addRecursiveGroupsPlugin
-from plone.session.plugins.session import manage_addSessionPlugin
-import logging
-
-logger = logging.getLogger('PlonePAS setup')
-
-
-def activatePluginInterfaces(portal, plugin, disable=None):
-    if disable is None:
-        disable = []
-    pas = portal.acl_users
-    plugin_obj = pas[plugin]
-
-    activatable = []
-
-    for info in plugin_obj.plugins.listPluginTypeInfo():
-        interface = info['interface']
-        interface_name = info['id']
-        if plugin_obj.testImplements(interface):
-            if interface_name in disable:
-                disable.append(interface_name)
-                logger.debug("Disabling: " + info['title'])
-            else:
-                activatable.append(interface_name)
-                logger.debug("Activating: " + info['title'])
-    plugin_obj.manage_activateInterfaces(activatable)
-    logger.debug(plugin + " activated.")
-
-
-def setupRoles(portal):
-    rmanager = portal.acl_users.role_manager
-    rmanager.addRole('Member', title="Portal Member")
-    rmanager.addRole('Reviewer', title="Content Reviewer")
-
-
-def registerPluginType(pas, plugin_type, plugin_info):
-    # Make sure there's no dupes in _plugin_types, otherwise your PAS
-    # will *CRAWL*
-    plugin_types = list(set(pas.plugins._plugin_types))
-    if plugin_type not in plugin_types:
-        plugin_types.append(plugin_type)
-
-    # Order doesn't seem to matter, but let's store it ordered.
-    plugin_types.sort()
-
-    # Re-assign to the object, because this is a non-persistent list.
-    pas.plugins._plugin_types = plugin_types
-
-    # It's safe to assign over a existing key here.
-    pas.plugins._plugin_type_info[plugin_type] = plugin_info
-
-
-def registerPluginTypes(pas):
-
-    PluginInfo = {
-        'id': 'IUserManagement',
-        'title': 'user_management',
-        'description': ("The User Management plugins allow the "
-                        "Pluggable Auth Service to add/delete/modify users")
-        }
-
-    registerPluginType(pas, IUserManagement, PluginInfo)
-
-    PluginInfo = {
-        'id': 'IUserIntrospection',
-        'title': 'user_introspection',
-        'description': ("The User Introspection plugins allow the "
-                        "Pluggable Auth Service to provide lists of users")
-        }
-
-    registerPluginType(pas, IUserIntrospection, PluginInfo)
-
-    PluginInfo = {
-        'id': 'IGroupManagement',
-        'title': 'group_management',
-        'description': ("Group Management provides add/write/deletion "
-                        "of groups and member management")
-        }
-
-    registerPluginType(pas, igroup.IGroupManagement, PluginInfo)
-
-    PluginInfo = {
-        'id': 'IGroupIntrospection',
-        'title': 'group_introspection',
-        'description': ("Group Introspection provides listings "
-                        "of groups and membership")
-        }
-
-    registerPluginType(pas, igroup.IGroupIntrospection, PluginInfo)
-
-    PluginInfo = {
-        'id': 'ILocalRolesPlugin',
-        'title': 'local_roles',
-        'description': "Defines Policy for getting Local Roles"
-        }
-
-    registerPluginType(pas, ILocalRolesPlugin, PluginInfo)
-
-
-def setupPlugins(portal):
-    uf = portal.acl_users
-    logger.debug("\nPlugin setup")
-
-    pas = uf.manage_addProduct['PluggableAuthService']
-    plone_pas = uf.manage_addProduct['PlonePAS']
-
-    setupAuthPlugins(portal, pas, plone_pas)
-
-    found = uf.objectIds(['User Manager'])
-    if not found:
-        plone_pas.manage_addUserManager('source_users')
-        logger.debug("Added User Manager.")
-    activatePluginInterfaces(portal, 'source_users')
-
-    found = uf.objectIds(['Group Aware Role Manager'])
-    if not found:
-        plone_pas.manage_addGroupAwareRoleManager('portal_role_manager')
-        logger.debug("Added Group Aware Role Manager.")
-        activatePluginInterfaces(portal, 'portal_role_manager')
-
-    found = uf.objectIds(['Local Roles Manager'])
-    if not found:
-        plone_pas.manage_addLocalRolesManager('local_roles')
-        logger.debug("Added Group Aware Role Manager.")
-        activatePluginInterfaces(portal, 'local_roles')
-
-    found = uf.objectIds(['Group Manager'])
-    if not found:
-        plone_pas.manage_addGroupManager('source_groups')
-        logger.debug("Added ZODB Group Manager.")
-        activatePluginInterfaces(portal, 'source_groups')
-
-    found = uf.objectIds(['Plone User Factory'])
-    if not found:
-        plone_pas.manage_addPloneUserFactory('user_factory')
-        logger.debug("Added Plone User Factory.")
-        activatePluginInterfaces(portal, "user_factory")
-
-    found = uf.objectIds(['ZODB Mutable Property Provider'])
-    if not found:
-        plone_pas.manage_addZODBMutablePropertyProvider('mutable_properties')
-        logger.debug("Added Mutable Property Manager.")
-        activatePluginInterfaces(portal, "mutable_properties")
-
-    found = uf.objectIds(['Automatic Group Plugin'])
-    if not found:
-        plone_pas.manage_addAutoGroup(
-                "auto_group", "Authenticated Users (Virtual Group)",
-                "AuthenticatedUsers", "Automatic Group Provider")
-        logger.debug("Added Automatic Group.")
-        activatePluginInterfaces(portal, "auto_group")
-
-    found = uf.objectIds(['Plone Session Plugin'])
-    if not found:
-        manage_addSessionPlugin(plone_pas, 'session')
-        logger.debug("Added Plone Session Plugin.")
-        activatePluginInterfaces(portal, "session")
-
-    found = uf.objectIds(['Recursive Groups Plugin'])
-    if not found:
-        addRecursiveGroupsPlugin(plone_pas, 'recursive_groups',
-                                 "Recursive Groups Plugin")
-        activatePluginInterfaces(portal, 'recursive_groups')
-        logger.debug("Added Recursive Groups plugin.")
-
-    setupPasswordPolicyPlugin(portal)
-
-
-def setupAuthPlugins(portal, pas, plone_pas,
-                     deactivate_basic_reset=True,
-                     deactivate_cookie_challenge=False):
-    uf = portal.acl_users
-    logger.debug("Cookie plugin setup")
-
-    login_path = 'login_form'
-    cookie_name = '__ac'
-
-    crumbler = getToolByName(portal, 'cookie_authentication', None)
-    if crumbler is not None:
-        login_path = crumbler.auto_login_page
-        cookie_name = crumbler.auth_cookie
-
-    found = uf.objectIds(['Extended Cookie Auth Helper'])
-    if not found:
-        plone_pas.manage_addExtendedCookieAuthHelper('credentials_cookie_auth',
-                                                     cookie_name=cookie_name)
-    logger.debug("Added Extended Cookie Auth Helper.")
-    if deactivate_basic_reset:
-        disable = ['ICredentialsResetPlugin', 'ICredentialsUpdatePlugin']
-    else:
-        disable = []
-    activatePluginInterfaces(
-        portal,
-        'credentials_cookie_auth',
-        disable=disable
-    )
-
-    credentials_cookie_auth = uf._getOb('credentials_cookie_auth')
-    if 'login_form' in credentials_cookie_auth:
-        credentials_cookie_auth.manage_delObjects(ids=['login_form'])
-        logger.debug("Removed default login_form from credentials cookie "
-                     "auth.")
-    credentials_cookie_auth.cookie_name = cookie_name
-    credentials_cookie_auth.login_path = login_path
-
-    # remove cookie crumbler(s)
-    if 'cookie_authentication' in portal:
-        portal.manage_delObjects(['cookie_authentication'])
-    logger.debug("Removed old Cookie Crumbler")
-
-    found = uf.objectIds(['HTTP Basic Auth Helper'])
-    if not found:
-        pas.addHTTPBasicAuthHelper(
-            'credentials_basic_auth',
-            title="HTTP Basic Auth"
-        )
-    logger.debug("Added Basic Auth Helper.")
-    activatePluginInterfaces(portal, 'credentials_basic_auth')
-
-    if deactivate_basic_reset:
-        uf.plugins.deactivatePlugin(
-            ICredentialsResetPlugin,
-            'credentials_basic_auth'
-        )
-    if deactivate_cookie_challenge:
-        uf.plugins.deactivatePlugin(
-            IChallengePlugin,
-            'credentials_cookie_auth'
-        )
-
-
-def updateProperties(tool, properties):
-    dependency_keys = ('selection', 'multiple selection')
-    propsWithNoDeps = [prop for prop in properties
-                       if prop['type'] not in dependency_keys]
-    propsWithDeps = [prop for prop in properties
-                     if prop['type'] in dependency_keys]
-    for prop in propsWithNoDeps:
-        updateProp(tool, prop)
-    for prop in propsWithDeps:
-        updateProp(tool, prop)
-
-
-def updateProp(prop_manager, prop_dict):
-    """Provided a PropertyManager and a property dict of {id, value,
-    type}, set or update that property as applicable.
-
-    Doesn't deal with existing properties changing type.
-    """
-    id = prop_dict['id']
-    value = prop_dict['value']
-    type = prop_dict['type']
-    if type in ('selection', 'multiple selection'):
-        value = prop_dict['select_variable']
-    if prop_manager.hasProperty(id):
-        prop_manager._updateProperty(id, value)
-    else:
-        prop_manager._setProperty(id, value, type)
-    if type in ('selection', 'multiple selection'):
-        prop_manager._updateProperty(id, prop_dict['value'])
-
-
-def addPAS(portal):
-    logger.debug("Adding PAS user folder")
-    portal.manage_addProduct['PluggableAuthService'].addPluggableAuthService()
-
-
-def migrate_root_uf(self):
-    # Acquire parent user folder.
-    parent = self.getPhysicalRoot()
-    uf = getToolByName(parent, 'acl_users')
-    if IPluggableAuthService.providedBy(uf):
-        # It's a PAS already, fixup if needed.
-        pas_fixup(parent)
-
-        # Configure Challenge Chooser plugin if available
-        challenge_chooser_setup(parent)
-        return
-
-    if not uf.meta_type == 'User Folder':
-        # It's not a standard User Folder at the root. Nothing we can do.
-        return
-
-    # It's a standard User Folder, replace it.
-    replace_acl_users(parent)
-
-    # Get the new uf
-    uf = getToolByName(parent, 'acl_users')
-
-    pas = uf.manage_addProduct['PluggableAuthService']
-    plone_pas = uf.manage_addProduct['PlonePAS']
-    # Setup authentication plugins
-    setupAuthPlugins(parent, pas, plone_pas,
-                     deactivate_basic_reset=False,
-                     deactivate_cookie_challenge=True)
-
-    # Activate *all* interfaces for user manager. IUserAdder is not
-    # activated for some reason by default.
-    activatePluginInterfaces(parent, 'users')
-
-    # Configure Challenge Chooser plugin if available
-    challenge_chooser_setup(parent)
-
-
-def pas_fixup(self):
-    from Products.PluggableAuthService.PluggableAuthService \
-         import _PLUGIN_TYPE_INFO
-
-    pas = getToolByName(self, 'acl_users')
-    if not IPluggableAuthService.providedBy(pas):
-        logger.debug('PAS UF not found, skipping PAS fixup.')
-        return
-
-    plugins = pas['plugins']
-
-    plugin_types = list(set(plugins._plugin_types))
-    for key, id, title, description in _PLUGIN_TYPE_INFO:
-        if key in plugin_types:
-            logger.debug("Plugin type '%s' already registered." % id)
-            continue
-        logger.debug("Plugin type '%s' was not registered." % id)
-        plugin_types.append(key)
-        plugins._plugin_type_info[key] = {
-            'id': id,
-            'title': title,
-            'description': description,
-            }
-    # Make it ordered
-    plugin_types.sort()
-
-    # Re-assign because it's a non-persistent property.
-    plugins._plugin_types = plugin_types
-
-
-def challenge_chooser_setup(self):
-    uf = getToolByName(self, 'acl_users')
-    pas = uf.manage_addProduct['PluggableAuthService']
-
-    # Only install plugins if available
-    req = ('addChallengeProtocolChooserPlugin',
-           'addRequestTypeSnifferPlugin')
-    for m in req:
-        if getattr(pas, m, None) is None:
-            logger.debug('Needed plugins have not been found, ignoring')
-            return
-
-    found = uf.objectIds(['Challenge Protocol Chooser Plugin'])
-    if not found:
-        logger.debug('Adding Challenge Protocol Chooser Plugin.')
-        pas.addChallengeProtocolChooserPlugin(
-            'chooser',
-            mapping=config.DEFAULT_PROTO_MAPPING)
-        activatePluginInterfaces(self, 'chooser')
-    else:
-        assert len(found) == 1, 'Found extra plugins %s' % found
-        logger.debug('Found existing Challenge Protocol Chooser Plugin.')
-        plugin = uf[found[0]]
-        plugin.manage_updateProtocolMapping(
-            mapping=config.DEFAULT_PROTO_MAPPING)
-        activatePluginInterfaces(self, found[0])
-
-    found = uf.objectIds(['Request Type Sniffer Plugin'])
-    if not found:
-        logger.debug('Adding Request Type Sniffer Plugin.')
-        pas.addRequestTypeSnifferPlugin('sniffer')
-        activatePluginInterfaces(self, 'sniffer')
-    else:
-        assert len(found) == 1, 'Found extra plugins %s' % found
-        logger.debug('Found existing Request Type Sniffer Plugin.')
-        activatePluginInterfaces(self, found[0])
-
-
-def setupPasswordPolicyPlugin(portal):
-    uf = portal.acl_users
-    plone_pas = uf.manage_addProduct['PlonePAS']
-
-    found = uf.objectIds(['Default Plone Password Policy'])
-    logger.debug("\nDefault Password Ploicy Plugin setup")
-    if not found:
-        plone_pas.manage_addPasswordPolicyPlugin(
-            'password_policy',
-            title="Default Plone Password Policy"
-        )
-        logger.debug("Added Default Plone Password Policy.")
-        activatePluginInterfaces(portal, 'password_policy')
-
-
-def setLoginFormInCookieAuth(context):
-    """Makes sure the cookie auth redirects to 'require_login' instead
-       of 'login_form'."""
-    uf = getattr(context, 'acl_users', None)
-    if uf is None or getattr(uf.aq_base, '_getOb', None) is None:
-        # we have no user folder or it's not a PAS folder, do nothing
-        return
-    cookie_auth = uf._getOb('credentials_cookie_auth', None)
-    if cookie_auth is None:
-        # there's no cookie auth object, do nothing
-        return
-    current_login_form = cookie_auth.getProperty('login_path')
-    if current_login_form != 'login_form':
-        # it's customized already, do nothing
-        return
-    cookie_auth.manage_changeProperties(login_path='require_login')
-
-
-def addRolesToPlugIn(p):
-    """
-    XXX This is horrible.. need to switch PlonePAS to a GenericSetup
-    based install so this doesn't need to happen.
-
-    Have to manually register the roles from the 'rolemap' step
-    with the roles plug-in.
-    """
-    uf = getToolByName(p, 'acl_users')
-    rmanager = uf.portal_role_manager
-    roles = ('Reviewer', 'Member')
-    existing = rmanager.listRoleIds()
-    for role in roles:
-        if role not in existing:
-            rmanager.addRole(role)
-
-
-def setupGroups(site):
-    """
-    Create Plone's default set of groups.
-    """
-    uf = getToolByName(site, 'acl_users')
-    gtool = getToolByName(site, 'portal_groups')
-    if not uf.searchGroups(id='Administrators'):
-        gtool.addGroup(
-            'Administrators',
-            title='Administrators',
-            roles=['Manager']
-        )
-
-    if not uf.searchGroups(id='Site Administrators'):
-        gtool.addGroup(
-            'Site Administrators',
-            title='Site Administrators',
-            roles=['Site Administrator']
-        )
-
-    if not uf.searchGroups(id='Reviewers'):
-        gtool.addGroup('Reviewers', title='Reviewers', roles=['Reviewer'])
-
-
-def installPAS(portal):
-    # Add user folder
-    portal.manage_addProduct['PluggableAuthService'].addPluggableAuthService()
-
-    # Configure Challenge Chooser plugin if available
-    challenge_chooser_setup(portal)
-
-    # A bunch of general configuration settings
-    registerPluginTypes(portal.acl_users)
-    setupPlugins(portal)
-
-    # XXX Why are we doing this?
-    # According to Sidnei, "either cookie or basic auth for a user in the root
-    # folder doesn't work
-    # if it's not a PAS UF when you sign in to Plone. IIRC."
-    # See: http://twitter.com/#!/sidneidasilva/status/14030732112429056
-    # And here's the original commit:
-    # http://dev.plone.org/collective/changeset/10720/PlonePAS/trunk/Extensions/Install.py
-    if aq_parent(portal):
-        migrate_root_uf(portal)
-
-
-def setupPlonePAS(context):
-    """
-    Setup PlonePAS step.
-    """
-    # Only run step if a flag file is present (e.g. not an extension profile)
-    if context.readDataFile('plone-pas.txt') is None:
-        return
-    site = context.getSite()
-    if 'acl_users' not in site:
-        installPAS(site)
-        addRolesToPlugIn(site)
-        setupGroups(site)
-        setLoginFormInCookieAuth(site)
diff --git a/Products/PlonePAS/sheet.py b/Products/PlonePAS/sheet.py
deleted file mode 100644
index 8b05083..0000000
--- a/Products/PlonePAS/sheet.py
+++ /dev/null
@@ -1,136 +0,0 @@
-# -*- coding: utf-8 -*-
-"""
-Add Mutable Property Sheets and Schema Mutable Property Sheets to PAS
-
-also a property schema type registry which is extensible.
-
-"""
-from Products.CMFCore.interfaces import ISiteRoot
-from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
-from Products.PluggableAuthService.UserPropertySheet import UserPropertySheet
-from Products.PluggableAuthService.UserPropertySheet import _SequenceTypes
-from zope.component import getUtility
-from zope.interface import implementer
-
-
-class PropertyValueError(ValueError):
-    pass
-
-
-class PropertySchemaTypeMap(object):
-
-    def __init__(self):
-        self.tmap = {}
-        self.tmap_order = []
-
-    def addType(self, type_name, identifier, order=None):
-        self.tmap[type_name] = identifier
-        if order is not None and isinstance(order, int):
-            self.tmap_order.insert(order, type_name)
-        else:
-            self.tmap_order.append(type_name)
-
-    def getTypeFor(self, value):
-        ptypes = [(ptype, self.tmap[ptype]) for ptype in self.tmap_order]
-        for ptype, inspector in ptypes:
-            if inspector(value):
-                return ptype
-        raise TypeError('Invalid property type: %s' % type(value))
-
-    def validate(self, property_type, value):
-        inspector = self.tmap[property_type]
-        return inspector(value)
-
-PropertySchema = PropertySchemaTypeMap()
-PropertySchema.addType(
-    'string',
-    lambda x: x is None or isinstance(x, basestring)
-)
-PropertySchema.addType(
-    'text',
-    lambda x: x is None or isinstance(x, basestring)
-)
-PropertySchema.addType(
-    'boolean',
-    lambda x: 1  # anything can be boolean
-)
-PropertySchema.addType(
-    'int',
-    lambda x:  x is None or isinstance(x, int)
-)
-PropertySchema.addType(
-    'long',
-    lambda x:  x is None or isinstance(x, long)
-)
-PropertySchema.addType(
-    'float',
-    lambda x:  x is None or isinstance(x, float)
-)
-PropertySchema.addType(
-    'lines',
-    lambda x:  x is None or isinstance(x, _SequenceTypes)
-)
-PropertySchema.addType(
-    'selection',
-    lambda x: x is None or isinstance(x, basestring)
-)
-PropertySchema.addType(
-    'multiple selection',
-    lambda x:  x is None or isinstance(x, _SequenceTypes)
-)
-PropertySchema.addType(
-    'date',
-    lambda x: 1
-)
-validateValue = PropertySchema.validate
-
-
-@implementer(IMutablePropertySheet)
-class MutablePropertySheet(UserPropertySheet):
-
-    def validateProperty(self, id, value):
-        if id not in self._properties:
-            raise PropertyValueError('No such property found on this schema')
-
-        proptype = self.getPropertyType(id)
-        if not validateValue(proptype, value):
-            raise PropertyValueError(
-                "Invalid value (%s) for property '%s' of type %s" %
-                (value, id, proptype)
-            )
-
-    def setProperty(self, user, id, value):
-        self.validateProperty(id, value)
-
-        self._properties[id] = value
-        self._properties = self._properties
-
-        # cascade to plugin
-        provider = self._getPropertyProviderForUser(user)
-        provider.setPropertiesForUser(user, self)
-
-    def setProperties(self, user, mapping):
-        prop_keys = self._properties.keys()
-        prop_update = mapping.copy()
-
-        for key, value in tuple(prop_update.items()):
-            if key not in prop_keys:
-                prop_update.pop(key)
-                continue
-            self.validateProperty(key, value)
-
-        self._properties.update(prop_update)
-
-        # cascade to plugin
-        provider = self._getPropertyProviderForUser(user)
-        provider.setPropertiesForUser(user, self)
-
-    def _getPropertyProviderForUser(self, user):
-        # XXX This assumes that the acl_users that we want is in the portal
-        # root. This may not always be the case.
-        portal = getUtility(ISiteRoot)
-        return portal.acl_users._getOb(self._id)
-
-
-class SchemaMutablePropertySheet(MutablePropertySheet):
-    pass
diff --git a/Products/PlonePAS/tests/__init__.py b/Products/PlonePAS/tests/__init__.py
deleted file mode 100644
index 633f866..0000000
--- a/Products/PlonePAS/tests/__init__.py
+++ /dev/null
@@ -1,2 +0,0 @@
-# -*- coding: utf-8 -*-
-
diff --git a/Products/PlonePAS/tests/base.py b/Products/PlonePAS/tests/base.py
deleted file mode 100644
index f274012..0000000
--- a/Products/PlonePAS/tests/base.py
+++ /dev/null
@@ -1,3 +0,0 @@
-# -*- coding: utf-8 -*-
-from plone.app.testing.bbb import PloneTestCase as TestCase
-from plone.app.testing.bbb import PloneTestCase as FunctionalTestCase
diff --git a/Products/PlonePAS/tests/cookie_auth.rst b/Products/PlonePAS/tests/cookie_auth.rst
deleted file mode 100644
index cb249b5..0000000
--- a/Products/PlonePAS/tests/cookie_auth.rst
+++ /dev/null
@@ -1,98 +0,0 @@
-Test for Cookie Auth
-====================
-
-  >>> from zope.interface import implementedBy
-  >>> from plone.app.testing import TEST_USER_NAME
-  >>> from plone.app.testing import TEST_USER_PASSWORD
-
-User in Plone Site
-------------------
-
-Plone Site has PAS installed
-
-  >>> portal = layer['portal']
-  >>> print portal.acl_users.meta_type
-  Pluggable Auth Service
-
-User exists in the user folder inside the Plone Site.
-
-  >>> uf = portal.acl_users
-  >>> print uf.meta_type
-  Pluggable Auth Service
-
-  >>> user_name, user_password, user_role = ('foo', 'bar', 'Manager')
-  >>> uf.userFolderAddUser(user_name, user_password, [user_role], [])
-
-  >>> uf.getUserById(user_name)
-  <PloneUser 'foo'>
-
-Login to Plone Site using Basic Auth works.
-
-  >>> from plone.testing.z2 import Browser
-  >>> browser = Browser(layer['app'])
-  >>> browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
-  >>> browser.open('%s/manage' % portal.absolute_url())
-  >>> print browser.headers
-  Status: 200 Ok...
-
-Make sure cookie plugin is installed and activated.
-
-  >>> uf.objectIds('Extended Cookie Auth Helper')
-  ['credentials_cookie_auth']
-
-  >>> plugins = uf.plugins
-  >>> cookie = uf['credentials_cookie_auth']
-
-  >>> ifaces = tuple(implementedBy(cookie.__class__).flattened())
-
-  >>> actives = []
-  >>> for iface in ifaces:
-  ...    try:
-  ...       actives.append((plugins.listPlugins(iface), iface))
-  ...    except KeyError:
-  ...       pass
-
-  >>> for active, iface in actives:
-  ...     print iface,
-  ...     for id, plugin in active:
-  ...         if id == 'credentials_cookie_auth':
-  ...            print True
-  <...IExtraction...> True
-  <...IChallenge...> True
-  <...ICredentialsUpdate...> <...ICredentialsReset...>
-
-User in parent folder
----------------------
-
-User Exists on the folder containing the Plone Site, which should be a
-Pluggable Auth Service too.
-
-  >>> uf = layer['app'].acl_users
-  >>> print uf.meta_type
-  Pluggable Auth Service
-
-  >>> user_name, user_password, user_role = ('baz', 'bar', 'Manager')
-  >>> uf.userFolderAddUser(user_name, user_password, [user_role], [])
-
-  >>> uf.getUserById(user_name)
-  <PropertiedUser 'baz'>
-
-  >>> import transaction
-  >>> transaction.commit()
-
-Login directly to containing folder using Basic Auth works.
-
-  >>> browser = Browser(layer['app'])
-  >>> browser.addHeader('Authorization', 'Basic %s:%s' % (user_name, user_password,))
-  >>> browser.open('%s/manage' % layer['app'].absolute_url())
-  >>> print browser.headers
-  Status: 200 Ok...
-
-Login to Plone Site using Basic Auth works.
-
-  >>> browser = Browser(layer['app'])
-  >>> browser.addHeader('Authorization', 'Basic %s:%s' % (user_name, user_password,))
-  >>> browser.open('%s/manage' % portal.absolute_url())
-  >>> print browser.headers
-  Status: 200 Ok...
-
diff --git a/Products/PlonePAS/tests/dummy.py b/Products/PlonePAS/tests/dummy.py
deleted file mode 100644
index 346e046..0000000
--- a/Products/PlonePAS/tests/dummy.py
+++ /dev/null
@@ -1,59 +0,0 @@
-# -*- coding: utf-8 -*-
-from OFS.SimpleItem import SimpleItem
-from ZPublisher.HTTPRequest import FileUpload
-
-TEXT = 'file data'
-
-
-class FieldStorage(object):
-    def __init__(self, file, filename='testfile', headers=None):
-        self.file = file
-        if headers is None:
-            headers = {}
-        self.headers = headers
-        self.filename = filename
-
-
-class File(FileUpload):
-    '''Dummy upload object
-       Used to fake uploaded files.
-    '''
-
-    __allow_access_to_unprotected_subobjects__ = 1
-    filename = 'dummy.txt'
-    data = TEXT
-    headers = {}
-
-    def __init__(self, filename=None, data=None, headers=None):
-        if filename is not None:
-            self.filename = filename
-        if data is not None:
-            self.data = data
-        if headers is not None:
-            self.headers = headers
-
-    def seek(self, *args):
-        pass
-
-    def tell(self, *args):
-        return 1
-
-    def read(self, *args):
-        return self.data
-
-
-class Error(Exception):
-    '''Dummy exception'''
-
-
-class Raiser(SimpleItem):
-    '''Raises the stored exception when called'''
-
-    exception = Error
-
-    def __init__(self, exception=None):
-        if exception is not None:
-            self.exception = exception
-
-    def __call__(self, *args, **kw):
-        raise self.exception
diff --git a/Products/PlonePAS/tests/images/test.gif b/Products/PlonePAS/tests/images/test.gif
deleted file mode 100644
index b1ac85b..0000000
Binary files a/Products/PlonePAS/tests/images/test.gif and /dev/null differ
diff --git a/Products/PlonePAS/tests/images/test.jpg b/Products/PlonePAS/tests/images/test.jpg
deleted file mode 100644
index d444aff..0000000
Binary files a/Products/PlonePAS/tests/images/test.jpg and /dev/null differ
diff --git a/Products/PlonePAS/tests/images/test.png b/Products/PlonePAS/tests/images/test.png
deleted file mode 100644
index 078487d..0000000
Binary files a/Products/PlonePAS/tests/images/test.png and /dev/null differ
diff --git a/Products/PlonePAS/tests/test_basic_ops.py b/Products/PlonePAS/tests/test_basic_ops.py
deleted file mode 100644
index e70540d..0000000
--- a/Products/PlonePAS/tests/test_basic_ops.py
+++ /dev/null
@@ -1,150 +0,0 @@
-# -*- coding: utf-8 -*-
-from Products.PlonePAS.tests import base
-from Products.PluggableAuthService.PluggableAuthService import \
-    _SWALLOWABLE_PLUGIN_EXCEPTIONS
-from Products.PluggableAuthService.interfaces.authservice import \
-    IPluggableAuthService
-from Products.PluggableAuthService.interfaces.events import \
-    IPrincipalDeletedEvent
-from Products.PluggableAuthService.interfaces.plugins import IRolesPlugin
-from zope.component import adapter
-from zope.component import getGlobalSiteManager
-
-
-class BasicOpsTestCase(base.TestCase):
-
-    def afterSetUp(self):
-        self.loginAsPortalOwner()
-        self.acl_users = self.portal.acl_users
-
-    def compareRoles(self, target, user, roles):
-        """
-        compareRoles(self, target, user, roles) => do not raise if
-        user has exactly the specified roles.
-
-        If target is None, test user roles (no local roles)
-        """
-        u = self.acl_users.getUser(user)
-        if not u:
-            raise RuntimeError("compareRoles: Invalid user: '%s'" % user)
-        non_roles = ('Authenticated', 'Anonymous', '')
-        if target is None:
-            user_roles = list(u.getRoles())
-        else:
-            user_roles = list(u.getRolesInContext(target))
-        actual_roles = filter(lambda x: x not in non_roles, user_roles)
-        actual_roles.sort()
-        wished_roles = list(roles)
-        wished_roles.sort()
-        if actual_roles == wished_roles:
-            return 1
-        raise RuntimeError("User %s: Whished roles: %s BUT current "
-                           "roles: %s" % (user, wished_roles, actual_roles))
-
-    def createUser(self, login="created_user", password="secret",
-                   roles=[], groups=[], domains=()):
-        self.acl_users.userFolderAddUser(
-            login, password, roles=roles, groups=groups, domains=domains,)
-
-    def test_installed(self):
-        self.assertTrue(IPluggableAuthService.providedBy(self.acl_users))
-
-    def test_add(self):
-        self.createUser()
-        self.assertTrue(self.acl_users.getUser("created_user"))
-
-    def test_edit(self):
-        # this will fail unless the PAS role plugin is told it manages
-        # the new role.
-        self.createUser()
-        self.compareRoles(None, "created_user", [])
-        self.acl_users.userFolderEditUser(
-            "created_user",  # name
-            "secret2",  # password
-            roles=["Member"],
-            groups=["g1"],
-            domains=(),)
-        self.compareRoles(None, "created_user", ['Member'])
-
-    def test_edit_userDefinedRole(self):
-        roleplugins = self.acl_users.plugins.listPlugins(IRolesPlugin)
-        for id, plugin in roleplugins:
-            try:
-                plugin.addRole('r1')
-            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-                pass
-            else:
-                break
-
-        self.createUser()
-        self.compareRoles(None, "created_user", [])
-        self.acl_users.userFolderEditUser(
-            "created_user",  # name
-            "secret2",  # password
-            roles=["r1"],
-            groups=["g1"],
-            domains=(),)
-        self.compareRoles(None, "created_user", ['r1'])
-
-    def test_del(self):
-        self.createUser()
-        self.assertTrue(self.acl_users.getUser("created_user"))
-        self.acl_users.userFolderDelUsers(['created_user'])
-        self.assertFalse(self.acl_users.getUser("created_user"))
-
-    def test_principal_del_event(self):
-        eventsFired = []
-
-        @adapter(IPrincipalDeletedEvent)
-        def gotDeletion(event):
-            eventsFired.append(event)
-
-        gsm = getGlobalSiteManager()
-        gsm.registerHandler(gotDeletion)
-        self.createUser()
-        self.acl_users.userFolderDelUsers(['created_user'])
-        self.assertEqual(len(eventsFired), 1)
-        self.assertEqual(eventsFired[0].principal, 'created_user')
-        gsm.unregisterHandler(gotDeletion)
-
-    def test_search(self):
-        self.createUser("created_user1")
-        self.createUser("created_user2")
-        mt = self.portal.portal_membership
-        retlist = mt.searchForMembers(REQUEST=None, login="created_user1")
-        usernames = [user.getUserName() for user in retlist]
-        self.assertEqual(len(usernames), 1)
-        self.assertTrue("created_user1" in usernames,
-                        "'created_user1' not in %s" % usernames)
-
-    def test_setpw(self):
-        # there is more than one place where one can set the password.
-        # insane. anyway we have to check the patch in pas.py userSetPassword
-        # here its checked in the general setup using ZODBUserManager.
-        self.createUser()
-        uf = self.acl_users
-        new_secret = 'new_secret'
-        uf.userSetPassword('created_user', new_secret)
-
-        # possible to authenticate with new password?
-        from Products.PluggableAuthService.interfaces.plugins \
-            import IAuthenticationPlugin
-        authenticators = uf.plugins.listPlugins(IAuthenticationPlugin)
-        credentials = {'login': 'created_user', 'password': new_secret}
-        result = None
-        for aid, authenticator in authenticators:
-            result = authenticator.authenticateCredentials(credentials)
-            if result is not None:
-                break
-        self.assertTrue(result)
-
-    def test_setProperties(self):
-        self.createUser()
-        user = self.acl_users.getUser('created_user')
-        user.setProperties(fullname='Test User', email='test@example.org')
-        self.assertEqual(user.getProperty('fullname'), 'Test User')
-        self.assertEqual(user.getProperty('email'), 'test@example.org')
-
-        user.setProperties(properties={'fullname': 'Test User2', 'email': 'test2@example.org'})
-        self.assertEqual(user.getProperty('fullname'), 'Test User2')
-        self.assertEqual(user.getProperty('email'), 'test2@example.org')
diff --git a/Products/PlonePAS/tests/test_doctests.py b/Products/PlonePAS/tests/test_doctests.py
deleted file mode 100644
index 9e2c509..0000000
--- a/Products/PlonePAS/tests/test_doctests.py
+++ /dev/null
@@ -1,26 +0,0 @@
-# -*- coding: utf-8 -*-
-from plone.app.testing.bbb import PTC_FUNCTIONAL_TESTING
-from plone.testing import layered
-import doctest
-import unittest
-
-
-def test_suite():
-    suite = unittest.TestSuite()
-    suite.addTest(
-        layered(
-            doctest.DocFileSuite(
-                'cookie_auth.rst',
-                package='Products.PlonePAS.tests',
-                optionflags=doctest.ELLIPSIS
-            ),
-            layer=PTC_FUNCTIONAL_TESTING
-        )
-    )
-    suite.addTest(
-        doctest.DocTestSuite(
-            'Products.PlonePAS.utils',
-            optionflags=doctest.ELLIPSIS
-        )
-    )
-    return suite
diff --git a/Products/PlonePAS/tests/test_groupdatatool.py b/Products/PlonePAS/tests/test_groupdatatool.py
deleted file mode 100644
index 6bb8600..0000000
--- a/Products/PlonePAS/tests/test_groupdatatool.py
+++ /dev/null
@@ -1,181 +0,0 @@
-# -*- coding: utf-8 -*-
-from AccessControl import Permissions
-from AccessControl import Unauthorized
-from Products.CMFCore.tests.base.testcase import WarningInterceptor
-from Products.PlonePAS.tests import base
-from plone.app.testing import TEST_USER_ID
-from plone.app.testing import TEST_USER_NAME
-
-
-def sortTuple(t):
-    l = list(t)
-    l.sort()
-    return tuple(l)
-
-
-class TestGroupDataTool(base.TestCase):
-
-    def afterSetUp(self):
-        self.acl_users = self.portal.acl_users
-        self.groups = self.portal.portal_groups
-        self.groupdata = self.portal.portal_groupdata
-        self.groups.addGroup('foo')
-        # MUST reset _v_ attributes!
-        self.groupdata._v_temps = None
-        if 'auto_group' in self.acl_users:
-            self.acl_users.manage_delObjects(['auto_group'])
-
-    def testWrapGroup(self):
-        g = self.acl_users.getGroup('foo')
-        self.assertEqual(g.__class__.__name__, 'PloneGroup')
-        g = self.groupdata.wrapGroup(g)
-        self.assertEqual(g.__class__.__name__, 'GroupData')
-        self.assertEqual(g.aq_parent.__class__.__name__, 'PloneGroup')
-        self.assertEqual(g.aq_parent.aq_parent.__class__.__name__,
-                         'GroupManager')
-
-
-class TestGroupData(base.TestCase, WarningInterceptor):
-
-    def afterSetUp(self):
-        self.membership = self.portal.portal_membership
-        self.memberdata = self.portal.portal_memberdata
-        self.acl_users = self.portal.acl_users
-        self.groups = self.portal.portal_groups
-        self.groupdata = self.portal.portal_groupdata
-        self.groups.addGroup('foo')
-        if 'auto_group' in self.acl_users:
-            self.acl_users.manage_delObjects(['auto_group'])
-        # MUST reset _v_ attributes!
-        self.memberdata._v_temps = None
-        self.groupdata._v_temps = None
-        self._trap_warning_output()
-
-    def testGetGroup(self):
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(g.__class__.__name__, 'GroupData')
-        g = g.getGroup()
-        self.assertEqual(g.__class__.__name__, 'PloneGroup')
-
-    def testGetTool(self):
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(g.getTool().getId(), 'portal_groupdata')
-
-    def testGetGroupMembers(self):
-        g = self.groups.getGroupById('foo')
-        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
-        self.assertEqual(g.getGroupMembers()[0].getId(), TEST_USER_ID)
-
-    def testGroupMembersAreWrapped(self):
-        g = self.groups.getGroupById('foo')
-        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
-        ms = g.getGroupMembers()
-        self.assertEqual(ms[0].__class__.__name__, 'MemberData')
-        self.assertEqual(ms[0].aq_parent.__class__.__name__, 'PloneUser')
-        self.assertEqual(ms[0].aq_parent.aq_parent.__class__.__name__,
-                         'PluggableAuthService')
-
-    def testAddMember(self):
-        self.setPermissions([Permissions.manage_users])
-        g = self.groups.getGroupById('foo')
-        g.addMember(TEST_USER_ID)
-        self.assertEqual(g.getGroupMembers()[0].getId(), TEST_USER_ID)
-
-    def testRemoveMember(self):
-        self.setPermissions([Permissions.manage_users])
-        g = self.groups.getGroupById('foo')
-        g.addMember(TEST_USER_ID)
-        g.removeMember(TEST_USER_ID)
-        self.assertEqual(len(g.getGroupMembers()), 0)
-
-    def testSetGroupProperties(self):
-        g = self.groups.getGroupById('foo')
-        g.setGroupProperties({'email': 'foo@bar.com'})
-        gd = self.groups.getGroupById('foo')
-        self.assertEqual(gd.getProperty('email'), 'foo@bar.com')
-
-    def testSetMemberProperties(self):
-        # For reference
-        m = self.membership.getMemberById(TEST_USER_ID)
-        m.setMemberProperties({'email': 'foo@bar.com'})
-        md = self.membership.getMemberById(TEST_USER_ID)
-        self.assertEqual(md.getProperty('email'), 'foo@bar.com')
-
-    def testGetProperty(self):
-        g = self.groups.getGroupById('foo')
-        g.setGroupProperties({'email': 'foo@bar.com'})
-        self.assertEqual(g.getProperty('email'), 'foo@bar.com')
-        self.assertEqual(g.getProperty('id'), 'foo')
-
-    def testGetGroupName(self):
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(g.getGroupName(), 'foo')
-
-    def testGetGroupId(self):
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(g.getGroupId(), 'foo')
-
-    def testGetRoles(self):
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(tuple(g.getRoles()), ('Authenticated',))
-        self.groups.editGroup(g.getId(), roles=['Member'])
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(sortTuple(tuple(g.getRoles())),
-                         ('Authenticated', 'Member'))
-
-    def testGetRolesInContext(self):
-        g = self.groups.getGroupById('foo')
-        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
-        user = self.acl_users.getUser(TEST_USER_NAME)
-        self.assertEqual(user.getRolesInContext(self.folder).sort(),
-                        ['Member', 'Authenticated', 'Owner'].sort())
-        self.folder.manage_setLocalRoles(g.getId(), ['NewRole'])
-        self.assertEqual(user.getRolesInContext(self.folder).sort(),
-                        ['Member', 'Authenticated', 'Owner', 'NewRole'].sort())
-
-    def testGetDomains(self):
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(g.getDomains(), ())
-
-    def testHasRole(self):
-        g = self.groups.getGroupById('foo')
-        self.groups.editGroup(g.getId(), roles=['Member'])
-        g = self.groups.getGroupById('foo')
-        self.assertTrue(g.has_role('Member'))
-
-    def beforeTearDown(self):
-        self._free_warning_output()
-
-
-class TestMethodProtection(base.TestCase):
-
-    def afterSetUp(self):
-        self.groups = self.portal.portal_groups
-        self.groups.addGroup('foo')
-        self.groupdata = self.groups.getGroupById('foo')
-
-    def testAnonAddMember(self):
-        self.logout()
-        self.assertRaises(Unauthorized, self.groupdata.addMember, TEST_USER_ID)
-
-    def testAnonRemoveMember(self):
-        self.logout()
-        self.assertRaises(Unauthorized, self.groupdata.removeMember,
-                          TEST_USER_ID)
-
-    def testMemberAddMember(self):
-        self.assertRaises(Unauthorized, self.groupdata.addMember, TEST_USER_ID)
-
-    def testMemberRemoveMember(self):
-        self.assertRaises(Unauthorized, self.groupdata.removeMember,
-                          TEST_USER_ID)
-
-    def testManagerAddMember(self):
-        self.setPermissions([Permissions.manage_users])
-        self.groupdata.addMember(TEST_USER_ID)
-
-    def testManagerRemoveMember(self):
-        self.setPermissions([Permissions.manage_users])
-        self.groupdata.addMember(TEST_USER_ID)
-        self.groupdata.removeMember(TEST_USER_ID)
-
diff --git a/Products/PlonePAS/tests/test_groupstool.py b/Products/PlonePAS/tests/test_groupstool.py
deleted file mode 100644
index cdac9c0..0000000
--- a/Products/PlonePAS/tests/test_groupstool.py
+++ /dev/null
@@ -1,259 +0,0 @@
-# -*- coding: utf-8 -*-
-from AccessControl import Permissions
-from AccessControl import Unauthorized
-from Acquisition import aq_base
-from Acquisition import aq_parent
-from Products.CMFCore.tests.base.testcase import WarningInterceptor
-from Products.CMFCore.utils import getToolByName
-from Products.PlonePAS.plugins.group import PloneGroup
-from Products.PlonePAS.tests import base
-from Products.PlonePAS.tools.groupdata import GroupData
-from plone.app.testing import TEST_USER_ID
-
-
-def sortTuple(t):
-    l = list(t)
-    l.sort()
-    return tuple(l)
-
-
-class GroupsToolTest(base.TestCase):
-
-    def afterSetUp(self):
-        self.gt = getToolByName(self.portal, 'portal_groups')
-        self.gd = getToolByName(self.portal, 'portal_groupdata')
-
-        self.group_id = 'group1'
-        # Create a new Group
-        self.loginAsPortalOwner()
-        self.gt.addGroup(
-            self.group_id,
-            ['Reviewer'],
-            [],
-            {'email': 'group1@host.com', 'title': 'Group #1'}
-        )
-
-    def test_get_group(self):
-        # Use PAS (monkeypatched) API method to get a group by id.
-        group = self.portal.acl_users.getGroup(self.group_id)
-        self.assertFalse(group is None)
-
-        # Should be wrapped into the GroupManagement, which is wrapped
-        # into the PAS.
-        got = aq_base(aq_parent(aq_parent(group)))
-        expected = aq_base(self.portal.acl_users)
-        self.assertEqual(got, expected)
-
-        self.assertTrue(isinstance(group, PloneGroup))
-
-    def test_get_group_by_id(self):
-        # Use tool way of getting group by id. This returns a
-        # GroupData object wrapped by the group
-        group = self.gt.getGroupById(self.group_id)
-        self.assertFalse(group is None)
-        self.assertTrue(isinstance(group, GroupData))
-        self.assertTrue(isinstance(aq_parent(group), PloneGroup))
-
-    def test_edit_group(self):
-        # Use the tool way to edit a group.
-        properties = {
-            'email': 'group1@host2.com',
-            'title': 'Group #1 new title'
-        }
-        self.gt.editGroup(
-            self.group_id,
-            roles=['Manager'],
-            **properties
-        )
-
-        # test edition of roles and properties
-        group = self.gt.getGroupById(self.group_id)
-        self.assertTrue(group.has_role('Manager'))
-        self.assertEqual(group.getProperty('email'), properties['email'])
-        self.assertEqual(group.getProperty('title'), properties['title'])
-
-        # test for empty list of roles
-        self.gt.editGroup(self.group_id, roles=[])
-        self.assertTrue(group.has_role('Authenticated'))
-
-        # test edition of group groups
-        self.gt.editGroup(
-            self.group_id,
-            groups=['Reviewers'],
-            **properties
-        )
-        group = self.gt.getGroupById(self.group_id)
-        self.assertTrue('Reviewers' in group.getGroups())
-
-
-class TestMethodProtection(base.TestCase):
-    # GroupData has wrong security declarations
-
-    def afterSetUp(self):
-        self.groups = self.portal.portal_groups
-        self.groups.addGroup('foo')
-        self.groupdata = self.groups.getGroupById('foo')
-
-    def testAnonAddMember(self):
-        self.logout()
-        self.assertRaises(Unauthorized, self.groupdata.addMember, TEST_USER_ID)
-
-    def testAnonRemoveMember(self):
-        self.logout()
-        self.assertRaises(Unauthorized, self.groupdata.removeMember,
-                          TEST_USER_ID)
-
-    def testMemberAddMember(self):
-        self.assertRaises(Unauthorized, self.groupdata.addMember, TEST_USER_ID)
-
-    def testMemberRemoveMember(self):
-        self.assertRaises(Unauthorized, self.groupdata.removeMember,
-                          TEST_USER_ID)
-
-    def testManagerAddMember(self):
-        self.setPermissions([Permissions.manage_users])
-        self.groupdata.addMember(TEST_USER_ID)
-
-    def testManagerRemoveMember(self):
-        self.setPermissions([Permissions.manage_users])
-        self.groupdata.addMember(TEST_USER_ID)
-        self.groupdata.removeMember(TEST_USER_ID)
-
-
-class TestGroupsTool(base.TestCase, WarningInterceptor):
-
-    def afterSetUp(self):
-        self.membership = self.portal.portal_membership
-        self.acl_users = self.portal.acl_users
-        self.groups = self.portal.portal_groups
-        self._trap_warning_output()
-
-        if 'auto_group' in self.acl_users:
-            self.acl_users.manage_delObjects(['auto_group'])
-
-        # Nuke Administators and Reviewers groups added in 2.1a2 migrations
-        # (and any other migrated-in groups) to avoid test confusion
-        self.groups.removeGroups(self.groups.listGroupIds())
-
-    def testAddGroup(self):
-        self.groups.addGroup('foo', [], [])
-        self.assertEqual(self.groups.listGroupIds(), ['foo'])
-
-    def testGetGroupById(self):
-        self.groups.addGroup('foo', [], [])
-        g = self.groups.getGroupById('foo')
-        self.assertNotEqual(g, None)
-
-    def testGetBadGroupById(self):
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(g, None)
-
-    def testGroupByIdIsWrapped(self):
-        self.groups.addGroup('foo', [], [])
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(g.__class__.__name__, 'GroupData')
-        self.assertEqual(g.aq_parent.__class__.__name__, 'PloneGroup')
-        self.assertEqual(g.aq_parent.aq_parent.__class__.__name__,
-                         'GroupManager')
-
-    def testEditGroup(self):
-        self.groups.addGroup('foo', )
-        self.groups.editGroup('foo', roles=['Reviewer'])
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(sortTuple(g.getRoles()),
-                         ('Authenticated', 'Reviewer'))
-
-    def testEditBadGroup(self):
-        # Error type depends on the user folder...
-        try:
-            self.groups.editGroup('foo', [], [])
-        except (KeyError, ValueError):
-            pass        # Ok, this is the wanted behaviour
-        else:
-            self.fail("Should have raised KeyError or ValueError")
-
-    def testRemoveGroups(self):
-        self.groups.addGroup('foo', [], [])
-        self.groups.removeGroups(['foo'])
-        self.assertEqual(len(self.groups.listGroupIds()), 0)
-
-    def testListGroupIds(self):
-        self.groups.addGroup('foo', [], [])
-        self.groups.addGroup('bar', [], [])
-        grps = self.groups.listGroupIds()
-        grps.sort()
-        self.assertEqual(grps, ['bar', 'foo'])
-
-    def testGetGroupsByUserId(self):
-        self.groups.addGroup('foo', [], [])
-        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
-        gs = self.groups.getGroupsByUserId(TEST_USER_ID)
-        self.assertEqual(gs[0].getId(), 'foo')
-
-    def testGroupsByUserIdAreWrapped(self):
-        self.groups.addGroup('foo', [], [])
-        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
-        gs = self.groups.getGroupsByUserId(TEST_USER_ID)
-        self.assertEqual(gs[0].__class__.__name__, 'GroupData')
-        self.assertEqual(gs[0].aq_parent.__class__.__name__, 'PloneGroup')
-        self.assertEqual(gs[0].aq_parent.aq_parent.__class__.__name__,
-                         'GroupManager')
-
-    def testListGroups(self):
-        self.groups.addGroup('foo', [], [])
-        self.groups.addGroup('bar', [], [])
-        gs = self.groups.listGroups()
-        self.assertEqual(gs[0].getId(), 'bar')
-        self.assertEqual(gs[1].getId(), 'foo')
-
-    def testListedGroupsAreWrapped(self):
-        self.groups.addGroup('foo', [], [])
-        gs = self.groups.listGroups()
-        self.assertEqual(gs[0].__class__.__name__, 'GroupData')
-        self.assertEqual(gs[0].aq_parent.__class__.__name__, 'PloneGroup')
-        self.assertEqual(gs[0].aq_parent.aq_parent.__class__.__name__,
-                         'GroupManager')
-
-    def testSetGroupOwnership(self):
-        self.groups.addGroup('foo', [], [])
-        self.folder.invokeFactory('Document', 'doc')
-        doc = self.folder.doc
-        g = self.groups.getGroupById('foo')
-        self.groups.setGroupOwnership(g, doc)
-        self.assertEqual(doc.getOwnerTuple()[1], 'foo')
-        self.assertEqual(doc.get_local_roles_for_userid('foo'), ('Owner',))
-        self.assertEqual(doc.get_local_roles_for_userid(TEST_USER_ID),
-                         ('Owner',))
-
-    def testWrapGroup(self):
-        self.groups.addGroup('foo', [], [])
-        g = self.acl_users.getGroup('foo')
-        self.assertEqual(g.__class__.__name__, 'PloneGroup')
-        g = self.groups.wrapGroup(g)
-        self.assertEqual(g.__class__.__name__, 'GroupData')
-        self.assertEqual(g.aq_parent.__class__.__name__, 'PloneGroup')
-        self.assertEqual(g.aq_parent.aq_parent.__class__.__name__,
-                         'GroupManager')
-
-    def testGetGroupInfo(self):
-        self.groups.addGroup('foo', title='Foo', description='Bar',
-                             email='foo@foo.com')
-        info = self.groups.getGroupInfo('foo')
-        self.assertEqual(info.get('title'), 'Foo')
-        self.assertEqual(info.get('description'), 'Bar')
-        self.assertEqual(info.get('email'), None)  # No email!
-
-    def testGetGroupInfoAsAnonymous(self):
-        self.groups.addGroup('foo', title='Foo', description='Bar')
-        self.logout()
-        info = self.groups.restrictedTraverse('getGroupInfo')('foo')
-        self.assertEqual(info.get('title'), 'Foo')
-        self.assertEqual(info.get('description'), 'Bar')
-
-    def testGetBadGroupInfo(self):
-        info = self.groups.getGroupInfo('foo')
-        self.assertEqual(info, None)
-
-    def beforeTearDown(self):
-        self._free_warning_output()
-
diff --git a/Products/PlonePAS/tests/test_memberdatatool.py b/Products/PlonePAS/tests/test_memberdatatool.py
deleted file mode 100644
index b7ae400..0000000
--- a/Products/PlonePAS/tests/test_memberdatatool.py
+++ /dev/null
@@ -1,70 +0,0 @@
-# -*- coding: utf-8 -*-
-from DateTime import DateTime
-from OFS.Image import Image
-from Products.PlonePAS.tests import base
-from Products.PlonePAS.tests import dummy
-from plone.app.testing import TEST_USER_ID as default_user
-
-
-class TestMemberDataTool(base.TestCase):
-
-    def afterSetUp(self):
-        self.memberdata = self.portal.portal_memberdata
-        self.membership = self.portal.portal_membership
-        self.membership.memberareaCreationFlag = 0
-        # Don't let default_user disturb results
-        self.portal.acl_users._doDelUsers([default_user])
-        # Add some members
-        self.addMember('fred', 'Fred Flintstone', 'fred@bedrock.com',
-                       ['Member', 'Reviewer'], '2002-01-01')
-        self.addMember('barney', 'Barney Rubble', 'barney@bedrock.com',
-                       ['Member'], '2002-01-01')
-        self.addMember('brubble', 'Bambam Rubble', 'bambam@bambam.net',
-                       ['Member'], '2003-12-31')
-        # MUST reset this
-        self.memberdata._v_temps = None
-
-    def addMember(self, username, fullname, email, roles, last_login_time):
-        self.membership.addMember(username, 'secret', roles, [])
-        member = self.membership.getMemberById(username)
-        member.setMemberProperties({
-            'fullname': fullname,
-            'email': email,
-            'last_login_time': DateTime(last_login_time), })
-
-    def testSetPortrait(self):
-        self.memberdata._setPortrait(
-            Image(id=default_user, file=dummy.File(), title=''),
-            default_user)
-        self.assertEqual(self.memberdata._getPortrait(default_user).getId(),
-                         default_user)
-        self.assertEqual(self.memberdata._getPortrait(default_user).meta_type,
-                         'Image')
-
-    def testDeletePortrait(self):
-        self.memberdata._setPortrait(
-            Image(id=default_user, file=dummy.File(), title=''),
-            default_user)
-        self.memberdata._deletePortrait(default_user)
-        self.assertEqual(self.memberdata._getPortrait(default_user), None)
-
-    def testPruneMemberDataContents(self):
-        # Only test what is not already tested elswhere
-        self.memberdata._setPortrait(
-            Image(id=default_user, file=dummy.File(), title=''),
-            default_user)
-        self.memberdata._setPortrait(
-            Image(id=default_user, file=dummy.File(), title=''),
-            'dummy')
-        self.memberdata.pruneMemberDataContents()
-        self.assertEqual(len(self.memberdata.portraits), 1)
-
-    def testFulltextMemberSearch(self):
-        # Search for a user by id, name, email, ...
-        search = self.memberdata.searchFulltextForMembers
-        self.assertEqual(len(search('')), 3)
-        self.assertEqual(len(search('rubble')), 2)
-        self.assertEqual(len(search('stone')), 1)
-        self.assertEqual(len(search('bambam.net')), 1)
-        self.assertEqual(len(search('bedrock.com')), 2)
-        self.assertEqual(len(search('brubble')), 1)
diff --git a/Products/PlonePAS/tests/test_membershiptool.py b/Products/PlonePAS/tests/test_membershiptool.py
deleted file mode 100644
index 29d309d..0000000
--- a/Products/PlonePAS/tests/test_membershiptool.py
+++ /dev/null
@@ -1,968 +0,0 @@
-# -*- coding: utf-8 -*-
-from AccessControl import Unauthorized
-from AccessControl import getSecurityManager
-from AccessControl.User import nobody
-from Acquisition import aq_base
-from Acquisition import aq_parent
-from DateTime import DateTime
-from OFS.Image import Image
-from Products.CMFCore.interfaces import IPropertiesTool
-from Products.CMFCore.tests.base.testcase import WarningInterceptor
-from Products.CMFCore.utils import getToolByName
-from Products.PlonePAS.browser.member import PASMemberView
-from Products.PlonePAS.interfaces.membership import IMembershipTool
-from Products.PlonePAS.plugins.ufactory import PloneUser
-from Products.PlonePAS.tests import base
-from Products.PlonePAS.tests import dummy
-from Products.PlonePAS.tools.memberdata import MemberData
-from Products.PlonePAS.tools.membership import MembershipTool
-from Products.PlonePAS.utils import getGroupsForPrincipal
-from cStringIO import StringIO
-from plone.app.testing import PLONE_SITE_ID
-from plone.app.testing import SITE_OWNER_NAME
-from plone.app.testing import TEST_USER_ID
-from plone.app.testing import TEST_USER_NAME
-from plone.app.testing import TEST_USER_PASSWORD
-from zExceptions import BadRequest
-from zope.component import getUtility
-import os
-
-
-class MembershipToolTest(base.TestCase):
-
-    def afterSetUp(self):
-        self.mt = getToolByName(self.portal, 'portal_membership')
-        self.md = getToolByName(self.portal, 'portal_memberdata')
-
-        self.member_id = 'member1'
-        # Create a new Member
-        self.mt.addMember(
-            self.member_id,
-            'pw',
-            ['Member'],
-            [],
-            {'email': 'member1@host.com', 'title': 'Member #1'}
-        )
-
-    def test_get_member(self):
-        member = self.portal.acl_users.getUserById(self.member_id)
-        self.assertFalse(member is None)
-
-        # Should be wrapped into the PAS.
-        got = aq_base(aq_parent(member))
-        expected = aq_base(self.portal.acl_users)
-        self.assertEqual(got, expected)
-
-        self.assertTrue(isinstance(member, PloneUser))
-
-    def test_get_member_by_id(self):
-        # Use tool way of getting member by id. This returns a
-        # MemberData object wrapped by the member
-        member = self.mt.getMemberById(self.member_id)
-        self.assertFalse(member is None)
-        self.assertTrue(isinstance(member, MemberData))
-        self.assertTrue(isinstance(aq_parent(member), PloneUser))
-
-    def test_id_clean(self):
-        from Products.PlonePAS.utils import cleanId, decleanId
-        a = [
-             "asdfasdf",
-             "asdf-asdf",
-             "asdf--asdf",
-             "asdf---asdf",
-             "asdf----asdf",
-             "asdf-----asdf",
-             "asdf%asdf",
-             "asdf%%asdf",
-             "asdf%%%asdf",
-             "asdf%%%%asdf",
-             "asdf%%%%%asdf",
-             "asdf-%asdf",
-             "asdf%-asdf",
-             "asdf-%-asdf",
-             "asdf%-%asdf",
-             "asdf--%asdf",
-             "asdf%--asdf",
-             "asdf--%-asdf",
-             "asdf-%--asdf",
-             "asdf--%--asdf",
-             "asdf%-%asdf",
-             "asdf%--%asdf",
-             "asdf%---%asdf",
-             "-asdf",
-             "--asdf",
-             "---asdf",
-             "----asdf",
-             "-----asdf",
-             "asdf-",
-             "asdf--",
-             "asdf---",
-             "asdf----",
-             "asdf-----",
-             "%asdf",
-             "%%asdf",
-             "%%%asdf",
-             "%%%%asdf",
-             "%%%%%asdf",
-             "asdf%",
-             "asdf%%",
-             "asdf%%%",
-             "asdf%%%%",
-             "asdf%%%%%",
-             "asdf\x00asdf",
-        ]
-        b = [cleanId(id) for id in a]
-        c = [decleanId(id) for id in b]
-        ac = zip(a, c)
-        for aa, cc in ac:
-            self.assertTrue(aa == cc)
-
-
-class MemberAreaTest(base.TestCase):
-
-    def afterSetUp(self):
-        self.mt = getToolByName(self.portal, 'portal_membership')
-        self.md = getToolByName(self.portal, 'portal_memberdata')
-        # Enable member-area creation
-        self.mt.memberareaCreationFlag = 1
-        # Those are all valid chars in Zope.
-        self.mid = "Member #1 - Houston, TX. ($100)"
-        self.pas = self.portal.acl_users
-        self.loginAsPortalOwner()
-
-    def test_funky_member_ids_1(self):
-        mid = self.mid
-        minfo = (mid, 'pw', ['Member'], [])
-
-        # Create a new User
-        self.pas._doAddUser(*minfo)
-        self.mt.createMemberArea, (mid)
-
-    def test_funky_member_ids_2(self):
-        # Forward-slash is not allowed
-        mid = self.mid + '/'
-        minfo = (mid, 'pw', ['Member'], [])
-
-        # Create a new User
-        self.pas._doAddUser(*minfo)
-        self.mt.createMemberArea(mid)
-
-    def test_memberareaCreationFlag_respected(self):
-        self.pas._doAddUser('foo', 'pw', ['Member'], [])
-        self.pas._doAddUser('bar', 'pw', ['Member'], [])
-
-        self.assertFalse('foo' in self.portal.Members)
-        self.assertFalse('bar' in self.portal.Members)
-
-        self.mt.createMemberarea('foo')
-        self.assertTrue('foo' in self.portal.Members)
-
-        self.mt.memberareaCreationFlag = 0
-        self.mt.createMemberArea('bar')
-        self.assertFalse('bar' in self.portal.Members)
-
-
-class TestMembershipTool(base.TestCase, WarningInterceptor):
-
-    def afterSetUp(self):
-        self.membership = self.portal.portal_membership
-        self.groups = self.portal.portal_groups
-        self._trap_warning_output()
-
-    def test_interface(self):
-        from zope.interface.verify import verifyClass
-        verifyClass(IMembershipTool, MembershipTool)
-
-    def addMember(self, username, fullname, email, roles, last_login_time):
-        self.membership.addMember(username, 'secret', roles, [])
-        member = self.membership.getMemberById(username)
-        member.setMemberProperties({
-            'fullname': fullname, 'email': email,
-            'last_login_time': DateTime(last_login_time), })
-
-    def makeRealImage(self):
-        import Products.PlonePAS as ppas
-        pas_path = os.path.dirname(ppas.__file__)
-        path = os.path.join(pas_path, 'tool.gif')
-        image = open(path, 'rb')
-        image_upload = dummy.FileUpload(dummy.FieldStorage(image))
-        return image_upload
-
-    def testNoMorePersonalFolder(self):
-        # .personal folders are history
-        personal = getattr(self.folder, self.membership.personal_id, None)
-        self.assertEqual(personal, None)
-        self.assertEqual(self.membership.getPersonalFolder(TEST_USER_ID), None)
-
-    def testGetPersonalFolderIfNoHome(self):
-        # Should return None as the user has no home folder
-        members = self.membership.getMembersFolder()
-        members._delObject(TEST_USER_ID)
-        self.assertEqual(self.membership.getPersonalFolder(TEST_USER_ID), None)
-
-    def testGetPersonalPortrait(self):
-        # Should return the default portrait
-        self.assertEqual(
-            self.membership.getPersonalPortrait(TEST_USER_ID).getId(),
-            'defaultUser.png')
-
-    def testChangeOwnMemberPortrait(self):
-        # Should change the portrait image
-        # first we need a valid image
-        image = self.makeRealImage()
-        self.membership.changeMemberPortrait(image, TEST_USER_ID)
-        self.assertEqual(
-            self.membership.getPersonalPortrait(TEST_USER_ID).getId(),
-            TEST_USER_ID)
-        self.assertEqual(
-            self.membership.getPersonalPortrait(TEST_USER_ID).meta_type,
-            'Image')
-
-    def testChangeOwnMemberPortraitWithEmailUsers(self):
-        member_id = 'member2@host.com'
-        self.membership.addMember(
-            member_id,
-            'pw',
-            ['Member'],
-            [],
-            {'email': 'member2@host.com', 'title': 'Member #2'}
-        )
-
-        self.login(member_id)
-        image = self.makeRealImage()
-        safe_member_id = self.membership._getSafeMemberId(member_id)
-
-        self.membership.changeMemberPortrait(image, member_id)
-        self.assertEqual(
-            self.membership.getPersonalPortrait(member_id).getId(),
-            safe_member_id)
-        self.assertEqual(
-            self.membership.getPersonalPortrait(member_id).meta_type,
-            'Image')
-
-    def testCannotChangeOtherMemberPortrait(self):
-        # A normal member should not be able to change the portrait of
-        # another member.
-        image = self.makeRealImage()
-        self.membership.addMember('joe', 'secret', ['Member'], [])
-        self.assertRaises(Unauthorized, self.membership.changeMemberPortrait,
-                          image, 'joe')
-
-    def testChangeMemberPortraitAsManager(self):
-        # Managers should be able to change the portrait of another
-        # member.
-        image = self.makeRealImage()
-        self.membership.addMember('joe', 'secret', ['Member'], [])
-        self.setRoles(['Manager'])
-        # This should not raise Unauthorized:
-        self.membership.changeMemberPortrait(image, 'joe')
-        self.assertEqual(self.membership.getPersonalPortrait('joe').getId(),
-                         'joe')
-        self.assertEqual(self.membership.getPersonalPortrait('joe').meta_type,
-                         'Image')
-
-    def testDeleteOwnPersonalPortrait(self):
-        # Should delete the portrait image
-        image = self.makeRealImage()
-        self.membership.changeMemberPortrait(image, TEST_USER_ID)
-        self.assertEqual(
-            self.membership.getPersonalPortrait(TEST_USER_ID).getId(),
-            TEST_USER_ID)
-        self.membership.deletePersonalPortrait(TEST_USER_ID)
-        self.assertEqual(
-            self.membership.getPersonalPortrait(TEST_USER_ID).getId(),
-            'defaultUser.png')
-
-    def testCannotDeleteOtherPersonalPortrait(self):
-        # A normal member should not be able to delete the portrait of
-        # another member.
-        image = self.makeRealImage()
-        self.membership.addMember('joe', 'secret', ['Member'], [])
-        self.setRoles(['Manager'])
-        self.membership.changeMemberPortrait(image, 'joe')
-        self.setRoles(['Member'])
-        self.assertRaises(Unauthorized, self.membership.deletePersonalPortrait,
-                          'joe')
-
-    def testDeleteOtherPersonalPortraitAsManager(self):
-        # Managers should be able to change the portrait of another
-        # member.
-        image = self.makeRealImage()
-        self.membership.addMember('joe', 'secret', ['Member'], [])
-        self.setRoles(['Manager'])
-        self.membership.changeMemberPortrait(image, 'joe')
-        self.membership.deletePersonalPortrait('joe')
-        self.assertEqual(
-            self.membership.getPersonalPortrait('joe').getId(),
-            'defaultUser.png'
-        )
-
-    def testGetPersonalPortraitWithoutPassingId(self):
-        # Should return the logged in users portrait if no id is given
-        image = self.makeRealImage()
-        self.membership.changeMemberPortrait(image, TEST_USER_ID)
-        self.assertEqual(self.membership.getPersonalPortrait().getId(),
-                         TEST_USER_ID)
-        self.assertEqual(self.membership.getPersonalPortrait().meta_type,
-                         'Image')
-
-    def testPortraitForNonStandardUserId(self):
-        # Some characters in a user id can give problems for getting
-        # or saving a portrait, especially '-', '+', '@'.
-        image = self.makeRealImage()
-        user_id = 'bob-jones+test@example.org'
-        safe_id = self.membership._getSafeMemberId(user_id)
-        self.assertEqual(safe_id, 'bob--jones-2Btest-40example.org')
-        self.membership.addMember(user_id, 'secret', ['Member'], [])
-        self.login(user_id)
-
-        # Should return the default portrait
-        self.assertEqual(
-            self.membership.getPersonalPortrait(user_id).getId(),
-            'defaultUser.png')
-
-        # Change your own portrait.
-        self.membership.changeMemberPortrait(image, user_id)
-        self.assertEqual(self.membership.getPersonalPortrait().getId(),
-                         safe_id)
-        self.assertEqual(self.membership.getPersonalPortrait().meta_type,
-                         'Image')
-
-        # Other users should be able to see your portrait.
-        self.login(TEST_USER_NAME)
-        self.assertEqual(
-            self.membership.getPersonalPortrait(user_id).getId(),
-            safe_id)
-        self.assertEqual(
-            self.membership.getPersonalPortrait(user_id).meta_type,
-            'Image')
-
-        # You can delete your own portrait.
-        self.login(user_id)
-        self.membership.deletePersonalPortrait(user_id)
-        self.assertEqual(
-            self.membership.getPersonalPortrait(user_id).getId(),
-            'defaultUser.png')
-
-        # Managers should be able to change the portrait of another
-        # member and delete it.
-        manager_image = self.makeRealImage()
-        self.loginAsPortalOwner()
-        # This should not raise Unauthorized:
-        self.membership.changeMemberPortrait(manager_image, user_id)
-        self.assertEqual(self.membership.getPersonalPortrait(user_id).getId(),
-                         safe_id)
-        self.membership.deletePersonalPortrait(user_id)
-        self.assertEqual(
-            self.membership.getPersonalPortrait(user_id).getId(),
-            'defaultUser.png'
-        )
-
-    def testListMembers(self):
-        # Should return the members list
-        members = self.membership.listMembers()
-        self.assertEqual(len(members), 1)
-        self.assertEqual(members[0].getId(), TEST_USER_ID)
-
-    def testListMembersSkipsGroups(self):
-        # Should only return real members, not groups
-        uf = self.portal.acl_users
-        self.groups.addGroup('Foo')
-        self.groups.addGroup('Bar')
-        self.assertEqual(len(uf.getUserNames()), 1)
-        members = self.membership.listMembers()
-        self.assertEqual(len(members), 1)
-        self.assertEqual(members[0].getId(), TEST_USER_ID)
-
-    def testListMemberIds(self):
-        # Should return the members ids list
-        memberids = self.membership.listMemberIds()
-        self.assertEqual(len(memberids), 1)
-        self.assertEqual(memberids[0], TEST_USER_ID)
-
-    def testListMemberIdsSkipsGroups(self):
-        # Should only return real members, not groups
-        uf = self.portal.acl_users
-        self.groups.addGroup('Foo')
-        self.groups.addGroup('Bar')
-        self.assertEqual(len(uf.getUserNames()), 1)
-        memberids = self.membership.listMemberIds()
-        self.assertEqual(len(memberids), 1)
-        self.assertEqual(memberids[0], TEST_USER_ID)
-
-    def testCurrentPassword(self):
-        # Password checking should work
-        self.assertTrue(self.membership.testCurrentPassword('secret'))
-        self.assertFalse(self.membership.testCurrentPassword('geheim'))
-
-    def testSetPassword(self):
-        # Password should be changed
-        self.membership.setPassword('geheim')
-        self.assertTrue(self.membership.testCurrentPassword('geheim'))
-
-    def testSetPasswordIfAnonymous(self):
-        # Anonymous should not be able to change password
-        self.logout()
-        try:
-            self.membership.setPassword('geheim')
-        except BadRequest:
-            import sys
-            e, v, tb = sys.exc_info()
-            del tb
-            if str(v) == 'Not logged in.':
-                pass
-            else:
-                raise
-
-    def testSetPasswordAndKeepGroups(self):
-        # Password should be changed and user must not change group membership
-        group2 = 'g2'
-        groups = self.groups
-        groups.addGroup(group2, None, [], [])
-        group = groups.getGroupById(group2)
-        self.loginAsPortalOwner()
-        group.addMember(TEST_USER_ID)
-        self.login(TEST_USER_NAME)  # Back to normal
-        ugroups = self.portal.acl_users.getUserById(TEST_USER_ID).getGroups()
-        self.membership.setPassword('geheim')
-        t_groups = self.portal.acl_users.getUserById(TEST_USER_ID).getGroups()
-        self.assertTrue(t_groups == ugroups)
-
-    def testGetMemberById(self):
-        # This should work for portal users,
-        self.assertNotEqual(self.membership.getMemberById(TEST_USER_ID), None)
-        self.assertEqual(self.membership.getMemberById('foo'), None)
-        self.assertNotEqual(
-            self.membership.getMemberById(SITE_OWNER_NAME),
-            None
-        )
-
-    def testGetMemberByIdIsWrapped(self):
-        member = self.membership.getMemberById(TEST_USER_ID)
-        self.assertNotEqual(member, None)
-        self.assertEqual(member.__class__.__name__, 'MemberData')
-        self.assertEqual(member.aq_parent.__class__.__name__, 'PloneUser')
-
-    def testGetAuthenticatedMember(self):
-        member = self.membership.getAuthenticatedMember()
-        self.assertEqual(member.getUserName(), TEST_USER_NAME)
-
-    def testGetAuthenticatedMemberIsWrapped(self):
-        member = self.membership.getAuthenticatedMember()
-        self.assertEqual(member.getUserName(), TEST_USER_NAME)
-        self.assertEqual(member.__class__.__name__, 'MemberData')
-        self.assertEqual(member.aq_parent.__class__.__name__, 'PloneUser')
-
-    def testGetAuthenticatedMemberIfAnonymous(self):
-        self.logout()
-        member = self.membership.getAuthenticatedMember()
-        self.assertEqual(member.getUserName(), 'Anonymous User')
-
-    def testAnonymousMemberIsNotWrapped(self):
-        # Also see http://dev.plone.org/plone/ticket/1851
-        self.logout()
-        member = self.membership.getAuthenticatedMember()
-        self.assertNotEqual(member.__class__.__name__, 'MemberData')
-        self.assertEqual(member.__class__.__name__, 'SpecialUser')
-
-    def testIsAnonymousUser(self):
-        self.assertFalse(self.membership.isAnonymousUser())
-        self.logout()
-        self.assertTrue(self.membership.isAnonymousUser())
-
-    def testWrapUserWrapsBareUser(self):
-        user = self.portal.acl_users.getUserById(TEST_USER_ID)
-        # TODO: GRUF users are wrapped
-        self.assertTrue(hasattr(user, 'aq_base'))
-        user = aq_base(user)
-        user = self.membership.wrapUser(user)
-        self.assertEqual(user.__class__.__name__, 'MemberData')
-        self.assertEqual(user.aq_parent.__class__.__name__, 'PloneUser')
-        self.assertEqual(user.aq_parent.aq_parent.__class__.__name__,
-                         'PluggableAuthService')
-
-    def testWrapUserWrapsWrappedUser(self):
-        user = self.portal.acl_users.getUserById(TEST_USER_ID)
-        # TODO: GRUF users are wrapped
-        self.assertTrue(hasattr(user, 'aq_base'))
-        user = self.membership.wrapUser(user)
-        self.assertEqual(user.__class__.__name__, 'MemberData')
-        self.assertEqual(user.aq_parent.__class__.__name__, 'PloneUser')
-        self.assertEqual(user.aq_parent.aq_parent.__class__.__name__,
-                         'PluggableAuthService')
-
-    def testWrapUserDoesntWrapMemberData(self):
-        user = self.portal.acl_users.getUserById(TEST_USER_ID)
-        user.getMemberId = lambda x: 1
-        user = self.membership.wrapUser(user)
-        self.assertEqual(user.__class__.__name__, 'PloneUser')
-
-    def testWrapUserDoesntWrapAnonymous(self):
-        user = self.membership.wrapUser(nobody)
-        self.assertEqual(user.__class__.__name__, 'SpecialUser')
-
-    def testWrapUserWrapsAnonymous(self):
-        self.assertFalse(hasattr(nobody, 'aq_base'))
-        user = self.membership.wrapUser(nobody, wrap_anon=1)
-        self.assertEqual(user.__class__.__name__, 'MemberData')
-        self.assertEqual(user.aq_parent.__class__.__name__, 'SpecialUser')
-        self.assertEqual(user.aq_parent.aq_parent.__class__.__name__,
-                         'PluggableAuthService')
-
-    def testGetCandidateLocalRoles(self):
-        self.assertEqual(self.membership.getCandidateLocalRoles(self.folder),
-                         ('Owner',))
-        self.setRoles(['Member', 'Reviewer'])
-        self.assertEqual(self.membership.getCandidateLocalRoles(self.folder),
-                         ('Owner', 'Reviewer'))
-
-    def testSetLocalRoles(self):
-        self.assertTrue(
-            'Owner' in self.folder.get_local_roles_for_userid(TEST_USER_ID))
-        self.setRoles(['Member', 'Reviewer'])
-        self.membership.setLocalRoles(self.folder, [TEST_USER_ID, 'user2'],
-                                      'Reviewer')
-        self.assertEqual(self.folder.get_local_roles_for_userid(TEST_USER_ID),
-                         ('Owner', 'Reviewer'))
-        self.assertEqual(self.folder.get_local_roles_for_userid('user2'),
-                         ('Reviewer',))
-
-    def testDeleteLocalRoles(self):
-        self.setRoles(['Member', 'Reviewer'])
-        self.membership.setLocalRoles(self.folder, ['user2'], 'Reviewer')
-        self.assertEqual(self.folder.get_local_roles_for_userid('user2'),
-                         ('Reviewer',))
-        self.membership.deleteLocalRoles(self.folder, ['user2'])
-        self.assertEqual(self.folder.get_local_roles_for_userid('user2'), ())
-
-    def testGetHomeFolder(self):
-        self.assertNotEqual(self.membership.getHomeFolder(), None)
-        self.assertEqual(self.membership.getHomeFolder('user2'), None)
-
-    def testGetHomeUrl(self):
-        self.assertNotEqual(self.membership.getHomeUrl(), None)
-        self.assertEqual(self.membership.getHomeUrl('user2'), None)
-
-    def testGetAuthenticatedMemberInfo(self):
-        member = self.membership.getAuthenticatedMember()
-        member.setMemberProperties({'fullname': 'Test user'})
-        info = self.membership.getMemberInfo()
-        self.assertEqual(info['fullname'], 'Test user')
-
-    def testGetMemberInfo(self):
-        self.membership.addMember('user2', 'secret', ['Member'], [],
-                                  properties={'fullname': 'Second user'})
-        info = self.membership.getMemberInfo('user2')
-        self.assertEqual(info['fullname'], 'Second user')
-
-    def testGetCandidateLocalRolesIncludesLocalRolesOnObjectForManager(self):
-        self.folder._addRole('my_test_role')
-        self.folder.manage_setLocalRoles(TEST_USER_ID,
-                                         ('Manager', 'Owner'))
-        roles = self.membership.getCandidateLocalRoles(self.folder)
-        self.assertTrue('my_test_role' in roles,
-                        'my_test_role not in: %s' % str(roles))
-
-    def testGetCandidateLocalRolesIncludesLocalRolesOnObjectForAssignees(self):
-        self.folder._addRole('my_test_role')
-        self.folder.manage_setLocalRoles(TEST_USER_ID,
-                                         ('my_test_role', 'Owner'))
-        roles = self.membership.getCandidateLocalRoles(self.folder)
-        self.assertTrue('Owner' in roles)
-        self.assertTrue('my_test_role' in roles)
-        self.assertEqual(len(roles), 2)
-
-    def testGetCandidateLocalRolesForManager(self):
-        self.folder._addRole('my_test_role')
-        self.folder.manage_setLocalRoles(TEST_USER_ID, ('Manager', 'Owner'))
-        roles = self.membership.getCandidateLocalRoles(self.folder)
-        self.assertTrue('Manager' in roles)
-        self.assertTrue('Owner' in roles)
-        self.assertTrue('Reviewer' in roles)
-
-    def testGetCandidateLocalRolesForOwner(self):
-        self.folder._addRole('my_test_role')
-        roles = self.membership.getCandidateLocalRoles(self.folder)
-        self.assertTrue('Owner' in roles)
-        self.assertEqual(len(roles), 1)
-
-    def testGetCandidateLocalRolesForAssigned(self):
-        self.folder._addRole('my_test_role')
-        self.folder.manage_setLocalRoles(TEST_USER_ID, ('Reviewer', 'Owner'))
-        roles = self.membership.getCandidateLocalRoles(self.folder)
-        self.assertTrue('Owner' in roles)
-        self.assertTrue('Reviewer' in roles)
-        self.assertEqual(len(roles), 2)
-
-    def test_bug4333_delete_user_remove_memberdata(self):
-        # delete user should delete portal_memberdata
-        memberdata = self.portal.portal_memberdata
-        self.setRoles(['Manager'])
-        self.addMember('barney', 'Barney Rubble', 'barney@bedrock.com',
-                       ['Member'], '2002-01-01')
-        barney = self.membership.getMemberById('barney')
-        self.assertEqual(barney.getProperty('email'), 'barney@bedrock.com')
-        del barney
-
-        self.membership.deleteMembers(['barney'])
-        md = memberdata._members
-        self.assertFalse('barney' in md)
-
-        # There is an _v_ variable that is killed at the end of each request
-        # which stores a temporary version of the member object, this is
-        # a problem in this test.  In fact, this test does not really
-        # demonstrate the bug, which is actually caused by the script not
-        # using the tool.
-        memberdata._v_temps = None
-
-        self.membership.addMember('barney', 'secret', ['Member'], [])
-        barney = self.membership.getMemberById('barney')
-        self.assertNotEqual(barney.getProperty('fullname'), 'Barney Rubble')
-        self.assertNotEqual(barney.getProperty('email'), 'barney@bedrock.com')
-
-    def testBogusMemberPortrait(self):
-        # Should change the portrait image
-        bad_file = dummy.File(data='<div>This is a lie!!!</div>',
-                              headers={'content_type': 'image/jpeg'})
-        self.assertRaises(IOError, self.membership.changeMemberPortrait,
-                          bad_file, TEST_USER_ID)
-
-    def testGetBadMembers(self):
-        # Should list members with bad images
-        # We should not have any bad images out of the box
-        self.assertEqual(self.membership.getBadMembers(), [])
-        # Let's add one
-        bad_file = Image(
-            id=TEST_USER_ID,
-            title='',
-            file=StringIO('<div>This is a lie!!!</div>')
-        )
-        # Manually set a bad image using private methods
-        self.portal.portal_memberdata._setPortrait(bad_file, TEST_USER_ID)
-        self.assertEqual(self.membership.getBadMembers(), [TEST_USER_ID])
-        # Try an empty image
-        empty_file = Image(id=TEST_USER_ID, title='', file=StringIO(''))
-        self.portal.portal_memberdata._setPortrait(empty_file, TEST_USER_ID)
-        self.assertEqual(self.membership.getBadMembers(), [])
-        # And a good image
-        self.membership.changeMemberPortrait(self.makeRealImage(),
-                                             TEST_USER_ID)
-        self.assertEqual(self.membership.getBadMembers(), [])
-
-    def beforeTearDown(self):
-        self._free_warning_output()
-
-
-class TestCreateMemberarea(base.TestCase):
-
-    def afterSetUp(self):
-        self.membership = self.portal.portal_membership
-        self.membership.addMember('user2', 'secret', ['Member'], [])
-
-    def testCreateMemberarea(self):
-        # Should create a memberarea for user2
-        if self.membership.memberareaCreationFlag is True:
-            self.membership.createMemberarea('user2')
-            memberfolder = self.membership.getHomeFolder('user2')
-            self.assertTrue(memberfolder,
-                            'createMemberarea failed to create memberarea')
-            # member area creation should be on by default
-            self.assertTrue(self.membership.getMemberareaCreationFlag())
-
-    def testCreatMemberareaUsesCurrentUser(self):
-        if self.membership.memberareaCreationFlag is True:
-            # Should create a memberarea for user2
-            self.login('user2')
-            self.membership.createMemberarea()
-            memberfolder = self.membership.getHomeFolder('user2')
-            self.assertTrue(
-                memberfolder,
-                'createMemberarea failed to create memberarea for current '
-                'user'
-            )
-        else:
-            pass
-
-    def testNoMemberareaIfNoMembersFolder(self):
-        # Should not create a memberarea if the Members folder is missing
-        self.portal._delObject('Members')
-        self.membership.createMemberarea('user2')
-        memberfolder = self.membership.getHomeFolder('user2')
-        self.assertFalse(
-            memberfolder,
-            'createMemberarea unexpectedly created a memberarea'
-        )
-
-    def testNoMemberareaIfMemberareaExists(self):
-        # Should not attempt to create a memberarea if a memberarea already
-        # exists
-        self.membership.createMemberarea('user2')
-        # The second call should do nothing (not cause an error)
-        self.membership.createMemberarea('user2')
-
-    def testNotifyScriptIsCalled(self):
-        # The notify script should be called
-        if self.membership.memberareaCreationFlag is True:
-            self.portal.notifyMemberAreaCreated = dummy.Raiser(dummy.Error)
-            self.assertRaises(dummy.Error, self.membership.createMemberarea,
-                              'user2')
-
-    def testCreateMemberareaAlternateName(self):
-        # Alternate method name 'createMemberaArea' should work
-        if self.membership.memberareaCreationFlag is True:
-            self.membership.createMemberArea('user2')
-            memberfolder = self.membership.getHomeFolder('user2')
-            self.assertTrue(memberfolder,
-                            'createMemberArea failed to create memberarea')
-
-    def testCreateMemberareaAlternateType(self):
-        # Should be able to create another type instead of a normal Folder
-        if self.membership.memberareaCreationFlag is True:
-            self.membership.setMemberAreaType('Document')
-            self.membership.createMemberarea('user2')
-            memberfolder = self.membership.getHomeFolder('user2')
-            self.assertEqual(memberfolder.getPortalTypeName(), 'Document')
-
-    def testCreateMemberareaWhenDisabled(self):
-        # Should not create a member area
-        self.membership.setMemberareaCreationFlag = False
-        self.assertFalse(self.membership.getMemberareaCreationFlag())
-        self.membership.createMemberarea('user2')
-        memberfolder = self.membership.getHomeFolder('user2')
-        self.assertFalse(
-            memberfolder,
-            'createMemberarea created memberarea despite flag'
-        )
-
-
-class TestMemberareaSetup(base.TestCase):
-
-    def afterSetUp(self):
-        self.membership = self.portal.portal_membership
-        self.membership.addMember('user2', 'secret', ['Member'], [])
-        self.membership.createMemberarea('user2')
-        self.home = self.membership.getHomeFolder('user2')
-
-    def testMemberareaIsFolder(self):
-        if self.membership.memberareaCreationFlag is True:
-            # Memberarea should be a folder
-            self.assertEqual(self.home.meta_type, 'ATFolder')
-            self.assertEqual(self.home.portal_type, 'Folder')
-
-    def testMemberareaIsOwnedByMember(self):
-        if self.membership.memberareaCreationFlag is True:
-            # Memberarea should be owned by member
-            try:
-                owner_info = self.home.getOwnerTuple()
-            except AttributeError:
-                owner_info = self.home.getOwner(info=1)
-            self.assertEqual(owner_info[0], [PLONE_SITE_ID, 'acl_users'])
-            self.assertEqual(owner_info[1], 'user2')
-            self.assertEqual(len(self.home.get_local_roles()), 1)
-            self.assertEqual(self.home.get_local_roles_for_userid('user2'),
-                             ('Owner',))
-
-    def testMemberareaIsCataloged(self):
-        if self.membership.memberareaCreationFlag is True:
-            # Memberarea should be cataloged
-            catalog = self.portal.portal_catalog
-            self.assertTrue(catalog(id='user2', Type='Folder', Title="user2"),
-                            "Could not find user2's home folder in the "
-                            "catalog")
-
-    def testHomePageNotExists(self):
-        if self.membership.memberareaCreationFlag is True:
-            # Should not have an index_html document anymore
-            self.assertFalse('index_html' in self.home)
-
-
-class TestSearchForMembers(base.TestCase, WarningInterceptor):
-
-    def afterSetUp(self):
-        self.memberdata = self.portal.portal_memberdata
-        self.membership = self.portal.portal_membership
-        # Don't let default_user disturb results
-        self.portal.acl_users._doDelUsers([TEST_USER_ID])
-        # Add some members
-        self.addMember('fred', 'Fred Flintstone',
-                       'fred@bedrock.com', ['Member', 'Reviewer'],
-                       '2002-01-01')
-        self.addMember('barney', 'Barney Rubble',
-                       'barney@bedrock.com', ['Member'],
-                       '2002-01-01')
-        self.addMember('brubble', 'Bambam Rubble',
-                       'bambam@bambam.net', ['Member'],
-                       '2003-12-31')
-        # MUST reset this
-        self.memberdata._v_temps = None
-        self._trap_warning_output()
-
-    def addMember(self, username, fullname, email, roles, last_login_time):
-        self.membership.addMember(username, 'secret', roles, [])
-        member = self.membership.getMemberById(username)
-        member.setMemberProperties({
-            'fullname': fullname,
-            'email': email,
-            'last_login_time': DateTime(last_login_time), })
-
-    def testSearchById(self):
-        # Should search id and fullname
-        search = self.membership.searchForMembers
-        self.assertEqual(len(search(name='brubble')), 0)
-        self.assertEqual(len(search(name='barney')), 1)
-        self.assertEqual(len(search(name='rubble')), 2)
-
-    def testSearchByName(self):
-        # Should search id and fullname
-        search = self.membership.searchForMembers
-        self.assertEqual(len(search(name='rubble')), 2)
-        self.assertEqual(len(search(name='stone')), 1)
-
-    def testSearchByEmail(self):
-        search = self.membership.searchForMembers
-        self.assertEqual(len(search(email='bedrock')), 2)
-        self.assertEqual(len(search(email='bambam')), 1)
-
-    def testSearchByRoles(self):
-        search = self.membership.searchForMembers
-        self.assertEqual(len(search(roles=['Member'])), 3)
-        self.assertEqual(len(search(roles=['Reviewer'])), 1)
-
-    def testSearchByNameAndEmail(self):
-        search = self.membership.searchForMembers
-        self.assertEqual(len(search(name='rubble', email='bedrock')), 1)
-        self.assertEqual(len(search(name='bambam', email='bedrock')), 0)
-
-    def testSearchByNameAndRoles(self):
-        search = self.membership.searchForMembers
-        self.assertEqual(len(search(name='fred', roles=['Reviewer'])), 1)
-        self.assertEqual(len(search(name='fred', roles=['Manager'])), 0)
-
-    def testSearchByEmailAndRoles(self):
-        search = self.membership.searchForMembers
-        self.assertEqual(len(search(email='fred', roles=['Reviewer'])), 1)
-        self.assertEqual(len(search(email='fred', roles=['Manager'])), 0)
-
-    def testSearchByRequestObj(self):
-        search = self.membership.searchForMembers
-        self.addMember(u'jürgen', u'Jürgen Internationalist',
-                       'juergen@example.com', ['Member'],
-                       '2014-02-03')
-
-        self.assertEqual(len(search(
-            REQUEST=dict(name=u'jürgen'))), 1)
-
-        ptool = getUtility(IPropertiesTool)
-        ptool._setProperty('default_charset', 'iso8859-1')
-        self.assertEqual(len(search(
-            REQUEST=dict(name=u'jürgen'.encode('iso8859-1')))), 1)
-
-    def beforeTearDown(self):
-        self._free_warning_output()
-
-
-class TestDefaultUserAndPasswordNotChanged(base.TestCase):
-    # A test for a silly transaction/persistency bug in PlonePAS
-
-    def afterSetUp(self):
-        self.membership = self.portal.portal_membership
-
-    def testDefaultUserAndPasswordUnchanged(self):
-        member = self.membership.getAuthenticatedMember()
-        self.assertEqual(member.getUserName(), TEST_USER_NAME)
-        self.assertTrue(
-            self.membership.testCurrentPassword(TEST_USER_PASSWORD)
-        )
-        self.assertFalse(self.membership.testCurrentPassword('geheim'))
-
-
-class TestMethodProtection(base.TestCase):
-    # MembershipTool is missing security declarations
-    # http://dev.plone.org/plone/ticket/5432
-
-    _unprotected = (
-        'changeMemberPortrait',
-        'deletePersonalPortrait',
-        'testCurrentPassword',
-        'searchForMembers',
-    )
-
-    def afterSetUp(self):
-        self.membership = self.portal.portal_membership
-
-    def assertUnprotected(self, object, method):
-        self.logout()
-        object.restrictedTraverse(method)
-
-    def assertProtected(self, object, method):
-        self.logout()
-        self.assertRaises(Unauthorized, object.restrictedTraverse, method)
-
-    for method in _unprotected:
-        exec "def testUnprotected_%s(self):" \
-             "    self.assertProtected(self.membership, '%s')" \
-                % (method, method)
-
-        exec "def testMemberAccessible_%s(self):" \
-             "    self.membership.restrictedTraverse('%s')" % (method, method)
-
-
-class TestMemberInfoView(base.TestCase):
-
-    def afterSetUp(self):
-        self.membership = self.portal.portal_membership
-        self.view = PASMemberView(self.portal, self.portal.REQUEST)
-
-    def testMemberInfoViewForAuthenticated(self):
-        member = self.membership.getAuthenticatedMember()
-        member.setMemberProperties({'fullname': 'Test user'})
-        info = self.view.info()
-        self.assertEqual(info['username'], 'test-user')
-        self.assertEqual(info['fullname'], 'Test user')
-        self.assertEqual(info['name_or_id'], 'Test user')
-
-    def testGetMemberInfoViewForMember(self):
-        self.membership.addMember('user2', 'secret', ['Member'], [],
-                                  properties={'fullname': 'Second user'})
-        info = self.view.info('user2')
-        self.assertEqual(info['username'], 'user2')
-        self.assertEqual(info['fullname'], 'Second user')
-        self.assertEqual(info['name_or_id'], 'Second user')
-
-    def testGetMemberInfoViewForNonMember(self):
-        # When content is owned by a user who has meanwhile been
-        # removed, we do not want to throw an exception when asking
-        # for his member info.
-        self.assertFalse(self.membership.getMemberById('charon'))
-        info = self.view.info('charon')
-        self.assertEqual(info['username'], 'charon')
-        self.assertEqual(info['fullname'], '')
-        self.assertEqual(info['name_or_id'], 'charon')
-
-    def testGetMemberInfoViewForAnonymous(self):
-        self.logout()
-        self.assertTrue(self.membership.isAnonymousUser())
-        info = self.view.info()
-        self.assertEqual(info['username'], 'Anonymous User')
-        self.assertEqual(info['fullname'], None)
-        self.assertEqual(info['name_or_id'], 'Anonymous User')
-
-    def testSetGroupsWithUserNameIdDifference(self):
-        pas = self.portal['acl_users']
-        self.portal.portal_groups.addGroup('Editors', [], [])
-        self.setGroups(['Editors'], name=TEST_USER_ID)
-        self.login(TEST_USER_NAME)
-        user = getSecurityManager().getUser()
-        self.assertTrue(
-            'Editors' in getGroupsForPrincipal(user, pas['plugins'])
-        )
-        self.login()
-
-    def testSetGroupsWithSameUserNameAndId(self):
-        pas = self.portal['acl_users']
-        self.portal.portal_groups.addGroup('Editors', [], [])
-        self.setGroups(['Editors'])
-        user = getSecurityManager().getUser()
-        self.assertTrue(
-            'Editors' in getGroupsForPrincipal(user, pas['plugins'])
-        )
diff --git a/Products/PlonePAS/tests/test_properties.py b/Products/PlonePAS/tests/test_properties.py
deleted file mode 100644
index d2e808f..0000000
--- a/Products/PlonePAS/tests/test_properties.py
+++ /dev/null
@@ -1,287 +0,0 @@
-# -*- coding: utf-8 -*-
-from Products.CMFCore.utils import getToolByName
-from Products.PlonePAS.plugins.property import ZODBMutablePropertyProvider
-from Products.PlonePAS.tests import base
-from Products.PluggableAuthService.interfaces.plugins import \
-    IUserEnumerationPlugin
-
-
-class PropertiesTest(base.TestCase):
-
-    def test_user_properties(self):
-        mt = getToolByName(self.portal, 'portal_membership')
-        md = getToolByName(self.portal, 'portal_memberdata')
-
-        # Create a new Member
-        mt.addMember('user1', 'u1', ['Member'], [],
-                     {'email': 'user1@host.com',
-                      'fullname': 'User #1'})
-        member = mt.getMemberById('user1')
-        self.assertFalse(member is None)
-
-        # Assert user doesn't have the property yet
-        self.assertFalse(member.hasProperty('age'))
-
-        # Add new property
-        md.manage_addProperty('age', 20, 'int')
-
-        # Assert user has the property now
-        self.assertTrue(member.hasProperty('age'))
-
-        # Get the property, should have the default value
-        got = member.getProperty('age', None)
-        expected = 20
-        self.assertEqual(got, expected)
-
-        # get a handle on the member
-        member = mt.getMemberById('user1')
-
-        # Set some member properties. Needs to be logged in as the user.
-        self.login('user1')
-        member.setMemberProperties({'age': 30, 'fullname': 'User #1 Is Cool',
-                                    'email': 'user1@anotherhost.qa'})
-
-        # Check the properties have been set
-        got = member.getProperty('age', None)
-        expected = 30
-        self.assertEqual(got, expected)
-
-        got = member.getProperty('fullname', None)
-        expected = 'User #1 Is Cool'
-        self.assertEqual(got, expected)
-
-        got = member.getProperty('email', None)
-        expected = 'user1@anotherhost.qa'
-        self.assertEqual(got, expected)
-
-        # Delete the property
-        md.manage_delProperties(ids=('age',))
-
-        # re-get the member to reflect the new memberdata schema
-        member = mt.getMemberById('user1')
-
-        # Assert property is gone
-        self.assertFalse(member.hasProperty('age'))
-
-        # Get the property, should return default (None)
-        got = member.getProperty('age', None)
-        expected = None
-        self.assertEqual(got, expected)
-
-        # Other properties should still be there.
-        got = member.getProperty('fullname', None)
-        expected = 'User #1 Is Cool'
-        self.assertEqual(got, expected)
-
-        got = member.getProperty('email', None)
-        expected = 'user1@anotherhost.qa'
-        self.assertEqual(got, expected)
-
-    def test_group_properties(self):
-        gt = getToolByName(self.portal, 'portal_groups')
-        gd = getToolByName(self.portal, 'portal_groupdata')
-
-        self.loginAsPortalOwner()
-
-        # Create a new Group
-        gt.addGroup(
-            'group1',
-            ['Reviewer'],
-            [],
-            {'email': 'group1@host.com', 'title': 'Group #1'}
-        )
-        group = gt.getGroupById('group1')
-        self.assertFalse(group is None)
-
-        # Assert group doesn't have the property yet
-        self.assertFalse(group.hasProperty('karma'))
-
-        # Add new property
-        gd.manage_addProperty('karma', 20, 'int')
-
-        # get group again to re-create with new groupdata schema
-        group = gt.getGroupById('group1')
-
-        # Assert group has the property now
-        self.assertTrue(group.hasProperty('karma'))
-
-        # Get the property, should have the default value
-        got = group.getProperty('karma', None)
-        expected = 20
-
-        self.assertEqual(got, expected)
-
-        # Set some group properties
-        group.setGroupProperties({'karma': 30, 'title': 'Group #1 Is Cool',
-                                  'email': 'group1@anotherhost.qa'})
-
-        # Check the properties have been set
-        got = group.getProperty('karma', None)
-        expected = 30
-        self.assertEqual(got, expected)
-
-        got = group.getProperty('title', None)
-        expected = 'Group #1 Is Cool'
-        self.assertEqual(got, expected)
-
-        got = group.getProperty('email', None)
-        expected = 'group1@anotherhost.qa'
-        self.assertEqual(got, expected)
-
-        # Delete the property
-        gd.manage_delProperties(ids=('karma',))
-
-        # get group again to re-create with new groupdata schema
-        group = gt.getGroupById('group1')
-
-        # Assert property is gone
-        self.assertFalse(group.hasProperty('karma'))
-
-        # Get the property, should return default (None)
-        got = group.getProperty('karma', None)
-        expected = None
-        self.assertEqual(got, expected)
-
-        # Other properties should still be there.
-        got = group.getProperty('title', None)
-        expected = 'Group #1 Is Cool'
-        self.assertEqual(got, expected)
-
-        got = group.getProperty('email', None)
-        expected = 'group1@anotherhost.qa'
-        self.assertEqual(got, expected)
-
-    def test_schema_for_mutable_property_provider(self):
-        """Add a schema to a ZODBMutablePropertyProvider.
-        """
-
-        # Schema is list of tuples with name, type (string), value.
-        # From the types it seems only 'lines' is handled differently.
-        address_schema = [
-            ('addresses', 'lines', ['Here', 'There']),
-            ('city', 'str', 'Somewhere'),
-            ('telephone', 'int', 1234567),
-            ]
-
-        # This used to give a ValueError, so we just check that it
-        # does not.
-        provider = ZODBMutablePropertyProvider(
-            'address_plugin', "Address Plugin", schema=address_schema)
-
-        # When this test passes, we are happy already, but let's add a
-        # few more basic tests.
-
-        # Create a new Member
-        mt = getToolByName(self.portal, 'portal_membership')
-        mt.addMember('user1', 'u1', ['Member'], [],
-                     {'email': 'user1@host.com',
-                      'fullname': 'User #1'})
-        member = mt.getMemberById('user1')
-        sheet = provider.getPropertiesForUser(member)
-        self.assertEqual(
-            sheet.propertyIds(), ['addresses', 'city', 'telephone'])
-        self.assertEqual(sheet.propertyInfo('city'),
-                         {'type': 'str', 'id': 'city', 'mode': ''})
-        self.assertEqual(sheet.getProperty('addresses'), ('Here', 'There'))
-
-
-class PropertySearchTest(base.TestCase):
-
-    def afterSetUp(self):
-        self.mt = getToolByName(self.portal, 'portal_membership')
-        self.md = getToolByName(self.portal, 'portal_memberdata')
-        self.gt = getToolByName(self.portal, 'portal_groups')
-
-        # Create a new Member
-        self.mt.addMember(
-            'member1',
-            'pw',
-            ['Member'],
-            [],
-            {'email': 'member1@host.com', 'title': 'Member #1'}
-        )
-        member = self.mt.getMemberById('member1')
-        self.assertFalse(member is None)
-
-        self.mt.addMember(
-            'member2',
-            'pw',
-            ['Member'],
-            [],
-            {'email': 'user2@otherhost.com', 'fullname': 'User #2'}
-        )
-        member = self.mt.getMemberById('member2')
-        self.assertFalse(member is None)
-
-        # Add a Group to make sure searchUsers isn't returning them in results.
-        self.gt.addGroup('group1', title="Group 1")
-        group = self.gt.getGroupById('group1')
-        self.assertFalse(group is None)
-
-        self.pas = getToolByName(self.portal, "acl_users")
-        for plugin in self.pas.plugins \
-                          .getAllPlugins('IUserEnumerationPlugin')['active']:
-            if plugin != 'mutable_properties':
-                self.pas.plugins.deactivatePlugin(IUserEnumerationPlugin,
-                                                  plugin)
-
-    def testPluginActivated(self):
-        plugins = self.pas.plugins \
-                      .getAllPlugins('IUserEnumerationPlugin')['active']
-        self.assertEqual(plugins, ('mutable_properties',))
-
-    def testEmptySearch(self):
-        results = self.pas.searchUsers()
-        self.assertEqual(len(results), 2)
-
-    def testInexactStringSearch(self):
-        results = self.pas.searchUsers(email="something@somewhere.tld")
-        self.assertEqual(results, ())
-
-        results = self.pas.searchUsers(email="member1@host.com",
-                                       exact_match=False)
-        results = [info['userid'] for info in results]
-        self.assertEqual(results, ['member1'])
-
-        results = self.pas.searchUsers(email="@host.com", exact_match=False)
-        results = [info['userid'] for info in results]
-        self.assertEqual(results, ['member1'])
-
-        results = self.pas.searchUsers(email="member1@host.com",
-                                       exact_match=True)
-        results = [info['userid'] for info in results]
-        self.assertEqual(results, ['member1'])
-
-        results = self.pas.searchUsers(email="@host.com", exact_match=True)
-        results = [info['userid'] for info in results]
-        self.assertEqual(results, [])
-
-    def testBooleanSearch(self):
-        results = self.pas.searchUsers(visible_ids=True)
-        results = [info['userid'] for info in results]
-        self.assertEqual(results, [])
-
-        results = self.pas.searchUsers(visible_ids=False)
-        results = [info['userid'] for info in results]
-        self.assertEqual(results, ['member1', 'member2'])
-
-    def testGroupsNotReturnedByEnumerateUsers(self):
-        """Check to make sure that groups aren't returned by a enumerateUsers
-           call.
-           See http://dev.plone.org/plone/ticket/9435"""
-        results = self.pas.searchUsers()
-        resultIds = [a['id'] for a in results]
-        self.assertFalse('group1' in resultIds)
-
-    def testSearchEmptyId(self):
-        self.assertEqual(self.pas.mutable_properties.enumerateUsers(id=''), ())
-        self.assertEqual(
-                self.pas.mutable_properties.enumerateUsers(login=''), ())
-
-    def testCantSearchByIdOrLogin(self):
-        # we can't search by id
-        results = self.pas.searchUsers(id='member1')
-        self.assertEqual(results, ())
-        # or login
-        results = self.pas.searchUsers(login='member1')
-        self.assertEqual(results, ())
diff --git a/Products/PlonePAS/tests/test_role_plugin.py b/Products/PlonePAS/tests/test_role_plugin.py
deleted file mode 100644
index 00ec703..0000000
--- a/Products/PlonePAS/tests/test_role_plugin.py
+++ /dev/null
@@ -1,86 +0,0 @@
-# -*- coding: utf-8 -*-
-# $Id$
-"""Tests for Products.PlonePAS.plugins.role.GroupAwareRoleManager"""
-
-from Products.PlonePAS.tests import base
-from Products.PluggableAuthService.PluggableAuthService import \
-    _PLUGIN_TYPE_INFO
-from Products.PluggableAuthService.interfaces.plugins import IGroupsPlugin
-from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
-from Products.PluggableAuthService.plugins.tests.helpers import DummyUser
-from Products.PluggableAuthService.plugins.tests.helpers import FauxPAS
-from Products.PluggableAuthService.plugins.tests.helpers import \
-    makeRequestAndResponse
-from Products.PluginRegistry.PluginRegistry import PluginRegistry
-from zope.interface import implementer
-
-
-@implementer(IGroupsPlugin)
-class FauxGroupsPlugin(BasePlugin):
-
-    def getGroupsForPrincipal(self, principal, request=None):
-        return principal._groups
-
-
-class GroupAwareRoleManagerTests(base.TestCase):
-    """Roles manager that takes care of goup of principal"""
-
-    def _getTargetClass(self):
-
-        from Products.PlonePAS.plugins.role import GroupAwareRoleManager
-        return GroupAwareRoleManager
-
-    def _makeOne(self, id='test', *args, **kw):
-
-        plugin = self._getTargetClass()(id=id, *args, **kw)
-        # We need to bind a fake request to this plugin
-        request, dummy_response = makeRequestAndResponse()
-        setattr(plugin, 'REQUEST', request)
-        return plugin
-
-    def test_roles_for_control_panel(self):
-        """There's a special case, the users control panel for which
-        we should never grant to users the roles they have got through
-        the groups they belong.
-        In that intent, the control panels view pushes
-        '__ignore_group_roles__' = True
-        in the request.
-        """
-        root = FauxPAS()
-
-        # Add a minimal PluginRegistry with a mock IGroupsPlugin, because the
-        # roles plugin depends on it:
-        root._setObject('plugins', PluginRegistry(_PLUGIN_TYPE_INFO))
-        root._setObject('groups', FauxGroupsPlugin())
-        root['plugins'].activatePlugin(IGroupsPlugin, 'groups')
-
-        garm = self._makeOne('garm').__of__(root)
-
-        # 2 roles
-        garm.addRole('foo_role')
-        garm.addRole('bar_role')
-
-        # Group 'somegroup' has 'bar_role'
-        garm.assignRoleToPrincipal('bar_role', 'somegroup')
-
-        # 'johndoe' has 'foo_role'
-        johndoe = DummyUser('johndoe', ('somegroup',))
-        garm.assignRoleToPrincipal('foo_role', 'johndoe')
-
-        # 'johndoe' should have 'foo_role' and 'bar_roles'
-        got = garm.getRolesForPrincipal(johndoe)
-        expected = ['foo_role', 'bar_role']
-        self.assertEqual(set(got), set(expected))
-
-        # For the users control panel, johndoe has only the 'foo_role'
-        garm.REQUEST.set('__ignore_group_roles__', True)
-        got = garm.getRolesForPrincipal(johndoe)
-        self.assertEqual(got, ('foo_role',))
-
-        # Confirm we can get only the inherited roles
-        garm.REQUEST.set('__ignore_group_roles__', False)
-        garm.REQUEST.set('__ignore_direct_roles__', True)
-        got = garm.getRolesForPrincipal(johndoe)
-        self.assertEqual(got, ('bar_role',))
-
-        return
diff --git a/Products/PlonePAS/tests/test_views.py b/Products/PlonePAS/tests/test_views.py
deleted file mode 100644
index d0a7f60..0000000
--- a/Products/PlonePAS/tests/test_views.py
+++ /dev/null
@@ -1,19 +0,0 @@
-# -*- encoding: utf-8 -*-
-from Products.PlonePAS.tests import base
-
-
-class TestPASSearchView(base.TestCase):
-
-    def test_sort(self):
-        pas_search = self.portal.restrictedTraverse('@@pas_search')
-        values = [{'title': u'Sociologie'}, {'title': u'Économie'},
-                  {'title': u'anthropologie'}]
-        sorted_values = pas_search.sort(values, 'title')
-        # do not modify original
-        self.assertEqual(values,
-                         [{'title': u'Sociologie'}, {'title': u'Économie'},
-                          {'title': u'anthropologie'}])
-        # sorted here
-        self.assertEqual(sorted_values,
-                         [{'title': u'anthropologie'}, {'title': u'Économie'},
-                          {'title': u'Sociologie'}])
diff --git a/Products/PlonePAS/tool.gif b/Products/PlonePAS/tool.gif
deleted file mode 100644
index 2d866bb..0000000
Binary files a/Products/PlonePAS/tool.gif and /dev/null differ
diff --git a/Products/PlonePAS/tools/__init__.py b/Products/PlonePAS/tools/__init__.py
deleted file mode 100644
index 40a96af..0000000
--- a/Products/PlonePAS/tools/__init__.py
+++ /dev/null
@@ -1 +0,0 @@
-# -*- coding: utf-8 -*-
diff --git a/Products/PlonePAS/tools/groupdata.py b/Products/PlonePAS/tools/groupdata.py
deleted file mode 100644
index 615223e..0000000
--- a/Products/PlonePAS/tools/groupdata.py
+++ /dev/null
@@ -1,523 +0,0 @@
-# -*- coding: utf-8 -*-
-from AccessControl import ClassSecurityInfo
-from AccessControl import Permissions
-from AccessControl import Unauthorized
-from AccessControl import getSecurityManager
-from AccessControl.requestmethod import postonly
-from Acquisition import aq_base
-from Acquisition import aq_inner
-from Acquisition import aq_parent
-from App.class_init import InitializeClass
-from BTrees.OOBTree import OOBTree
-from OFS.PropertyManager import PropertyManager
-from OFS.SimpleItem import SimpleItem
-from Products.CMFCore.utils import UniqueObject
-from Products.CMFCore.utils import getToolByName
-from Products.CMFCore.utils import registerToolInterface
-from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
-from Products.PlonePAS.interfaces.capabilities import IManageCapabilities
-from Products.PlonePAS.interfaces.group import IGroupData
-from Products.PlonePAS.interfaces.group import IGroupDataTool
-from Products.PlonePAS.interfaces.group import IGroupManagement
-from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
-from Products.PlonePAS.tools.memberdata import MemberData
-from Products.PlonePAS.utils import CleanupTemp
-from Products.PluggableAuthService.PluggableAuthService import \
-    _SWALLOWABLE_PLUGIN_EXCEPTIONS
-from Products.PluggableAuthService.interfaces.authservice import \
-    IPluggableAuthService
-from ZPublisher.Converters import type_converters
-from zope.interface import implementer
-
-import logging
-
-logger = logging.getLogger('PlonePAS')
-_marker = object()
-
-
-@implementer(IGroupDataTool)
-class GroupDataTool(UniqueObject, SimpleItem, PropertyManager):
-    """This tool wraps group objects, allowing transparent access to
-    properties.
-    """
-
-    id = 'portal_groupdata'
-    meta_type = "PlonePAS GroupData Tool"
-    toolicon = 'tool.gif'
-
-    _v_temps = None
-    _properties = ({'id': 'title', 'type': 'string', 'mode': 'wd'},)
-    security = ClassSecurityInfo()
-
-    def __init__(self):
-        self._members = OOBTree()
-        # Create the default properties.
-        self._setProperty('description', '', 'text')
-        self._setProperty('email', '', 'string')
-
-    def wrapGroup(self, g):
-        """Returns an object implementing the GroupData interface."""
-
-        gid = g.getId()
-        members = self._members
-        if gid not in members:
-            # Get a temporary member that might be
-            # registered later via registerMemberData().
-            temps = self._v_temps
-            if temps is not None and gid in temps:
-                portal_group = temps[gid]
-            else:
-                base = aq_base(self)
-                portal_group = GroupData(base, gid)
-                if temps is None:
-                    self._v_temps = {gid: portal_group}
-                    if hasattr(self, 'REQUEST'):
-                        self.REQUEST._hold(CleanupTemp(self))
-                else:
-                    temps[gid] = portal_group
-        else:
-            portal_group = members[gid]
-        # Return a wrapper with self as containment and
-        # the user as context.
-        return portal_group.__of__(self).__of__(g)
-
-    @security.private
-    def registerGroupData(self, g, id):
-        '''
-        Adds the given member data to the _members dict.
-        This is done as late as possible to avoid side effect
-        transactions and to reduce the necessary number of
-        entries.
-        '''
-        self._members[id] = aq_base(g)
-
-
-InitializeClass(GroupDataTool)
-registerToolInterface('portal_groupdata', IGroupDataTool)
-
-
-@implementer(IGroupData, IManageCapabilities)
-class GroupData(SimpleItem):
-
-    security = ClassSecurityInfo()
-
-    id = None
-    _tool = None
-
-    def __init__(self, tool, id):
-        self.id = id
-        # Make a temporary reference to the tool.
-        # The reference will be removed by notifyModified().
-        self._tool = tool
-
-    def _getGRUF(self,):
-        return self.acl_users
-
-    @security.private
-    def notifyModified(self):
-        # Links self to parent for full persistence.
-        tool = getattr(self, '_tool', None)
-        if tool is not None:
-            del self._tool
-            tool.registerGroupData(self, self.getId())
-
-    @security.public
-    def getGroup(self):
-        """ Returns the actual group implementation. Varies by group
-        implementation (GRUF/Nux/et al). In GRUF this is a user object."""
-        # The user object is our context, but it's possible for
-        # restricted code to strip context while retaining
-        # containment.  Therefore we need a simple security check.
-        parent = aq_parent(self)
-        bcontext = aq_base(parent)
-        bcontainer = aq_base(aq_parent(aq_inner(self)))
-        if bcontext is bcontainer or not hasattr(bcontext, 'getUserName'):
-            raise 'GroupDataError', "Can't find group data"
-        # Return the user object, which is our context.
-        return parent
-
-    def getTool(self):
-        return aq_parent(aq_inner(self))
-
-    @security.public
-    def getGroupMemberIds(self):
-        """
-        Return a list of group member ids
-        """
-        return map(lambda x: x.getMemberId(), self.getGroupMembers())
-
-    @security.public
-    def getAllGroupMemberIds(self):
-        """
-        Return a list of group member ids
-        """
-        return map(lambda x: x.getMemberId(), self.getAllGroupMembers())
-
-    @security.public
-    def getGroupMembers(self):
-        """
-        Returns a list of the portal_memberdata-ish members of the group.
-        This doesn't include TRANSITIVE groups/users.
-        """
-        md = self.portal_memberdata
-        gtool = self.portal_groups
-        ret = []
-        for u_name in gtool.getGroupMembers(self.getId()):
-            usr = self._getGRUF().getUserById(u_name)
-            # getUserById from
-            #   Products.PluggableAuthService.PluggableAuthService
-            # The returned object is not wrapped, we wrapped it below
-            if not usr:
-                usr = self._getGRUF().getGroupById(u_name)
-                # getGroupById from Products.PlonePAS.pas
-                # The returned object is already wrapped
-                if not usr:
-                    logger.debug(
-                        "Group has a non-existing principal {0}".format(u_name)
-                    )
-                    continue
-                ret.append(usr)
-            else:
-                ret.append(md.wrapUser(usr))
-        return ret
-
-    @security.public
-    def getAllGroupMembers(self):
-        """
-        Returns a list of the portal_memberdata-ish members of the group.
-        This will include transitive groups / users
-        """
-        md = self.portal_memberdata
-        ret = []
-        for u_name in self.getGroup().getMemberIds():
-            usr = self._getGRUF().getUserById(u_name)
-            if not usr:
-                usr = self._getGRUF().getGroupById(u_name)
-                if not usr:
-                    logger.debug(
-                        "Group has a non-existing principal {0}".format(u_name)
-                    )
-                    continue
-                ret.append(usr)
-            else:
-                ret.append(md.wrapUser(usr))
-        return ret
-
-    def _getGroup(self):
-        """Get the underlying group object in a PAS-acceptable way.
-        (I don't even know why there's the two different ways for GRUF. Speed?)
-        """
-        return self.getGroup()
-
-    @security.private
-    def canAdministrateGroup(self):
-        """
-        Return true if the #current# user can administrate this group
-        """
-        user = getSecurityManager().getUser()
-        tool = self.getTool()
-        portal = getToolByName(tool, 'portal_url').getPortalObject()
-
-        # Has manager users pemission?
-        if user.has_permission(Permissions.manage_users, portal):
-            return True
-
-        # Is explicitly mentioned as a group administrator?
-        managers = self.getProperty('delegated_group_member_managers', ())
-        if user.getId() in managers:
-            return True
-
-        # Belongs to a group which is explicitly mentionned as a group
-        # administrator
-        meth = getattr(user, "getAllGroupNames", None)
-        if meth:
-            groups = meth()
-        else:
-            groups = ()
-        for v in groups:
-            if v in managers:
-                return True
-
-        # No right to edit this: we complain.
-        return False
-
-    @security.public
-    @postonly
-    def addMember(self, id, REQUEST=None):
-        """ Add the existing member with the given id to the group"""
-        if not self.canAdministrateGroup():
-            raise Unauthorized("You cannot add a member to the group.")
-
-        plugins = self._getPlugins()
-        managers = plugins.listPlugins(IGroupManagement)
-        for mid, manager in managers:
-            try:
-                if manager.addPrincipalToGroup(id, self.getId()):
-                    break
-            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-                pass
-
-    @security.public
-    @postonly
-    def removeMember(self, id, REQUEST=None):
-        """Remove the member with the provided id from the group.
-        """
-        if not self.canAdministrateGroup():
-            raise Unauthorized("You cannot remove a member from the group.")
-
-        plugins = self._getPlugins()
-        managers = plugins.listPlugins(IGroupManagement)
-        for mid, manager in managers:
-            try:
-                if manager.removePrincipalFromGroup(id, self.getId()):
-                    break
-            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-                pass
-
-    @security.protected(Permissions.manage_users)
-    def setProperties(self, properties=None, **kw):
-        """Allows the manager group to set his/her own properties.
-        Accepts either keyword arguments or a mapping for the "properties"
-        argument.
-        """
-        if properties is None:
-            properties = kw
-        return self.setGroupProperties(properties)
-
-    @security.protected(Permissions.manage_users)
-    def setGroupProperties(self, mapping):
-        """PAS-specific method to set the properties of a group.
-        """
-        sheets = None
-
-        if not IPluggableAuthService.providedBy(self.acl_users):
-            # Defer to base impl in absence of PAS, a PAS group, or
-            # property sheets
-            return self._gruf_setGroupProperties(mapping)
-        else:
-            # It's a PAS! Whee!
-            group = self.getGroup()
-            sheets = getattr(group, 'getOrderedPropertySheets', lambda: [])()
-
-            # We won't always have PlonePAS groups, due to acquisition,
-            # nor are guaranteed property sheets
-            if not sheets:
-                # Defer to base impl if we have a PAS but no property
-                # sheets.
-                return self._gruf_setGroupProperties(mapping)
-
-        # If we got this far, we have a PAS and some property sheets.
-        # XXX track values set to defer to default impl
-        # property routing?
-        modified = False
-        for k, v in mapping.items():
-            for sheet in sheets:
-                if not sheet.hasProperty(k):
-                    continue
-                if IMutablePropertySheet.providedBy(sheet):
-                    sheet.setProperty(group, k, v)
-                    modified = True
-                else:
-                    raise RuntimeError("Mutable property provider "
-                                       "shadowed by read only provider")
-        if modified:
-            self.notifyModified()
-
-    def _gruf_setGroupProperties(self, mapping):
-        '''Sets the properties of the member.
-        '''
-        # Sets the properties given in the MemberDataTool.
-        tool = self.getTool()
-        for id in tool.propertyIds():
-            if id in mapping:
-                if id not in self.__class__.__dict__:
-                    value = mapping[id]
-                    if isinstance(value, str):
-                        proptype = tool.getPropertyType(id) or 'string'
-                        if proptype in type_converters:
-                            value = type_converters[proptype](value)
-                    setattr(self, id, value)
-
-        # Hopefully we can later make notifyModified() implicit.
-        self.notifyModified()
-
-    @security.public
-    def getProperties(self):
-        """ Return the properties of this group. Properties are as usual
-            in Zope.
-        """
-        tool = self.getTool()
-        ret = {}
-        for pty in tool.propertyIds():
-            try:
-                ret[pty] = self.getProperty(pty)
-            except ValueError:
-                # We ignore missing ptys
-                continue
-        return ret
-
-    @security.public
-    def getProperty(self, id, default=None):
-        """PAS-specific method to fetch a group's properties. Looks
-        through the ordered property sheets.
-        """
-        group = self.getGroup()
-        sheets = getattr(group, 'getOrderedPropertySheets', lambda: [])()
-
-        # If we made this far, we found a PAS and some property sheets.
-        for sheet in sheets:
-            if sheet.hasProperty(id):
-                # Return the first one that has the property.
-                return sheet.getProperty(id)
-        # we won't always have PlonePAS groups, due to acquisition,
-        # nor are guaranteed property sheets
-        # Couldn't find the property in the property sheets. Try to
-        # delegate back to the base implementation.
-
-        tool = self.getTool()
-        base = aq_base(self)
-
-        # Then, check the user object, the tool, and attrs of myself for a
-        # value:
-        user_value = getattr(aq_base(self.getGroup()), id, _marker)
-        tool_value = tool.getProperty(id, _marker)
-        value = getattr(base, id, _marker)
-
-        # Take the first of the above that is filled out:
-        for v in [user_value, tool_value, value]:
-            if v is not _marker:
-                return v
-
-        return default
-
-    def __str__(self):
-        return self.getGroupId()
-
-    @security.public
-    def isGroup(self):
-        """
-        isGroup(self,) => Return true if this is a group.
-        Will always return true for groups.
-        As MemberData objects do not support this method, it is quite useless
-        by now.
-        So one can use groupstool.isGroup(g) instead to get this information.
-        """
-        return 1
-
-    # Group object interface ###
-
-    @security.public
-    def getGroupName(self):
-        return self.getName()
-
-    @security.public
-    def getGroupId(self):
-        """Get the ID of the group. The ID can be used, at least from
-        Python, to get the user from the user's UserDatabase.
-        Within Plone, all group ids are UNPREFIXED."""
-        return self.getGroup().getId()
-
-    def getGroupTitleOrName(self):
-        """Get the Title property of the group. If there is none
-        then return the name """
-        title = self.getProperty('title', None)
-        return title or self.getGroupName()
-
-    @security.public
-    def getMemberId(self):
-        """This exists only for a basic user/group API compatibility
-        """
-        return self.getGroupId()
-
-    @security.public
-    def getRoles(self):
-        """Return the list of roles assigned to a user."""
-        return self.getGroup().getRoles()
-
-    @security.public
-    def getRolesInContext(self, object):
-        """Return the list of roles assigned to the user,  including local
-        roles assigned in context of the passed in object."""
-        return self.getGroup().getRolesInContext(object)
-
-    @security.public
-    def getDomains(self):
-        """Return the list of domain restrictions for a user"""
-        return self.getGroup().getDomains()
-
-    @security.public
-    def has_role(self, roles, object=None):
-        """Check to see if a user has a given role or roles."""
-        return self.getGroup().has_role(roles, object)
-
-    ## GRUF 3.2 methods...
-
-    def getUserName(self):
-        return self.getName()
-    getUserNameWithoutGroupPrefix = getUserName
-
-    ## IManageCapabilities methods
-    def canDelete(self):
-        """True iff user can be removed from the Plone UI.
-        """
-        # IGroupManagement provides removeGroup
-        plugins = self._getPlugins()
-        managers = plugins.listPlugins(IGroupManagement)
-        if managers:
-            for mid, manager in managers:
-                if (IDeleteCapability.providedBy(manager) and
-                        manager.allowDeletePrincipal(self.getId())):
-                    return True
-        return False
-
-    def canPasswordSet(self):
-        """Always false for groups, which have no password.
-        """
-        return False
-
-    def passwordInClear(self):
-        """True iff password can be retrieved in the clear (not hashed.)
-
-        False for PAS. It provides no API for getting passwords,
-        though it would be possible to add one in the future.
-        """
-        return False
-
-    def _groupdataHasProperty(self, prop_name):
-        gdata = getToolByName(self, 'portal_groupdata', None)
-        if gdata:
-            return gdata.hasProperty(prop_name)
-        return 0
-
-    def canWriteProperty(self, prop_name):
-        """True iff the group property named in 'prop_name'
-        can be changed.
-        """
-        # this looks almost exactly like in memberdata. refactor?
-        if not IPluggableAuthService.providedBy(self.acl_users):
-            # not PAS; Groupdata is writable
-            return self._groupdataHasProperty(prop_name)
-        else:
-            # it's PAS
-            group = self.getGroup()
-            sheets = getattr(group, 'getOrderedPropertySheets', lambda: [])()
-            for sheet in sheets:
-                if not sheet.hasProperty(prop_name):
-                    continue
-                if IMutablePropertySheet.providedBy(sheet):
-                    return 1
-                else:
-                    break  # shadowed by read-only
-        return 0
-
-    canAddToGroup = MemberData.canAddToGroup.im_func
-    canRemoveFromGroup = MemberData.canRemoveFromGroup.im_func
-    canAssignRole = MemberData.canAssignRole.im_func
-
-    ## plugin getters
-
-    @security.private
-    def _getPlugins(self):
-        return self.acl_users.plugins
-
-InitializeClass(GroupData)
diff --git a/Products/PlonePAS/tools/groups.py b/Products/PlonePAS/tools/groups.py
deleted file mode 100644
index 90be6f0..0000000
--- a/Products/PlonePAS/tools/groups.py
+++ /dev/null
@@ -1,440 +0,0 @@
-# -*- coding: utf-8 -*-
-from AccessControl import ClassSecurityInfo
-from AccessControl.User import nobody
-from AccessControl.requestmethod import postonly
-from Acquisition import aq_base
-from App.class_init import InitializeClass
-from OFS.SimpleItem import SimpleItem
-from Products.CMFCore.utils import UniqueObject
-from Products.CMFCore.utils import getToolByName
-from Products.CMFCore.utils import registerToolInterface
-from Products.PlonePAS.interfaces import group as igroup
-from Products.PlonePAS.permissions import AddGroups
-from Products.PlonePAS.permissions import DeleteGroups
-from Products.PlonePAS.permissions import ManageGroups
-from Products.PlonePAS.permissions import SetGroupOwnership
-from Products.PlonePAS.permissions import ViewGroups
-from Products.PlonePAS.utils import getGroupsForPrincipal
-from Products.PluggableAuthService.PluggableAuthService import \
-    _SWALLOWABLE_PLUGIN_EXCEPTIONS
-from Products.PluggableAuthService.interfaces.plugins import \
-    IRoleAssignerPlugin
-from ZODB.POSException import ConflictError
-from zope.interface import implementer
-import logging
-
-logger = logging.getLogger('PluggableAuthService')
-
-
-class NotSupported(Exception):
-    pass
-
-
-@implementer(igroup.IGroupTool)
-class GroupsTool(UniqueObject, SimpleItem):
-    """ This tool accesses group data through a acl_users object.
-
-    It can be replaced with something that groups member data in a
-    different way.
-    """
-
-    id = 'portal_groups'
-    meta_type = 'PlonePAS Groups Tool'
-    security = ClassSecurityInfo()
-    toolicon = 'tool.gif'
-
-    ##
-    # basic group mgmt
-    ##
-
-    @security.protected(AddGroups)
-    @postonly
-    def addGroup(self, id, roles=[], groups=[], properties=None,
-                 REQUEST=None, *args, **kw):
-        """Create a group, with the supplied id, roles, and domains.
-
-        Underlying user folder must support adding users via the usual
-        Zope API.
-        """
-        group = None
-        success = 0
-        managers = self._getGroupManagers()
-        if roles is None:
-            roles = []
-        if groups is None:
-            groups = []
-
-        # Check to see if a user with the id already exists fail if it does
-        results = self.acl_users.searchPrincipals(id=id, exact_match=True)
-        if results:
-            return 0
-
-        if not managers:
-            raise NotSupported('No plugins allow for group management')
-        for mid, manager in managers:
-            success = manager.addGroup(id, title=kw.get('title', id),
-                                       description=kw.get('description', ''))
-            if success:
-                self.setRolesForGroup(id, roles)
-                for g in groups:
-                    manager.addPrincipalToGroup(g, id)
-                break
-
-        if success:
-            group = self.getGroupById(id)
-            group.setGroupProperties(properties or kw)
-
-        return success
-
-    @security.protected(ManageGroups)
-    @postonly
-    def editGroup(self, id, roles=None, groups=None, REQUEST=None,
-                  *args, **kw):
-        """Edit the given group with the supplied roles.
-
-        Passwords for groups seem to be irrelevant.
-        PlonePAS doesn't deal with domains either.
-
-        If group is not present, returns without exception.
-        """
-        g = self.getGroupById(id)
-        if not g:
-            raise KeyError('Trying to edit a non-existing group: %s' % id)
-
-        # Update title/description properties of original group
-        gTools = self._getGroupTools()
-        if not gTools:
-            raise NotSupported('No plugins allow for both group management '
-                               'and introspection')
-
-        for tid, tool in gTools:
-            if id in tool.getGroupIds():
-                tool.updateGroup(
-                    id,
-                    title=kw.get('title'),
-                    description=kw.get('description')
-                )
-                break
-
-        if roles is not None:
-            self.setRolesForGroup(id, roles)
-
-        g.setGroupProperties(kw)
-        if groups:
-            # remove absent groups
-            groupset = set(groups)
-            p_groups = set(self.getGroupsForPrincipal(g))
-            rmgroups = p_groups - groupset
-            for gid in rmgroups:
-                if gid != 'AuthenticatedUsers':
-                    self.removePrincipalFromGroup(g, gid)
-
-            # add groups
-            try:
-                groupmanagers = self.acl_users.plugins.listPlugins(
-                    igroup.IGroupManagement
-                )
-            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-                logger.exception('Plugin listing error')
-                groupmanagers = ()
-
-            for group in groups:
-                for gm_id, gm in groupmanagers:
-                    try:
-                        if gm.addPrincipalToGroup(id, group):
-                            break
-                    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-                        logger.exception(
-                            'AuthenticationPlugin {0} error'.format(gm_id)
-                        )
-
-    @security.protected(DeleteGroups)
-    @postonly
-    def removeGroup(self, group_id, REQUEST=None):
-        """Remove a single group.
-        """
-        retval = False
-        managers = self._getGroupManagers()
-        if not managers:
-            raise NotSupported('No plugins allow for group management')
-
-        for mid, manager in managers:
-            if manager.removeGroup(group_id):
-                retval = True
-
-        return retval
-
-    @security.protected(DeleteGroups)
-    @postonly
-    def removeGroups(self, ids, REQUEST=None):
-        """Remove the group in the provided list (if possible).
-        """
-        for gid in ids:
-            self.removeGroup(gid)
-
-    @security.protected(ManageGroups)
-    @postonly
-    def setRolesForGroup(self, group_id, roles=(), REQUEST=None):
-        rmanagers = self._getPlugins().listPlugins(IRoleAssignerPlugin)
-        if not (rmanagers):
-            raise NotImplementedError(
-                'There is no plugin that can assign roles to groups'
-            )
-        for rid, rmanager in rmanagers:
-            rmanager.assignRolesToPrincipal(roles, group_id)
-
-    ##
-    # basic principal mgmt
-    ##
-
-    @security.protected(ManageGroups)
-    @postonly
-    def addPrincipalToGroup(self, principal_id, group_id, REQUEST=None):
-        managers = self._getGroupManagers()
-        if not managers:
-            raise NotSupported('No plugins allow for group management')
-        for mid, manager in managers:
-            if manager.addPrincipalToGroup(principal_id, group_id):
-                return True
-        return False
-
-    @security.protected(ManageGroups)
-    @postonly
-    def removePrincipalFromGroup(self, principal_id, group_id, REQUEST=None):
-        managers = self._getGroupManagers()
-        if not managers:
-            raise NotSupported('No plugins allow for group management')
-        for mid, manager in managers:
-            if manager.removePrincipalFromGroup(principal_id, group_id):
-                return True
-        return False
-
-    ##
-    # group getters
-    ##
-
-    @security.protected(ViewGroups)
-    def getGroupById(self, group_id):
-        group = self.acl_users.getGroup(group_id)
-        if group is not None:
-            group = self.wrapGroup(group)
-        return group
-
-    @security.protected(ManageGroups)
-    def searchGroups(self, *args, **kw):
-        return self.acl_users.searchGroups(*args, **kw)
-
-    def searchForGroups(self, REQUEST={}, **kw):
-        """Search for groups by keyword.
-        The following properties can be searched:
-        - name
-        #- email
-        #- title
-
-        Only id/title search is implemented for groups. Is the rest of
-        this junk used anywhere?
-
-        This is an 'AND' request.
-
-        When it takes 'name' as keyword (or in REQUEST) and searches on
-        Full name and id.
-
-        Simple name searches are "fast".
-        """
-        acl_users = self.acl_users
-        if REQUEST:
-            dict = REQUEST
-        else:
-            dict = kw
-
-        name = dict.get('name', None)
-        title_or_name = dict.get('title_or_name', None)
-        if name:
-            name = name.strip().lower()
-        if name is not None:
-            name = None
-        if title_or_name is not None:
-            name = title_or_name
-
-        md_groups = []
-        uf_groups = []
-
-        if name is not None:
-            # This will allow us to retrieve groups by their id only
-            uf_groups = acl_users.searchGroups(id=name)
-
-            # PAS allows search to return dupes. We must winnow...
-            uf_groups_new = []
-            for group in uf_groups:
-                if group not in uf_groups_new:
-                    uf_groups_new.append(group)
-            uf_groups = uf_groups_new
-
-        groups = []
-        if md_groups or uf_groups:
-            getGroupById = self.getGroupById
-
-            for groupid in md_groups:
-                groups.append(getGroupById(groupid))
-            for group in uf_groups:
-                groupid = group['groupid']
-                if groupid in md_groups:
-                    continue             # Kill dupes
-                groups.append(getGroupById(groupid))
-
-        return groups
-
-    @security.protected(ViewGroups)
-    def listGroups(self):
-        # potentially not all groups may be found by this interface
-        # if the underlying group source doesn't support introspection
-        groups = []
-        introspectors = self._getGroupIntrospectors()
-        for iid, introspector in introspectors:
-            groups.extend(introspector.getGroups())
-        return [self.wrapGroup(elt) for elt in groups]
-
-    @security.protected(ViewGroups)
-    def getGroupIds(self):
-        groups = []
-        introspectors = self._getGroupIntrospectors()
-        for iid, introspector in introspectors:
-            groups.extend(introspector.getGroupIds())
-        return groups
-
-    listGroupIds = getGroupIds
-
-    @security.protected(ViewGroups)
-    def getGroupMembers(self, group_id):
-        members = set()
-        introspectors = self._getGroupIntrospectors()
-        for iid, introspector in introspectors:
-            members.update(introspector.getGroupMembers(group_id))
-        return list(members)
-
-    @security.protected(ViewGroups)
-    def getGroupsForPrincipal(self, principal):
-        return getGroupsForPrincipal(principal, self._getPlugins())
-
-    ##
-    # plugin getters
-    ##
-
-    @security.private
-    def _getPlugins(self):
-        return self.acl_users.plugins
-
-    @security.private
-    def _getGroupManagers(self):
-        return self._getPlugins().listPlugins(
-            igroup.IGroupManagement
-            )
-
-    @security.private
-    def _getGroupIntrospectors(self):
-        return self._getPlugins().listPlugins(
-            igroup.IGroupIntrospection
-            )
-
-    @security.private
-    def _getGroupTools(self):
-        managers = self._getPlugins().listPlugins(
-                        igroup.IGroupManagement)
-        return [(id, manager) for (id, manager) in managers
-                if igroup.IGroupIntrospection.providedBy(manager)]
-
-    ##
-    # BBB
-    ##
-
-    @security.public
-    def getGroupInfo(self, groupId):
-        """
-        Return default group info of any group
-        """
-        group = self.getGroupById(groupId)
-
-        if group is None:
-            return None
-
-        groupinfo = {'title': group.getProperty('title'),
-                     'description': group.getProperty('description')}
-
-        return groupinfo
-
-    @security.protected(ViewGroups)
-    def getGroupsByUserId(self, userid):
-        """Return a list of the groups the user corresponding to 'userid'
-        belongs to."""
-        user = self.acl_users.getUserById(userid)
-        if user:
-            groups = user.getGroups() or []
-        else:
-            groups = []
-        return [self.getGroupById(elt) for elt in groups]
-
-    @security.protected(ViewGroups)
-    def listGroupNames(self):
-        """Return a list of the available groups' ids as entered
-        (without group prefixes)."""
-        return self.acl_users.getGroupNames()
-
-    @security.public
-    def isGroup(self, u):
-        """Test if a user/group object is a group or not.
-        You must pass an object you get earlier with wrapUser() or wrapGroup()
-        """
-        base = aq_base(u)
-        if hasattr(base, "isGroup") and base.isGroup():
-            return 1
-        return 0
-
-    @security.protected(SetGroupOwnership)
-    @postonly
-    def setGroupOwnership(self, group, object, REQUEST=None):
-        """Make the object  'object' owned by group 'group'
-        (a portal_groupdata-ish object).
-
-        For GRUF this is easy. Others may have to re-implement."""
-        user = group.getGroup()
-        if user is None:
-            raise ValueError("Invalid group: '%s'." % (group, ))
-        object.changeOwnership(user)
-        object.manage_setLocalRoles(user.getId(), ['Owner'])
-
-    @security.private
-    def wrapGroup(self, g, wrap_anon=0):
-        ''' Sets up the correct acquisition wrappers for a group
-        object and provides an opportunity for a portal_memberdata
-        tool to retrieve and store member data independently of
-        the user object.
-        '''
-        b = getattr(g, 'aq_base', None)
-        if b is None:
-            # u isn't wrapped at all.  Wrap it in self.acl_users.
-            b = g
-            g = g.__of__(self.acl_users)
-        if (b is nobody and not wrap_anon) or hasattr(b, 'getMemberId'):
-            # This user is either not recognized by acl_users or it is
-            # already registered with something that implements the
-            # member data tool at least partially.
-            return g
-
-        parent = self.aq_inner.aq_parent
-        base = getattr(parent, 'aq_base', None)
-        if hasattr(base, 'portal_groupdata'):
-            # Get portal_groupdata to do the wrapping.
-            gd = getToolByName(parent, 'portal_groupdata')
-            try:
-                portal_group = gd.wrapGroup(g)
-                return portal_group
-            except ConflictError:
-                raise
-            except:
-                logger.exception('Error during wrapGroup')
-        # Failed.
-        return g
-
-
-InitializeClass(GroupsTool)
-registerToolInterface('portal_groups', igroup.IGroupTool)
diff --git a/Products/PlonePAS/tools/memberdata.py b/Products/PlonePAS/tools/memberdata.py
deleted file mode 100644
index 6d62f45..0000000
--- a/Products/PlonePAS/tools/memberdata.py
+++ /dev/null
@@ -1,448 +0,0 @@
-# -*- coding: utf-8 -*-
-from AccessControl import ClassSecurityInfo
-from AccessControl.requestmethod import postonly
-from Acquisition import aq_base
-from App.class_init import InitializeClass
-from Products.BTreeFolder2.BTreeFolder2 import BTreeFolder2
-from Products.CMFCore.MemberDataTool import MemberData as BaseMemberData
-from Products.CMFCore.MemberDataTool import MemberDataTool as BaseTool
-from Products.CMFCore.permissions import ManagePortal
-from Products.CMFCore.utils import getToolByName
-from Products.PlonePAS.interfaces.capabilities import IAssignRoleCapability
-from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
-from Products.PlonePAS.interfaces.capabilities import IGroupCapability
-from Products.PlonePAS.interfaces.capabilities import IManageCapabilities
-from Products.PlonePAS.interfaces.capabilities import IPasswordSetCapability
-from Products.PlonePAS.interfaces.group import IGroupManagement
-from Products.PlonePAS.interfaces.plugins import IUserManagement
-from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
-from Products.PluggableAuthService.interfaces.authservice import \
-    IPluggableAuthService
-from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
-from Products.PluggableAuthService.interfaces.plugins import \
-    IRoleAssignerPlugin
-from zope.interface import implementer
-
-_marker = object()
-
-
-class MemberDataTool(BaseTool):
-    """PAS-specific implementation of memberdata tool.
-    """
-
-    meta_type = "PlonePAS MemberData Tool"
-    security = ClassSecurityInfo()
-    toolicon = 'tool.gif'
-
-    def __init__(self):
-        BaseTool.__init__(self)
-        self.portraits = BTreeFolder2(id='portraits')
-
-    def _getPortrait(self, member_id):
-        "return member_id's portrait if you can "
-        return self.portraits.get(member_id, None)
-
-    def _setPortrait(self, portrait, member_id):
-        " store portrait which must be a raw image in _portrais "
-        if member_id in self.portraits:
-            self.portraits._delObject(member_id)
-        self.portraits._setObject(id=member_id, object=portrait)
-
-    def _deletePortrait(self, member_id):
-        " remove member_id's portrait "
-        if member_id in self.portraits:
-            self.portraits._delObject(member_id)
-
-    @security.private
-    def pruneMemberDataContents(self):
-        '''
-        Compare the user IDs stored in the member data
-        tool with the list in the actual underlying acl_users
-        and delete anything not in acl_users
-        '''
-        BaseTool.pruneMemberDataContents(self)
-        membertool = getToolByName(self, 'portal_membership')
-        portraits = self.portraits
-        user_list = membertool.listMemberIds()
-
-        for tuple in portraits.items():
-            member_id = tuple[0]
-            if member_id not in user_list:
-                self.portraits._delObject(member_id)
-
-    @security.protected(ManagePortal)
-    def purgeMemberDataContents(self):
-        '''
-        Delete ALL MemberData information. This is required for us as we change
-        the MemberData class.
-        '''
-        members = self._members
-
-        for tuple in members.items():
-            member_name = tuple[0]
-            del members[member_name]
-
-        return "Done."
-
-    @security.private
-    def updateMemberDataContents(self,):
-        """Update former MemberData objects to new MemberData objects
-        """
-        count = 0
-        members = self._members
-        properties = self.propertyIds()
-
-        # Scan members for old MemberData
-        for member_name, member_obj in members.items():
-            values = {}
-            if getattr(member_obj, "_is_new_kind", None):
-                continue        # Do not have to upgrade that object
-
-            # Have to upgrade. Create the values mapping.
-            for pty_name in properties:
-                user_value = getattr(member_obj, pty_name, _marker)
-                if user_value is not _marker:
-                    values[pty_name] = user_value
-
-            # Wrap a new user object of the RIGHT class
-            u = self.acl_users.getUserById(member_name, None)
-            if not u:
-                continue                # User is not in main acl_users anymore
-            self.wrapUser(u)
-
-            # Set its properties
-            mbr = self._members.get(member_name, None)
-            if not mbr:
-                raise RuntimeError(
-                    "Error while upgrading user '{0}'.".format(member_name)
-                )
-            mbr.setProperties(values, force_local=1)
-            count += 1
-
-        return count
-
-    @security.private
-    def searchMemberDataContents(self, search_param, search_term):
-        """
-        Search members.
-        This is the same as CMFCore except that it doesn't check term case.
-        """
-        res = []
-
-        search_term = search_term.strip().lower()
-
-        if search_param == 'username':
-            search_param = 'id'
-
-        mtool = getToolByName(self, 'portal_membership')
-
-        for member_id in self._members.keys():
-            user_wrapper = mtool.getMemberById(member_id)
-
-            if user_wrapper is not None:
-                memberProperty = user_wrapper.getProperty
-                searched = memberProperty(search_param, None)
-
-                if searched is not None:
-                    if searched.strip().lower().find(search_term) != -1:
-
-                        res.append({'username': memberProperty('id'),
-                                    'email': memberProperty('email', '')})
-        return res
-
-    @security.public
-    def searchFulltextForMembers(self, s):
-        """search for members which do have string 's' in name, email or full
-        name (if defined)
-
-        this is mainly used for the localrole form
-        """
-        s = s.strip().lower()
-        mu = getToolByName(self, 'portal_membership')
-
-        res = []
-        for member in mu.listMembers():
-            u = member.getUser()
-            if u.getUserName().lower().find(s) != -1 \
-               or member.getProperty('fullname').lower().find(s) != -1 \
-               or member.getProperty('email').lower().find(s) != -1:
-                res.append(member)
-        return res
-
-    # check to see if we can add users. Need to be careful here
-    # so we do not write on read
-    def canAddMemberData(self):
-        try:
-            if self.REQUEST.REQUEST_METHOD != 'POST':
-                return False
-            if getattr(self, '_p_jar', None) and \
-                    len(self._p_jar._registered_objects) > 0:
-                # XXX do not write on read
-                return True
-        except AttributeError:
-            pass
-        return False
-
-    # an exact copy from the base, so that we pick up the new MemberData.
-    # wrapUser should have a MemberData factory method to over-ride (or even
-    # set at run-time!) so that we don't have to do this.
-    def wrapUser(self, u):
-        '''
-        If possible, returns the Member object that corresponds
-        to the given User object.
-        We override this to ensure OUR MemberData class is used
-        '''
-        user_id = u.getId()
-        members = self._members
-        if user_id not in members:
-            base = aq_base(self)
-            md = MemberData(base, user_id)
-            if self.canAddMemberData():
-                # XXX do not write on read
-                members[user_id] = md
-            return md.__of__(self).__of__(u)
-        else:
-            # Return a wrapper with self as containment and
-            # the user as context.
-            return members[user_id].__of__(self).__of__(u)
-
-    @postonly
-    def deleteMemberData(self, member_id, REQUEST=None):
-        """ Delete member data of specified member.
-        """
-        if IPluggableAuthService.providedBy(self.acl_users):
-            # It's a PAS! Whee!
-            # XXX: can we safely assume that user name == member_id
-            plugins = self._getPlugins()
-            prop_managers = plugins.listPlugins(IPropertiesPlugin)
-            for mid, prop_manager in prop_managers:
-                # Not all PropertiesPlugins support user deletion
-                try:
-                    prop_manager.deleteUser(member_id)
-                except AttributeError:
-                    pass
-
-        # we won't always have PlonePAS users, due to acquisition,
-        # nor are guaranteed property sheets
-        members = self._members
-        if member_id in members:
-            del members[member_id]
-            return 1
-        else:
-            return 0
-
-    # plugin getter
-    def _getPlugins(self):
-        return self.acl_users.plugins
-
-InitializeClass(MemberDataTool)
-
-
-@implementer(IManageCapabilities)
-class MemberData(BaseMemberData):
-
-    security = ClassSecurityInfo()
-
-    # setProperties uses setMemberProperties. no need to override.
-
-    def setMemberProperties(self, mapping, force_local=0):
-        """PAS-specific method to set the properties of a
-        member. Ignores 'force_local', which is not reliably present.
-        """
-        sheets = None
-
-        # We could pay attention to force_local here...
-        if not IPluggableAuthService.providedBy(self.acl_users):
-            # Defer to base impl in absence of PAS, a PAS user, or
-            # property sheets
-            return BaseMemberData.setMemberProperties(self, mapping)
-        else:
-            # It's a PAS! Whee!
-            user = self.getUser()
-            sheets = getattr(user, 'getOrderedPropertySheets', lambda: None)()
-
-            # We won't always have PlonePAS users, due to acquisition,
-            # nor are guaranteed property sheets
-            if not sheets:
-                # Defer to base impl if we have a PAS but no property
-                # sheets.
-                return BaseMemberData.setMemberProperties(self, mapping)
-
-        # If we got this far, we have a PAS and some property sheets.
-        # XXX track values set to defer to default impl
-        # property routing?
-        modified = False
-        for k, v in mapping.items():
-            if v is None:
-                continue
-            for sheet in sheets:
-                if not sheet.hasProperty(k):
-                    continue
-                if IMutablePropertySheet.providedBy(sheet):
-                    sheet.setProperty(user, k, v)
-                    modified = True
-                else:
-                    break
-        if modified:
-            self.notifyModified()
-
-    def getProperty(self, id, default=_marker):
-        """PAS-specific method to fetch a user's properties. Looks
-        through the ordered property sheets.
-        """
-        sheets = None
-        if not IPluggableAuthService.providedBy(self.acl_users):
-            return BaseMemberData.getProperty(self, id)
-        else:
-            # It's a PAS! Whee!
-            user = self.getUser()
-            sheets = getattr(user, 'getOrderedPropertySheets', lambda: None)()
-
-            # we won't always have PlonePAS users, due to acquisition,
-            # nor are guaranteed property sheets
-            if not sheets:
-                return BaseMemberData.getProperty(self, id, default)
-
-        # If we made this far, we found a PAS and some property sheets.
-        for sheet in sheets:
-            if sheet.hasProperty(id):
-                # Return the first one that has the property.
-                value = sheet.getProperty(id)
-                if isinstance(value, unicode):
-                    # XXX Temporarily work around the fact that
-                    # property sheets blindly store and return
-                    # unicode. This is sub-optimal and should be
-                    # dealed with at the property sheets level by
-                    # using Zope's converters.
-                    return value.encode('utf-8')
-                return value
-
-        # Couldn't find the property in the property sheets. Try to
-        # delegate back to the base implementation.
-        return BaseMemberData.getProperty(self, id, default)
-
-    def getPassword(self):
-        """Returns None. Present to avoid NotImplementedError."""
-        return None
-
-    # IManageCapabilities methods
-
-    def canDelete(self):
-        """True iff user can be removed from the Plone UI."""
-        # IUserManagement provides doDeleteUser
-        plugins = self._getPlugins()
-        managers = plugins.listPlugins(IUserManagement)
-        for mid, manager in managers:
-            if (IDeleteCapability.providedBy(manager) and
-                    manager.allowDeletePrincipal(self.getId())):
-                return True
-        return False
-
-    def canPasswordSet(self):
-        """True iff user can change password."""
-        # IUserManagement provides doChangeUser
-        plugins = self._getPlugins()
-        managers = plugins.listPlugins(IUserManagement)
-        for mid, manager in managers:
-            if (IPasswordSetCapability.providedBy(manager) and
-                    manager.allowPasswordSet(self.getId())):
-                return True
-        return False
-
-    def passwordInClear(self):
-        """True iff password can be retrieved in the clear (not hashed.)
-
-        False for PAS. It provides no API for getting passwords,
-        though it would be possible to add one in the future.
-        """
-        return 0
-
-    def _memberdataHasProperty(self, prop_name):
-        mdata = getToolByName(self, 'portal_memberdata', None)
-        if mdata:
-            return mdata.hasProperty(prop_name)
-        return 0
-
-    def canWriteProperty(self, prop_name):
-        """True iff the member/group property named in 'prop_name'
-        can be changed.
-        """
-        if not IPluggableAuthService.providedBy(self.acl_users):
-            # not PAS; Memberdata is writable
-            return self._memberdataHasProperty(prop_name)
-        else:
-            # it's PAS
-            user = self.getUser()
-            sheets = getattr(user, 'getOrderedPropertySheets', lambda: None)()
-            if not sheets:
-                return self._memberdataHasProperty(prop_name)
-
-            for sheet in sheets:
-                if not sheet.hasProperty(prop_name):
-                    continue
-                if IMutablePropertySheet.providedBy(sheet):
-                    # BBB for plugins implementing an older version of
-                    # IMutablePropertySheet
-                    if hasattr(sheet, 'canWriteProperty'):
-                        return sheet.canWriteProperty(user, prop_name)
-                    return True
-                else:
-                    break  # shadowed by read-only
-        return False
-
-    def canAddToGroup(self, group_id):
-        """True iff member can be added to group."""
-        # IGroupManagement provides IGroupCapability
-        plugins = self._getPlugins()
-        managers = plugins.listPlugins(IGroupManagement)
-        for mid, manager in managers:
-            if (IGroupCapability.providedBy(manager) and
-                    manager.allowGroupAdd(self.getId(), group_id)):
-                return True
-        return False
-
-    def canRemoveFromGroup(self, group_id):
-        """True iff member can be removed from group."""
-        # IGroupManagement provides IGroupCapability
-        plugins = self._getPlugins()
-        managers = plugins.listPlugins(IGroupManagement)
-        for mid, manager in managers:
-            if (IGroupCapability.providedBy(manager) and
-                    manager.allowGroupRemove(self.getId(), group_id)):
-                return True
-        return False
-
-    def canAssignRole(self, role_id):
-        """True iff member can be assigned role. Role id is string."""
-        # IRoleAssignerPlugin provides IAssignRoleCapability
-        plugins = self._getPlugins()
-        managers = plugins.listPlugins(IRoleAssignerPlugin)
-        for mid, manager in managers:
-            if (IAssignRoleCapability.providedBy(manager) and
-                    manager.allowRoleAssign(self.getId(), role_id)):
-                return True
-        return False
-
-    @security.private
-    def setSecurityProfile(self, password=None, roles=None, domains=None):
-        """Set the user's basic security profile"""
-        u = self.getUser()
-
-        # The Zope User API is stupid, it should check for None.
-        if roles is None:
-            roles = list(u.getRoles())
-            if 'Authenticated' in roles:
-                roles.remove('Authenticated')
-        if domains is None:
-            domains = u.getDomains()
-
-        u.userFolderEditUser(u.getUserId(), password, roles, domains)
-
-    # plugin getters
-
-    @security.private
-    def _getPlugins(self):
-        return self.acl_users.plugins
-
-
-InitializeClass(MemberData)
diff --git a/Products/PlonePAS/tools/membership.py b/Products/PlonePAS/tools/membership.py
deleted file mode 100644
index 4fe629f..0000000
--- a/Products/PlonePAS/tools/membership.py
+++ /dev/null
@@ -1,762 +0,0 @@
-# -*- coding: utf-8 -*-
-from AccessControl import ClassSecurityInfo
-from AccessControl import Unauthorized
-from AccessControl import getSecurityManager
-from AccessControl.SecurityManagement import noSecurityManager
-from AccessControl.requestmethod import postonly
-from Acquisition import aq_get
-from Acquisition import aq_inner
-from Acquisition import aq_parent
-from App.class_init import InitializeClass
-from App.special_dtml import DTMLFile
-from DateTime import DateTime
-from OFS.Image import Image
-from Products.CMFCore.MembershipTool import MembershipTool as BaseTool
-from Products.CMFCore.interfaces import IPropertiesTool
-from Products.CMFCore.permissions import ListPortalMembers
-from Products.CMFCore.permissions import ManagePortal
-from Products.CMFCore.permissions import ManageUsers
-from Products.CMFCore.permissions import SetOwnPassword
-from Products.CMFCore.permissions import SetOwnProperties
-from Products.CMFCore.permissions import View
-from Products.CMFCore.utils import _checkPermission
-from Products.CMFCore.utils import getToolByName
-from Products.PlonePAS.config import HAS_PIL
-from Products.PlonePAS.events import UserInitialLoginInEvent
-from Products.PlonePAS.events import UserLoggedInEvent
-from Products.PlonePAS.events import UserLoggedOutEvent
-from Products.PlonePAS.interfaces import membership
-from Products.PlonePAS.utils import cleanId
-from Products.PlonePAS.utils import scale_image
-from ZODB.POSException import ConflictError
-from cStringIO import StringIO
-from zExceptions import BadRequest
-from zope import event
-from zope.component import getUtility
-from zope.interface import implementer
-import logging
-import transaction
-
-default_portrait = 'defaultUser.png'
-logger = logging.getLogger('PlonePAS')
-
-_marker = dict()
-
-
-def _unicodify_structure(value, charset=_marker):
-    """ Convert value to unicode.
-    """
-    if charset is _marker:
-        ptool = getUtility(IPropertiesTool)
-        charset = ptool.getProperty('default_charset', None)
-
-    if isinstance(value, str):
-        return charset and unicode(value, charset) or unicode(value)
-    if isinstance(value, list):
-        return [_unicodify_structure(val, charset) for val in value]
-    if isinstance(value, tuple):
-        return tuple([_unicodify_structure(entry, charset) for entry in value])
-    if isinstance(value, dict):
-        for key, val in value.items():
-            value[key] = _unicodify_structure(val, charset)
-        return value
-    return value
-
-
-@implementer(membership.IMembershipTool)
-class MembershipTool(BaseTool):
-    """PAS-based customization of MembershipTool.
-    """
-
-    meta_type = "PlonePAS Membership Tool"
-    toolicon = 'tool.gif'
-    personal_id = '.personal'
-    portrait_id = 'MyPortrait'
-    default_portrait = 'defaultUser.gif'
-    memberarea_type = 'Folder'
-    membersfolder_id = 'Members'
-    memberareaCreationFlag = False
-    security = ClassSecurityInfo()
-
-    user_search_keywords = ('login', 'fullname', 'email', 'exact_match',
-                            'sort_by', 'max_results')
-
-    _properties = (getattr(BaseTool, '_properties', ()) +
-                   ({'id': 'user_search_keywords',
-                     'type': 'lines',
-                     'mode': 'rw',
-                     },))
-
-    manage_options = (BaseTool.manage_options +
-                      ({'label': 'Portraits',
-                        'action': 'manage_portrait_fix'},))
-
-    # TODO I'm not quite sure why getPortalRoles is declared 'Managed'
-    #    in CMFCore.MembershipTool - but in Plone we are not so anal ;-)
-    security.declareProtected(View, 'getPortalRoles')
-
-    security.declareProtected(ManagePortal, 'manage_mapRoles')
-    manage_mapRoles = DTMLFile('../zmi/membershipRolemapping', globals())
-
-    security.declareProtected(ManagePortal, 'manage_portrait_fix')
-    manage_portrait_fix = DTMLFile('../zmi/portrait_fix', globals())
-
-    @security.protected(ManagePortal)
-    def manage_setMemberAreaType(self, type_name, REQUEST=None):
-        """ ZMI method to set the home folder type by its type name.
-        """
-        self.setMemberAreaType(type_name)
-        if REQUEST is not None:
-            REQUEST['RESPONSE'].redirect(
-                self.absolute_url() +
-                '/manage_mapRoles'
-                '?manage_tabs_message=Member+area+type+changed.'
-            )
-
-    @security.protected(ManagePortal)
-    def manage_setMembersFolderById(self, id, REQUEST=None):
-        """ ZMI method to set the members folder object by its id.
-        """
-        self.setMembersFolderById(id)
-        if REQUEST is not None:
-            REQUEST['RESPONSE'].redirect(
-                self.absolute_url() +
-                '/manage_mapRoles'
-                '?manage_tabs_message=Members+folder+id+changed.'
-            )
-
-    @security.protected(ManagePortal)
-    def setMemberAreaType(self, type_name):
-        """ Sets the portal type to use for new home folders.
-        """
-        # No check for folderish since someone somewhere may actually want
-        # members to have objects instead of folders as home "directory".
-        self.memberarea_type = str(type_name).strip()
-
-    @security.protected(ManagePortal)
-    def setMembersFolderById(self, id=''):
-        """ Set the members folder object by its id.
-        """
-        self.membersfolder_id = id.strip()
-
-    @security.public
-    def getMembersFolder(self):
-        """ Get the members folder object.
-        """
-        parent = aq_parent(aq_inner(self))
-        members = getattr(parent, self.membersfolder_id, None)
-        return members
-
-    @security.private
-    def addMember(self, id, password, roles, domains, properties=None):
-        """Adds a new member to the user folder.
-
-        Security checks will have already been performed.  Called by
-        portal_registration.  This one specific to PAS. PAS ignores
-        domains. Adding members with login_name also not yet
-        supported.
-        """
-        acl_users = self.acl_users
-        acl_users._doAddUser(id, password, roles, domains)
-
-        if properties is not None:
-            member = self.getMemberById(id)
-            member.setMemberProperties(properties)
-
-    @security.protected(ListPortalMembers)
-    def searchForMembers(self, REQUEST=None, **kw):
-        """Hacked up version of Plone searchForMembers.
-
-        The following properties can be provided:
-        - name
-        - email
-        - last_login_time
-        - before_specified_time
-        - roles (any role will cause a match)
-        - groupname
-
-        This is an 'AND' request.
-
-        Simple name searches are "fast".
-        """
-        logger.debug('searchForMembers: started.')
-
-        acl_users = getToolByName(self, "acl_users")
-
-        if REQUEST is not None:
-            searchmap = REQUEST
-            for key, value in searchmap.items():
-                if isinstance(value, str):
-                    searchmap[key] = _unicodify_structure(value)
-        else:
-            searchmap = kw
-
-        # While the parameter is called name it is actually used to search a
-        # users name, which is stored in the fullname property. We need to fix
-        # that here so the right name is used when calling into PAS plugins.
-        if 'name' in searchmap:
-            searchmap['fullname'] = searchmap['name']
-            del searchmap['name']
-
-        user_search = dict(
-            [x for x in searchmap.items()
-             if x[0] in self.user_search_keywords and x[1]]
-        )
-
-        fullname = searchmap.get('fullname', None)
-        email = searchmap.get('email', None)
-        roles = searchmap.get('roles', None)
-        last_login_time = searchmap.get('last_login_time', None)
-        before_specified_time = searchmap.get('before_specified_time', None)
-        groupname = searchmap.get('groupname', '').strip()
-
-        if fullname:
-            fullname = fullname.strip().lower()
-        if not fullname:
-            fullname = None
-        if email:
-            email = email.strip().lower()
-        if not email:
-            email = None
-
-        uf_users = []
-
-        logger.debug(
-            'searchForMembers: searching PAS '
-            'with arguments %r.' % user_search)
-        for user in acl_users.searchUsers(**user_search):
-            uf_users.append(user['userid'])
-
-        if not uf_users:
-            return []
-
-        getUserById = acl_users.getUserById
-
-        def dedupe(seq):
-            # Thanks http://www.peterbe.com/plog/uniqifiers-benchmark
-            seen = set()
-            seen_add = seen.add
-            # nice trick! set.add() does always return None
-            return [x for x in seq if x not in seen and not seen_add(x)]
-
-        uf_users = dedupe(uf_users)
-        members = [getUserById(userid) for userid in uf_users]
-        members = [member for member in members if member is not None]
-
-        if not (email or fullname or roles or groupname or last_login_time):
-            logger.debug(
-                'searchForMembers: searching users '
-                'with no extra filter, immediate return.')
-            return members
-
-        # Now perform individual checks on each user
-        res = []
-
-        for member in members:
-            if groupname and groupname not in member.getGroupIds():
-                continue
-
-            if roles:
-                user_roles = member.getRoles()
-                found = 0
-                for r in roles:
-                    if r in user_roles:
-                        found = 1
-                        break
-                if not found:
-                    continue
-
-            if last_login_time:
-                last_login = member.getProperty('last_login_time', '')
-
-                if isinstance(last_login, basestring):
-                    # value is a string when member hasn't yet logged in
-                    last_login = DateTime(last_login or '2000/01/01')
-
-                if before_specified_time:
-                    if last_login >= last_login_time:
-                        continue
-                elif last_login < last_login_time:
-                    continue
-
-            res.append(member)
-
-        logger.debug('searchForMembers: finished.')
-        return res
-
-    ############
-    # sanitize home folders (we may get URL-illegal ids)
-
-    @security.public
-    def createMemberarea(self, member_id=None, minimal=None):
-        """
-        Create a member area for 'member_id' or the authenticated
-        user, but don't assume that member_id is url-safe.
-        """
-        if not self.getMemberareaCreationFlag():
-            return None
-        membership = getToolByName(self, 'portal_membership')
-        members = self.getMembersFolder()
-
-        if not member_id:
-            # member_id is optional (see CMFCore.interfaces.portal_membership:
-            #     Create a member area for 'member_id' or authenticated user.)
-            member = membership.getAuthenticatedMember()
-            member_id = member.getId()
-
-        if hasattr(members, 'aq_explicit'):
-            members = members.aq_explicit
-
-        if members is None:
-            # no members area
-            logger.debug('createMemberarea: members area does not exist.')
-            return
-
-        safe_member_id = cleanId(member_id)
-        if hasattr(members, safe_member_id):
-            # has already this member
-            logger.debug(
-                'createMemberarea: member area '
-                'for %r already exists.' % safe_member_id)
-            return
-
-        if not safe_member_id:
-            # Could be one of two things:
-            # - A Emergency User
-            # - cleanId made a empty string out of member_id
-            logger.debug(
-                'createMemberarea: empty member id '
-                '(%r, %r), skipping member area creation.' %
-                (member_id, safe_member_id)
-            )
-            return
-
-        # Create member area without security checks
-        typesTool = getToolByName(members, 'portal_types')
-        fti = typesTool.getTypeInfo(self.memberarea_type)
-        member_folder = fti._constructInstance(members, safe_member_id)
-
-        # Get the user object from acl_users
-        acl_users = getToolByName(self, "acl_users")
-        user = acl_users.getUserById(member_id)
-        if user is not None:
-            user = user.__of__(acl_users)
-        else:
-            user = getSecurityManager().getUser()
-            # check that we do not do something wrong
-            if user.getId() != member_id:
-                raise NotImplementedError(
-                        'cannot get user for member area creation')
-
-        member_object = self.getMemberById(member_id)
-
-        # Modify member folder
-        member_folder = self.getHomeFolder(member_id)
-        # Grant Ownership and Owner role to Member
-        member_folder.changeOwnership(user)
-        member_folder.__ac_local_roles__ = None
-        member_folder.manage_setLocalRoles(member_id, ['Owner'])
-        # We use ATCT now use the mutators
-        fullname = member_object.getProperty('fullname')
-        member_folder.setTitle(fullname or member_id)
-        member_folder.reindexObject()
-
-        # Hook to allow doing other things after memberarea creation.
-        notify_script = getattr(member_folder, 'notifyMemberAreaCreated', None)
-        if notify_script is not None:
-            notify_script()
-
-    # deal with ridiculous API change in CMF
-    security.declarePublic('createMemberArea')
-    createMemberArea = createMemberarea
-
-    @security.public
-    def getMemberInfo(self, memberId=None):
-        # Return 'harmless' Memberinfo of any member, such as Full name,
-        # Location, etc
-        if not memberId:
-            member = self.getAuthenticatedMember()
-        else:
-            member = self.getMemberById(memberId)
-
-        if member is None:
-            return None
-
-        memberinfo = {
-            'fullname': member.getProperty('fullname'),
-            'description': member.getProperty('description'),
-            'location': member.getProperty('location'),
-            'language': member.getProperty('language'),
-            'home_page': member.getProperty('home_page'),
-            'username': member.getUserName(),
-            'has_email': bool(member.getProperty('email')),
-        }
-
-        return memberinfo
-
-    def _getSafeMemberId(self, id=None):
-        """Return a safe version of a member id.
-
-        If no id is given return the id for the currently authenticated user.
-        """
-
-        if id is None:
-            member = self.getAuthenticatedMember()
-            if not hasattr(member, 'getMemberId'):
-                return None
-            id = member.getMemberId()
-
-        return cleanId(id)
-
-    @security.public
-    def getHomeFolder(self, id=None, verifyPermission=0):
-        """ Return a member's home folder object, or None.
-
-        Specially instrumented for URL-quoted-member-id folder
-        names.
-        """
-        safe_id = self._getSafeMemberId(id)
-        if safe_id is None:
-            member = self.getAuthenticatedMember()
-            if not hasattr(member, 'getMemberId'):
-                return None
-            safe_id = member.getMemberId()
-        members = self.getMembersFolder()
-        if members:
-            try:
-                folder = members._getOb(safe_id)
-                if verifyPermission and not _checkPermission(View, folder):
-                    # Don't return the folder if the user can't get to it.
-                    return None
-                return folder
-            # KeyError added to deal with btree member folders
-            except (AttributeError, KeyError, TypeError):
-                pass
-        return None
-
-    def getHomeUrl(self, id=None, verifyPermission=0):
-        """ Return the URL to a member's home folder, or None.
-        """
-        home = self.getHomeFolder(id, verifyPermission)
-        if home is not None:
-            return home.absolute_url()
-        else:
-            return None
-
-    @security.public
-    def getPersonalFolder(self, member_id=None):
-        """
-        returns the Personal Item folder for a member
-        if no Personal Folder exists will return None
-        """
-        home = self.getHomeFolder(member_id)
-        personal = None
-        if home:
-            personal = getattr(home, self.personal_id, None)
-        return personal
-
-    @security.public
-    def getPersonalPortrait(self, id=None, verifyPermission=0):
-        """Return a members personal portait.
-
-        Modified from CMFPlone version to URL-quote the member id.
-        """
-        if not id:
-            id = self.getAuthenticatedMember().getId()
-        safe_id = self._getSafeMemberId(id)
-        membertool = getToolByName(self, 'portal_memberdata')
-        portrait = membertool._getPortrait(safe_id)
-        if isinstance(portrait, str):
-            portrait = None
-        if portrait is not None:
-            if verifyPermission and not _checkPermission('View', portrait):
-                # Don't return the portrait if the user can't get to it
-                portrait = None
-        if portrait is None:
-            portal = getToolByName(self, 'portal_url').getPortalObject()
-            portrait = getattr(portal, default_portrait, None)
-
-        return portrait
-
-    @security.protected(SetOwnProperties)
-    def deletePersonalPortrait(self, id=None):
-        """deletes the Portait of a member.
-        """
-        authenticated_id = self.getAuthenticatedMember().getId()
-        if not id:
-            id = authenticated_id
-        safe_id = self._getSafeMemberId(id)
-        if id != authenticated_id and not _checkPermission(
-                ManageUsers, self):
-            raise Unauthorized
-
-        membertool = getToolByName(self, 'portal_memberdata')
-        return membertool._deletePortrait(safe_id)
-
-    @security.protected(SetOwnProperties)
-    def changeMemberPortrait(self, portrait, id=None):
-        """update the portait of a member.
-
-        We URL-quote the member id if needed.
-
-        Note that this method might be called by an anonymous user who
-        is getting registered.  This method will then be called from
-        plone.app.users and this is fine.  When called from restricted
-        python code or with a curl command by a hacker, the
-        declareProtected line will kick in and prevent use of this
-        method.
-        """
-        authenticated_id = self.getAuthenticatedMember().getId()
-        if not id:
-            id = authenticated_id
-        safe_id = self._getSafeMemberId(id)
-        if authenticated_id and id != authenticated_id:
-            # Only Managers can change portraits of others.
-            if not _checkPermission(ManageUsers, self):
-                raise Unauthorized
-        if portrait and portrait.filename:
-            scaled, mimetype = scale_image(portrait)
-            portrait = Image(id=safe_id, file=scaled, title='')
-            membertool = getToolByName(self, 'portal_memberdata')
-            membertool._setPortrait(portrait, safe_id)
-
-    @security.protected(ManageUsers)
-    def listMembers(self):
-        '''Gets the list of all members.
-        THIS METHOD MIGHT BE VERY EXPENSIVE ON LARGE USER FOLDERS AND MUST
-        BE USED WITH CARE! We plan to restrict its use in the future (ie.
-        force large requests to use searchForMembers instead of listMembers,
-        so that it will not be possible anymore to have a method returning
-        several hundred of users :)
-        '''
-        return BaseTool.listMembers(self)
-
-    @security.protected(ManageUsers)
-    def listMemberIds(self):
-        '''Lists the ids of all members.  This may eventually be
-        replaced with a set of methods for querying pieces of the
-        list rather than the entire list at once.
-        '''
-        return self.acl_users.getUserIds()
-
-    @security.protected(SetOwnPassword)
-    def testCurrentPassword(self, password):
-        """ test to see if password is current """
-        REQUEST = getattr(self, 'REQUEST', {})
-        member = self.getAuthenticatedMember()
-        acl_users = self._findUsersAclHome(member.getUserId())
-        if not acl_users:
-            return 0
-        return acl_users.authenticate(member.getUserName(), password, REQUEST)
-
-    def _findUsersAclHome(self, userid):
-        portal = getToolByName(self, 'portal_url').getPortalObject()
-        acl_users = portal.acl_users
-        parent = acl_users
-        while parent:
-            if acl_users.aq_explicit.getUserById(userid, None) is not None:
-                break
-            parent = aq_parent(aq_inner(parent)).aq_parent
-            acl_users = getattr(parent, 'acl_users')
-        if parent:
-            return acl_users
-        else:
-            return None
-
-    @security.protected(SetOwnPassword)
-    def setPassword(self, password, domains=None, REQUEST=None):
-        '''Allows the authenticated member to set his/her own password.
-        '''
-        registration = getToolByName(self, 'portal_registration', None)
-        if not self.isAnonymousUser():
-            member = self.getAuthenticatedMember()
-            acl_users = self._findUsersAclHome(member.getUserId())
-            if not acl_users:
-                # should not possibly ever happen
-                raise BadRequest('did not find current user in any '
-                                 'user folder')
-            if registration:
-                failMessage = registration.testPasswordValidity(password)
-                if failMessage is not None:
-                    raise BadRequest(failMessage)
-
-            if domains is None:
-                domains = []
-            user = acl_users.getUserById(member.getUserId(), None)
-            # we must change the users password trough grufs changepassword
-            # to keep her  group settings
-            if hasattr(user, 'changePassword'):
-                user.changePassword(password)
-            else:
-                acl_users._doChangeUser(member.getUserId(), password,
-                                        member.getRoles(), domains)
-            if REQUEST is None:
-                REQUEST = aq_get(self, 'REQUEST', None)
-            self.credentialsChanged(password, REQUEST=REQUEST)
-        else:
-            raise BadRequest('Not logged in.')
-    setPassword = postonly(setPassword)
-
-    @security.protected(View)
-    def getCandidateLocalRoles(self, obj):
-        """ What local roles can I assign?
-            Override the CMFCore version so that we can see the local roles on
-            an object, and so that local managers can assign all roles locally.
-        """
-        member = self.getAuthenticatedMember()
-        # Use getRolesInContext as someone may be a local manager
-        if 'Manager' in member.getRolesInContext(obj):
-            # Use valid_roles as we may want roles defined only on a subobject
-            local_roles = [r for r in obj.valid_roles() if r not in
-                           ('Anonymous', 'Authenticated', 'Shared')]
-        else:
-            local_roles = [role for role in member.getRolesInContext(obj)
-                           if role not in ('Member', 'Authenticated')]
-        local_roles.sort()
-        return tuple(local_roles)
-
-    @security.protected(View)
-    def loginUser(self, REQUEST=None):
-        """ Handle a login for the current user.
-
-        This method takes care of all the standard work that needs to be
-        done when a user logs in:
-        - clear the copy/cut/paste clipboard
-        - PAS credentials update
-        - sending a logged-in event
-        - storing the login time
-        - create the member area if it does not exist
-        """
-        user = getSecurityManager().getUser()
-        if user is None:
-            return
-
-        if self.setLoginTimes():
-            event.notify(UserInitialLoginInEvent(user))
-        else:
-            event.notify(UserLoggedInEvent(user))
-
-        if REQUEST is None:
-            REQUEST = getattr(self, 'REQUEST', None)
-        if REQUEST is None:
-            return
-
-        # Expire the clipboard
-        if REQUEST.get('__cp', None) is not None:
-            REQUEST.RESPONSE.expireCookie('__cp', path='/')
-
-        self.createMemberArea()
-
-        try:
-            pas = getToolByName(self, 'acl_users')
-            pas.credentials_cookie_auth.login()
-        except AttributeError:
-            # The cookie plugin may not be present
-            pass
-
-    @security.protected(View)
-    def logoutUser(self, REQUEST=None):
-        """Process a user logout.
-
-        This takes care of all the standard logout work:
-        - ask the user folder to logout
-        - expire a skin selection cookie
-        - invalidate a Zope session if there is one
-        """
-        # Invalidate existing sessions, but only if they exist.
-        sdm = getToolByName(self, 'session_data_manager', None)
-        if sdm is not None:
-                session = sdm.getSessionData(create=0)
-                if session is not None:
-                            session.invalidate()
-
-        if REQUEST is None:
-            REQUEST = getattr(self, 'REQUEST', None)
-        if REQUEST is not None:
-            pas = getToolByName(self, 'acl_users')
-            try:
-                pas.logout(REQUEST)
-            except:
-                # XXX Bare except copied from logout.cpy. This should be
-                # changed in the next Plone release.
-                pass
-
-            # Expire the skin cookie if it is not configured to persist
-            st = getToolByName(self, "portal_skins")
-            skinvar = st.getRequestVarname()
-            if skinvar in REQUEST and not st.getCookiePersistence():
-                    portal = getToolByName(self, "portal_url") \
-                                .getPortalObject()
-                    path = '/' + portal.absolute_url(1)
-                    # XXX check if this path is sane
-                    REQUEST.RESPONSE.expireCookie(skinvar, path=path)
-
-        user = getSecurityManager().getUser()
-        if user is not None:
-            event.notify(UserLoggedOutEvent(user))
-
-    @security.protected(View)
-    def immediateLogout(self):
-        """ Log the current user out immediately.  Used by logout.py so that
-            we do not have to do a redirect to show the logged out status. """
-        noSecurityManager()
-
-    @security.public
-    def setLoginTimes(self):
-        """ Called by logged_in to set the login time properties
-            even if members lack the "Set own properties" permission.
-
-            The return value indicates if this is the first logged
-            login time.
-        """
-        res = False
-        if not self.isAnonymousUser():
-            member = self.getAuthenticatedMember()
-            default = DateTime('2000/01/01')
-            login_time = member.getProperty('login_time', default)
-            if login_time == default:
-                res = True
-                login_time = DateTime()
-            member.setProperties(login_time=self.ZopeTime(),
-                                 last_login_time=login_time)
-        return res
-
-    @security.protected(ManagePortal)
-    def getBadMembers(self):
-        """Will search for members with bad images in the portal_memberdata
-        delete their portraits and return their member ids"""
-        memberdata = getToolByName(self, 'portal_memberdata')
-        portraits = getattr(memberdata, 'portraits', None)
-        if portraits is None:
-            return []
-        bad_member_ids = []
-        TXN_THRESHOLD = 50
-        counter = 1
-        for member_id in tuple(portraits.keys()):
-            portrait = portraits[member_id]
-            portrait_data = str(portrait.data)
-            if portrait_data == '':
-                continue
-            if not HAS_PIL:
-                raise RuntimeError(
-                    'No Python Imaging Libraries (PIL) found. '
-                    'Unable to validate profile image. '
-                )
-            try:
-                import PIL
-                PIL.Image.open(StringIO(portrait_data))
-            except ConflictError:
-                pass
-            except:
-                # Anything else we have a bad bad image and we destroy it
-                # and ask questions later.
-                portraits._delObject(member_id)
-                bad_member_ids.append(member_id)
-            if not counter % TXN_THRESHOLD:
-                transaction.savepoint(optimistic=True)
-            counter = counter + 1
-
-        return bad_member_ids
-
-
-InitializeClass(MembershipTool)
diff --git a/Products/PlonePAS/tools/plonetool.py b/Products/PlonePAS/tools/plonetool.py
deleted file mode 100644
index 8e3bd6a..0000000
--- a/Products/PlonePAS/tools/plonetool.py
+++ /dev/null
@@ -1,3 +0,0 @@
-# This is a backwards compatibility alias. It can be removed once Plone
-# doesn't support upgrading from Plone 2.5 anymore.
-from Products.CMFPlone.PloneTool import PloneTool
diff --git a/Products/PlonePAS/utils.py b/Products/PlonePAS/utils.py
deleted file mode 100644
index 4a7d55c..0000000
--- a/Products/PlonePAS/utils.py
+++ /dev/null
@@ -1,198 +0,0 @@
-# -*- coding: utf-8 -*-
-from Products.PlonePAS.config import IMAGE_SCALE_PARAMS
-from Products.PluggableAuthService.interfaces.plugins import IGroupsPlugin
-from cStringIO import StringIO
-from urllib import quote as url_quote
-from urllib import unquote as url_unquote
-
-
-def unique(iterable):
-    d = {}
-    for i in iterable:
-        d[i] = None
-    return d.keys()
-
-
-def cleanId(id):
-    """'url_quote' turns strange chars into '%xx', which is not a valid char
-    for ObjectManager. Here we encode '%' into '-' (and '-' into '--' as
-    escaping).
-    De-clean is possible; see 'decleanId'.
-    Assumes that id can start with non-alpha(numeric), which is true.
-    """
-    __traceback_info__ = (id,)
-    if id:
-        # note: we provide the 'safe' param to get '/' encoded
-        return url_quote(id, '').replace('-', '--').replace('%', '-')
-    return ''
-
-
-def decleanId(id):
-    """Reverse cleanId."""
-    if id:
-        id = id.replace('--', '\x00').replace('-', '%').replace('\x00', '-')
-        return url_unquote(id)
-    return ''
-
-
-def scale_image(image_file, max_size=None, default_format=None):
-    """Scales an image down to at most max_size preserving aspect ratio
-    from an input file
-
-        >>> from Products.PlonePAS import config
-        >>> import os
-        >>> from StringIO import StringIO
-        >>> from Products.PlonePAS.utils import scale_image
-        >>> from PIL import Image
-
-    Let's make a couple test images and see how it works (all are
-    100x100), the gif is palletted mode::
-
-        >>> pas_path = os.path.dirname(config.__file__)
-        >>> pjoin = os.path.join
-        >>> path = pjoin(pas_path, 'tests', 'images')
-        >>> orig_jpg = open(pjoin(path, 'test.jpg'), 'rb')
-        >>> orig_png = open(pjoin(path, 'test.png'), 'rb')
-        >>> orig_gif = open(pjoin(path, 'test.gif'), 'rb')
-
-    We'll also make some evil non-images, including one which
-    masquerades as a jpeg (which would trick OFS.Image)::
-
-        >>> invalid = StringIO('<div>Evil!!!</div>')
-        >>> sneaky = StringIO('\377\330<div>Evil!!!</div>')
-
-    OK, let's get to it, first check that our bad images fail:
-
-        >>> scale_image(invalid, (50, 50))
-        Traceback (most recent call last):
-        ...
-        IOError: cannot identify image file...
-        >>> scale_image(sneaky, (50, 50))
-        Traceback (most recent call last):
-        ...
-        IOError: cannot identify image file...
-
-    Now that that's out of the way we check on our real images to make
-    sure the format and mode are preserved, that they are scaled, and that they
-    return the correct mimetype::
-
-        >>> new_jpg, mimetype = scale_image(orig_jpg, (50, 50))
-        >>> img = Image.open(new_jpg)
-        >>> img.size
-        (50, 50)
-        >>> img.format
-        'JPEG'
-        >>> mimetype
-        'image/jpeg'
-
-        >>> new_png, mimetype = scale_image(orig_png, (50, 50))
-        >>> img = Image.open(new_png)
-        >>> img.size
-        (50, 50)
-        >>> img.format
-        'PNG'
-        >>> mimetype
-        'image/png'
-
-        >>> new_gif, mimetype = scale_image(orig_gif, (50, 50))
-        >>> img = Image.open(new_gif)
-        >>> img.size
-        (50, 50)
-        >>> img.format
-        'GIF'
-        >>> img.mode
-        'P'
-        >>> mimetype
-        'image/gif'
-
-    We should also preserve the aspect ratio by scaling to the given
-    width only unless told not to (we need to reset out files before
-    trying again though::
-
-        >>> orig_jpg.seek(0)
-        >>> new_jpg, mimetype = scale_image(orig_jpg, (70, 100))
-        >>> img = Image.open(new_jpg)
-        >>> img.size
-        (70, 70)
-
-        >>> orig_jpg.seek(0)
-        >>> new_jpg, mimetype = scale_image(orig_jpg, (70, 50))
-        >>> img = Image.open(new_jpg)
-        >>> img.size
-        (50, 50)
-
-    """
-    from PIL import Image
-
-    if max_size is None:
-        max_size = IMAGE_SCALE_PARAMS['scale']
-    if default_format is None:
-        default_format = IMAGE_SCALE_PARAMS['default_format']
-    # Make sure we have ints
-    size = (int(max_size[0]), int(max_size[1]))
-    # Load up the image, don't try to catch errors, we want to fail miserably
-    # on invalid images
-    image = Image.open(image_file)
-    # When might image.format not be true?
-    format = image.format
-    mimetype = 'image/%s' % format.lower()
-
-    # from Archetypes ImageField
-    # consider image mode when scaling
-    # source images can be mode '1','L,','P','RGB(A)'
-    # convert to greyscale or RGBA before scaling
-    # preserve palletted mode (but not pallette)
-    # for palletted-only image formats, e.g. GIF
-    # PNG compression is OK for RGBA thumbnails
-    original_mode = image.mode
-    if original_mode == '1':
-        image = image.convert('L')
-    elif original_mode == 'P':
-        image = image.convert('RGBA')
-    # Rescale in place with an method that will not alter the aspect ratio
-    # and will only shrink the image not enlarge it.
-    image.thumbnail(size, resample=IMAGE_SCALE_PARAMS['algorithm'])
-    # preserve palletted mode for GIF and PNG
-    if original_mode == 'P' and format in ('GIF', 'PNG'):
-        image = image.convert('P')
-    # Save
-    new_file = StringIO()
-    image.save(new_file, format, quality=IMAGE_SCALE_PARAMS['quality'])
-    new_file.seek(0)
-    # Return the file data and the new mimetype
-    return new_file, mimetype
-
-
-def getGroupsForPrincipal(principal, plugins, request=None):
-    groups = set()
-    for iid, plugin in plugins.listPlugins(IGroupsPlugin):
-        groups.update(plugin.getGroupsForPrincipal(principal, request))
-    return list(groups)
-
-
-def safe_unicode(value, encoding='utf-8'):
-    """Converts a value to unicode, even it is already a unicode string.
-    """
-    if isinstance(value, unicode):
-        return value
-    elif isinstance(value, basestring):
-        try:
-            value = unicode(value, encoding)
-        except UnicodeDecodeError:
-            value = value.decode('utf-8', 'replace')
-    return value
-
-
-# Imported from Products.CMFCore.MemberdataTool as it has now been removed.
-class CleanupTemp:
-    """Used to cleanup _v_temps at the end of the request."""
-
-    def __init__(self, tool):
-        self._tool = tool
-
-    def __del__(self):
-        try:
-            del self._tool._v_temps
-        except (AttributeError, KeyError):
-            # The object has already been deactivated.
-            pass
diff --git a/Products/PlonePAS/zmi/AutoGroupForm.zpt b/Products/PlonePAS/zmi/AutoGroupForm.zpt
deleted file mode 100644
index 187abc6..0000000
--- a/Products/PlonePAS/zmi/AutoGroupForm.zpt
+++ /dev/null
@@ -1,66 +0,0 @@
-<h1 tal:replace="structure here/manage_page_header">Header</h1>
-
-<h2 tal:define="form_title string:Add Auto Group plugin"
-    tal:replace="structure here/manage_form_title">Form Title</h2>
-
-<p class="form-help">
-The Auto Group plugin automatically puts all authenticated users in a virtual
-group.
-</p>
-
-<form action="manage_addAutoGroup" method="post">
-<table cellspacing="0" cellpadding="2" border="0">
-  <tr>
-    <td align="left" valign="top">
-    <div class="form-label">
-    Id
-    </div>
-    </td>
-    <td align="left" valign="top">
-    <input type="text" name="id" size="40" />
-    </td>
-  </tr>
-  <tr>
-    <td align="left" valign="top">
-    <div class="form-optional">
-    Title
-    </div>
-    </td>
-    <td align="left" valign="top">
-    <input type="text" name="title" size="40" />
-    </td>
-  </tr>
-  <tr>
-    <td align="left" valign="top">
-    <div class="form-label">
-    Group id
-    </div>
-    </td>
-    <td align="left" valign="top">
-    <input type="text" name="group" size="40" />
-    </td>
-  </tr>
-  <tr>
-    <td align="left" valign="top">
-    <div class="form-label">
-    Description
-    </div>
-    </td>
-    <td align="left" valign="top">
-    <input type="text" name="description" size="40" />
-    </td>
-  </tr>
-  <tr>
-    <td align="left" valign="top">
-    </td>
-    <td align="left" valign="top">
-    <div class="form-element">
-    <input class="form-element" type="submit" name="submit" 
-     value=" Add " /> 
-    </div>
-    </td>
-  </tr>
-</table>
-</form>
-
-<h1 tal:replace="structure here/manage_page_footer">Footer</h1>
diff --git a/Products/PlonePAS/zmi/CookieCrumblingPluginForm.dtml b/Products/PlonePAS/zmi/CookieCrumblingPluginForm.dtml
deleted file mode 100644
index 56facac..0000000
--- a/Products/PlonePAS/zmi/CookieCrumblingPluginForm.dtml
+++ /dev/null
@@ -1,39 +0,0 @@
-<dtml-var manage_page_header>
-
-<h2> Add A CookieCrumblingPlugin For PAS</h2>
-
-<p class="form-help">
- This user factory allows form-based logins to be authenticated against regular user folders
- in parent folders. Otherwise, users from, say, the root's <code>acl_users</code> won't be able
- to log in via a form
-</p>
-
-<p>
- It does this by injecting form-provided credentials into the REQUEST as CookieCrumbler does.
-</p>
-
-<form action="manage_addCookieCrumblingPlugin" method="POST">
-
-<table>
-<tr>
-   <td class="form-label"> Id </td>
-   <td> <input type="text" name="id" /> </td>
-</tr>
-<tr>
-   <td class="form-label"> Title </td>
-   <td> <input type="text" name="title" /> </td>
-</tr>
-<tr>
-   <td colspan="2"> 
-    <div class="form-element">
-     <input type="submit" value="submit"/>
-     </div>
-   </td>
-</tr>
-
-</table>
-
-</form>
-
-</body>
-</html>
diff --git a/Products/PlonePAS/zmi/ExtendedCookieAuthHelperForm.dtml b/Products/PlonePAS/zmi/ExtendedCookieAuthHelperForm.dtml
deleted file mode 100644
index 285c6d3..0000000
--- a/Products/PlonePAS/zmi/ExtendedCookieAuthHelperForm.dtml
+++ /dev/null
@@ -1,30 +0,0 @@
-<dtml-var manage_page_header>
-
-<h2> Add An ExtendedCookieAuthHelper For PAS</h2>
-
-
-<form action="manage_addExtendedCookieAuthHelper" method="POST">
-
-<table>
-<tr>
-   <td class="form-label"> Id </td>
-   <td> <input type="text" name="id" /> </td>
-</tr>
-<tr>
-   <td class="form-label"> Title </td>
-   <td> <input type="text" name="title" /> </td>
-</tr>
-<tr>
-   <td colspan="2"> 
-    <div class="form-element">
-     <input type="submit" value="submit"/>
-     </div>
-   </td>
-</tr>
-
-</table>
-
-</form>
-
-</body>
-</html>
diff --git a/Products/PlonePAS/zmi/GroupAwareRoleManagerForm.dtml b/Products/PlonePAS/zmi/GroupAwareRoleManagerForm.dtml
deleted file mode 100644
index cf2c5f2..0000000
--- a/Products/PlonePAS/zmi/GroupAwareRoleManagerForm.dtml
+++ /dev/null
@@ -1,35 +0,0 @@
-<dtml-var manage_page_header>
-
-<h2> Add A Group Aware Role Manager For PAS </h2>
-
-<p class="form-help">
-  install a group aware role manager. returns roles assigned to group 
-  a principal is a member of, in addition to the explicit roles
-  assigned directly to the principal.
-</p>
-
-<form action="manage_addGroupAwareRoleManager" method="POST">
-
-<table>
-
-<tr>
-   <td class="form-label"> Id </td>
-   <td> <input type="text" name="id" /> </td>
-</tr>
-<tr>
-   <td class="form-label"> Title </td>
-   <td> <input type="text" name="title" /> </td>
-</tr>
-<tr>
-   <td colspan="2"> 
-   <div class="form-element">
-    <input type="submit" value="add group aware role manager"/>
-   </div>
-   </td>
-</tr>
-</table>   
-
-</form>
-
-</body>
-</html>
diff --git a/Products/PlonePAS/zmi/GroupManagerForm.dtml b/Products/PlonePAS/zmi/GroupManagerForm.dtml
deleted file mode 100644
index fcb2974..0000000
--- a/Products/PlonePAS/zmi/GroupManagerForm.dtml
+++ /dev/null
@@ -1,35 +0,0 @@
-<dtml-var manage_page_header>
-
-<h2> Add A Group Manager For PAS </h2>
-
-<p class="form-help">
- This group manager allows for zodb based storage of groups, as well
- exposing a management interface for adding, deleting, modifying, and
- introspecting groups. 
-</p>
-
-<form action="manage_addGroupManager" method="POST">
-
-<table>
-<tr>
-   <td class="form-label"> Id </td>
-   <td> <input type="text" name="id" /> </td>
-</tr>
-<tr>
-   <td class="form-label"> Title </td>
-   <td> <input type="text" name="title" /> </td>
-</tr>
-<tr>
-   <td colspan="2"> 
-    <div class="form-element">
-     <input type="submit" value="submit"/>
-     </div>
-   </td>
-</tr>
-
-</table>
-
-</form>
-
-</body>
-</html>
diff --git a/Products/PlonePAS/zmi/LocalRolesManagerForm.dtml b/Products/PlonePAS/zmi/LocalRolesManagerForm.dtml
deleted file mode 100644
index 1a136b6..0000000
--- a/Products/PlonePAS/zmi/LocalRolesManagerForm.dtml
+++ /dev/null
@@ -1,34 +0,0 @@
-<dtml-var manage_page_header>
-
-<h2> Add A Local Roles Manager For PAS </h2>
-
-<p class="form-help">
- This local roles manager checks for both user and the user's groups
- local roles as well allowing for local roles blocking on containers.
-</p>
-
-<form action="manage_addLocalRolesManager" method="POST">
-
-<table>
-<tr>
-   <td class="form-label"> Id </td>
-   <td> <input type="text" name="id" /> </td>
-</tr>
-<tr>
-   <td class="form-label"> Title </td>
-   <td> <input type="text" name="title" /> </td>
-</tr>
-<tr>
-   <td colspan="2"> 
-    <div class="form-element">
-     <input type="submit" value="submit"/>
-     </div>
-   </td>
-</tr>
-
-</table>
-
-</form>
-
-</body>
-</html>
diff --git a/Products/PlonePAS/zmi/MutablePropertyProviderForm.dtml b/Products/PlonePAS/zmi/MutablePropertyProviderForm.dtml
deleted file mode 100644
index 53731fa..0000000
--- a/Products/PlonePAS/zmi/MutablePropertyProviderForm.dtml
+++ /dev/null
@@ -1,34 +0,0 @@
-<dtml-var manage_page_header>
-
-<h2> Add A Mutable Property Provider For PAS </h2>
-
-<p class="form-help">
-  install a ZODB-based mutable property provider. provides property sheets like
-  a regular property manager, but allows writing as well.
-</p>
-
-<form action="manage_addZODBMutablePropertyProvider" method="POST">
-
-<table>
-
-<tr>
-   <td class="form-label"> Id </td>
-   <td> <input type="text" name="id" /> </td>
-</tr>
-<tr>
-   <td class="form-label"> Title </td>
-   <td> <input type="text" name="title" /> </td>
-</tr>
-<tr>
-   <td colspan="2"> 
-   <div class="form-element">
-    <input type="submit" value="add mutable property provider"/>
-   </div>
-   </td>
-</tr>
-</table>   
-
-</form>
-
-</body>
-</html>
diff --git a/Products/PlonePAS/zmi/PasswordPolicyForm.zpt b/Products/PlonePAS/zmi/PasswordPolicyForm.zpt
deleted file mode 100644
index 43a2726..0000000
--- a/Products/PlonePAS/zmi/PasswordPolicyForm.zpt
+++ /dev/null
@@ -1,45 +0,0 @@
-<h1 tal:replace="structure here/manage_page_header">Header</h1>
-
-<h2 tal:define="form_title string:Add Default Plone Password Policy plugin"
-    tal:replace="structure here/manage_form_title">Form Title</h2>
-
-<p class="form-help">
-The Default Plone Password Policy validates passwords to be at least 5 chars long
-</p>
-
-<form action="manage_addPasswordPolicyPlugin" method="post">
-<table cellspacing="0" cellpadding="2" border="0">
-  <tr>
-    <td align="left" valign="top">
-    <div class="form-label">
-    Id
-    </div>
-    </td>
-    <td align="left" valign="top">
-    <input type="text" name="id" size="40" />
-    </td>
-  </tr>
-  <tr>
-    <td align="left" valign="top">
-    <div class="form-optional">
-    Title
-    </div>
-    </td>
-    <td align="left" valign="top">
-    <input type="text" name="title" size="40" />
-    </td>
-  </tr>
-  <tr>
-    <td align="left" valign="top">
-    </td>
-    <td align="left" valign="top">
-    <div class="form-element">
-    <input class="form-element" type="submit" name="submit"
-     value=" Add " />
-    </div>
-    </td>
-  </tr>
-</table>
-</form>
-
-<h1 tal:replace="structure here/manage_page_footer">Footer</h1>
diff --git a/Products/PlonePAS/zmi/PloneUserFactoryForm.dtml b/Products/PlonePAS/zmi/PloneUserFactoryForm.dtml
deleted file mode 100644
index a4b8a08..0000000
--- a/Products/PlonePAS/zmi/PloneUserFactoryForm.dtml
+++ /dev/null
@@ -1,35 +0,0 @@
-<dtml-var manage_page_header>
-
-<h2> Add A PloneUser Factory For PAS </h2>
-
-<p class="form-help">
- This user factory allows for creation of plone compatible users from
- PAS, specifically it performs name/id demangling and allows for local
- roles black listing.
-</p>
-
-<form action="manage_addPloneUserFactory" method="POST">
-
-<table>
-<tr>
-   <td class="form-label"> Id </td>
-   <td> <input type="text" name="id" /> </td>
-</tr>
-<tr>
-   <td class="form-label"> Title </td>
-   <td> <input type="text" name="title" /> </td>
-</tr>
-<tr>
-   <td colspan="2"> 
-    <div class="form-element">
-     <input type="submit" value="submit"/>
-     </div>
-   </td>
-</tr>
-
-</table>
-
-</form>
-
-</body>
-</html>
diff --git a/Products/PlonePAS/zmi/UserManagerForm.dtml b/Products/PlonePAS/zmi/UserManagerForm.dtml
deleted file mode 100644
index 1601847..0000000
--- a/Products/PlonePAS/zmi/UserManagerForm.dtml
+++ /dev/null
@@ -1,35 +0,0 @@
-<dtml-var manage_page_header>
-
-<h2> Add A User Manager For PAS </h2>
-
-<p class="form-help">
- This user manager allows for zodb based storage of users, as well
- exposing a management interface for adding, deleting, and modifying
- users. 
-</p>
-
-<form action="manage_addUserManager" method="POST">
-
-<table>
-<tr>
-   <td class="form-label"> Id </td>
-   <td> <input type="text" name="id" /> </td>
-</tr>
-<tr>
-   <td class="form-label"> Title </td>
-   <td> <input type="text" name="title" /> </td>
-</tr>
-<tr>
-   <td colspan="2"> 
-    <div class="form-element">
-     <input type="submit" value="submit"/>
-     </div>
-   </td>
-</tr>
-
-</table>
-
-</form>
-
-</body>
-</html>
diff --git a/Products/PlonePAS/zmi/membershipRolemapping.dtml b/Products/PlonePAS/zmi/membershipRolemapping.dtml
deleted file mode 100644
index 1b535af..0000000
--- a/Products/PlonePAS/zmi/membershipRolemapping.dtml
+++ /dev/null
@@ -1,136 +0,0 @@
-<dtml-let form_title="'Membership Tool Role Mappings'">
-<dtml-if manage_page_header>
- <dtml-var manage_page_header>
-<dtml-else>
- <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.or
- <html lang="en">
- <head>
- <title>&dtml-form_title;</title>
- </head>
- <body bgcolor="#FFFFFF" link="#000099" vlink="#555555">
- <h3>&dtml-form_title;</h3>
-</dtml-if>
-</dtml-let>
-
-<dtml-var name="manage_tabs">
-
-<h2>Membership role mappings</h2>
-
-<p>Use this screen if you are using a userfolder other than the built-in folder
-existing role names to roles understood by the CMF.</p>
-
-<dtml-in expr="getPortalRoles()">
-  <dtml-if name="sequence-start">
-    <table border="1" cellpadding="3">
-      <tr>
-        <td class="form-label"><b>Portal Role</b></td>
-        <td class="form-label"><b>User Folder-defined Role</b></td>
-        <td>&nbsp;</td>
-      </tr>
-  </dtml-if>
-
-  <tr>
-    <form method="post" action="setRoleMapping">
-
-    <td class="form-label"><dtml-var name="sequence-item"><input type="hidden"
-        name="portal_role" value="&dtml-sequence-item;"></td>
-    <td class="form-element"><input type="text" size="30" name="userfolder_role"
-              value="<dtml-var expr="getMappedRole(_['sequence-item'])">"></td>
-    <td><input type="submit" value="Set Mapping"></td>
-    </form>
-  </tr>
-
-  <dtml-if name="sequence-end">
-    </table>
-  </dtml-if>
-</dtml-in>
-
-<p><hr></p>
-
-<h2>Control creation of member areas</h2>
-
-<p>This feature controls whether users
-will have their own folder created upon first login or not.</p>
-
-<form method="post" action="setMemberareaCreationFlag">
-
-<dtml-if expr="getMemberareaCreationFlag() == 1">
-  <p><b>Member areas are created upon first login.</b>
-  <input type="submit" value=" Turn folder creation off ">
-<dtml-else>
-  <p><b>No member areas are created.</b>
-  <input type="submit" value=" Turn folder creation on ">
-</dtml-if>
-
-</form>
-
-<p><hr></p>
-
-<h2>Set member area type</h2>
-
-<p>Select the (folderish) type to use when creating new
-member areas. You have all the freedom you want but be aware that
-non-folderish types may cause problems.</p>
-
-<form action="manage_setMemberAreaType" method="post">
-<table cellspacing="2">
-<tr>
-  <td align="left" valign="top">
-    <div class="form-label">Member area type</div>
-  </td>
-  <td align="left" valign="top">
-    <select name="type_name">
-      <dtml-let types="[x.getId() for x in portal_types.listTypeInfo()]"
-                dummy="types.sort()">
-        <dtml-in types>
-          <dtml-let id="_['sequence-item']">
-            <option
-              <dtml-if expr="id == memberarea_type">
-                selected="selected"
-              </dtml-if>
-              name="<dtml-var id>"><dtml-var id></option>
-          </dtml-let>
-        </dtml-in>
-      </dtml-let>
-    </select>
-  </td>
-</tr>
-<tr>
-  <td>
-  </td>
-  <td align="left" valign="top">
-    <input class="form-element" type="submit" value=" Change ">
-  </td>
-</tr>
-</table>
-</form>
-
-<p><hr></p>
-
-<h2>Set members folder</h2>
-
-<p>The members folder has to be in the same container as the membership tool.</p>
-
-<form action="manage_setMembersFolderById" method="post">
-<table cellspacing="2">
-<tr>
-  <td align="left" valign="top">
-    <div class="form-label">Members folder id</div>
-  </td>
-  <td align="left" valign="top">
-    <input class="form-element" type="text" name="id"
-        value="&dtml-membersfolder_id;">
-  </td>
-</tr>
-<tr>
-  <td>
-  </td>
-  <td align="left" valign="top">
-    <input class="form-element" type="submit" value=" Change ">
-  </td>
-</tr>
-</table>
-</form>
-
-</body>
-</html>
diff --git a/Products/PlonePAS/zmi/portrait_fix.dtml b/Products/PlonePAS/zmi/portrait_fix.dtml
deleted file mode 100644
index 6109e31..0000000
--- a/Products/PlonePAS/zmi/portrait_fix.dtml
+++ /dev/null
@@ -1,55 +0,0 @@
-<dtml-var manage_page_header>
-<dtml-var manage_tabs>
-
-<p>This is a simple tool for purging members who have uploaded non-image files
-as their member portraits in an attempted cross site scripting attack.  The
-issue which allowed such portraits to be uploaded has been resolved, and this
-tool will remove any existing bad portraits and give you the option of removing
-the members to whom those portraits belonged.
-</p>
-
-<hr />
-<dtml-if search_for_bad_members>
-  <dtml-let ids="getBadMembers()">
-    <dtml-if ids>
-      <p>Found <dtml-var "len(ids)"> bad member portraits and removed them.
-         You may optionally delete these members as well using the form below.
-      </p>
-      <form name="purge_bad_members"
-            method="POST"
-            action="manage_portrait_fix">
-        <ul>
-          <dtml-in ids>
-            <li><dtml-var sequence-item></li>
-            <input type="hidden"
-                   name="member_ids:list"
-                   value="&dtml-sequence-item;"/>
-          </dtml-in>
-        </ul>
-        <input type="checkbox"
-               name="delete_memberareas:bool"
-               checked="true">Delete member areas
-        <br />
-        <input type="submit"
-               name="purge_bad_members"
-               value="Remove These Members" />
-      </form>
-    <dtml-else>
-      <p>No bad members found</p>
-    </dtml-if>
-  </dtml-let>
-<dtml-elif purge_bad_members>
-  
-  <dtml-let deleted="deleteMembers(member_ids, REQUEST.get('delete_memberareas', False), REQUEST=REQUEST)">
-    <dtml-call "portal_memberdata.pruneMemberDataContents()">
-    <p>Deleted <dtml-var "len(deleted)"> bad members</p>
-  </dtml-let>
-<dtml-else>
-  <form name="get_bad_members"
-        method="POST"
-        action="manage_portrait_fix">
-
-    <input type="submit" name="search_for_bad_members"
-           value="Remove Bad Portraits" />
-  </form>
-</dtml-if>
diff --git a/Products/__init__.py b/Products/__init__.py
deleted file mode 100644
index 68c04af..0000000
--- a/Products/__init__.py
+++ /dev/null
@@ -1,2 +0,0 @@
-# -*- coding: utf-8 -*-
-__import__('pkg_resources').declare_namespace(__name__)
diff --git a/setup.py b/setup.py
index c7da31c..e220ae6 100644
--- a/setup.py
+++ b/setup.py
@@ -22,7 +22,8 @@
     author_email='plone-developers@lists.sourceforge.net',
     url='http://pypi.python.org/pypi/Products.PlonePAS',
     license='ZPL',
-    packages=find_packages(exclude=['ez_setup']),
+    packages=find_packages('src'),
+    package_dir={'': 'src'},
     namespace_packages=['Products'],
     include_package_data=True,
     zip_safe=False,
diff --git a/src/Products/PlonePAS/Extensions/Install.py b/src/Products/PlonePAS/Extensions/Install.py
new file mode 100644
index 0000000..3f02911
--- /dev/null
+++ b/src/Products/PlonePAS/Extensions/Install.py
@@ -0,0 +1,18 @@
+# -*- coding: utf-8 -*-
+# BBB
+
+# imported at least by borg.localrole.utils
+from Products.PlonePAS.setuphandlers import activatePluginInterfaces  # noqa
+
+# used by plone.app.upgrade/plone/app/upgrade/v43/final.py
+from Products.PlonePAS.setuphandlers import setupPasswordPolicyPlugin  # noqa
+
+# seems this is not needed anywhere outside setuphandlers
+# from Products.PlonePAS.setuphandlers import setupRoles
+# from Products.PlonePAS.setuphandlers import registerPluginType
+# from Products.PlonePAS.setuphandlers import registerPluginTypes
+# from Products.PlonePAS.setuphandlers import setupAuthPlugins
+# from Products.PlonePAS.setuphandlers import updateProperties
+# from Products.PlonePAS.setuphandlers import updateProp
+# from Products.PlonePAS.setuphandlers import addPAS
+# from Products.PlonePAS.setuphandlers import challenge_chooser_setup
diff --git a/src/Products/PlonePAS/Extensions/__init__.py b/src/Products/PlonePAS/Extensions/__init__.py
new file mode 100644
index 0000000..691ba77
--- /dev/null
+++ b/src/Products/PlonePAS/Extensions/__init__.py
@@ -0,0 +1 @@
+# poof!
diff --git a/src/Products/PlonePAS/__init__.py b/src/Products/PlonePAS/__init__.py
new file mode 100644
index 0000000..46ebe11
--- /dev/null
+++ b/src/Products/PlonePAS/__init__.py
@@ -0,0 +1,146 @@
+# -*- coding: utf-8 -*-
+from AccessControl.Permissions import add_user_folders
+from Products.CMFCore.utils import ToolInit
+from Products.PlonePAS.pas import patch_pas
+from Products.PlonePAS.plugins import autogroup
+from Products.PlonePAS.plugins import cookie_handler
+from Products.PlonePAS.plugins import crumbler
+from Products.PlonePAS.plugins import group
+from Products.PlonePAS.plugins import local_role
+from Products.PlonePAS.plugins import passwordpolicy
+from Products.PlonePAS.plugins import property
+from Products.PlonePAS.plugins import role
+from Products.PlonePAS.plugins import ufactory
+from Products.PlonePAS.plugins import user
+from Products.PlonePAS.tools.groupdata import GroupDataTool
+from Products.PlonePAS.tools.groups import GroupsTool
+from Products.PlonePAS.tools.memberdata import MemberDataTool
+from Products.PlonePAS.tools.membership import MembershipTool
+from Products.PluggableAuthService import registerMultiPlugin
+
+####################################
+# monkey patch pas, the evil happens
+patch_pas()
+
+#################################
+# new groups tool
+
+#################################
+# register plugins with pas
+try:
+    registerMultiPlugin(user.UserManager.meta_type)
+    registerMultiPlugin(group.GroupManager.meta_type)
+    registerMultiPlugin(role.GroupAwareRoleManager.meta_type)
+    registerMultiPlugin(local_role.LocalRolesManager.meta_type)
+    registerMultiPlugin(ufactory.PloneUserFactory.meta_type)
+    registerMultiPlugin(property.ZODBMutablePropertyProvider.meta_type)
+    registerMultiPlugin(crumbler.CookieCrumblingPlugin.meta_type)
+    registerMultiPlugin(cookie_handler.ExtendedCookieAuthHelper.meta_type)
+    registerMultiPlugin(autogroup.AutoGroup.meta_type)
+    registerMultiPlugin(passwordpolicy.PasswordPolicyPlugin.meta_type)
+except RuntimeError:
+    # make refresh users happy
+    pass
+
+
+def initialize(context):
+
+    tools = (GroupsTool, GroupDataTool, MembershipTool, MemberDataTool)
+
+    ToolInit(
+        'PlonePAS Tool',
+        tools=tools,
+        icon='tool.gif',
+    ).initialize(context)
+
+    context.registerClass(
+        role.GroupAwareRoleManager,
+        permission=add_user_folders,
+        constructors=(
+            role.manage_addGroupAwareRoleManagerForm,
+            role.manage_addGroupAwareRoleManager),
+        visibility=None
+    )
+
+    context.registerClass(
+        user.UserManager,
+        permission=add_user_folders,
+        constructors=(
+            user.manage_addUserManagerForm,
+            user.manage_addUserManager),
+        visibility=None
+    )
+
+    context.registerClass(
+        group.GroupManager,
+        permission=add_user_folders,
+        constructors=(
+            group.manage_addGroupManagerForm,
+            group.manage_addGroupManager
+        ),
+        visibility=None
+    )
+
+    context.registerClass(
+        ufactory.PloneUserFactory,
+        permission=add_user_folders,
+        constructors=(
+            ufactory.manage_addPloneUserFactoryForm,
+            ufactory.manage_addPloneUserFactory),
+        visibility=None
+    )
+
+    context.registerClass(
+        local_role.LocalRolesManager,
+        permission=add_user_folders,
+        constructors=(
+            local_role.manage_addLocalRolesManagerForm,
+            local_role.manage_addLocalRolesManager),
+        visibility=None
+    )
+
+    context.registerClass(
+        property.ZODBMutablePropertyProvider,
+        permission=add_user_folders,
+        constructors=(
+            property.manage_addZODBMutablePropertyProviderForm,
+            property.manage_addZODBMutablePropertyProvider),
+        visibility=None
+    )
+
+    context.registerClass(
+        crumbler.CookieCrumblingPlugin,
+        permission=add_user_folders,
+        constructors=(
+            crumbler.manage_addCookieCrumblingPluginForm,
+            crumbler.manage_addCookieCrumblingPlugin),
+        visibility=None
+    )
+
+    context.registerClass(
+        cookie_handler.ExtendedCookieAuthHelper,
+        permission=add_user_folders,
+        constructors=(
+            cookie_handler.manage_addExtendedCookieAuthHelperForm,
+            cookie_handler.manage_addExtendedCookieAuthHelper),
+        visibility=None
+    )
+
+    context.registerClass(
+        autogroup.AutoGroup,
+        permission=add_user_folders,
+        constructors=(
+            autogroup.manage_addAutoGroupForm,
+            autogroup.manage_addAutoGroup),
+        visibility=None
+    )
+
+    context.registerClass(
+        passwordpolicy.PasswordPolicyPlugin,
+        permission=add_user_folders,
+        constructors=(
+            passwordpolicy.manage_addPasswordPolicyForm,
+            passwordpolicy.manage_addPasswordPolicyPlugin
+        ),
+        visibility=None
+    )
diff --git a/src/Products/PlonePAS/browser/__init__.py b/src/Products/PlonePAS/browser/__init__.py
new file mode 100644
index 0000000..792d600
--- /dev/null
+++ b/src/Products/PlonePAS/browser/__init__.py
@@ -0,0 +1 @@
+#
diff --git a/src/Products/PlonePAS/browser/configure.zcml b/src/Products/PlonePAS/browser/configure.zcml
new file mode 100644
index 0000000..f8e6749
--- /dev/null
+++ b/src/Products/PlonePAS/browser/configure.zcml
@@ -0,0 +1,36 @@
+<configure
+    i18n_domain="Five"
+    xmlns="http://namespaces.zope.org/zope"
+    xmlns:browser="http://namespaces.zope.org/browser"
+    xmlns:five="http://namespaces.zope.org/five">
+
+  <permission
+      id="PAS.SearchPrincipals"
+      title="Search for principals"
+  />
+
+  <browser:page
+      allowed_interface="Products.PlonePAS.interfaces.browser.IPASInfoView"
+      class=".info.PASInfoView"
+      for="*"
+      name="pas_info"
+      permission="zope2.View"
+  />
+
+  <browser:page
+      allowed_interface="Products.PlonePAS.interfaces.browser.IPASMemberView"
+      class=".member.PASMemberView"
+      for="*"
+      name="pas_member"
+      permission="zope2.View"
+  />
+
+  <browser:page
+      allowed_interface="Products.PlonePAS.interfaces.browser.IPASSearchView"
+      class=".search.PASSearchView"
+      for="*"
+      name="pas_search"
+      permission="zope2.View"
+  />
+
+</configure>
diff --git a/src/Products/PlonePAS/browser/info.py b/src/Products/PlonePAS/browser/info.py
new file mode 100644
index 0000000..353228f
--- /dev/null
+++ b/src/Products/PlonePAS/browser/info.py
@@ -0,0 +1,41 @@
+# -*- coding: utf-8 -*-
+from zope.interface import implementer
+from plone.memoize.instance import memoize
+from Acquisition import aq_inner
+from Products.PlonePAS.interfaces.browser import IPASInfoView
+from Products.PluggableAuthService.interfaces.plugins import IExtractionPlugin
+from Products.PluggableAuthService.interfaces.plugins \
+    import ILoginPasswordExtractionPlugin
+from Products.CMFCore.utils import getToolByName
+from Products.Five import BrowserView
+
+
+@implementer(IPASInfoView)
+class PASInfoView(BrowserView):
+
+    def checkExtractorForInterface(self, interface):
+        acl = getToolByName(aq_inner(self.context), "acl_users")
+        plugins = acl.plugins.listPlugins(IExtractionPlugin)
+
+        for plugin in plugins:
+            if interface.providedBy(plugin[1]):
+                return True
+
+        return False
+
+    @memoize
+    def hasLoginPasswordExtractor(self):
+        return self.checkExtractorForInterface(ILoginPasswordExtractionPlugin)
+
+    @memoize
+    def hasOpenIDExtractor(self):
+        try:
+            from plone.openid.interfaces import IOpenIdExtractionPlugin
+        except ImportError:
+            return False
+
+        return self.checkExtractorForInterface(IOpenIdExtractionPlugin)
+
+    def hasOpenIDdExtractor(self):
+        # BBB Keeping method name with typo for backwards compatibility.
+        return self.hasOpenIDExtractor()
diff --git a/src/Products/PlonePAS/browser/member.py b/src/Products/PlonePAS/browser/member.py
new file mode 100644
index 0000000..b0fcfa6
--- /dev/null
+++ b/src/Products/PlonePAS/browser/member.py
@@ -0,0 +1,29 @@
+# -*- coding: utf-8 -*-
+from Products.CMFCore.utils import getToolByName
+from Products.PlonePAS.interfaces.browser import IPASMemberView
+from plone.memoize.instance import memoize
+from zope.interface import implementer
+from zope.publisher.browser import BrowserView
+
+
+@implementer(IPASMemberView)
+class PASMemberView(BrowserView):
+
+    @memoize
+    def info(self, userid=None):
+        pm = getToolByName(self.context, 'portal_membership')
+        result = pm.getMemberInfo(memberId=userid)
+        if result is None:
+            # No such member: removed?  We return something useful anyway.
+            return {
+                'username': userid,
+                'description': '',
+                'language': '',
+                'home_page': '',
+                'name_or_id': userid,
+                'location': '',
+                'fullname': ''
+            }
+        result['name_or_id'] = result.get('fullname') or \
+            result.get('username') or userid
+        return result
diff --git a/src/Products/PlonePAS/browser/search.py b/src/Products/PlonePAS/browser/search.py
new file mode 100644
index 0000000..b2d0b00
--- /dev/null
+++ b/src/Products/PlonePAS/browser/search.py
@@ -0,0 +1,76 @@
+# -*- coding: utf-8 -*-
+from Products.CMFCore.utils import getToolByName
+from Products.Five import BrowserView
+from Products.PlonePAS.interfaces.browser import IPASSearchView
+from plone.i18n.normalizer.interfaces import IIDNormalizer
+from zope.component import queryUtility
+from zope.interface import implementer
+
+
+@implementer(IPASSearchView)
+class PASSearchView(BrowserView):
+
+    @staticmethod
+    def extractCriteriaFromRequest(request):
+        criteria = request.form.copy()
+
+        for key in ["form.submitted", "submit", 'b_start', 'b_size']:
+            if key in criteria:
+                del criteria[key]
+
+        for (key, value) in criteria.items():
+            if not value:
+                del criteria[key]
+
+        return criteria
+
+    @staticmethod
+    def merge(results, key):
+        output = {}
+        for entry in results:
+            id = entry[key]
+            if id not in output:
+                output[id] = entry.copy()
+            else:
+                buf = entry.copy()
+                buf.update(output[id])
+                output[id] = buf
+
+        return output.values()
+
+    def sort(self, results, sort_key):
+        idnormalizer = queryUtility(IIDNormalizer)
+
+        def key_func(a):
+            return idnormalizer.normalize(a.get(sort_key, a))
+        return sorted(results, key=key_func)
+
+    def searchUsers(self, sort_by=None, **criteria):
+        self.pas = getToolByName(self.context, "acl_users")
+        results = self.merge(self.pas.searchUsers(**criteria), "userid")
+        if sort_by is not None:
+            results = self.sort(results, sort_by)
+        return results
+
+    def searchUsersByRequest(self, request, sort_by=None):
+        criteria = self.extractCriteriaFromRequest(request)
+        return self.searchUsers(sort_by=sort_by, **criteria)
+
+    def searchGroups(self, sort_by=None, **criteria):
+        self.pas = getToolByName(self.context, "acl_users")
+        results = self.merge(self.pas.searchGroups(**criteria), "groupid")
+        if sort_by is not None:
+            results = self.sort(results, sort_by)
+        return results
+
+    def searchGroupsByRequest(self, request):
+        criteria = self.extractCriteriaFromRequest(request)
+        return self.searchGroups(**criteria)
+
+    def getPhysicalPath(self):
+        # We call various PAS methods which can be ZCached. The ZCache
+        # infrastructure relies on getPhysicalPath on the context being
+        # available, which this view does not have, it not being a
+        # persistent object. So we fake things and return the physical path
+        # for our context.
+        return self.context.getPhysicalPath()
diff --git a/src/Products/PlonePAS/config.py b/src/Products/PlonePAS/config.py
new file mode 100644
index 0000000..99ae0bc
--- /dev/null
+++ b/src/Products/PlonePAS/config.py
@@ -0,0 +1,28 @@
+# -*- coding: utf-8 -*-
+PROJECTNAME = 'PlonePAS'
+GLOBALS = globals()
+
+DEFAULT_CHALLENGE_PROTOCOL = ['http']
+DEFAULT_PROTO_MAPPING = {
+    'WebDAV': DEFAULT_CHALLENGE_PROTOCOL,
+    'FTP': DEFAULT_CHALLENGE_PROTOCOL,
+    'XML-RPC': DEFAULT_CHALLENGE_PROTOCOL
+}
+
+# Settings for member image resize quality
+HAS_PIL = True
+try:
+    from PIL import Image
+    PIL_SCALING_ALGO = Image.ANTIALIAS
+except ImportError:
+    PIL_SCALING_ALGO = None
+    HAS_PIL = False
+
+PIL_QUALITY = 88
+MEMBER_IMAGE_SCALE = (75, 100)
+IMAGE_SCALE_PARAMS = {
+    'scale': MEMBER_IMAGE_SCALE,
+    'quality': PIL_QUALITY,
+    'algorithm': PIL_SCALING_ALGO,
+    'default_format': 'PNG'
+}
diff --git a/src/Products/PlonePAS/configure.zcml b/src/Products/PlonePAS/configure.zcml
new file mode 100644
index 0000000..f326d9e
--- /dev/null
+++ b/src/Products/PlonePAS/configure.zcml
@@ -0,0 +1,26 @@
+<configure
+    i18n_domain="plone"
+    xmlns="http://namespaces.zope.org/zope"
+    xmlns:five="http://namespaces.zope.org/five"
+    xmlns:genericsetup="http://namespaces.zope.org/genericsetup"
+    xmlns:i18n="http://namespaces.zope.org/i18n">
+
+  <include package=".browser" />
+  <include file="profiles.zcml" />
+  <include file="exportimport.zcml" />
+
+  <genericsetup:importStep
+      description="Configure PlonePas"
+      handler="Products.PlonePAS.setuphandlers.setupPlonePAS"
+      name="plonepas"
+      title="PlonePAS setup">
+    <depends name="componentregistry" />
+    <depends name="controlpanel" />
+    <depends name="memberdata-properties" />
+    <depends name="rolemap" />
+  </genericsetup:importStep>
+
+  <five:deprecatedManageAddDelete class=".plugins.cookie_handler.ExtendedCookieAuthHelper" />
+  <five:deprecatedManageAddDelete class=".plugins.role.GroupAwareRoleManager" />
+
+</configure>
diff --git a/src/Products/PlonePAS/events.py b/src/Products/PlonePAS/events.py
new file mode 100644
index 0000000..79c2433
--- /dev/null
+++ b/src/Products/PlonePAS/events.py
@@ -0,0 +1,30 @@
+# -*- coding: utf-8 -*-
+from Products.PlonePAS.interfaces.events import IUserInitialLoginInEvent
+from Products.PluggableAuthService.events import PASEvent
+from Products.PluggableAuthService.interfaces.events import IUserLoggedInEvent
+from Products.PluggableAuthService.interfaces.events import IUserLoggedOutEvent
+from zope.interface import implementer
+
+
+@implementer(IUserLoggedInEvent)
+class UserLoggedInEvent(PASEvent):
+    """Plone Implementation of the logged in event
+
+    PAS Event
+    """
+
+
+@implementer(IUserInitialLoginInEvent)
+class UserInitialLoginInEvent(UserLoggedInEvent):
+    """Implementation of the initial logged in event
+
+    Plone only event!
+    """
+
+
+@implementer(IUserLoggedOutEvent)
+class UserLoggedOutEvent(PASEvent):
+    """Plone Implementation of the logged out event
+
+    PAS Event
+    """
diff --git a/src/Products/PlonePAS/exportimport.zcml b/src/Products/PlonePAS/exportimport.zcml
new file mode 100644
index 0000000..ae6fa67
--- /dev/null
+++ b/src/Products/PlonePAS/exportimport.zcml
@@ -0,0 +1,26 @@
+<configure xmlns="http://namespaces.zope.org/zope">
+
+  <adapter
+      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
+      for="Products.PluggableAuthService.interfaces.plugins.IUserFactoryPlugin"
+      provides="Products.GenericSetup.interfaces.IFilesystemExporter"
+  />
+  <adapter
+      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
+      for="Products.PluggableAuthService.interfaces.plugins.IUserFactoryPlugin"
+      provides="Products.GenericSetup.interfaces.IFilesystemImporter"
+  />
+
+  <!-- XXX This should point to an own export/import class! TitleOnly is far not enough -->
+  <adapter
+      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
+      for="Products.PlonePAS.interfaces.plugins.IMutablePropertiesPlugin"
+      provides="Products.GenericSetup.interfaces.IFilesystemExporter"
+  />
+  <adapter
+      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
+      for="Products.PlonePAS.interfaces.plugins.IMutablePropertiesPlugin"
+      provides="Products.GenericSetup.interfaces.IFilesystemImporter"
+  />
+
+</configure>
diff --git a/src/Products/PlonePAS/interfaces/__init__.py b/src/Products/PlonePAS/interfaces/__init__.py
new file mode 100644
index 0000000..40a96af
--- /dev/null
+++ b/src/Products/PlonePAS/interfaces/__init__.py
@@ -0,0 +1 @@
+# -*- coding: utf-8 -*-
diff --git a/src/Products/PlonePAS/interfaces/browser.py b/src/Products/PlonePAS/interfaces/browser.py
new file mode 100644
index 0000000..6f2b5cb
--- /dev/null
+++ b/src/Products/PlonePAS/interfaces/browser.py
@@ -0,0 +1,89 @@
+# -*- coding: utf-8 -*-
+from zope.interface import Interface
+
+
+class IPASInfoView(Interface):
+
+    def hasLoginPasswordExtractor():
+        """Check if a login & password extraction plugin is active.
+
+        Check if there is a plugin with an enabled
+        ILoginPasswordExtractionPlugin interface. This can be used to
+        conditionally show username & password logins.
+        """
+
+    def hasOpenIDExtractor():
+        """Check if an OpenID extraction plugin is active.
+        """
+
+    def hasOpenIDdExtractor():
+        """Check if an OpenID extraction plugin is active.
+
+        BBB Keeping method name with typo for backwards compatibility.
+        """
+
+
+class IPASMemberView(Interface):
+
+    def info(userid=None):
+        """Return 'harmless' member info of any user, such as full name,
+        location, etc.
+        """
+
+
+class IPASSearchView(Interface):
+
+    def searchUsers(sort_by=None, any_field=None, **criteria):
+        """Search for users matching a set of criteria.
+
+        The criteria are a dictionary mapping user properties to values and
+        have the semantics declared by IPluggableAuthService.searchUsers().
+        Duplicate results returned by PAS are filtered so only the first
+        result remains in the result set. The results can be sorted on
+        sort_bys (case insensitive).
+
+        In addition, a single search string can be sought in multiple
+        fields at a time by passing any_field='your-string'. The fields
+        that will be searched are not explicitly enumerated but will be the
+        user-facing ones a user would expect to search, such as login name
+        and full name. (Perhaps any_field should/could be moved into PAS
+        proper. This could be done without breaking code that depends on
+        this interface.)
+
+        If you specify both any_field and other criteria that include a
+        field that any_field would typically search (such as login name),
+        the other criteria will be enforced at the expense of any_field.
+        """
+
+    def searchUsersByRequest(request, sort_by=None):
+        """Search for users matching a set of criteria found in a request.
+
+        This method will look remove any obvious values from the request
+        which are not search criteria. It will also remove any fields
+        which have an empty string value.
+        Duplicate results returned by PAS are filtered so only the first
+        result remains in the result set. The results can be sorted on
+        sort_by (case insensitive).
+        """
+
+    def searchGroups(**criteria):
+        """Search for groups matching a set of criteria.
+
+        The criteria are a dictionary mapping group properties
+        to values and have the semantics declared by
+        IPluggableAuthService.searchGroups().
+        """
+
+    def searchGroupsByRequest(request):
+        """Search for groups matching a set of criteria found in a request.
+
+        This method will look remove any obvious values from the request
+        which are not search criteria. It will also remove any fields
+        which have an empty string value.
+        """
+
+    def merge(results, key):
+        """merge two search results based on key as the unique criterion"""
+
+    def sort(results, key):
+        """sort results on a key"""
diff --git a/src/Products/PlonePAS/interfaces/capabilities.py b/src/Products/PlonePAS/interfaces/capabilities.py
new file mode 100644
index 0000000..92b1286
--- /dev/null
+++ b/src/Products/PlonePAS/interfaces/capabilities.py
@@ -0,0 +1,78 @@
+# -*- coding: utf-8 -*-
+# Define certain interfaces that a plugin must meet if it is to allow
+# certain operations to be done by the Plone UI.
+from Products.PluggableAuthService.interfaces.plugins import Interface
+
+
+class IDeleteCapability(Interface):
+    """Interface for plugin to say if it allows for deletion of a user.
+    Expected to be found on IUserManagement plugins.
+    For Plone UI.
+    """
+
+    def allowDeletePrincipal(id):
+        """True iff this plugin can delete a certain user/group."""
+
+
+class IPasswordSetCapability(Interface):
+    """Interface for plugin to say if it allows for setting the password of a
+    user.
+    Expected to be found on IUserManagement plugins.
+    For Plone UI.
+    """
+
+    def allowPasswordSet(id):
+        """True iff this plugin can set the password of a certain user."""
+
+
+class IGroupCapability(Interface):
+    """Interface for plugin to say if it allows for deletion of a user.
+    For Plone UI.
+    """
+
+    def allowGroupAdd(principal_id, group_id):
+        """True iff this plugin will allow adding a certain principal to a
+        certain group."""
+
+    def allowGroupRemove(principal_id, group_id):
+        """True iff this plugin will allow removing a certain principal from a
+        certain group."""
+
+
+class IAssignRoleCapability(Interface):
+    """Interface for plugin to say if it allows for deletion of a user.
+    For Plone UI.
+    """
+
+    def allowRoleAssign(id, role):
+        """True iff this plugin will allow assigning a certain principal a
+        certain role."""
+
+
+class IManageCapabilities(Interface):
+    """Interface for MemberData/GroupData to provide information as to whether
+    or not the member can be deleted, reset password, modify a property.
+    """
+
+    def canDelete():
+        """True iff user can be removed from the Plone UI."""
+
+    def canPasswordSet():
+        """True iff user can change password."""
+
+    def passwordInClear():
+        """True iff password can be retrieved in the clear (not hashed.)"""
+
+    def canWriteProperty(prop_name):
+        """True iff the member/group property named in 'prop_name'
+        can be changed.
+        """
+
+    def canAddToGroup(group_id):
+        """True iff member can be added to group."""
+
+    def canRemoveFromGroup(group_id):
+        """True iff member can be removed from group."""
+
+    def canAssignRole(role):
+        """True iff member can be assigned role."""
diff --git a/src/Products/PlonePAS/interfaces/events.py b/src/Products/PlonePAS/interfaces/events.py
new file mode 100644
index 0000000..500ca8d
--- /dev/null
+++ b/src/Products/PlonePAS/interfaces/events.py
@@ -0,0 +1,7 @@
+# -*- coding: utf-8 -*-
+from Products.PluggableAuthService.interfaces.events import IUserLoggedInEvent
+
+
+class IUserInitialLoginInEvent(IUserLoggedInEvent):
+    """A user logs in for the first time in the portal.
+    """
diff --git a/src/Products/PlonePAS/interfaces/group.py b/src/Products/PlonePAS/interfaces/group.py
new file mode 100644
index 0000000..537eca1
--- /dev/null
+++ b/src/Products/PlonePAS/interfaces/group.py
@@ -0,0 +1,140 @@
+# -*- coding: utf-8 -*-
+from zope.interface import Interface
+from Products.PluggableAuthService.interfaces import plugins
+
+
+class IGroupManagement(Interface):
+
+    def addGroup(id, **kw):
+        """
+        Create a group with the supplied id, roles, and groups.
+        return True if the operation suceeded
+        """
+
+    def addPrincipalToGroup(principal_id, group_id):
+        """
+        Add a given principal to the group.
+        return True on success
+        """
+
+    def updateGroup(id, **kw):
+        """
+        Edit the given group. plugin specific
+        return True on success
+        """
+
+    def setRolesForGroup(group_id, roles=()):
+        """
+        set roles for group
+        return True on success
+        """
+
+    def removeGroup(group_id):
+        """
+        Remove the given group
+        return True on success
+        """
+
+    def removePrincipalFromGroup(principal_id, group_id):
+        """
+        remove the given principal from the group
+        return True on success
+        """
+
+
+class IGroupIntrospection(Interface):
+
+    def getGroupById(group_id):
+        """
+        Returns the portal_groupdata-ish object for a group
+        corresponding to this id.
+        """
+
+    #################################
+    # these interface methods are suspect for scalability.
+    #################################
+
+    def getGroups():
+        """
+        Returns an iteration of the available groups
+        """
+
+    def getGroupIds():
+        """
+        Returns a list of the available groups
+        """
+
+    def getGroupMembers(group_id):
+        """
+        return the members of the given group
+        """
+
+
+class IGroupDataTool(Interface):
+
+    def wrapGroup(group):
+        """
+        decorate a group with property management capabilities if needed
+        """
+
+
+class IGroupTool(IGroupIntrospection,
+                  IGroupManagement,
+                  plugins.IGroupsPlugin):
+
+    """
+    Defines an interface for managing and introspecting and
+    groups and group membership.
+    """
+
+
+class IGroupData(Interface):
+    """ An abstract interface for accessing properties on a group object"""
+
+    def setProperties(properties=None, **kw):
+        """Allows setting of group properties en masse.
+        Properties can be given either as a dict or a keyword parameters
+        list"""
+
+    def getProperty(id):
+        """ Return the value of the property specified by 'id' """
+
+    def getProperties():
+        """ Return the properties of this group. Properties are as usual in
+        Zope."""
+
+    def getGroupId():
+        """ Return the string id of this group, WITHOUT group prefix."""
+
+    def getMemberId():
+        """This exists only for a basic user/group API compatibility
+        """
+
+    def getGroupName():
+        """ Return the name of the group."""
+
+    def getGroupMembers():
+        """ Return a list of the portal_memberdata-ish members of the group."""
+
+    def getAllGroupMembers():
+        """ Return a list of the portal_memberdata-ish members of the group
+        including transitive ones (ie. users or groups of a group in that
+        group)."""
+
+    def getGroupMemberIds():
+        """ Return a list of the user ids of the group."""
+
+    def getAllGroupMemberIds():
+        """ Return a list of the user ids of the group.
+        including transitive ones (ie. users or groups of a group in that
+        group)."""
+
+    def addMember(id):
+        """ Add the existing member with the given id to the group"""
+
+    def removeMember(id):
+        """ Remove the member with the provided id from the group """
+
+    def getGroup():
+        """ Returns the actual group implementation. Varies by group
+        implementation (GRUF/Nux/et al)."""
diff --git a/src/Products/PlonePAS/interfaces/membership.py b/src/Products/PlonePAS/interfaces/membership.py
new file mode 100644
index 0000000..1f8a757
--- /dev/null
+++ b/src/Products/PlonePAS/interfaces/membership.py
@@ -0,0 +1,12 @@
+# -*- coding: utf-8 -*-
+from Products.CMFCore import interfaces
+
+
+class IMembershipTool(interfaces.IMembershipTool):
+
+    def getMemberInfo(memberId=None):
+        """Return 'harmless' Memberinfo of any member, such as full name,
+        location, etc
+        """
+
+__all__ = (IMembershipTool, )
diff --git a/src/Products/PlonePAS/interfaces/plugins.py b/src/Products/PlonePAS/interfaces/plugins.py
new file mode 100644
index 0000000..a1f78a3
--- /dev/null
+++ b/src/Products/PlonePAS/interfaces/plugins.py
@@ -0,0 +1,127 @@
+# -*- coding: utf-8 -*-
+from Products.PluggableAuthService.interfaces import plugins
+from Products.PluggableAuthService.interfaces.plugins import Interface
+
+
+class IUserIntrospection(Interface):
+    """
+    Introspect users in a user source, api users need to be careful as
+    all sources may or not support this interface.
+
+    Realistically this can only be done by authentication sources, or
+    plugins which have intimate knowledge of such.
+    """
+
+    def getUserIds():
+        """
+        Return a list of user ids
+        """
+
+    def getUserNames():
+        """
+        Return a list of usernames
+        """
+
+    def getUsers():
+        """
+        Return a list of users
+        """
+
+
+class ILocalRolesPlugin(Interface):
+    """
+    Plugin for determining a user's local roles and object access
+    based on local roles.
+    """
+
+    def getRolesInContext(user, object):
+        """
+        Return the list of roles assigned to the user.
+
+        o Include local roles assigned in context of the passed-in object.
+
+        o Include *both* local roles assigned directly to us *and* those
+          assigned to our groups.
+
+        o Ripped off from AccessControl.User.BasicUser, which provides
+          no other extension mechanism. :(
+        """
+
+    def checkLocalRolesAllowed(user, object, object_roles):
+        """
+        Check whether the user has access to object based
+        on local roles. access is determined by a user's local roles
+        including one of the object roles.
+        """
+
+    def getAllLocalRolesInContext(object):
+        """
+        Return active all local roles in a context.
+
+        The roles are returned in a dictionary mapping a principal (a
+        user or a group) to the set of roles assigned to it.
+        """
+
+
+class IUserManagement(plugins.IUserAdderPlugin):
+    """
+    Manage users
+    """
+
+    def doChangeUser(user_id, password, **kw):
+        """
+        Change a user's password (differs from role) roles are set in
+        the pas engine api for the same but are set via a role
+        manager)
+        """
+
+    def doDeleteUser(login):
+        """
+        Remove a user record from a User Manager, with the given login
+        and password
+
+        o Return a Boolean indicating whether a user was removed or
+          not
+        """
+
+
+class IMutablePropertiesPlugin(Interface):
+    """
+    Return a property set for a user. Property set can either an
+    object conforming to the IMutable property sheet interface or a
+    dictionary (in which case the properties are not persistently
+    mutable).
+    """
+
+    def getPropertiesForUser(user, request=None):
+        """
+        User -> IMutablePropertySheet || {}
+
+        o User will implement IPropertiedUser.
+
+        o Plugin may scribble on the user, if needed (but must still
+          return a mapping, even if empty).
+
+        o May assign properties based on values in the REQUEST object, if
+          present
+        """
+
+    def setPropertiesForUser(user, propertysheet):
+        """
+        Set modified properties on the user persistently.
+
+        Raise a ValueError if the property or property value is invalid
+        """
+
+    def deleteUser(user_id):
+        """
+        Remove properties stored for a user
+        """
+
+
+class ISchemaMutablePropertiesPlugin(Interface):
+
+    def addProperty(property_type, property_name, default=None):
+        """
+        Add a new property to a property provider.
+        """
diff --git a/src/Products/PlonePAS/interfaces/propertysheets.py b/src/Products/PlonePAS/interfaces/propertysheets.py
new file mode 100644
index 0000000..8ff7ab3
--- /dev/null
+++ b/src/Products/PlonePAS/interfaces/propertysheets.py
@@ -0,0 +1,22 @@
+# -*- coding: utf-8 -*-
+from Products.PluggableAuthService.interfaces.propertysheets \
+    import IPropertySheet
+
+
+class IMutablePropertySheet(IPropertySheet):
+
+    def canWriteProperty(object, id):
+        """ Check if a property can be modified.
+        """
+
+    def setProperty(object, id, value):
+        """
+        """
+
+    def setProperties(object, mapping):
+        """
+        """
+
+
+class ISchemaMutablePropertySheet(IMutablePropertySheet):
+    pass
diff --git a/src/Products/PlonePAS/ldapmp.py b/src/Products/PlonePAS/ldapmp.py
new file mode 100644
index 0000000..dd25b1a
--- /dev/null
+++ b/src/Products/PlonePAS/ldapmp.py
@@ -0,0 +1,72 @@
+# -*- coding: utf-8 -*-
+from Products.PlonePAS.patch import call
+from Products.PlonePAS.patch import wrap_method
+from Products.PlonePAS.plugins.group import PloneGroup
+
+GROUP_PROPERTY_MAP = {
+    # target property: (possible key, ...)
+    'title': ('name',
+              'displayName',
+              'cn',),
+    'description': ('description', ),
+    'email': ('mail', ),
+    }
+
+KNOWN_ATTRS = []
+for attrs in GROUP_PROPERTY_MAP.values():
+    for attr in attrs:
+        KNOWN_ATTRS.append(attr)
+KNOWN_ATTRS = set(KNOWN_ATTRS)
+
+
+def getPropertiesForUser(self, user, request=None):
+    """Fullfill PropertiesPlugin requirements
+    """
+
+    if not isinstance(user, PloneGroup):
+        # It's not a PloneGroup, continue as usual
+        return call(self, 'getPropertiesForUser', user=user, request=request)
+
+    # We've got a PloneGroup.
+    # Search for groups instead of users
+    groups = self.enumerateGroups(id=user.getId(), exact_match=True)
+    # XXX Should we assert there's only one group?
+    properties = {}
+    for group in groups:
+        for pname, attrs in GROUP_PROPERTY_MAP.items():
+            for attr in attrs:
+                value = group.get(attr)
+                if value:
+                    # Break on first found
+                    properties[pname] = value
+                    break
+
+    return properties
+
+
+def getGroupsForPrincipal(self, user, request=None, attr=None):
+    """ Fulfill GroupsPlugin requirements, but don't return any groups for
+    groups """
+
+    if not isinstance(user, PloneGroup):
+        # It's not a PloneGroup, continue as usual
+        return call(self, 'getGroupsForPrincipal', user,
+                    request=request, attr=attr)
+
+    return ()
+
+
+def patch_ldapmp():
+    from Products.LDAPMultiPlugins.LDAPPluginBase import LDAPPluginBase
+    wrap_method(
+        LDAPPluginBase,
+        'getPropertiesForUser',
+        getPropertiesForUser
+    )
+
+    from Products.LDAPMultiPlugins.LDAPMultiPlugin import LDAPMultiPlugin
+    wrap_method(
+        LDAPMultiPlugin,
+        'getGroupsForPrincipal',
+        getGroupsForPrincipal
+    )
diff --git a/src/Products/PlonePAS/pas.py b/src/Products/PlonePAS/pas.py
new file mode 100644
index 0000000..52ba319
--- /dev/null
+++ b/src/Products/PlonePAS/pas.py
@@ -0,0 +1,735 @@
+# -*- coding: utf-8 -*-
+# pas alterations and monkies
+from AccessControl import Unauthorized
+from AccessControl import getSecurityManager
+from AccessControl.PermissionRole import PermissionRole
+from AccessControl.Permissions import change_permissions
+from AccessControl.Permissions import manage_properties
+from AccessControl.Permissions import manage_users as ManageUsers
+from AccessControl.requestmethod import postonly
+from OFS.Folder import Folder
+from Products.CMFCore.utils import getToolByName
+from Products.CMFCore.utils import registerToolInterface
+from Products.PlonePAS.interfaces.group import IGroupIntrospection
+from Products.PlonePAS.interfaces.group import IGroupManagement
+from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
+from Products.PlonePAS.interfaces.plugins import IUserIntrospection
+from Products.PlonePAS.interfaces.plugins import IUserManagement
+from Products.PlonePAS.patch import wrap_method
+from Products.PlonePAS.patch import ORIG_NAME
+from Products.PluggableAuthService.PluggableAuthService import \
+    PluggableAuthService
+from Products.PluggableAuthService.PluggableAuthService import \
+    _SWALLOWABLE_PLUGIN_EXCEPTIONS
+from Products.PluggableAuthService.events import PrincipalDeleted
+from Products.PluggableAuthService.interfaces.authservice import \
+    IPluggableAuthService
+from Products.PluggableAuthService.interfaces.plugins import \
+    IAuthenticationPlugin
+from Products.PluggableAuthService.interfaces.plugins import \
+    IGroupEnumerationPlugin
+from Products.PluggableAuthService.interfaces.plugins import \
+    IRoleAssignerPlugin
+from Products.PluggableAuthService.interfaces.plugins import \
+    IUserEnumerationPlugin
+from zope.event import notify
+import logging
+
+logger = logging.getLogger('PlonePAS')
+
+registerToolInterface('acl_users', IPluggableAuthService)
+
+
+#################################
+# helper functions
+
+def _userSetGroups(pas, user_id, groupnames):
+    """method was used at GRUF level, but is used inside this monkies at several
+    places too.
+
+    We no longer provide it on PAS to clean up patches
+
+    """
+    plugins = pas.plugins
+    gtool = getToolByName(pas, "portal_groups")
+
+    member = pas.getUserById(user_id)
+    groupnameset = set(groupnames)
+
+    # remove absent groups
+    groups = set(gtool.getGroupsForPrincipal(member))
+    rmgroups = groups - groupnameset
+    for gid in rmgroups:
+        try:
+            gtool.removePrincipalFromGroup(user_id, gid)
+        except KeyError:
+            # We could hit a group which does not allow user removal, such as
+            # created by our AutoGroup plugin.
+            pass
+
+    # add groups
+    try:
+        groupmanagers = plugins.listPlugins(IGroupManagement)
+    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+        logger.info(
+            'PluggableAuthService: Plugin listing error',
+            exc_info=1
+        )
+        groupmanagers = ()
+
+    for group in groupnames:
+        for gm_id, gm in groupmanagers:
+            try:
+                if gm.addPrincipalToGroup(user_id, group):
+                    break
+            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+                logger.info(
+                    'PluggableAuthService: GroupManagement %s error',
+                    gm_id,
+                    exc_info=1
+                )
+
+#################################
+# pas folder monkies - standard zope user folder api or GRUF
+
+
+def _doAddUser(self, login, password, roles, domains, groups=None, **kw):
+    """Masking of PAS._doAddUser to add groups param."""
+    _old_doAddUser = getattr(self, getattr(_doAddUser, ORIG_NAME))
+    retval = _old_doAddUser(login, password, roles, domains)
+    if groups is not None:
+        _userSetGroups(self, login, groups)
+    return retval
+
+
+def _doDelUsers(self, names, REQUEST=None):
+    """
+    Delete users given by a list of user ids.
+    Has no return value, like the original (GRUF).
+    """
+    for name in names:
+        self._doDelUser(name)
+
+
+def _doDelUser(self, id):
+    """
+    Given a user id, hand off to a deleter plugin if available.
+    """
+    plugins = self._getOb('plugins')
+    userdeleters = plugins.listPlugins(IUserManagement)
+
+    if not userdeleters:
+        raise NotImplementedError(
+            "There is no plugin that can delete users."
+        )
+
+    for userdeleter_id, userdeleter in userdeleters:
+        try:
+            userdeleter.doDeleteUser(id)
+        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+            pass
+        else:
+            notify(PrincipalDeleted(id))
+
+
+def _doChangeUser(self, principal_id, password, roles, domains=(), groups=None,
+                  REQUEST=None, **kw):
+    """
+    Given a principal id, change its password, roles, domains, if
+    respective plugins for such exist.
+
+    XXX domains are currently ignored.
+    """
+    # Might be called with 'None' as password from the Plone UI, in
+    # prefs_users_overview when resetPassword is not set.
+    if password is not None:
+        self.userSetPassword(principal_id, password)
+
+    plugins = self._getOb('plugins')
+    rmanagers = plugins.listPlugins(IRoleAssignerPlugin)
+
+    if not (rmanagers):
+        raise NotImplementedError("There is no plugin that can modify roles")
+
+    for rid, rmanager in rmanagers:
+        rmanager.assignRolesToPrincipal(roles, principal_id)
+
+    if groups is not None:
+        _userSetGroups(self, principal_id, groups)
+
+    return True
+
+
+def userFolderAddUser(self, login, password, roles, domains,
+                      groups=None, REQUEST=None, **kw):
+    self._doAddUser(login, password, roles, domains, **kw)
+    if groups is not None:
+        _userSetGroups(self, login, groups)
+
+
+def _doAddGroup(self, id, roles, groups=None, **kw):
+    gtool = getToolByName(self, 'portal_groups')
+    return gtool.addGroup(id, roles, groups, **kw)
+
+
+# for prefs_group_manage compatibility. really should be using tool.
+def _doDelGroups(self, names, REQUEST=None):
+    gtool = getToolByName(self, 'portal_groups')
+    for group_id in names:
+        gtool.removeGroup(group_id)
+
+
+def _doChangeGroup(self, principal_id, roles, groups=None, REQUEST=None, **kw):
+    """
+    Given a group's id, change its roles, domains, if respective
+    plugins for such exist. Domains are currently ignored.
+
+    See also _doChangeUser
+    """
+    gtool = getToolByName(self, 'portal_groups')
+    gtool.editGroup(principal_id, roles, groups, **kw)
+    return True
+
+
+def _updateGroup(self, principal_id, roles=None, groups=None, **kw):
+    """
+    Given a group's id, change its roles, groups, if respective
+    plugins for such exist. Domains are ignored.
+
+    This is not an alias to _doChangeGroup because its params are different
+    (slightly).
+    """
+    return self._doChangeGroup(principal_id, roles, groups, **kw)
+
+
+def getGroups(self):
+    gtool = getToolByName(self, 'portal_groups')
+    return gtool.listGroups()
+
+
+def getGroupNames(self):
+    gtool = getToolByName(self, 'portal_groups')
+    return gtool.getGroupIds()
+
+
+def getGroupIds(self):
+    gtool = getToolByName(self, 'portal_groups')
+    return gtool.getGroupIds()
+
+
+def getGroup(self, group_id):
+    """Like getGroupById in groups tool, but doesn't wrap.
+    """
+    group = None
+    introspectors = self.plugins.listPlugins(IGroupIntrospection)
+
+    if not introspectors:
+        raise ValueError('No plugins allow for group management')
+    for iid, introspector in introspectors:
+        group = introspector.getGroupById(group_id)
+        if group is not None:
+            break
+    return group
+
+
+def getGroupByName(self, name, default=None):
+    ret = self.getGroup(name)
+    if ret is None:
+        return default
+    return ret
+
+
+def getGroupById(self, id, default=None):
+    gtool = getToolByName(self, "portal_groups")
+    ret = gtool.getGroupById(id)
+    if ret is None:
+        return default
+    else:
+        return ret
+
+
+def getLocalRolesForDisplay(self, object):
+    """This is used for plone's local roles display
+
+    This method returns a tuple (massagedUsername, roles, userType,
+    actualUserName).  This method is protected by the 'access content
+    information' permission. We may change that if it's too
+    permissive...
+
+    A GRUF method originally.
+    """
+    # Perform security check on destination object
+    if not getSecurityManager().checkPermission(manage_properties, object):
+        raise Unauthorized(name="getLocalRolesForDisplay")
+
+    return self._getLocalRolesForDisplay(object)
+
+
+def _getLocalRolesForDisplay(self, object):
+    result = []
+    # we don't have a PAS-side way to get this
+    local_roles = object.get_local_roles()
+    for one_user in local_roles:
+        username = userid = one_user[0]
+        roles = one_user[1]
+        userType = 'user'
+        if self.getGroup(userid):
+            userType = 'group'
+        else:
+            user = self.getUserById(userid) or self.getUser(username)
+            if user:
+                username = user.getUserName()
+                userid = user.getId()
+        result.append((username, roles, userType, userid))
+    return tuple(result)
+
+
+def getUsers(self):
+    """
+    Return a list of all users from plugins that implement the user
+    introspection interface.
+
+    Could potentially be very long.
+    """
+    # We should have a method that's cheap about returning number of users.
+    retval = []
+    try:
+        introspectors = self.plugins.listPlugins(IUserIntrospection)
+    except KeyError:
+        return retval
+
+    for iid, introspector in introspectors:
+        retval += introspector.getUsers()
+
+    return retval
+
+
+def canListAllUsers(self):
+    plugins = self._getOb('plugins')
+    # Do we have multiple user plugins?
+    num_enumeration_plugins = plugins.listPlugins(IUserEnumerationPlugin)
+    num_introspection_plugins = plugins.listPlugins(IUserEnumerationPlugin)
+    return num_enumeration_plugins == num_introspection_plugins
+
+
+def canListAllGroups(self):
+    plugins = self._getOb('plugins')
+    # Do we have multiple group plugins?
+    num_enumeration_plugins = plugins.listPlugins(IGroupEnumerationPlugin)
+    num_introspection_plugins = plugins.listPlugins(IGroupEnumerationPlugin)
+    return num_enumeration_plugins == num_introspection_plugins
+
+
+def userSetPassword(self, userid, password):
+    """Emulate GRUF 3 call for password set, for use with PwRT."""
+    # used by _doChangeUser
+    plugins = self._getOb('plugins')
+    managers = plugins.listPlugins(IUserManagement)
+
+    if not managers:
+        raise NotImplementedError("There is no plugin that can modify users")
+
+    modified = False
+    for mid, manager in managers:
+        try:
+            manager.doChangeUser(userid, password)
+        except RuntimeError:
+            # XXX: why silent ignore this Error?
+            pass
+        else:
+            modified = True
+
+    if not modified:
+        raise RuntimeError("No user management plugins were able "
+                           "to successfully modify the user")
+
+
+def credentialsChanged(self, user, name, new_password):
+    """Notifies the authentication mechanism that this user has changed
+    passwords.  This can be used to update the authentication cookie.
+    Note that this call should *not* cause any change at all to user
+    databases.
+
+    For use by CMFCore.MembershipTool.credentialsChanged
+    """
+    request = self.REQUEST
+    response = request.RESPONSE
+    login = name
+
+    self.updateCredentials(request, response, login, new_password)
+
+
+# for ZopeVersionControl, we need to check 'plugins' for more than
+# existence, since it replaces objects (like 'plugins') with SimpleItems
+# and calls _delOb, which tries to use special methods of 'plugins'
+def _delOb(self, id):
+    #
+    #   Override ObjectManager's version to clean up any plugin
+    #   registrations for the deleted object
+    #
+    # XXX imo this is a evil one
+    #
+    plugins = self._getOb('plugins', None)
+
+    if getattr(plugins, 'removePluginById', None) is not None:
+        plugins.removePluginById(id)
+
+    Folder._delOb(self, id)
+
+
+def addRole(self, role):
+    plugins = self._getOb('plugins')
+    roles = plugins.listPlugins(IRoleAssignerPlugin)
+
+    for plugin_id, plugin in roles:
+        try:
+            plugin.addRole(role)
+            break
+        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+            pass
+
+
+def getAllLocalRoles(self, context):
+    # Perform security check on destination object
+    if not getSecurityManager().checkPermission(change_permissions, context):
+        raise Unauthorized(name="getAllLocalRoles")
+    return self._getAllLocalRoles(context)
+
+
+def _getAllLocalRoles(self, context):
+    plugins = self._getOb('plugins')
+    lrmanagers = plugins.listPlugins(ILocalRolesPlugin)
+
+    roles = {}
+    for lrid, lrmanager in lrmanagers:
+        newroles = lrmanager.getAllLocalRolesInContext(context)
+        for k, v in newroles.items():
+            if k not in roles:
+                roles[k] = set()
+            roles[k].update(v)
+
+    return roles
+
+
+def authenticate(self, name, password, request):
+    """See AccessControl.User.BasicUserFolder.authenticate
+
+    Products.PluggableAuthService.PluggableAuthService does not provide this
+    method, BasicUserFolder documents it as "Private UserFolder object
+    interface". GRUF does provide the method, so not marked as private.
+
+    should be deprecated in future!
+    """
+
+    plugins = self.plugins
+
+    try:
+        authenticators = plugins.listPlugins(IAuthenticationPlugin)
+    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
+        authenticators = ()
+
+    credentials = {'login': name,
+                   'password': password}
+
+    user_id = None
+
+    for authenticator_id, auth in authenticators:
+        try:
+            uid_and_name = auth.authenticateCredentials(credentials)
+            if uid_and_name is not None:
+                user_id, name = uid_and_name
+                break
+        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+            logger.info(
+                    'PluggableAuthService: AuthenticationPlugin %s error',
+                    authenticator_id, exc_info=1)
+            continue
+
+    if not user_id:
+        return
+
+    return self._findUser(plugins, user_id, name, request)
+
+
+def getUserIds(self):
+    """method was used at GRUF and is here for bbb. Not good for many users!
+    DEPRECATED
+    """
+    plugins = self.plugins
+
+    try:
+        introspectors = plugins.listPlugins(IUserIntrospection)
+    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
+        introspectors = ()
+
+    results = []
+    for introspector_id, introspector in introspectors:
+        try:
+            results.extend(introspector.getUserIds())
+        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+            logger.info(
+                    'PluggableAuthService: UserIntrospection %s error',
+                    introspector_id, exc_info=1)
+
+    return results
+
+
+def getUserNames(self):
+    """method was used at GRUF and is here for bbb. Not good for many users!
+    DEPRECATED
+    """
+    plugins = self.plugins
+
+    try:
+        introspectors = plugins.listPlugins(IUserIntrospection)
+    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
+        introspectors = ()
+
+    results = []
+    for introspector_id, introspector in introspectors:
+        try:
+            results.extend(introspector.getUserNames())
+        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+            logger.info(
+                'PluggableAuthService: UserIntroSpection plugin %s error',
+                introspector_id, exc_info=1)
+
+    return results
+
+
+def patch_pas():
+    # sort alphabetically by patched/added method name
+    wrap_method(
+        PluggableAuthService,
+        '_delOb',
+        _delOb
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_getAllLocalRoles',
+        _getAllLocalRoles,
+        add=True,
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doAddGroup',
+        _doAddGroup,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doAddUser',
+        _doAddUser
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doChangeGroup',
+        _doChangeGroup,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doChangeUser',
+        _doChangeUser,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doDelGroups',
+        _doDelGroups,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doDelUser',
+        _doDelUser,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doDelUsers',
+        _doDelUsers,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_getLocalRolesForDisplay',
+        _getLocalRolesForDisplay,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_updateGroup',
+        _updateGroup,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        'addRole',
+        addRole,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'authenticate',
+        authenticate,
+        add=True,
+        roles=(),
+    )
+    wrap_method(
+        PluggableAuthService,
+        'canListAllGroups',
+        canListAllGroups,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'canListAllUsers',
+        canListAllUsers,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'credentialsChanged',
+        credentialsChanged,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getAllLocalRoles',
+        getAllLocalRoles,
+        add=True,
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getGroup',
+        getGroup,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getGroupById',
+        getGroupById,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getGroupByName',
+        getGroupByName,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getGroupIds',
+        getGroupIds,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getGroupNames',
+        getGroupNames,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getGroups',
+        getGroups,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getLocalRolesForDisplay',
+        getLocalRolesForDisplay,
+        add=True,
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getUserIds',
+        getUserIds,
+        add=True,
+        deprecated="Inefficient GRUF wrapper, use IUserIntrospection instead."
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getUserNames',
+        getUserNames,
+        add=True,
+        deprecated="Inefficient GRUF wrapper, use IUserIntrospection instead."
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getUsers',
+        getUsers,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getPureUsers',
+        getUsers,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userFolderAddUser',
+        postonly(userFolderAddUser),
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userFolderDelUsers',
+        postonly(_doDelUsers),
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userFolderEditGroup',
+        postonly(_doChangeGroup),
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userFolderEditUser',
+        postonly(_doChangeUser),
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userFolderDelGroups',
+        postonly(_doDelGroups),
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userSetGroups',
+        _userSetGroups,
+        add=True,
+        deprecated="Method from GRUF was removed."
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userSetPassword',
+        userSetPassword,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
diff --git a/src/Products/PlonePAS/patch.py b/src/Products/PlonePAS/patch.py
new file mode 100644
index 0000000..0c95d31
--- /dev/null
+++ b/src/Products/PlonePAS/patch.py
@@ -0,0 +1,74 @@
+# -*- coding: utf-8 -*-
+import logging
+from zope.deprecation import deprecation
+
+logger = logging.getLogger('PlonePAS')
+
+PATTERN = '__PlonePAS_%s__'
+
+
+def call(self, __name__, *args, **kw):
+    return getattr(self, PATTERN % __name__)(*args, **kw)
+
+
+WRAPPER = '__PlonePAS_is_wrapper_method__'
+ADDED = '__PlonePAS_is_added_method__'
+ORIG_NAME = '__PlonePAS_original_method_name__'
+
+_marker = dict()
+
+
+def isWrapperMethod(meth):
+    return getattr(meth, WRAPPER, False)
+
+
+def wrap_method(klass, name, method,
+                pattern=PATTERN, add=False, roles=None, deprecated=False):
+    """takes a method and set it to a class. Annotates with hints what happened.
+    """
+    new_name = pattern % name
+    if not add:
+        old_method = getattr(klass, name)
+        if isWrapperMethod(old_method):
+            logger.info(
+                'PlonePAS: *NOT* wrapping already wrapped method at '
+                '{0}.{1}'.format(
+                    klass.__name__, name)
+                )
+
+            return
+        logger.info('PlonePAS: Wrapping method at %s.%s', klass.__name__, name)
+        setattr(klass, new_name, old_method)
+        setattr(method, ORIG_NAME, new_name)
+        setattr(method, WRAPPER, True)
+        setattr(method, ADDED, False)
+    else:
+        logger.info('PlonePAS: Adding method at %s.%s', klass.__name__, name)
+        setattr(method, WRAPPER, False)
+        setattr(method, ADDED, True)
+
+    if deprecated:
+        setattr(klass, name, deprecation.deprecated(method, deprecated))
+    else:
+        setattr(klass, name, method)
+
+    if roles is not None:
+        roles_attr = '{0}__roles__'.format(name)
+        logger.info(
+            'PlonePAS: Setting new permission roles at {0}.{1}'.format(
+                klass.__name__, name
+            )
+        )
+        setattr(klass, roles_attr, roles)
+
+
+def unwrap_method(klass, name):
+    # seems to be dead code, nowwhere used nor tested
+    old_method = getattr(klass, name)
+    if not isWrapperMethod(old_method):
+        raise ValueError('Trying to unwrap non-wrapped '
+                         'method at %s.%s' % (klass.__name__, name))
+    orig_name = getattr(old_method, ORIG_NAME)
+    new_method = getattr(klass, orig_name)
+    delattr(klass, orig_name)
+    setattr(klass, name, new_method)
diff --git a/src/Products/PlonePAS/permissions.py b/src/Products/PlonePAS/permissions.py
new file mode 100644
index 0000000..126932a
--- /dev/null
+++ b/src/Products/PlonePAS/permissions.py
@@ -0,0 +1,17 @@
+# -*- coding: utf-8 -*-
+from Products.CMFCore.permissions import setDefaultRoles
+
+AddGroups = 'Add Groups'
+setDefaultRoles(AddGroups, ('Manager',))
+
+ManageGroups = 'Manage Groups'
+setDefaultRoles(ManageGroups, ('Manager',))
+
+ViewGroups = 'View Groups'
+setDefaultRoles(ViewGroups, ('Manager', 'Owner', 'Member'))
+
+DeleteGroups = 'Delete Groups'
+setDefaultRoles(DeleteGroups, ('Manager', ))
+
+SetGroupOwnership = 'Set Group Ownership'
+setDefaultRoles(SetGroupOwnership, ('Manager', 'Owner'))
diff --git a/src/Products/PlonePAS/plugins/__init__.py b/src/Products/PlonePAS/plugins/__init__.py
new file mode 100644
index 0000000..40a96af
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/__init__.py
@@ -0,0 +1 @@
+# -*- coding: utf-8 -*-
diff --git a/src/Products/PlonePAS/plugins/autogroup.py b/src/Products/PlonePAS/plugins/autogroup.py
new file mode 100644
index 0000000..4b21b79
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/autogroup.py
@@ -0,0 +1,148 @@
+# -*- coding: utf-8 -*-
+from App.class_init import InitializeClass
+from Products.PageTemplates.PageTemplateFile import PageTemplateFile
+from Products.PlonePAS.interfaces.group import IGroupIntrospection
+from Products.PluggableAuthService.PropertiedUser import PropertiedUser
+from Products.PluggableAuthService.interfaces.plugins import \
+    IGroupEnumerationPlugin
+from Products.PluggableAuthService.interfaces.plugins import IGroupsPlugin
+from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
+from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from zope.interface import implementer
+
+manage_addAutoGroupForm = PageTemplateFile("../zmi/AutoGroupForm", globals())
+
+
+def manage_addAutoGroup(self, id, title='', group='', description='',
+                        RESPONSE=None):
+    """Add an Auto Group plugin."""
+
+    plugin = AutoGroup(id, title, group, description)
+    self._setObject(id, plugin)
+
+    if RESPONSE is not None:
+        return RESPONSE.redirect(
+            "%s/manage_workspace?manage_tabs_message=AutoGroup+plugin+added"
+            % self.absolute_url())
+
+
+class VirtualGroup(PropertiedUser):
+    def __init__(self, id, title='', description=''):
+        super(VirtualGroup, self).__init__(id)
+        self.id = id
+        self.title = title
+        self.description = description
+
+    def getId(self):
+        return self.id
+
+    def getUserName(self):
+        return self.id
+
+    def getName(self):
+        return self.id
+
+    def getMemberIds(self, transitive=1):
+        return []
+
+    def getRolesInContext(self, context):
+        return []
+
+    def getRoles(self):
+        return []
+
+    def allowed(self, object, object_roles=None):
+        return 0
+
+    def getDomains(self):
+        return []
+
+    def isGroup(self):
+        return True
+
+
+@implementer(
+        IGroupEnumerationPlugin,
+        IGroupsPlugin,
+        IGroupIntrospection,
+        IPropertiesPlugin
+)
+class AutoGroup(BasePlugin):
+    meta_type = "Automatic Group Plugin"
+
+    _properties = (
+        {'id': 'title',
+         'label': 'Title',
+         'type': 'string',
+         'mode': 'w'},
+        {'id': 'group',
+         'label': 'Group',
+         'type': 'string',
+         'mode': 'w'},
+        {'id': 'description',
+         'label': 'Description',
+         'type': 'string',
+         'mode': 'w'},
+    )
+
+    def __init__(self, id, title='', group=None, description=''):
+        self._setId(id)
+        self.title = title
+        self.group = group
+        self.description = description
+
+    # IGroupEnumerationPlugin implementation
+    def enumerateGroups(self, id=None, exact_match=False, sort_by=None,
+                        max_results=None, **kw):
+        if kw:
+            return []
+
+        if id:
+            id = id.lower()
+            mygroup = self.group.lower()
+
+            if exact_match and id != mygroup:
+                return []
+
+            if not exact_match and id not in mygroup:
+                return []
+
+        return [{'id': self.group,
+                 'groupid': self.group,
+                 'title': self.title,
+                 'pluginid': self.getId()}]
+
+    # IGroupsPlugin implementation
+    def getGroupsForPrincipal(self, principal, request=None):
+        if principal.getUserName() == self.group:
+            return ()
+
+        return (self.group,)
+
+    # IGroupIntrospection implementation
+    def getGroupById(self, group_id):
+        if group_id != self.group:
+            return None
+
+        return VirtualGroup(self.group, title=self.title,
+                            description=self.description)
+
+    def getGroups(self):
+        return [self.getGroupById(id) for id in self.getGroupIds()]
+
+    def getGroupIds(self):
+        return [self.group]
+
+    def getGroupMembers(self, group_id):
+        return ()
+
+    # IPropertiesPlugin:
+    def getPropertiesForUser(self, user, request=None):
+        if user == self.group:
+            return {'title': self.title,
+                    'description': self.description}
+        else:
+            return {}
+
+
+InitializeClass(AutoGroup)
diff --git a/src/Products/PlonePAS/plugins/cookie_handler.py b/src/Products/PlonePAS/plugins/cookie_handler.py
new file mode 100644
index 0000000..9c65297
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/cookie_handler.py
@@ -0,0 +1,113 @@
+# -*- coding: utf-8 -*-
+""" Class: ExtendedCookieAuthHelper
+
+Simply extends the standard CookieAuthHelper provided via regular
+PluggableAuthService but overrides the updateCookie mechanism to
+provide similar functionality as CookieCrumbler does... by giving
+the portal the ability to provide a setAuthCookie method.
+"""
+from AccessControl.SecurityInfo import ClassSecurityInfo
+from AccessControl.SecurityManagement import getSecurityManager
+from Acquisition import aq_base
+from Acquisition import aq_parent
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from Products.PluggableAuthService.interfaces.authservice import \
+    IPluggableAuthService
+from Products.PluggableAuthService.interfaces.plugins \
+    import IChallengePlugin
+from Products.PluggableAuthService.interfaces.plugins \
+    import ICredentialsResetPlugin
+from Products.PluggableAuthService.interfaces.plugins \
+    import ICredentialsUpdatePlugin
+from Products.PluggableAuthService.interfaces.plugins \
+    import ILoginPasswordHostExtractionPlugin
+from Products.PluggableAuthService.plugins.CookieAuthHelper \
+    import CookieAuthHelper as BasePlugin
+from base64 import encodestring
+from urllib import quote
+from zope.interface import implementer
+
+
+def manage_addExtendedCookieAuthHelper(self, id, title='',
+                                       RESPONSE=None, **kw):
+    """Create an instance of a extended cookie auth helper.
+    """
+
+    self = self.this()
+
+    o = ExtendedCookieAuthHelper(id, title, **kw)
+    self._setObject(o.getId(), o)
+    o = getattr(aq_base(self), id)
+
+    if RESPONSE is not None:
+        RESPONSE.redirect('manage_workspace')
+
+manage_addExtendedCookieAuthHelperForm = DTMLFile(
+    "../zmi/ExtendedCookieAuthHelperForm",
+    globals()
+)
+
+
+@implementer(
+    ILoginPasswordHostExtractionPlugin,
+    IChallengePlugin,
+    ICredentialsUpdatePlugin,
+    ICredentialsResetPlugin
+)
+class ExtendedCookieAuthHelper(BasePlugin):
+    """Multi-plugin which adds ability to override the updating of cookie via
+    a setAuthCookie method/script.
+    """
+
+    meta_type = 'Extended Cookie Auth Helper'
+    security = ClassSecurityInfo()
+
+    @security.private
+    def updateCredentials(self, request, response, login, new_password):
+        """Override standard updateCredentials method
+        """
+
+        setAuthCookie = getattr(self, 'setAuthCookie', None)
+        if setAuthCookie:
+            cookie_val = encodestring('%s:%s' % (login, new_password))
+            cookie_val = cookie_val.rstrip()
+            setAuthCookie(response, self.cookie_name, quote(cookie_val))
+        else:
+            BasePlugin.updateCredentials(self, request, response, login,
+                                         new_password)
+
+    @security.public
+    def login(self):
+        """Set a cookie and redirect to the url that we tried to
+        authenticate against originally.
+
+        Override standard login method to avoid calling
+        'return response.redirect(came_from)' as there is additional
+        processing to ignore known bad come_from templates at
+        login_next.cpy script.
+        """
+        request = self.REQUEST
+        response = request['RESPONSE']
+
+        password = request.get('__ac_password', '')
+
+        user = getSecurityManager().getUser()
+        login = user.getUserName()
+        user_pas = aq_parent(user)
+
+        if IPluggableAuthService.providedBy(user_pas):
+            # Delegate to the users own PAS if possible
+            user_pas.updateCredentials(request, response, login, password)
+        else:
+            # User does not originate from a PAS user folder, so lets try
+            # to do our own thing.
+            # XXX Perhaps we should do nothing here; test with pure User
+            # Folder!
+            pas_instance = self._getPAS()
+            if pas_instance is not None:
+                pas_instance.updateCredentials(request, response, login,
+                                               password)
+
+
+InitializeClass(ExtendedCookieAuthHelper)
diff --git a/src/Products/PlonePAS/plugins/crumbler.py b/src/Products/PlonePAS/plugins/crumbler.py
new file mode 100644
index 0000000..9838693
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/crumbler.py
@@ -0,0 +1,73 @@
+# -*- coding: utf-8 -*-
+""" Class: CookieCrumblingPlugin
+
+Acts as auth plugin, but injects cookie form credentials as HTTPBasicAuth.
+This allows form logins to fall through to parent user folders.
+
+"""
+from AccessControl.SecurityInfo import ClassSecurityInfo
+from Acquisition import aq_base
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from OFS.Folder import Folder
+from Products.CMFCore.CookieCrumbler import manage_addCC
+from Products.PluggableAuthService.interfaces.plugins import IExtractionPlugin
+from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from zope.interface import implementer
+import logging
+
+logger = logging.getLogger('PlonePAS')
+
+CC_ID = 'cookie_auth'
+
+
+def manage_addCookieCrumblingPlugin(self, id, title='',
+                                    RESPONSE=None, **kw):
+    """
+    Create an instance of a cookie crumbling plugin.
+    """
+    self = self.this()
+
+    o = CookieCrumblingPlugin(id, title, **kw)
+    self._setObject(o.getId(), o)
+    o = getattr(aq_base(self), id)
+
+    manage_addCC(o, CC_ID)
+
+    if RESPONSE is not None:
+        RESPONSE.redirect('manage_workspace')
+
+manage_addCookieCrumblingPluginForm = \
+    DTMLFile("../zmi/CookieCrumblingPluginForm", globals())
+
+
+@implementer(IExtractionPlugin)
+class CookieCrumblingPlugin(Folder, BasePlugin):
+    """Multi-plugin for injecting HTTP Basic Authentication
+    credentials from form credentials.
+    """
+    meta_type = 'Cookie Crumbling Plugin'
+
+    security = ClassSecurityInfo()
+
+    def __init__(self, id, title=None):
+        self._setId(id)
+        self.title = title
+
+    def _getCC(self):
+        return getattr(aq_base(self), CC_ID, None)
+
+    @security.private
+    def extractCredentials(self, request):
+        """ Extract basic auth credentials from 'request'.
+        """
+
+        try:
+            self._getCC().modifyRequest(request, request.RESPONSE)
+
+        except Exception, e:
+            logger.error("PlonePAS error: %s", e, exc_info=1)
+
+        return {}
+
+InitializeClass(CookieCrumblingPlugin)
diff --git a/src/Products/PlonePAS/plugins/group.py b/src/Products/PlonePAS/plugins/group.py
new file mode 100644
index 0000000..cb46c5d
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/group.py
@@ -0,0 +1,289 @@
+"""
+ZODB Group Implementation with basic introspection and
+management (ie. rw) capabilities.
+
+"""
+from AccessControl import ClassSecurityInfo
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from BTrees.OOBTree import OOBTree, OOSet
+from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
+from Products.PlonePAS.interfaces.capabilities import IGroupCapability
+from Products.PlonePAS.interfaces.group import IGroupIntrospection
+from Products.PlonePAS.interfaces.group import IGroupManagement
+from Products.PluggableAuthService.PluggableAuthService \
+    import _SWALLOWABLE_PLUGIN_EXCEPTIONS
+from Products.PluggableAuthService.interfaces.plugins \
+    import IGroupEnumerationPlugin
+from Products.PluggableAuthService.interfaces.plugins \
+    import IPropertiesPlugin
+from Products.PluggableAuthService.interfaces.plugins import IRolesPlugin
+from Products.PluggableAuthService.plugins.ZODBGroupManager \
+    import ZODBGroupManager
+from ufactory import PloneUser
+from zope.interface import implementer
+import logging
+
+manage_addGroupManagerForm = DTMLFile("../zmi/GroupManagerForm", globals())
+logger = logging.getLogger('PlonePAS')
+
+
+def manage_addGroupManager(self, id, title='', RESPONSE=None):
+    """
+    Add a zodb group manager with management and introspection
+    capabilities to pas.
+    """
+    grum = GroupManager(id, title)
+
+    self._setObject(grum.getId(), grum)
+
+    if RESPONSE is not None:
+        return RESPONSE.redirect('manage_workspace')
+
+
+@implementer(
+    IGroupManagement,
+    IGroupIntrospection,
+    IGroupCapability,
+    IDeleteCapability
+)
+class GroupManager(ZODBGroupManager):
+
+    meta_type = "Group Manager"
+    security = ClassSecurityInfo()
+
+    def __init__(self, *args, **kw):
+        ZODBGroupManager.__init__(self, *args, **kw)
+        # reverse index of groups->principal
+        self._group_principal_map = OOBTree()
+
+    #################################
+    # overrides to ease group principal lookups for introspection api
+
+    def addGroup(self, group_id, *args, **kw):
+        ZODBGroupManager.addGroup(self, group_id, *args, **kw)
+        self._group_principal_map[group_id] = OOSet()
+        return True
+
+    def removeGroup(self, group_id):
+        ZODBGroupManager.removeGroup(self, group_id)
+        del self._group_principal_map[group_id]
+        return True
+
+    def addPrincipalToGroup(self, principal_id, group_id):
+        ZODBGroupManager.addPrincipalToGroup(self, principal_id, group_id)
+        self._group_principal_map[group_id].insert(principal_id)
+        return True
+
+    def removePrincipalFromGroup(self, principal_id, group_id):
+        already = ZODBGroupManager.removePrincipalFromGroup(self, principal_id,
+                                                            group_id)
+        if already:
+            self._group_principal_map[group_id].remove(principal_id)
+        return True
+
+    #################################
+    # overrides for api matching/massage
+
+    def updateGroup(self, group_id, title=None, description=None):
+        ZODBGroupManager.updateGroup(self, group_id, title=title,
+                                     description=description)
+        return True
+
+    #################################
+    # introspection interface
+
+    def getGroupById(self, group_id, default=None):
+        plugins = self._getPAS()._getOb('plugins')
+        title = None
+        if group_id not in self.getGroupIds():
+            return default
+
+        return self._findGroup(plugins, group_id, title)
+
+    def getGroups(self):
+        return map(self.getGroupById, self.getGroupIds())
+
+    def getGroupIds(self):
+        return self.listGroupIds()
+
+    def getGroupMembers(self, group_id):
+        return tuple(self._group_principal_map.get(group_id, ()))
+
+    #################################
+    # capabilties interface impls.
+
+    @security.public
+    def allowDeletePrincipal(self, principal_id):
+        """True iff this plugin can delete a certain group.
+        This is true if this plugin manages the group.
+        """
+        if self._groups.get(principal_id) is not None:
+            return 1
+        return 0
+
+    def getGroupInfo(self, group_id):
+        """Over-ride parent to not explode when getting group info dict by
+        group id."""
+        return self._groups.get(group_id, None)
+
+    def allowGroupAdd(self, user_id, group_id):
+        """True iff this plugin will allow adding a certain user to a
+        certain group."""
+        present = self.getGroupInfo(group_id)
+        # if we have a group, we can add users to it
+        # slightly naive, but should be okay.
+        if present:
+            return 1
+
+        return 0
+
+    def allowGroupRemove(self, user_id, group_id):
+        """True iff this plugin will allow removing a certain user from a
+        certain group."""
+        present = self.getGroupInfo(group_id)
+        # if we don't have a group, we can't do anything
+        if not present:
+            return 0
+
+        group_members = self.getGroupMembers(group_id)
+        if user_id in group_members:
+            return 1
+        return 0
+
+    #################################
+    # group wrapping mechanics
+
+    @security.private
+    def _createGroup(self, plugins, group_id, name):
+        """ Create group object. For users, this can be done with a
+        plugin, but I don't care to define one for that now. Just uses
+        PloneGroup.  But, the code's still here, just commented out.
+        This method based on PluggableAuthervice._createUser
+        """
+        return PloneGroup(group_id, name).__of__(self)
+
+    @security.private
+    def _findGroup(self, plugins, group_id, title=None, request=None):
+        """ group_id -> decorated_group
+        This method based on PluggableAuthService._findGroup
+        """
+        group = self._createGroup(plugins, group_id, title)
+
+        propfinders = plugins.listPlugins(IPropertiesPlugin)
+        for propfinder_id, propfinder in propfinders:
+
+            data = propfinder.getPropertiesForUser(group, request)
+            if data:
+                group.addPropertysheet(propfinder_id, data)
+
+        groups = self._getPAS()._getGroupsForPrincipal(group, request,
+                                                       plugins=plugins)
+        group._addGroups(groups)
+
+        rolemakers = plugins.listPlugins(IRolesPlugin)
+
+        for rolemaker_id, rolemaker in rolemakers:
+            roles = rolemaker.getRolesForPrincipal(group, request)
+            if roles:
+                group._addRoles(roles)
+
+        group._addRoles(['Authenticated'])
+
+        return group.__of__(self)
+
+    @security.private
+    def _verifyGroup(self, plugins, group_id=None, title=None):
+
+        """ group_id -> boolean
+        This method based on PluggableAuthService._verifyUser
+        """
+        criteria = {}
+
+        if group_id is not None:
+            criteria['id'] = group_id
+            criteria['exact_match'] = True
+
+        if title is not None:
+            criteria['title'] = title
+
+        if criteria:
+            enumerators = plugins.listPlugins(IGroupEnumerationPlugin)
+
+            for enumerator_id, enumerator in enumerators:
+                try:
+                    info = enumerator.enumerateGroups(**criteria)
+
+                    if info:
+                        return info[0]['id']
+
+                except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+                    logger.info(
+                       'PluggableAuthService: GroupEnumerationPlugin %s error',
+                       enumerator_id, exc_info=1)
+
+        return 0
+
+
+InitializeClass(GroupManager)
+
+
+class PloneGroup(PloneUser):
+    """Plone expects a user to come, with approximately the same
+    behavior as a user.
+    """
+
+    security = ClassSecurityInfo()
+    _isGroup = True
+
+    def getId(self, unprefixed=None):
+        """ -> user ID
+        Modified to accept silly GRUF param.
+        """
+        return self._id
+
+    @security.private
+    def getMemberIds(self, transitive=1):
+        """Return member ids of this group, including or not
+        transitive groups.
+        """
+        # acquired from the groups_source
+        plugins = self._getPAS().plugins
+        introspectors = plugins.listPlugins(IGroupIntrospection)
+        members = []
+        for iid, introspector in introspectors:
+            try:
+                members.extend(
+                    list(introspector.getGroupMembers(self.getId())))
+            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+                logger.info(
+                    'PluggableAuthService: getGroupMembers %s error',
+                    iid, exc_info=1)
+
+        return members
+
+    @security.public
+    def addMember(self, id):
+        """Add the existing member with the given id to the group
+        """
+        self.addPrincipalToGroup(id, self.getId())
+
+    @security.public
+    def removeMember(self, id):
+        """Remove the member with the provided id from the group.
+        """
+        self.removePrincipalFromGroup(id, self.getId())
+
+    @security.public
+    def getRolesInContext(self, object):
+        """Since groups can't actually log in, do nothing.
+        """
+        return []
+
+    @security.public
+    def allowed(self, object, object_roles=None):
+        """Since groups can't actually log in, do nothing.
+        """
+        return 0
+
+InitializeClass(PloneGroup)
diff --git a/src/Products/PlonePAS/plugins/local_role.py b/src/Products/PlonePAS/plugins/local_role.py
new file mode 100644
index 0000000..7748ece
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/local_role.py
@@ -0,0 +1,186 @@
+"""
+A Local Roles Plugin Implementation that respects Black Listing markers.
+
+ie. containers/objects which denote that they do not wish to acquire local
+roles from their containment structure.
+
+"""
+from AccessControl import ClassSecurityInfo
+from Acquisition import aq_inner, aq_parent
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
+from Products.PluggableAuthService.plugins.LocalRolePlugin \
+    import LocalRolePlugin
+from zope.interface import implementer
+
+
+def manage_addLocalRolesManager(dispatcher, id, title=None, RESPONSE=None):
+    """
+    add a local roles manager
+    """
+    lrm = LocalRolesManager(id, title)
+    dispatcher._setObject(lrm.getId(), lrm)
+
+    if RESPONSE is not None:
+        RESPONSE.redirect('manage_workspace')
+
+manage_addLocalRolesManagerForm = \
+    DTMLFile('../zmi/LocalRolesManagerForm', globals())
+
+
+@implementer(ILocalRolesPlugin)
+class LocalRolesManager(LocalRolePlugin):
+    """Class incorporating local role storage with
+    PlonePAS-specific local role permission checking.
+    """
+
+    meta_type = "Local Roles Manager"
+    security = ClassSecurityInfo()
+
+    def __init__(self, id, title=None):
+        self._id = self.id = id
+        self.title = title
+
+    #security.declarePrivate( 'getRolesInContext' )
+    def getRolesInContext(self, user, object):
+        user_id = user.getId()
+        group_ids = user.getGroups()
+
+        principal_ids = list(group_ids)
+        principal_ids.insert(0, user_id)
+
+        local = {}
+        object = aq_inner(object)
+
+        while 1:
+            local_roles = getattr(object, '__ac_local_roles__', None)
+
+            if local_roles and callable(local_roles):
+                local_roles = local_roles()
+
+            if local_roles:
+                dict = local_roles
+
+                for principal_id in principal_ids:
+                    for role in dict.get(principal_id, []):
+                        local[role] = 1
+
+            inner = aq_inner(object)
+            parent = aq_parent(inner)
+
+            if getattr(object, '__ac_local_roles_block__', None):
+                break
+
+            if parent is not None:
+                object = parent
+                continue
+
+            new = getattr(object, 'im_self', None)
+
+            if new is not None:
+                object = aq_inner(new)
+                continue
+
+            break
+
+        return local.keys()
+
+    #security.declarePrivate( 'checkLocalRolesAllowed' )
+    def checkLocalRolesAllowed(self, user, object, object_roles):
+        # Still have not found a match, so check local roles. We do
+        # this manually rather than call getRolesInContext so that
+        # we can incur only the overhead required to find a match.
+        inner_obj = aq_inner(object)
+        user_id = user.getId()
+        group_ids = user.getGroups()
+
+        principal_ids = list(group_ids)
+        principal_ids.insert(0, user_id)
+
+        while 1:
+
+            local_roles = getattr(inner_obj, '__ac_local_roles__', None)
+
+            if local_roles and callable(local_roles):
+                local_roles = local_roles()
+
+            if local_roles:
+                dict = local_roles
+
+                for principal_id in principal_ids:
+                    local_roles = dict.get(principal_id, [])
+
+                    # local_roles is empty most of the time, where as
+                    # object_roles is usually not.
+                    if not local_roles:
+                        continue
+
+                    for role in object_roles:
+                        if role in local_roles:
+                            if user._check_context(object):
+                                return 1
+                            return 0
+
+            inner = aq_inner(inner_obj)
+            parent = aq_parent(inner)
+
+            if getattr(inner_obj, '__ac_local_roles_block__', None):
+                break
+
+            if parent is not None:
+                inner_obj = parent
+                continue
+
+            new = getattr(inner_obj, 'im_self', None)
+
+            if new is not None:
+                inner_obj = aq_inner(new)
+                continue
+
+            break
+
+        return None
+
+    def getAllLocalRolesInContext(self, context):
+        roles = {}
+        object = aq_inner(context)
+
+        while True:
+
+            local_roles = getattr(object, '__ac_local_roles__', None)
+
+            if local_roles and callable(local_roles):
+                local_roles = local_roles()
+
+            if local_roles:
+
+                dict = local_roles
+
+                for principal, localroles in dict.items():
+                    if principal not in roles:
+                        roles[principal] = set()
+
+                    roles[principal].update(localroles)
+
+            inner = aq_inner(object)
+            parent = aq_parent(inner)
+
+            if getattr(object, '__ac_local_roles_block__', None):
+                break
+
+            if parent is not None:
+                object = parent
+                continue
+
+            new = getattr(object, 'im_self', None)
+
+            if new is not None:
+                object = aq_inner(new)
+                continue
+
+            break
+
+        return roles
+
+InitializeClass(LocalRolesManager)
diff --git a/src/Products/PlonePAS/plugins/passwordpolicy.py b/src/Products/PlonePAS/plugins/passwordpolicy.py
new file mode 100644
index 0000000..b0eee47
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/passwordpolicy.py
@@ -0,0 +1,76 @@
+"""
+Password Validation plugin (IValidationPlugin)
+Mutable Property Provider
+"""
+from AccessControl import ClassSecurityInfo
+from App.class_init import InitializeClass
+from Products.PageTemplates.PageTemplateFile import PageTemplateFile
+from Products.PluggableAuthService.interfaces.plugins import IValidationPlugin
+from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from zope.i18nmessageid import MessageFactory
+from zope.interface import implementer
+
+_ = MessageFactory('plone')
+
+manage_addPasswordPolicyForm = PageTemplateFile(
+    "../zmi/PasswordPolicyForm",
+    globals()
+)
+
+
+def manage_addPasswordPolicyPlugin(self, id, title='',
+                                   RESPONSE=None, schema=None, **kw):
+    """
+    Create an instance of a password validation plugin.
+    """
+    o = PasswordPolicyPlugin(id, title)
+    self._setObject(o.getId(), o)
+
+    if RESPONSE is not None:
+        return RESPONSE.redirect(
+            "%s/manage_workspace?"
+            "manage_tabs_message=DefaultPasswordPlugin+plugin+added" %
+            self.absolute_url()
+        )
+
+
+@implementer(IValidationPlugin)
+class PasswordPolicyPlugin(BasePlugin):
+    """Simple Password Policy to ensure password is 5 chars long.
+    """
+
+    meta_type = 'Default Plone Password Policy'
+
+    security = ClassSecurityInfo()
+
+    def __init__(self, id, title=''):
+        """Create a default plone password policy to ensure 5 char passwords
+        """
+        self.id = id
+        self.title = title
+
+    @security.private
+    def validateUserInfo(self, user, set_id, set_info):
+        """ See IValidationPlugin. Used to validate password property
+        """
+
+        if not set_info:
+            return []
+        password = set_info.get('password', None)
+        if password is None:
+            return []
+        elif password == '':
+            return [{'id': 'password', 'error': _(u'Minimum 5 characters.')}]
+        elif len(password) < 5:
+            return [
+                {
+                    'id': 'password',
+                    'error': _(
+                        u'Your password must contain at least 5 characters.'
+                    )
+                }
+            ]
+        else:
+            return []
+
+InitializeClass(PasswordPolicyPlugin)
diff --git a/src/Products/PlonePAS/plugins/property.py b/src/Products/PlonePAS/plugins/property.py
new file mode 100644
index 0000000..3d6cb6b
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/property.py
@@ -0,0 +1,292 @@
+# -*- coding: utf-8 -*-
+"""
+Mutable Property Provider
+"""
+from AccessControl import ClassSecurityInfo
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from BTrees.OOBTree import OOBTree
+from Products.CMFCore.utils import getToolByName
+from Products.PlonePAS.interfaces.plugins import IMutablePropertiesPlugin
+from Products.PlonePAS.sheet import MutablePropertySheet, validateValue
+from Products.PlonePAS.utils import safe_unicode
+from Products.PluggableAuthService.UserPropertySheet import _guessSchema
+from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
+from Products.PluggableAuthService.interfaces.plugins \
+    import IUserEnumerationPlugin
+from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from ZODB.PersistentMapping import PersistentMapping
+from zope.i18nmessageid import MessageFactory
+from zope.interface import implementer
+import copy
+
+_ = MessageFactory('plone')
+
+
+def manage_addZODBMutablePropertyProvider(self, id, title='',
+                                          RESPONSE=None, schema=None, **kw):
+    """
+    Create an instance of a mutable property manager.
+    """
+    o = ZODBMutablePropertyProvider(id, title, schema, **kw)
+    self._setObject(o.getId(), o)
+
+    if RESPONSE is not None:
+        RESPONSE.redirect('manage_workspace')
+
+manage_addZODBMutablePropertyProviderForm = DTMLFile(
+    "../zmi/MutablePropertyProviderForm", globals())
+
+
+def isStringType(data):
+    return isinstance(data, str) or isinstance(data, unicode)
+
+
+@implementer(
+    IPropertiesPlugin,
+    IUserEnumerationPlugin,
+    IMutablePropertiesPlugin
+)
+class ZODBMutablePropertyProvider(BasePlugin):
+    """Storage for mutable properties in the ZODB for users/groups.
+
+    API sounds like it's only for users, but groups work as well.
+    """
+
+    meta_type = 'ZODB Mutable Property Provider'
+
+    security = ClassSecurityInfo()
+
+    def __init__(self, id, title='', schema=None, **kw):
+        """Create in-ZODB mutable property provider.
+
+        Provide a schema either as a list of (name,type,value) tuples
+        in the 'schema' parameter or as a series of keyword parameters
+        'name=value'. Types will be guessed in this case.
+
+        The 'value' is meant as the default value, and will be used
+        unless the user provides data.
+
+        If no schema is provided by constructor, the properties of the
+        portal_memberdata object will be used.
+
+        Types available: string, text, boolean, int, long, float, lines, date
+        """
+        self.id = id
+        self.title = title
+        self._storage = OOBTree()
+
+        # calculate schema and default values
+        defaultvalues = {}
+        if not schema and not kw:
+            schema = ()
+        elif not schema and kw:
+            schema = _guessSchema(kw)
+            defaultvalues = kw
+        else:
+            valuetuples = [(name, value) for name, type, value in schema]
+            schema = [(name, type) for name, type, value in schema]
+            for name, value in valuetuples:
+                defaultvalues[name] = value
+        self._schema = tuple(schema)
+        self._defaultvalues = defaultvalues
+
+    def _getSchema(self, isgroup=None):
+        # this could probably stand to be cached
+        datatool = isgroup and "portal_groupdata" or "portal_memberdata"
+
+        schema = self._schema
+        if not schema:
+            # if no schema is provided, use portal_memberdata properties
+            schema = ()
+            mdtool = getToolByName(self, datatool, None)
+            # Don't fail badly if tool is not available.
+            if mdtool is not None:
+                mdschema = mdtool.propertyMap()
+                schema = [(elt['id'], elt['type']) for elt in mdschema]
+        return schema
+
+    def _getDefaultValues(self, isgroup=None):
+        """Returns a dictionary mapping of property names to default values.
+        Defaults to portal_*data tool if necessary.
+        """
+        datatool = isgroup and "portal_groupdata" or "portal_memberdata"
+
+        defaultvalues = self._defaultvalues
+        if not self._schema:
+            # if no schema is provided, use portal_*data properties
+            defaultvalues = {}
+            mdtool = getToolByName(self, datatool, None)
+            # Don't fail badly if tool is not available.
+            if mdtool is not None:
+                # we rely on propertyMap and propertyItems mapping
+                mdvalues = mdtool.propertyItems()
+                for name, value in mdvalues:
+                    # For selection types the default value is the name of a
+                    # method which returns the possible values. There is no way
+                    # to set a default value for those types.
+                    ptype = mdtool.getPropertyType(name)
+                    if ptype == "selection":
+                        defaultvalues[name] = ""
+                    elif ptype == "multiple selection":
+                        defaultvalues[name] = []
+                    else:
+                        defaultvalues[name] = value
+
+            # ALERT! if someone gives their *_data tool a title, and want a
+            #        title as a property of the user/group (and groups do by
+            #        default) we don't want them all to have this title, since
+            #        a title is used in the UI if it exists
+            if defaultvalues.get("title"):
+                defaultvalues["title"] = ""
+        return defaultvalues
+
+    @security.private
+    def getPropertiesForUser(self, user, request=None):
+        """Get property values for a user or group.
+        Returns a dictionary of values or a PropertySheet.
+
+        This implementation will always return a MutablePropertySheet.
+
+        NOTE: Must always return something, or else the property sheet
+        won't get created and this will screw up portal_memberdata.
+        """
+        isGroup = getattr(user, 'isGroup', lambda: None)()
+
+        data = self._storage.get(user.getId())
+        defaults = self._getDefaultValues(isGroup)
+
+        # provide default values where missing
+        if not data:
+            data = {}
+        for key, val in defaults.items():
+            if key not in data:
+                data[key] = val
+
+        return MutablePropertySheet(self.id,
+                                    schema=self._getSchema(isGroup), **data)
+
+    @security.private
+    def setPropertiesForUser(self, user, propertysheet):
+        """Set the properties of a user or group based on the contents of a
+        property sheet.
+        """
+        isGroup = getattr(user, 'isGroup', lambda: None)()
+
+        properties = dict(propertysheet.propertyItems())
+
+        for name, property_type in self._getSchema(isGroup) or ():
+            if (
+                name in properties and not
+                validateValue(property_type, properties[name])
+            ):
+                raise ValueError(
+                    'Invalid value: %s does not conform to %s' %
+                    (name, property_type)
+                )
+
+        allowed_prop_keys = [pn for pn, pt in self._getSchema(isGroup) or ()]
+        if allowed_prop_keys:
+            prop_names = set(properties.keys()) - set(allowed_prop_keys)
+            if prop_names:
+                raise ValueError('Unknown Properties: %r' % prop_names)
+
+        userid = user.getId()
+        userprops = self._storage.get(userid)
+        properties.update({'isGroup': isGroup})
+        if userprops is not None:
+            userprops.update(properties)
+            # notify persistence machinery of change
+            self._storage[userid] = self._storage[userid]
+        else:
+            self._storage.insert(user.getId(), properties)
+
+    @security.private
+    def deleteUser(self, user_id):
+        """Delete all user properties
+        """
+        # Do nothing if an unknown user_id is given
+        try:
+            del self._storage[user_id]
+        except KeyError:
+            pass
+
+    @security.private
+    def testMemberData(self, memberdata, criteria, exact_match=False):
+        """Test if a memberdata matches the search criteria.
+        """
+        for (key, value) in criteria.items():
+            testvalue = memberdata.get(key, None)
+            if testvalue is None:
+                return False
+
+            if isStringType(testvalue):
+                testvalue = safe_unicode(testvalue.lower())
+            if isStringType(value):
+                value = safe_unicode(value.lower())
+
+            if exact_match:
+                if value != testvalue:
+                    return False
+            else:
+                try:
+                    if value not in testvalue:
+                        return False
+                except TypeError:
+                    # Fall back to exact match if we can check for
+                    # sub-component
+                    if value != testvalue:
+                        return False
+
+        return True
+
+    @security.private
+    def enumerateUsers(self, id=None, login=None,
+                       exact_match=False, **kw):
+        """ See IUserEnumerationPlugin.
+        """
+        plugin_id = self.getId()
+
+        # This plugin can't search for a user by id or login, because there is
+        # no such keys in the storage (data dict in the comprehensive list)
+        # If kw is empty or not, we continue the search.
+        if id is not None or login is not None:
+            return ()
+
+        criteria = copy.copy(kw)
+
+        users = [(user, data) for (user, data) in self._storage.items()
+                 if self.testMemberData(data, criteria, exact_match)
+                 and not data.get('isGroup', False)]
+
+        user_info = [{'id': self.prefix + user_id,
+                      'login': user_id,
+                      'title': data.get('fullname', user_id),
+                      'description': data.get('fullname', user_id),
+                      'email': data.get('email', ''),
+                      'pluginid': plugin_id} for (user_id, data) in users]
+
+        return tuple(user_info)
+
+    def updateUser(self, user_id, login_name):
+        """ Update the login name of the user with id user_id.
+
+        This is a new part of the IUserEnumerationPlugin interface, but
+        not interesting for us.
+        """
+        pass
+
+    def updateEveryLoginName(self, quit_on_first_error=True):
+        """Update login names of all users to their canonical value.
+
+        This is a new part of the IUserEnumerationPlugin interface, but
+        not interesting for us.
+        """
+        pass
+
+
+InitializeClass(ZODBMutablePropertyProvider)
+
+
+class PersistentProperties(PersistentMapping):
+    pass
diff --git a/src/Products/PlonePAS/plugins/role.py b/src/Products/PlonePAS/plugins/role.py
new file mode 100644
index 0000000..5684ed3
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/role.py
@@ -0,0 +1,161 @@
+# -*- coding: utf-8 -*-
+"""
+group aware role manager, returns roles assigned to group a principal
+is a member of, in addition to the explicit roles assigned directly
+to the principal.
+
+"""
+from AccessControl import ClassSecurityInfo
+from AccessControl.requestmethod import postonly
+from Acquisition import aq_parent
+from Acquisition import aq_inner
+from Acquisition import aq_get
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from Products.PlonePAS.interfaces.capabilities import IAssignRoleCapability
+from Products.PlonePAS.utils import getGroupsForPrincipal
+from Products.PluggableAuthService.permissions import ManageUsers
+from Products.PluggableAuthService.plugins.ZODBRoleManager \
+    import ZODBRoleManager
+from zope.interface import implementer
+
+
+def manage_addGroupAwareRoleManager(self, id, title='', RESPONSE=None):
+    """
+    this is a doc string
+    """
+    garm = GroupAwareRoleManager(id, title)
+    self._setObject(garm.getId(), garm)
+
+    if RESPONSE is not None:
+        RESPONSE.redirect('manage_workspace')
+
+manage_addGroupAwareRoleManagerForm = DTMLFile(
+    '../zmi/GroupAwareRoleManagerForm', globals())
+
+
+@implementer(IAssignRoleCapability)
+class GroupAwareRoleManager(ZODBRoleManager):
+
+    meta_type = "Group Aware Role Manager"
+    security = ClassSecurityInfo()
+
+    def updateRolesList(self):
+        role_holder = aq_parent(aq_inner(self._getPAS()))
+        for role in getattr(role_holder, '__ac_roles__', ()):
+            if role not in ('Anonymous', 'Authenticated') and \
+                    role not in self._roles:
+                try:
+                    self.addRole(role)
+                except KeyError:
+                    pass
+
+    # don't blow up if manager already exists; mostly for ZopeVersionControl
+    def manage_afterAdd(self, item, container):
+        try:
+            self.addRole('Manager')
+        except KeyError:
+            pass
+
+        if item is self:
+            self.updateRolesList()
+
+    @security.protected(ManageUsers)
+    def assignRoleToPrincipal(self, role_id, principal_id, REQUEST=None):
+        try:
+            return ZODBRoleManager.assignRoleToPrincipal(
+                                        self, role_id, principal_id)
+        except KeyError:
+            # Lazily update our roles list and try again
+            self.updateRolesList()
+            return ZODBRoleManager.assignRoleToPrincipal(
+                                        self, role_id, principal_id)
+
+    @security.protected(ManageUsers)
+    def assignRolesToPrincipal(self, roles, principal_id, REQUEST=None):
+        """ Assign a specific set of roles, and only those roles, to a
+        principal.
+
+        o no return value
+
+        o Raise KeyError if a role_id is unknown.
+        """
+        for role_id in roles:
+            if role_id not in ('Authenticated', 'Anonymous', 'Owner'):
+                try:
+                    # raise KeyError if unknown!
+                    self._roles[role_id]
+                except KeyError:
+                    # Lazily update our roles list and try again
+                    self.updateRolesList()
+                    if role_id in self._roles:
+                        # check if this role is managed by this plugin, and
+                        # set it
+                        self._roles[role_id]
+
+        self._principal_roles[principal_id] = tuple(roles)
+
+    assignRolesToPrincipal = postonly(assignRolesToPrincipal)
+
+    @security.private
+    def getRolesForPrincipal(self, principal, request=None):
+        """ See IRolesPlugin.
+        """
+        roles = set([])
+        principal_ids = set([])
+        # Some services need to determine the roles obtained from groups
+        # while excluding the directly assigned roles.  In this case
+        # '__ignore_direct_roles__' = True should be pushed in the request.
+        request = aq_get(self, 'REQUEST', None)
+        if request is None \
+           or not request.get('__ignore_direct_roles__', False):
+            principal_ids.add(principal.getId())
+
+        # Some services may need the real roles of an user but **not**
+        # the ones he got through his groups. In this case, the
+        # '__ignore_group_roles__'= True should be previously pushed
+        # in the request.
+        plugins = self._getPAS()['plugins']
+        if request is None \
+           or not request.get('__ignore_group_roles__', False):
+            principal_ids.update(
+                getGroupsForPrincipal(principal, plugins, request)
+            )
+        for pid in principal_ids:
+            roles.update(self._principal_roles.get(pid, ()))
+        return tuple(roles)
+
+    # implement IAssignRoleCapability
+
+    def allowRoleAssign(self, user_id, role_id):
+        """True iff this plugin will allow assigning a certain user a
+        certain role.
+
+        Note that at least currently this only checks if the role_id
+        exists.  If it exists, this method returns True.  Nothing is
+        done with the user_id parameter.  This might be wrong.  See
+        http://dev.plone.org/plone/ticket/7762
+        """
+        present = self.getRoleInfo(role_id)
+        if present:
+            # if we have a role, we can assign it
+            # slightly naive, but should be okay.
+            return 1
+
+        return 0
+
+    def listRoleIds(self):
+        self.updateRolesList()
+        return ZODBRoleManager.listRoleIds(self)
+
+    def listRoleInfo(self):
+        self.updateRolesList()
+        return ZODBRoleManager.listRoleInfo(self)
+
+    def getRoleInfo(self, role_id):
+        if role_id not in self._roles:
+            self.updateRolesList()
+        return ZODBRoleManager.getRoleInfo(self, role_id)
+
+
+InitializeClass(GroupAwareRoleManager)
diff --git a/src/Products/PlonePAS/plugins/ufactory.py b/src/Products/PlonePAS/plugins/ufactory.py
new file mode 100644
index 0000000..db24491
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/ufactory.py
@@ -0,0 +1,235 @@
+# -*- coding: utf-8 -*-
+from AccessControl import ClassSecurityInfo
+from AccessControl.PermissionRole import _what_not_even_god_should_do
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
+from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
+from Products.PluggableAuthService.PropertiedUser import PropertiedUser
+from Products.PluggableAuthService.UserPropertySheet import UserPropertySheet
+from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
+from Products.PluggableAuthService.interfaces.plugins import IUserFactoryPlugin
+from Products.PluggableAuthService.interfaces.propertysheets \
+    import IPropertySheet
+from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from collections import OrderedDict
+from zope.interface import implementer
+
+manage_addPloneUserFactoryForm = DTMLFile('../zmi/PloneUserFactoryForm',
+                                          globals())
+
+_marker = object()
+
+
+def manage_addPloneUserFactory(self, id, title='', RESPONSE=None):
+    """
+    Add a plone user factory
+    """
+
+    puf = PloneUserFactory(id, title)
+    self._setObject(puf.getId(), puf)
+
+    if RESPONSE is not None:
+        return RESPONSE.redirect('manage_workspace')
+
+
+@implementer(IUserFactoryPlugin)
+class PloneUserFactory(BasePlugin):
+
+    security = ClassSecurityInfo()
+    meta_type = 'Plone User Factory'
+
+    def __init__(self, id, title=''):
+        self.id = id
+        self.title = title or self.meta_type
+
+    @security.private
+    def createUser(self, user_id, name):
+        return PloneUser(user_id, name)
+
+
+InitializeClass(PloneUserFactory)
+
+
+class PloneUser(PropertiedUser):
+
+    security = ClassSecurityInfo()
+
+    #################################
+    # GRUF API
+    _isGroup = False
+
+    def __init__(self, id, login=None):
+        super(PloneUser, self).__init__(id, login)
+        self._propertysheets = OrderedDict()
+
+    def _getPAS(self):
+        # XXX This is not very optimal *at all*
+        return self.acl_users
+
+    def _getPlugins(self):
+        # XXX This is not very optimal *at all*
+        return self._getPAS().plugins
+
+    @security.public
+    def isGroup(self):
+        """Return 1 if this user is a group abstraction"""
+        return self._isGroup
+
+    @security.public
+    def getName(self):
+        """Get user's or group's name.
+        This is the id. PAS doesn't do prefixes and such like GRUF.
+        """
+        return self.getId()
+
+    @security.public
+    def getUserId(self):
+        """Get user's or group's name.
+        This is the id. PAS doesn't do prefixes and such like GRUF.
+        """
+        return self.getId()
+
+    @security.public
+    def getGroupNames(self):
+        """Return ids of this user's groups. GRUF compat."""
+        return self.getGroups()
+
+    security.declarePublic('getGroupIds')
+    getGroupIds = getGroupNames
+
+    #################################
+    # acquisition aware
+
+    @security.public
+    def getPropertysheet(self, id):
+        """ -> propertysheet (wrapped if supported)
+        """
+        sheet = self._propertysheets[id]
+        try:
+            return sheet.__of__(self)
+        except AttributeError:
+            return sheet
+
+    @security.private
+    def addPropertysheet(self, id, data):
+        """ -> add a prop sheet, given data which is either
+        a property sheet or a raw mapping.
+        """
+        if IPropertySheet.providedBy(data):
+            sheet = data
+        else:
+            sheet = UserPropertySheet(id, **data)
+
+        if self._propertysheets.get(id) is not None:
+            raise KeyError('Duplicate property sheet: %s' % id)
+
+        self._propertysheets[id] = sheet
+
+    def _getPropertyPlugins(self):
+        return self._getPAS().plugins.listPlugins(IPropertiesPlugin)
+
+    @security.private
+    def getOrderedPropertySheets(self):
+        return self._propertysheets.values()
+
+    #################################
+    # local roles plugin type delegation
+
+    def _getLocalRolesPlugins(self):
+        return self._getPAS().plugins.listPlugins(ILocalRolesPlugin)
+
+    def getRolesInContext(self, object):
+        lrmanagers = self._getLocalRolesPlugins()
+        roles = set([])
+        for lrid, lrmanager in lrmanagers:
+            roles.update(lrmanager.getRolesInContext(self, object))
+        roles.update(self.getRoles())
+        return list(roles)
+
+    def allowed(self, object, object_roles=None):
+        if object_roles is _what_not_even_god_should_do:
+            return 0
+
+        # Short-circuit the common case of anonymous access.
+        if object_roles is None or 'Anonymous' in object_roles:
+            return 1
+
+        # Provide short-cut access if object is protected by 'Authenticated'
+        # role and user is not nobody
+        if 'Authenticated' in object_roles \
+           and self.getUserName() != 'Anonymous User':
+            return 1
+
+        # Check for ancient role data up front, convert if found.
+        # This should almost never happen, and should probably be
+        # deprecated at some point.
+        if 'Shared' in object_roles:
+            object_roles = self._shared_roles(object)
+            if object_roles is None or 'Anonymous' in object_roles:
+                return 1
+
+        # Check for a role match with the normal roles given to
+        # the user, then with local roles only if necessary. We
+        # want to avoid as much overhead as possible.
+        user_roles = self.getRoles()
+        for role in object_roles:
+            if role in user_roles:
+                if self._check_context(object):
+                    return 1
+                return None
+
+        # check for local roles
+        lrmanagers = self._getLocalRolesPlugins()
+
+        for lrid, lrm in lrmanagers:
+            allowed = lrm.checkLocalRolesAllowed(self, object, object_roles)
+            # return values
+            # 0, 1, None
+            # - 1 success
+            # - 0 object context violation
+            # - None - failure
+            if allowed is None:
+                continue
+            return allowed
+        return None
+
+    def setProperties(self, properties=None, **kw):
+        """ Set properties on a given user.
+
+        Accepts either keyword arguments or a mapping for the ``properties``
+        argument. The ``properties`` argument will take precedence over
+        keyword arguments if both are provided; no merging will occur.
+        """
+        if properties is None:
+            properties = kw
+
+        for sheet in self.getOrderedPropertySheets():
+            if not IMutablePropertySheet.providedBy(sheet):
+                continue
+
+            update = {}
+            for (key, value) in properties.items():
+                if sheet.hasProperty(key):
+                    update[key] = value
+                    del properties[key]
+
+            if update:
+                sheet.setProperties(self, update)
+
+    def getProperty(self, id, default=_marker):
+        for sheet in self.getOrderedPropertySheets():
+            if sheet.hasProperty(id):
+                value = sheet.getProperty(id)
+                if isinstance(value, unicode):
+                    # XXX Temporarily work around the fact that
+                    # property sheets blindly store and return
+                    # unicode. This is sub-optimal and should be
+                    # dealed with at the property sheets level by
+                    # using Zope's converters.
+                    return value.encode('utf-8')
+                return value
+
+        return default
+
+InitializeClass(PloneUser)
diff --git a/src/Products/PlonePAS/plugins/user.py b/src/Products/PlonePAS/plugins/user.py
new file mode 100644
index 0000000..79ee8f0
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/user.py
@@ -0,0 +1,132 @@
+# -*- coding: utf-8 -*-
+"""
+ZODB based user manager with introspection and management interfaces.
+"""
+from AccessControl import AuthEncoding
+from AccessControl import ClassSecurityInfo
+from AccessControl.Permissions import manage_users as ManageUsers
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
+from Products.PlonePAS.interfaces.capabilities import IPasswordSetCapability
+from Products.PlonePAS.interfaces.plugins import IUserIntrospection
+from Products.PlonePAS.interfaces.plugins import IUserManagement
+from Products.PluggableAuthService.plugins.ZODBUserManager \
+    import ZODBUserManager as BasePlugin
+from Products.PluggableAuthService.utils import createViewName
+from zope.interface import implementer
+
+manage_addUserManagerForm = DTMLFile('../zmi/UserManagerForm', globals())
+
+
+def manage_addUserManager(dispatcher, id, title=None, REQUEST=None):
+    """ Add a UserManager to a Pluggable Auth Service. """
+
+    pum = UserManager(id, title)
+    dispatcher._setObject(pum.getId(), pum)
+
+    if REQUEST is not None:
+        REQUEST['RESPONSE'].redirect(
+            '%s/manage_workspace'
+            '?manage_tabs_message='
+            'UserManager+added.'
+            % dispatcher.absolute_url())
+
+
+@implementer(
+    IUserManagement,
+    IUserIntrospection,
+    IDeleteCapability,
+    IPasswordSetCapability
+)
+class UserManager(BasePlugin):
+    """PAS plugin for managing users. (adds write API)
+    """
+
+    meta_type = 'User Manager'
+    security = ClassSecurityInfo()
+
+    @security.protected(ManageUsers)
+    def addUser(self, user_id, login_name, password):
+        """Original ZODBUserManager.addUser, modified to check if
+        incoming password is already encypted.
+
+        This support clean migration from default user source.
+        Should go into PAS.
+        """
+        if self._user_passwords.get(user_id) is not None:
+            raise KeyError('Duplicate user ID: %s' % user_id)
+
+        if self._login_to_userid.get(login_name) is not None:
+            raise KeyError('Duplicate login name: %s' % login_name)
+
+        if not AuthEncoding.is_encrypted(password):
+            password = AuthEncoding.pw_encrypt(password)
+        self._user_passwords[user_id] = password
+        self._login_to_userid[login_name] = user_id
+        self._userid_to_login[user_id] = login_name
+
+        # enumerateUsers return value has changed
+        view_name = createViewName('enumerateUsers')
+        self.ZCacheable_invalidate(view_name=view_name)
+
+    # User Management interface
+
+    @security.private
+    def doDeleteUser(self, userid):
+        """Given a user id, delete that user
+        """
+        return self.removeUser(userid)
+
+    @security.private
+    def doChangeUser(self, principal_id, password):
+        """Change a user's password
+        """
+        if self._user_passwords.get(principal_id) is None:
+            raise RuntimeError("User does not exist: %s" % principal_id)
+        self._user_passwords[principal_id] = AuthEncoding.pw_encrypt(password)
+
+    # implement interfaces IDeleteCapability, IPasswordSetCapability
+
+    @security.public
+    def allowDeletePrincipal(self, principal_id):
+        """True iff this plugin can delete a certain user/group.
+        This is true if this plugin manages the user.
+        """
+        if self._user_passwords.get(principal_id) is not None:
+            return 1
+        return 0
+
+    @security.public
+    def allowPasswordSet(self, principal_id):
+        """True iff this plugin can set the password a certain user.
+        This is true if this plugin manages the user.
+        """
+        return self.allowDeletePrincipal(principal_id)
+
+    # User Introspection interface
+
+    @security.protected(ManageUsers)
+    def getUserIds(self):
+        """
+        Return a list of user ids
+        """
+        return self.listUserIds()
+
+    @security.protected(ManageUsers)
+    def getUserNames(self):
+        """
+        Return a list of usernames
+        """
+        return [x['login_name'] for x in self.listUserInfo()]
+
+    @security.protected(ManageUsers)
+    def getUsers(self):
+        """
+        Return a list of users
+        """
+        uf = self.acl_users
+        return [uf.getUserById(x) for x in self.getUserIds()]
+
+
+InitializeClass(UserManager)
diff --git a/src/Products/PlonePAS/profiles.zcml b/src/Products/PlonePAS/profiles.zcml
new file mode 100644
index 0000000..8410395
--- /dev/null
+++ b/src/Products/PlonePAS/profiles.zcml
@@ -0,0 +1,14 @@
+<configure
+    xmlns="http://namespaces.zope.org/zope"
+    xmlns:genericsetup="http://namespaces.zope.org/genericsetup"
+    i18n_domain="plonepas">
+
+  <genericsetup:registerProfile
+      name="PlonePAS"
+      title="PlonePAS"
+      directory="profiles/default"
+      description="Extension profile for default PlonePAS setup."
+      provides="Products.GenericSetup.interfaces.EXTENSION"
+      />
+
+</configure>
diff --git a/src/Products/PlonePAS/profiles/default/metadata.xml b/src/Products/PlonePAS/profiles/default/metadata.xml
new file mode 100644
index 0000000..dab4dc0
--- /dev/null
+++ b/src/Products/PlonePAS/profiles/default/metadata.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0"?>
+<metadata>
+  <version>4</version>
+</metadata>
diff --git a/src/Products/PlonePAS/profiles/default/plone-pas.txt b/src/Products/PlonePAS/profiles/default/plone-pas.txt
new file mode 100644
index 0000000..9b080f9
--- /dev/null
+++ b/src/Products/PlonePAS/profiles/default/plone-pas.txt
@@ -0,0 +1 @@
+The plone-pas step is run if this file is present in the profile
diff --git a/src/Products/PlonePAS/setuphandlers.py b/src/Products/PlonePAS/setuphandlers.py
new file mode 100644
index 0000000..4e3637f
--- /dev/null
+++ b/src/Products/PlonePAS/setuphandlers.py
@@ -0,0 +1,496 @@
+# -*- coding: utf-8 -*-
+from Acquisition import aq_parent
+from Products.CMFCore.utils import getToolByName
+from Products.PlonePAS import config
+from Products.PlonePAS.interfaces import group as igroup
+from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
+from Products.PlonePAS.interfaces.plugins import IUserIntrospection
+from Products.PlonePAS.interfaces.plugins import IUserManagement
+from Products.PluggableAuthService.Extensions.upgrade import replace_acl_users
+from Products.PluggableAuthService.interfaces.authservice \
+    import IPluggableAuthService
+from Products.PluggableAuthService.interfaces.plugins import IChallengePlugin
+from Products.PluggableAuthService.interfaces.plugins \
+    import ICredentialsResetPlugin
+from Products.PluggableAuthService.plugins.RecursiveGroupsPlugin \
+    import addRecursiveGroupsPlugin
+from plone.session.plugins.session import manage_addSessionPlugin
+import logging
+
+logger = logging.getLogger('PlonePAS setup')
+
+
+def activatePluginInterfaces(portal, plugin, disable=None):
+    if disable is None:
+        disable = []
+    pas = portal.acl_users
+    plugin_obj = pas[plugin]
+
+    activatable = []
+
+    for info in plugin_obj.plugins.listPluginTypeInfo():
+        interface = info['interface']
+        interface_name = info['id']
+        if plugin_obj.testImplements(interface):
+            if interface_name in disable:
+                disable.append(interface_name)
+                logger.debug("Disabling: " + info['title'])
+            else:
+                activatable.append(interface_name)
+                logger.debug("Activating: " + info['title'])
+    plugin_obj.manage_activateInterfaces(activatable)
+    logger.debug(plugin + " activated.")
+
+
+def setupRoles(portal):
+    rmanager = portal.acl_users.role_manager
+    rmanager.addRole('Member', title="Portal Member")
+    rmanager.addRole('Reviewer', title="Content Reviewer")
+
+
+def registerPluginType(pas, plugin_type, plugin_info):
+    # Make sure there's no dupes in _plugin_types, otherwise your PAS
+    # will *CRAWL*
+    plugin_types = list(set(pas.plugins._plugin_types))
+    if plugin_type not in plugin_types:
+        plugin_types.append(plugin_type)
+
+    # Order doesn't seem to matter, but let's store it ordered.
+    plugin_types.sort()
+
+    # Re-assign to the object, because this is a non-persistent list.
+    pas.plugins._plugin_types = plugin_types
+
+    # It's safe to assign over a existing key here.
+    pas.plugins._plugin_type_info[plugin_type] = plugin_info
+
+
+def registerPluginTypes(pas):
+
+    PluginInfo = {
+        'id': 'IUserManagement',
+        'title': 'user_management',
+        'description': ("The User Management plugins allow the "
+                        "Pluggable Auth Service to add/delete/modify users")
+        }
+
+    registerPluginType(pas, IUserManagement, PluginInfo)
+
+    PluginInfo = {
+        'id': 'IUserIntrospection',
+        'title': 'user_introspection',
+        'description': ("The User Introspection plugins allow the "
+                        "Pluggable Auth Service to provide lists of users")
+        }
+
+    registerPluginType(pas, IUserIntrospection, PluginInfo)
+
+    PluginInfo = {
+        'id': 'IGroupManagement',
+        'title': 'group_management',
+        'description': ("Group Management provides add/write/deletion "
+                        "of groups and member management")
+        }
+
+    registerPluginType(pas, igroup.IGroupManagement, PluginInfo)
+
+    PluginInfo = {
+        'id': 'IGroupIntrospection',
+        'title': 'group_introspection',
+        'description': ("Group Introspection provides listings "
+                        "of groups and membership")
+        }
+
+    registerPluginType(pas, igroup.IGroupIntrospection, PluginInfo)
+
+    PluginInfo = {
+        'id': 'ILocalRolesPlugin',
+        'title': 'local_roles',
+        'description': "Defines Policy for getting Local Roles"
+        }
+
+    registerPluginType(pas, ILocalRolesPlugin, PluginInfo)
+
+
+def setupPlugins(portal):
+    uf = portal.acl_users
+    logger.debug("\nPlugin setup")
+
+    pas = uf.manage_addProduct['PluggableAuthService']
+    plone_pas = uf.manage_addProduct['PlonePAS']
+
+    setupAuthPlugins(portal, pas, plone_pas)
+
+    found = uf.objectIds(['User Manager'])
+    if not found:
+        plone_pas.manage_addUserManager('source_users')
+        logger.debug("Added User Manager.")
+    activatePluginInterfaces(portal, 'source_users')
+
+    found = uf.objectIds(['Group Aware Role Manager'])
+    if not found:
+        plone_pas.manage_addGroupAwareRoleManager('portal_role_manager')
+        logger.debug("Added Group Aware Role Manager.")
+        activatePluginInterfaces(portal, 'portal_role_manager')
+
+    found = uf.objectIds(['Local Roles Manager'])
+    if not found:
+        plone_pas.manage_addLocalRolesManager('local_roles')
+        logger.debug("Added Group Aware Role Manager.")
+        activatePluginInterfaces(portal, 'local_roles')
+
+    found = uf.objectIds(['Group Manager'])
+    if not found:
+        plone_pas.manage_addGroupManager('source_groups')
+        logger.debug("Added ZODB Group Manager.")
+        activatePluginInterfaces(portal, 'source_groups')
+
+    found = uf.objectIds(['Plone User Factory'])
+    if not found:
+        plone_pas.manage_addPloneUserFactory('user_factory')
+        logger.debug("Added Plone User Factory.")
+        activatePluginInterfaces(portal, "user_factory")
+
+    found = uf.objectIds(['ZODB Mutable Property Provider'])
+    if not found:
+        plone_pas.manage_addZODBMutablePropertyProvider('mutable_properties')
+        logger.debug("Added Mutable Property Manager.")
+        activatePluginInterfaces(portal, "mutable_properties")
+
+    found = uf.objectIds(['Automatic Group Plugin'])
+    if not found:
+        plone_pas.manage_addAutoGroup(
+                "auto_group", "Authenticated Users (Virtual Group)",
+                "AuthenticatedUsers", "Automatic Group Provider")
+        logger.debug("Added Automatic Group.")
+        activatePluginInterfaces(portal, "auto_group")
+
+    found = uf.objectIds(['Plone Session Plugin'])
+    if not found:
+        manage_addSessionPlugin(plone_pas, 'session')
+        logger.debug("Added Plone Session Plugin.")
+        activatePluginInterfaces(portal, "session")
+
+    found = uf.objectIds(['Recursive Groups Plugin'])
+    if not found:
+        addRecursiveGroupsPlugin(plone_pas, 'recursive_groups',
+                                 "Recursive Groups Plugin")
+        activatePluginInterfaces(portal, 'recursive_groups')
+        logger.debug("Added Recursive Groups plugin.")
+
+    setupPasswordPolicyPlugin(portal)
+
+
+def setupAuthPlugins(portal, pas, plone_pas,
+                     deactivate_basic_reset=True,
+                     deactivate_cookie_challenge=False):
+    uf = portal.acl_users
+    logger.debug("Cookie plugin setup")
+
+    login_path = 'login_form'
+    cookie_name = '__ac'
+
+    crumbler = getToolByName(portal, 'cookie_authentication', None)
+    if crumbler is not None:
+        login_path = crumbler.auto_login_page
+        cookie_name = crumbler.auth_cookie
+
+    found = uf.objectIds(['Extended Cookie Auth Helper'])
+    if not found:
+        plone_pas.manage_addExtendedCookieAuthHelper('credentials_cookie_auth',
+                                                     cookie_name=cookie_name)
+    logger.debug("Added Extended Cookie Auth Helper.")
+    if deactivate_basic_reset:
+        disable = ['ICredentialsResetPlugin', 'ICredentialsUpdatePlugin']
+    else:
+        disable = []
+    activatePluginInterfaces(
+        portal,
+        'credentials_cookie_auth',
+        disable=disable
+    )
+
+    credentials_cookie_auth = uf._getOb('credentials_cookie_auth')
+    if 'login_form' in credentials_cookie_auth:
+        credentials_cookie_auth.manage_delObjects(ids=['login_form'])
+        logger.debug("Removed default login_form from credentials cookie "
+                     "auth.")
+    credentials_cookie_auth.cookie_name = cookie_name
+    credentials_cookie_auth.login_path = login_path
+
+    # remove cookie crumbler(s)
+    if 'cookie_authentication' in portal:
+        portal.manage_delObjects(['cookie_authentication'])
+    logger.debug("Removed old Cookie Crumbler")
+
+    found = uf.objectIds(['HTTP Basic Auth Helper'])
+    if not found:
+        pas.addHTTPBasicAuthHelper(
+            'credentials_basic_auth',
+            title="HTTP Basic Auth"
+        )
+    logger.debug("Added Basic Auth Helper.")
+    activatePluginInterfaces(portal, 'credentials_basic_auth')
+
+    if deactivate_basic_reset:
+        uf.plugins.deactivatePlugin(
+            ICredentialsResetPlugin,
+            'credentials_basic_auth'
+        )
+    if deactivate_cookie_challenge:
+        uf.plugins.deactivatePlugin(
+            IChallengePlugin,
+            'credentials_cookie_auth'
+        )
+
+
+def updateProperties(tool, properties):
+    dependency_keys = ('selection', 'multiple selection')
+    propsWithNoDeps = [prop for prop in properties
+                       if prop['type'] not in dependency_keys]
+    propsWithDeps = [prop for prop in properties
+                     if prop['type'] in dependency_keys]
+    for prop in propsWithNoDeps:
+        updateProp(tool, prop)
+    for prop in propsWithDeps:
+        updateProp(tool, prop)
+
+
+def updateProp(prop_manager, prop_dict):
+    """Provided a PropertyManager and a property dict of {id, value,
+    type}, set or update that property as applicable.
+
+    Doesn't deal with existing properties changing type.
+    """
+    id = prop_dict['id']
+    value = prop_dict['value']
+    type = prop_dict['type']
+    if type in ('selection', 'multiple selection'):
+        value = prop_dict['select_variable']
+    if prop_manager.hasProperty(id):
+        prop_manager._updateProperty(id, value)
+    else:
+        prop_manager._setProperty(id, value, type)
+    if type in ('selection', 'multiple selection'):
+        prop_manager._updateProperty(id, prop_dict['value'])
+
+
+def addPAS(portal):
+    logger.debug("Adding PAS user folder")
+    portal.manage_addProduct['PluggableAuthService'].addPluggableAuthService()
+
+
+def migrate_root_uf(self):
+    # Acquire parent user folder.
+    parent = self.getPhysicalRoot()
+    uf = getToolByName(parent, 'acl_users')
+    if IPluggableAuthService.providedBy(uf):
+        # It's a PAS already, fixup if needed.
+        pas_fixup(parent)
+
+        # Configure Challenge Chooser plugin if available
+        challenge_chooser_setup(parent)
+        return
+
+    if not uf.meta_type == 'User Folder':
+        # It's not a standard User Folder at the root. Nothing we can do.
+        return
+
+    # It's a standard User Folder, replace it.
+    replace_acl_users(parent)
+
+    # Get the new uf
+    uf = getToolByName(parent, 'acl_users')
+
+    pas = uf.manage_addProduct['PluggableAuthService']
+    plone_pas = uf.manage_addProduct['PlonePAS']
+    # Setup authentication plugins
+    setupAuthPlugins(parent, pas, plone_pas,
+                     deactivate_basic_reset=False,
+                     deactivate_cookie_challenge=True)
+
+    # Activate *all* interfaces for user manager. IUserAdder is not
+    # activated for some reason by default.
+    activatePluginInterfaces(parent, 'users')
+
+    # Configure Challenge Chooser plugin if available
+    challenge_chooser_setup(parent)
+
+
+def pas_fixup(self):
+    from Products.PluggableAuthService.PluggableAuthService \
+         import _PLUGIN_TYPE_INFO
+
+    pas = getToolByName(self, 'acl_users')
+    if not IPluggableAuthService.providedBy(pas):
+        logger.debug('PAS UF not found, skipping PAS fixup.')
+        return
+
+    plugins = pas['plugins']
+
+    plugin_types = list(set(plugins._plugin_types))
+    for key, id, title, description in _PLUGIN_TYPE_INFO:
+        if key in plugin_types:
+            logger.debug("Plugin type '%s' already registered." % id)
+            continue
+        logger.debug("Plugin type '%s' was not registered." % id)
+        plugin_types.append(key)
+        plugins._plugin_type_info[key] = {
+            'id': id,
+            'title': title,
+            'description': description,
+            }
+    # Make it ordered
+    plugin_types.sort()
+
+    # Re-assign because it's a non-persistent property.
+    plugins._plugin_types = plugin_types
+
+
+def challenge_chooser_setup(self):
+    uf = getToolByName(self, 'acl_users')
+    pas = uf.manage_addProduct['PluggableAuthService']
+
+    # Only install plugins if available
+    req = ('addChallengeProtocolChooserPlugin',
+           'addRequestTypeSnifferPlugin')
+    for m in req:
+        if getattr(pas, m, None) is None:
+            logger.debug('Needed plugins have not been found, ignoring')
+            return
+
+    found = uf.objectIds(['Challenge Protocol Chooser Plugin'])
+    if not found:
+        logger.debug('Adding Challenge Protocol Chooser Plugin.')
+        pas.addChallengeProtocolChooserPlugin(
+            'chooser',
+            mapping=config.DEFAULT_PROTO_MAPPING)
+        activatePluginInterfaces(self, 'chooser')
+    else:
+        assert len(found) == 1, 'Found extra plugins %s' % found
+        logger.debug('Found existing Challenge Protocol Chooser Plugin.')
+        plugin = uf[found[0]]
+        plugin.manage_updateProtocolMapping(
+            mapping=config.DEFAULT_PROTO_MAPPING)
+        activatePluginInterfaces(self, found[0])
+
+    found = uf.objectIds(['Request Type Sniffer Plugin'])
+    if not found:
+        logger.debug('Adding Request Type Sniffer Plugin.')
+        pas.addRequestTypeSnifferPlugin('sniffer')
+        activatePluginInterfaces(self, 'sniffer')
+    else:
+        assert len(found) == 1, 'Found extra plugins %s' % found
+        logger.debug('Found existing Request Type Sniffer Plugin.')
+        activatePluginInterfaces(self, found[0])
+
+
+def setupPasswordPolicyPlugin(portal):
+    uf = portal.acl_users
+    plone_pas = uf.manage_addProduct['PlonePAS']
+
+    found = uf.objectIds(['Default Plone Password Policy'])
+    logger.debug("\nDefault Password Ploicy Plugin setup")
+    if not found:
+        plone_pas.manage_addPasswordPolicyPlugin(
+            'password_policy',
+            title="Default Plone Password Policy"
+        )
+        logger.debug("Added Default Plone Password Policy.")
+        activatePluginInterfaces(portal, 'password_policy')
+
+
+def setLoginFormInCookieAuth(context):
+    """Makes sure the cookie auth redirects to 'require_login' instead
+       of 'login_form'."""
+    uf = getattr(context, 'acl_users', None)
+    if uf is None or getattr(uf.aq_base, '_getOb', None) is None:
+        # we have no user folder or it's not a PAS folder, do nothing
+        return
+    cookie_auth = uf._getOb('credentials_cookie_auth', None)
+    if cookie_auth is None:
+        # there's no cookie auth object, do nothing
+        return
+    current_login_form = cookie_auth.getProperty('login_path')
+    if current_login_form != 'login_form':
+        # it's customized already, do nothing
+        return
+    cookie_auth.manage_changeProperties(login_path='require_login')
+
+
+def addRolesToPlugIn(p):
+    """
+    XXX This is horrible.. need to switch PlonePAS to a GenericSetup
+    based install so this doesn't need to happen.
+
+    Have to manually register the roles from the 'rolemap' step
+    with the roles plug-in.
+    """
+    uf = getToolByName(p, 'acl_users')
+    rmanager = uf.portal_role_manager
+    roles = ('Reviewer', 'Member')
+    existing = rmanager.listRoleIds()
+    for role in roles:
+        if role not in existing:
+            rmanager.addRole(role)
+
+
+def setupGroups(site):
+    """
+    Create Plone's default set of groups.
+    """
+    uf = getToolByName(site, 'acl_users')
+    gtool = getToolByName(site, 'portal_groups')
+    if not uf.searchGroups(id='Administrators'):
+        gtool.addGroup(
+            'Administrators',
+            title='Administrators',
+            roles=['Manager']
+        )
+
+    if not uf.searchGroups(id='Site Administrators'):
+        gtool.addGroup(
+            'Site Administrators',
+            title='Site Administrators',
+            roles=['Site Administrator']
+        )
+
+    if not uf.searchGroups(id='Reviewers'):
+        gtool.addGroup('Reviewers', title='Reviewers', roles=['Reviewer'])
+
+
+def installPAS(portal):
+    # Add user folder
+    portal.manage_addProduct['PluggableAuthService'].addPluggableAuthService()
+
+    # Configure Challenge Chooser plugin if available
+    challenge_chooser_setup(portal)
+
+    # A bunch of general configuration settings
+    registerPluginTypes(portal.acl_users)
+    setupPlugins(portal)
+
+    # XXX Why are we doing this?
+    # According to Sidnei, "either cookie or basic auth for a user in the root
+    # folder doesn't work
+    # if it's not a PAS UF when you sign in to Plone. IIRC."
+    # See: http://twitter.com/#!/sidneidasilva/status/14030732112429056
+    # And here's the original commit:
+    # http://dev.plone.org/collective/changeset/10720/PlonePAS/trunk/Extensions/Install.py
+    if aq_parent(portal):
+        migrate_root_uf(portal)
+
+
+def setupPlonePAS(context):
+    """
+    Setup PlonePAS step.
+    """
+    # Only run step if a flag file is present (e.g. not an extension profile)
+    if context.readDataFile('plone-pas.txt') is None:
+        return
+    site = context.getSite()
+    if 'acl_users' not in site:
+        installPAS(site)
+        addRolesToPlugIn(site)
+        setupGroups(site)
+        setLoginFormInCookieAuth(site)
diff --git a/src/Products/PlonePAS/sheet.py b/src/Products/PlonePAS/sheet.py
new file mode 100644
index 0000000..8b05083
--- /dev/null
+++ b/src/Products/PlonePAS/sheet.py
@@ -0,0 +1,136 @@
+# -*- coding: utf-8 -*-
+"""
+Add Mutable Property Sheets and Schema Mutable Property Sheets to PAS
+
+also a property schema type registry which is extensible.
+
+"""
+from Products.CMFCore.interfaces import ISiteRoot
+from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
+from Products.PluggableAuthService.UserPropertySheet import UserPropertySheet
+from Products.PluggableAuthService.UserPropertySheet import _SequenceTypes
+from zope.component import getUtility
+from zope.interface import implementer
+
+
+class PropertyValueError(ValueError):
+    pass
+
+
+class PropertySchemaTypeMap(object):
+
+    def __init__(self):
+        self.tmap = {}
+        self.tmap_order = []
+
+    def addType(self, type_name, identifier, order=None):
+        self.tmap[type_name] = identifier
+        if order is not None and isinstance(order, int):
+            self.tmap_order.insert(order, type_name)
+        else:
+            self.tmap_order.append(type_name)
+
+    def getTypeFor(self, value):
+        ptypes = [(ptype, self.tmap[ptype]) for ptype in self.tmap_order]
+        for ptype, inspector in ptypes:
+            if inspector(value):
+                return ptype
+        raise TypeError('Invalid property type: %s' % type(value))
+
+    def validate(self, property_type, value):
+        inspector = self.tmap[property_type]
+        return inspector(value)
+
+PropertySchema = PropertySchemaTypeMap()
+PropertySchema.addType(
+    'string',
+    lambda x: x is None or isinstance(x, basestring)
+)
+PropertySchema.addType(
+    'text',
+    lambda x: x is None or isinstance(x, basestring)
+)
+PropertySchema.addType(
+    'boolean',
+    lambda x: 1  # anything can be boolean
+)
+PropertySchema.addType(
+    'int',
+    lambda x:  x is None or isinstance(x, int)
+)
+PropertySchema.addType(
+    'long',
+    lambda x:  x is None or isinstance(x, long)
+)
+PropertySchema.addType(
+    'float',
+    lambda x:  x is None or isinstance(x, float)
+)
+PropertySchema.addType(
+    'lines',
+    lambda x:  x is None or isinstance(x, _SequenceTypes)
+)
+PropertySchema.addType(
+    'selection',
+    lambda x: x is None or isinstance(x, basestring)
+)
+PropertySchema.addType(
+    'multiple selection',
+    lambda x:  x is None or isinstance(x, _SequenceTypes)
+)
+PropertySchema.addType(
+    'date',
+    lambda x: 1
+)
+validateValue = PropertySchema.validate
+
+
+@implementer(IMutablePropertySheet)
+class MutablePropertySheet(UserPropertySheet):
+
+    def validateProperty(self, id, value):
+        if id not in self._properties:
+            raise PropertyValueError('No such property found on this schema')
+
+        proptype = self.getPropertyType(id)
+        if not validateValue(proptype, value):
+            raise PropertyValueError(
+                "Invalid value (%s) for property '%s' of type %s" %
+                (value, id, proptype)
+            )
+
+    def setProperty(self, user, id, value):
+        self.validateProperty(id, value)
+
+        self._properties[id] = value
+        self._properties = self._properties
+
+        # cascade to plugin
+        provider = self._getPropertyProviderForUser(user)
+        provider.setPropertiesForUser(user, self)
+
+    def setProperties(self, user, mapping):
+        prop_keys = self._properties.keys()
+        prop_update = mapping.copy()
+
+        for key, value in tuple(prop_update.items()):
+            if key not in prop_keys:
+                prop_update.pop(key)
+                continue
+            self.validateProperty(key, value)
+
+        self._properties.update(prop_update)
+
+        # cascade to plugin
+        provider = self._getPropertyProviderForUser(user)
+        provider.setPropertiesForUser(user, self)
+
+    def _getPropertyProviderForUser(self, user):
+        # XXX This assumes that the acl_users that we want is in the portal
+        # root. This may not always be the case.
+        portal = getUtility(ISiteRoot)
+        return portal.acl_users._getOb(self._id)
+
+
+class SchemaMutablePropertySheet(MutablePropertySheet):
+    pass
diff --git a/src/Products/PlonePAS/tests/__init__.py b/src/Products/PlonePAS/tests/__init__.py
new file mode 100644
index 0000000..633f866
--- /dev/null
+++ b/src/Products/PlonePAS/tests/__init__.py
@@ -0,0 +1,2 @@
+# -*- coding: utf-8 -*-
+
diff --git a/src/Products/PlonePAS/tests/base.py b/src/Products/PlonePAS/tests/base.py
new file mode 100644
index 0000000..f274012
--- /dev/null
+++ b/src/Products/PlonePAS/tests/base.py
@@ -0,0 +1,3 @@
+# -*- coding: utf-8 -*-
+from plone.app.testing.bbb import PloneTestCase as TestCase
+from plone.app.testing.bbb import PloneTestCase as FunctionalTestCase
diff --git a/src/Products/PlonePAS/tests/cookie_auth.rst b/src/Products/PlonePAS/tests/cookie_auth.rst
new file mode 100644
index 0000000..cb249b5
--- /dev/null
+++ b/src/Products/PlonePAS/tests/cookie_auth.rst
@@ -0,0 +1,98 @@
+Test for Cookie Auth
+====================
+
+  >>> from zope.interface import implementedBy
+  >>> from plone.app.testing import TEST_USER_NAME
+  >>> from plone.app.testing import TEST_USER_PASSWORD
+
+User in Plone Site
+------------------
+
+Plone Site has PAS installed
+
+  >>> portal = layer['portal']
+  >>> print portal.acl_users.meta_type
+  Pluggable Auth Service
+
+User exists in the user folder inside the Plone Site.
+
+  >>> uf = portal.acl_users
+  >>> print uf.meta_type
+  Pluggable Auth Service
+
+  >>> user_name, user_password, user_role = ('foo', 'bar', 'Manager')
+  >>> uf.userFolderAddUser(user_name, user_password, [user_role], [])
+
+  >>> uf.getUserById(user_name)
+  <PloneUser 'foo'>
+
+Login to Plone Site using Basic Auth works.
+
+  >>> from plone.testing.z2 import Browser
+  >>> browser = Browser(layer['app'])
+  >>> browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+  >>> browser.open('%s/manage' % portal.absolute_url())
+  >>> print browser.headers
+  Status: 200 Ok...
+
+Make sure cookie plugin is installed and activated.
+
+  >>> uf.objectIds('Extended Cookie Auth Helper')
+  ['credentials_cookie_auth']
+
+  >>> plugins = uf.plugins
+  >>> cookie = uf['credentials_cookie_auth']
+
+  >>> ifaces = tuple(implementedBy(cookie.__class__).flattened())
+
+  >>> actives = []
+  >>> for iface in ifaces:
+  ...    try:
+  ...       actives.append((plugins.listPlugins(iface), iface))
+  ...    except KeyError:
+  ...       pass
+
+  >>> for active, iface in actives:
+  ...     print iface,
+  ...     for id, plugin in active:
+  ...         if id == 'credentials_cookie_auth':
+  ...            print True
+  <...IExtraction...> True
+  <...IChallenge...> True
+  <...ICredentialsUpdate...> <...ICredentialsReset...>
+
+User in parent folder
+---------------------
+
+User Exists on the folder containing the Plone Site, which should be a
+Pluggable Auth Service too.
+
+  >>> uf = layer['app'].acl_users
+  >>> print uf.meta_type
+  Pluggable Auth Service
+
+  >>> user_name, user_password, user_role = ('baz', 'bar', 'Manager')
+  >>> uf.userFolderAddUser(user_name, user_password, [user_role], [])
+
+  >>> uf.getUserById(user_name)
+  <PropertiedUser 'baz'>
+
+  >>> import transaction
+  >>> transaction.commit()
+
+Login directly to containing folder using Basic Auth works.
+
+  >>> browser = Browser(layer['app'])
+  >>> browser.addHeader('Authorization', 'Basic %s:%s' % (user_name, user_password,))
+  >>> browser.open('%s/manage' % layer['app'].absolute_url())
+  >>> print browser.headers
+  Status: 200 Ok...
+
+Login to Plone Site using Basic Auth works.
+
+  >>> browser = Browser(layer['app'])
+  >>> browser.addHeader('Authorization', 'Basic %s:%s' % (user_name, user_password,))
+  >>> browser.open('%s/manage' % portal.absolute_url())
+  >>> print browser.headers
+  Status: 200 Ok...
+
diff --git a/src/Products/PlonePAS/tests/dummy.py b/src/Products/PlonePAS/tests/dummy.py
new file mode 100644
index 0000000..346e046
--- /dev/null
+++ b/src/Products/PlonePAS/tests/dummy.py
@@ -0,0 +1,59 @@
+# -*- coding: utf-8 -*-
+from OFS.SimpleItem import SimpleItem
+from ZPublisher.HTTPRequest import FileUpload
+
+TEXT = 'file data'
+
+
+class FieldStorage(object):
+    def __init__(self, file, filename='testfile', headers=None):
+        self.file = file
+        if headers is None:
+            headers = {}
+        self.headers = headers
+        self.filename = filename
+
+
+class File(FileUpload):
+    '''Dummy upload object
+       Used to fake uploaded files.
+    '''
+
+    __allow_access_to_unprotected_subobjects__ = 1
+    filename = 'dummy.txt'
+    data = TEXT
+    headers = {}
+
+    def __init__(self, filename=None, data=None, headers=None):
+        if filename is not None:
+            self.filename = filename
+        if data is not None:
+            self.data = data
+        if headers is not None:
+            self.headers = headers
+
+    def seek(self, *args):
+        pass
+
+    def tell(self, *args):
+        return 1
+
+    def read(self, *args):
+        return self.data
+
+
+class Error(Exception):
+    '''Dummy exception'''
+
+
+class Raiser(SimpleItem):
+    '''Raises the stored exception when called'''
+
+    exception = Error
+
+    def __init__(self, exception=None):
+        if exception is not None:
+            self.exception = exception
+
+    def __call__(self, *args, **kw):
+        raise self.exception
diff --git a/src/Products/PlonePAS/tests/images/test.gif b/src/Products/PlonePAS/tests/images/test.gif
new file mode 100644
index 0000000..b1ac85b
Binary files /dev/null and b/src/Products/PlonePAS/tests/images/test.gif differ
diff --git a/src/Products/PlonePAS/tests/images/test.jpg b/src/Products/PlonePAS/tests/images/test.jpg
new file mode 100644
index 0000000..d444aff
Binary files /dev/null and b/src/Products/PlonePAS/tests/images/test.jpg differ
diff --git a/src/Products/PlonePAS/tests/images/test.png b/src/Products/PlonePAS/tests/images/test.png
new file mode 100644
index 0000000..078487d
Binary files /dev/null and b/src/Products/PlonePAS/tests/images/test.png differ
diff --git a/src/Products/PlonePAS/tests/test_basic_ops.py b/src/Products/PlonePAS/tests/test_basic_ops.py
new file mode 100644
index 0000000..e70540d
--- /dev/null
+++ b/src/Products/PlonePAS/tests/test_basic_ops.py
@@ -0,0 +1,150 @@
+# -*- coding: utf-8 -*-
+from Products.PlonePAS.tests import base
+from Products.PluggableAuthService.PluggableAuthService import \
+    _SWALLOWABLE_PLUGIN_EXCEPTIONS
+from Products.PluggableAuthService.interfaces.authservice import \
+    IPluggableAuthService
+from Products.PluggableAuthService.interfaces.events import \
+    IPrincipalDeletedEvent
+from Products.PluggableAuthService.interfaces.plugins import IRolesPlugin
+from zope.component import adapter
+from zope.component import getGlobalSiteManager
+
+
+class BasicOpsTestCase(base.TestCase):
+
+    def afterSetUp(self):
+        self.loginAsPortalOwner()
+        self.acl_users = self.portal.acl_users
+
+    def compareRoles(self, target, user, roles):
+        """
+        compareRoles(self, target, user, roles) => do not raise if
+        user has exactly the specified roles.
+
+        If target is None, test user roles (no local roles)
+        """
+        u = self.acl_users.getUser(user)
+        if not u:
+            raise RuntimeError("compareRoles: Invalid user: '%s'" % user)
+        non_roles = ('Authenticated', 'Anonymous', '')
+        if target is None:
+            user_roles = list(u.getRoles())
+        else:
+            user_roles = list(u.getRolesInContext(target))
+        actual_roles = filter(lambda x: x not in non_roles, user_roles)
+        actual_roles.sort()
+        wished_roles = list(roles)
+        wished_roles.sort()
+        if actual_roles == wished_roles:
+            return 1
+        raise RuntimeError("User %s: Whished roles: %s BUT current "
+                           "roles: %s" % (user, wished_roles, actual_roles))
+
+    def createUser(self, login="created_user", password="secret",
+                   roles=[], groups=[], domains=()):
+        self.acl_users.userFolderAddUser(
+            login, password, roles=roles, groups=groups, domains=domains,)
+
+    def test_installed(self):
+        self.assertTrue(IPluggableAuthService.providedBy(self.acl_users))
+
+    def test_add(self):
+        self.createUser()
+        self.assertTrue(self.acl_users.getUser("created_user"))
+
+    def test_edit(self):
+        # this will fail unless the PAS role plugin is told it manages
+        # the new role.
+        self.createUser()
+        self.compareRoles(None, "created_user", [])
+        self.acl_users.userFolderEditUser(
+            "created_user",  # name
+            "secret2",  # password
+            roles=["Member"],
+            groups=["g1"],
+            domains=(),)
+        self.compareRoles(None, "created_user", ['Member'])
+
+    def test_edit_userDefinedRole(self):
+        roleplugins = self.acl_users.plugins.listPlugins(IRolesPlugin)
+        for id, plugin in roleplugins:
+            try:
+                plugin.addRole('r1')
+            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+                pass
+            else:
+                break
+
+        self.createUser()
+        self.compareRoles(None, "created_user", [])
+        self.acl_users.userFolderEditUser(
+            "created_user",  # name
+            "secret2",  # password
+            roles=["r1"],
+            groups=["g1"],
+            domains=(),)
+        self.compareRoles(None, "created_user", ['r1'])
+
+    def test_del(self):
+        self.createUser()
+        self.assertTrue(self.acl_users.getUser("created_user"))
+        self.acl_users.userFolderDelUsers(['created_user'])
+        self.assertFalse(self.acl_users.getUser("created_user"))
+
+    def test_principal_del_event(self):
+        eventsFired = []
+
+        @adapter(IPrincipalDeletedEvent)
+        def gotDeletion(event):
+            eventsFired.append(event)
+
+        gsm = getGlobalSiteManager()
+        gsm.registerHandler(gotDeletion)
+        self.createUser()
+        self.acl_users.userFolderDelUsers(['created_user'])
+        self.assertEqual(len(eventsFired), 1)
+        self.assertEqual(eventsFired[0].principal, 'created_user')
+        gsm.unregisterHandler(gotDeletion)
+
+    def test_search(self):
+        self.createUser("created_user1")
+        self.createUser("created_user2")
+        mt = self.portal.portal_membership
+        retlist = mt.searchForMembers(REQUEST=None, login="created_user1")
+        usernames = [user.getUserName() for user in retlist]
+        self.assertEqual(len(usernames), 1)
+        self.assertTrue("created_user1" in usernames,
+                        "'created_user1' not in %s" % usernames)
+
+    def test_setpw(self):
+        # there is more than one place where one can set the password.
+        # insane. anyway we have to check the patch in pas.py userSetPassword
+        # here its checked in the general setup using ZODBUserManager.
+        self.createUser()
+        uf = self.acl_users
+        new_secret = 'new_secret'
+        uf.userSetPassword('created_user', new_secret)
+
+        # possible to authenticate with new password?
+        from Products.PluggableAuthService.interfaces.plugins \
+            import IAuthenticationPlugin
+        authenticators = uf.plugins.listPlugins(IAuthenticationPlugin)
+        credentials = {'login': 'created_user', 'password': new_secret}
+        result = None
+        for aid, authenticator in authenticators:
+            result = authenticator.authenticateCredentials(credentials)
+            if result is not None:
+                break
+        self.assertTrue(result)
+
+    def test_setProperties(self):
+        self.createUser()
+        user = self.acl_users.getUser('created_user')
+        user.setProperties(fullname='Test User', email='test@example.org')
+        self.assertEqual(user.getProperty('fullname'), 'Test User')
+        self.assertEqual(user.getProperty('email'), 'test@example.org')
+
+        user.setProperties(properties={'fullname': 'Test User2', 'email': 'test2@example.org'})
+        self.assertEqual(user.getProperty('fullname'), 'Test User2')
+        self.assertEqual(user.getProperty('email'), 'test2@example.org')
diff --git a/src/Products/PlonePAS/tests/test_doctests.py b/src/Products/PlonePAS/tests/test_doctests.py
new file mode 100644
index 0000000..9e2c509
--- /dev/null
+++ b/src/Products/PlonePAS/tests/test_doctests.py
@@ -0,0 +1,26 @@
+# -*- coding: utf-8 -*-
+from plone.app.testing.bbb import PTC_FUNCTIONAL_TESTING
+from plone.testing import layered
+import doctest
+import unittest
+
+
+def test_suite():
+    suite = unittest.TestSuite()
+    suite.addTest(
+        layered(
+            doctest.DocFileSuite(
+                'cookie_auth.rst',
+                package='Products.PlonePAS.tests',
+                optionflags=doctest.ELLIPSIS
+            ),
+            layer=PTC_FUNCTIONAL_TESTING
+        )
+    )
+    suite.addTest(
+        doctest.DocTestSuite(
+            'Products.PlonePAS.utils',
+            optionflags=doctest.ELLIPSIS
+        )
+    )
+    return suite
diff --git a/src/Products/PlonePAS/tests/test_groupdatatool.py b/src/Products/PlonePAS/tests/test_groupdatatool.py
new file mode 100644
index 0000000..6bb8600
--- /dev/null
+++ b/src/Products/PlonePAS/tests/test_groupdatatool.py
@@ -0,0 +1,181 @@
+# -*- coding: utf-8 -*-
+from AccessControl import Permissions
+from AccessControl import Unauthorized
+from Products.CMFCore.tests.base.testcase import WarningInterceptor
+from Products.PlonePAS.tests import base
+from plone.app.testing import TEST_USER_ID
+from plone.app.testing import TEST_USER_NAME
+
+
+def sortTuple(t):
+    l = list(t)
+    l.sort()
+    return tuple(l)
+
+
+class TestGroupDataTool(base.TestCase):
+
+    def afterSetUp(self):
+        self.acl_users = self.portal.acl_users
+        self.groups = self.portal.portal_groups
+        self.groupdata = self.portal.portal_groupdata
+        self.groups.addGroup('foo')
+        # MUST reset _v_ attributes!
+        self.groupdata._v_temps = None
+        if 'auto_group' in self.acl_users:
+            self.acl_users.manage_delObjects(['auto_group'])
+
+    def testWrapGroup(self):
+        g = self.acl_users.getGroup('foo')
+        self.assertEqual(g.__class__.__name__, 'PloneGroup')
+        g = self.groupdata.wrapGroup(g)
+        self.assertEqual(g.__class__.__name__, 'GroupData')
+        self.assertEqual(g.aq_parent.__class__.__name__, 'PloneGroup')
+        self.assertEqual(g.aq_parent.aq_parent.__class__.__name__,
+                         'GroupManager')
+
+
+class TestGroupData(base.TestCase, WarningInterceptor):
+
+    def afterSetUp(self):
+        self.membership = self.portal.portal_membership
+        self.memberdata = self.portal.portal_memberdata
+        self.acl_users = self.portal.acl_users
+        self.groups = self.portal.portal_groups
+        self.groupdata = self.portal.portal_groupdata
+        self.groups.addGroup('foo')
+        if 'auto_group' in self.acl_users:
+            self.acl_users.manage_delObjects(['auto_group'])
+        # MUST reset _v_ attributes!
+        self.memberdata._v_temps = None
+        self.groupdata._v_temps = None
+        self._trap_warning_output()
+
+    def testGetGroup(self):
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(g.__class__.__name__, 'GroupData')
+        g = g.getGroup()
+        self.assertEqual(g.__class__.__name__, 'PloneGroup')
+
+    def testGetTool(self):
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(g.getTool().getId(), 'portal_groupdata')
+
+    def testGetGroupMembers(self):
+        g = self.groups.getGroupById('foo')
+        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
+        self.assertEqual(g.getGroupMembers()[0].getId(), TEST_USER_ID)
+
+    def testGroupMembersAreWrapped(self):
+        g = self.groups.getGroupById('foo')
+        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
+        ms = g.getGroupMembers()
+        self.assertEqual(ms[0].__class__.__name__, 'MemberData')
+        self.assertEqual(ms[0].aq_parent.__class__.__name__, 'PloneUser')
+        self.assertEqual(ms[0].aq_parent.aq_parent.__class__.__name__,
+                         'PluggableAuthService')
+
+    def testAddMember(self):
+        self.setPermissions([Permissions.manage_users])
+        g = self.groups.getGroupById('foo')
+        g.addMember(TEST_USER_ID)
+        self.assertEqual(g.getGroupMembers()[0].getId(), TEST_USER_ID)
+
+    def testRemoveMember(self):
+        self.setPermissions([Permissions.manage_users])
+        g = self.groups.getGroupById('foo')
+        g.addMember(TEST_USER_ID)
+        g.removeMember(TEST_USER_ID)
+        self.assertEqual(len(g.getGroupMembers()), 0)
+
+    def testSetGroupProperties(self):
+        g = self.groups.getGroupById('foo')
+        g.setGroupProperties({'email': 'foo@bar.com'})
+        gd = self.groups.getGroupById('foo')
+        self.assertEqual(gd.getProperty('email'), 'foo@bar.com')
+
+    def testSetMemberProperties(self):
+        # For reference
+        m = self.membership.getMemberById(TEST_USER_ID)
+        m.setMemberProperties({'email': 'foo@bar.com'})
+        md = self.membership.getMemberById(TEST_USER_ID)
+        self.assertEqual(md.getProperty('email'), 'foo@bar.com')
+
+    def testGetProperty(self):
+        g = self.groups.getGroupById('foo')
+        g.setGroupProperties({'email': 'foo@bar.com'})
+        self.assertEqual(g.getProperty('email'), 'foo@bar.com')
+        self.assertEqual(g.getProperty('id'), 'foo')
+
+    def testGetGroupName(self):
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(g.getGroupName(), 'foo')
+
+    def testGetGroupId(self):
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(g.getGroupId(), 'foo')
+
+    def testGetRoles(self):
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(tuple(g.getRoles()), ('Authenticated',))
+        self.groups.editGroup(g.getId(), roles=['Member'])
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(sortTuple(tuple(g.getRoles())),
+                         ('Authenticated', 'Member'))
+
+    def testGetRolesInContext(self):
+        g = self.groups.getGroupById('foo')
+        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
+        user = self.acl_users.getUser(TEST_USER_NAME)
+        self.assertEqual(user.getRolesInContext(self.folder).sort(),
+                        ['Member', 'Authenticated', 'Owner'].sort())
+        self.folder.manage_setLocalRoles(g.getId(), ['NewRole'])
+        self.assertEqual(user.getRolesInContext(self.folder).sort(),
+                        ['Member', 'Authenticated', 'Owner', 'NewRole'].sort())
+
+    def testGetDomains(self):
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(g.getDomains(), ())
+
+    def testHasRole(self):
+        g = self.groups.getGroupById('foo')
+        self.groups.editGroup(g.getId(), roles=['Member'])
+        g = self.groups.getGroupById('foo')
+        self.assertTrue(g.has_role('Member'))
+
+    def beforeTearDown(self):
+        self._free_warning_output()
+
+
+class TestMethodProtection(base.TestCase):
+
+    def afterSetUp(self):
+        self.groups = self.portal.portal_groups
+        self.groups.addGroup('foo')
+        self.groupdata = self.groups.getGroupById('foo')
+
+    def testAnonAddMember(self):
+        self.logout()
+        self.assertRaises(Unauthorized, self.groupdata.addMember, TEST_USER_ID)
+
+    def testAnonRemoveMember(self):
+        self.logout()
+        self.assertRaises(Unauthorized, self.groupdata.removeMember,
+                          TEST_USER_ID)
+
+    def testMemberAddMember(self):
+        self.assertRaises(Unauthorized, self.groupdata.addMember, TEST_USER_ID)
+
+    def testMemberRemoveMember(self):
+        self.assertRaises(Unauthorized, self.groupdata.removeMember,
+                          TEST_USER_ID)
+
+    def testManagerAddMember(self):
+        self.setPermissions([Permissions.manage_users])
+        self.groupdata.addMember(TEST_USER_ID)
+
+    def testManagerRemoveMember(self):
+        self.setPermissions([Permissions.manage_users])
+        self.groupdata.addMember(TEST_USER_ID)
+        self.groupdata.removeMember(TEST_USER_ID)
+
diff --git a/src/Products/PlonePAS/tests/test_groupstool.py b/src/Products/PlonePAS/tests/test_groupstool.py
new file mode 100644
index 0000000..cdac9c0
--- /dev/null
+++ b/src/Products/PlonePAS/tests/test_groupstool.py
@@ -0,0 +1,259 @@
+# -*- coding: utf-8 -*-
+from AccessControl import Permissions
+from AccessControl import Unauthorized
+from Acquisition import aq_base
+from Acquisition import aq_parent
+from Products.CMFCore.tests.base.testcase import WarningInterceptor
+from Products.CMFCore.utils import getToolByName
+from Products.PlonePAS.plugins.group import PloneGroup
+from Products.PlonePAS.tests import base
+from Products.PlonePAS.tools.groupdata import GroupData
+from plone.app.testing import TEST_USER_ID
+
+
+def sortTuple(t):
+    l = list(t)
+    l.sort()
+    return tuple(l)
+
+
+class GroupsToolTest(base.TestCase):
+
+    def afterSetUp(self):
+        self.gt = getToolByName(self.portal, 'portal_groups')
+        self.gd = getToolByName(self.portal, 'portal_groupdata')
+
+        self.group_id = 'group1'
+        # Create a new Group
+        self.loginAsPortalOwner()
+        self.gt.addGroup(
+            self.group_id,
+            ['Reviewer'],
+            [],
+            {'email': 'group1@host.com', 'title': 'Group #1'}
+        )
+
+    def test_get_group(self):
+        # Use PAS (monkeypatched) API method to get a group by id.
+        group = self.portal.acl_users.getGroup(self.group_id)
+        self.assertFalse(group is None)
+
+        # Should be wrapped into the GroupManagement, which is wrapped
+        # into the PAS.
+        got = aq_base(aq_parent(aq_parent(group)))
+        expected = aq_base(self.portal.acl_users)
+        self.assertEqual(got, expected)
+
+        self.assertTrue(isinstance(group, PloneGroup))
+
+    def test_get_group_by_id(self):
+        # Use tool way of getting group by id. This returns a
+        # GroupData object wrapped by the group
+        group = self.gt.getGroupById(self.group_id)
+        self.assertFalse(group is None)
+        self.assertTrue(isinstance(group, GroupData))
+        self.assertTrue(isinstance(aq_parent(group), PloneGroup))
+
+    def test_edit_group(self):
+        # Use the tool way to edit a group.
+        properties = {
+            'email': 'group1@host2.com',
+            'title': 'Group #1 new title'
+        }
+        self.gt.editGroup(
+            self.group_id,
+            roles=['Manager'],
+            **properties
+        )
+
+        # test edition of roles and properties
+        group = self.gt.getGroupById(self.group_id)
+        self.assertTrue(group.has_role('Manager'))
+        self.assertEqual(group.getProperty('email'), properties['email'])
+        self.assertEqual(group.getProperty('title'), properties['title'])
+
+        # test for empty list of roles
+        self.gt.editGroup(self.group_id, roles=[])
+        self.assertTrue(group.has_role('Authenticated'))
+
+        # test edition of group groups
+        self.gt.editGroup(
+            self.group_id,
+            groups=['Reviewers'],
+            **properties
+        )
+        group = self.gt.getGroupById(self.group_id)
+        self.assertTrue('Reviewers' in group.getGroups())
+
+
+class TestMethodProtection(base.TestCase):
+    # GroupData has wrong security declarations
+
+    def afterSetUp(self):
+        self.groups = self.portal.portal_groups
+        self.groups.addGroup('foo')
+        self.groupdata = self.groups.getGroupById('foo')
+
+    def testAnonAddMember(self):
+        self.logout()
+        self.assertRaises(Unauthorized, self.groupdata.addMember, TEST_USER_ID)
+
+    def testAnonRemoveMember(self):
+        self.logout()
+        self.assertRaises(Unauthorized, self.groupdata.removeMember,
+                          TEST_USER_ID)
+
+    def testMemberAddMember(self):
+        self.assertRaises(Unauthorized, self.groupdata.addMember, TEST_USER_ID)
+
+    def testMemberRemoveMember(self):
+        self.assertRaises(Unauthorized, self.groupdata.removeMember,
+                          TEST_USER_ID)
+
+    def testManagerAddMember(self):
+        self.setPermissions([Permissions.manage_users])
+        self.groupdata.addMember(TEST_USER_ID)
+
+    def testManagerRemoveMember(self):
+        self.setPermissions([Permissions.manage_users])
+        self.groupdata.addMember(TEST_USER_ID)
+        self.groupdata.removeMember(TEST_USER_ID)
+
+
+class TestGroupsTool(base.TestCase, WarningInterceptor):
+
+    def afterSetUp(self):
+        self.membership = self.portal.portal_membership
+        self.acl_users = self.portal.acl_users
+        self.groups = self.portal.portal_groups
+        self._trap_warning_output()
+
+        if 'auto_group' in self.acl_users:
+            self.acl_users.manage_delObjects(['auto_group'])
+
+        # Nuke Administators and Reviewers groups added in 2.1a2 migrations
+        # (and any other migrated-in groups) to avoid test confusion
+        self.groups.removeGroups(self.groups.listGroupIds())
+
+    def testAddGroup(self):
+        self.groups.addGroup('foo', [], [])
+        self.assertEqual(self.groups.listGroupIds(), ['foo'])
+
+    def testGetGroupById(self):
+        self.groups.addGroup('foo', [], [])
+        g = self.groups.getGroupById('foo')
+        self.assertNotEqual(g, None)
+
+    def testGetBadGroupById(self):
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(g, None)
+
+    def testGroupByIdIsWrapped(self):
+        self.groups.addGroup('foo', [], [])
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(g.__class__.__name__, 'GroupData')
+        self.assertEqual(g.aq_parent.__class__.__name__, 'PloneGroup')
+        self.assertEqual(g.aq_parent.aq_parent.__class__.__name__,
+                         'GroupManager')
+
+    def testEditGroup(self):
+        self.groups.addGroup('foo', )
+        self.groups.editGroup('foo', roles=['Reviewer'])
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(sortTuple(g.getRoles()),
+                         ('Authenticated', 'Reviewer'))
+
+    def testEditBadGroup(self):
+        # Error type depends on the user folder...
+        try:
+            self.groups.editGroup('foo', [], [])
+        except (KeyError, ValueError):
+            pass        # Ok, this is the wanted behaviour
+        else:
+            self.fail("Should have raised KeyError or ValueError")
+
+    def testRemoveGroups(self):
+        self.groups.addGroup('foo', [], [])
+        self.groups.removeGroups(['foo'])
+        self.assertEqual(len(self.groups.listGroupIds()), 0)
+
+    def testListGroupIds(self):
+        self.groups.addGroup('foo', [], [])
+        self.groups.addGroup('bar', [], [])
+        grps = self.groups.listGroupIds()
+        grps.sort()
+        self.assertEqual(grps, ['bar', 'foo'])
+
+    def testGetGroupsByUserId(self):
+        self.groups.addGroup('foo', [], [])
+        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
+        gs = self.groups.getGroupsByUserId(TEST_USER_ID)
+        self.assertEqual(gs[0].getId(), 'foo')
+
+    def testGroupsByUserIdAreWrapped(self):
+        self.groups.addGroup('foo', [], [])
+        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
+        gs = self.groups.getGroupsByUserId(TEST_USER_ID)
+        self.assertEqual(gs[0].__class__.__name__, 'GroupData')
+        self.assertEqual(gs[0].aq_parent.__class__.__name__, 'PloneGroup')
+        self.assertEqual(gs[0].aq_parent.aq_parent.__class__.__name__,
+                         'GroupManager')
+
+    def testListGroups(self):
+        self.groups.addGroup('foo', [], [])
+        self.groups.addGroup('bar', [], [])
+        gs = self.groups.listGroups()
+        self.assertEqual(gs[0].getId(), 'bar')
+        self.assertEqual(gs[1].getId(), 'foo')
+
+    def testListedGroupsAreWrapped(self):
+        self.groups.addGroup('foo', [], [])
+        gs = self.groups.listGroups()
+        self.assertEqual(gs[0].__class__.__name__, 'GroupData')
+        self.assertEqual(gs[0].aq_parent.__class__.__name__, 'PloneGroup')
+        self.assertEqual(gs[0].aq_parent.aq_parent.__class__.__name__,
+                         'GroupManager')
+
+    def testSetGroupOwnership(self):
+        self.groups.addGroup('foo', [], [])
+        self.folder.invokeFactory('Document', 'doc')
+        doc = self.folder.doc
+        g = self.groups.getGroupById('foo')
+        self.groups.setGroupOwnership(g, doc)
+        self.assertEqual(doc.getOwnerTuple()[1], 'foo')
+        self.assertEqual(doc.get_local_roles_for_userid('foo'), ('Owner',))
+        self.assertEqual(doc.get_local_roles_for_userid(TEST_USER_ID),
+                         ('Owner',))
+
+    def testWrapGroup(self):
+        self.groups.addGroup('foo', [], [])
+        g = self.acl_users.getGroup('foo')
+        self.assertEqual(g.__class__.__name__, 'PloneGroup')
+        g = self.groups.wrapGroup(g)
+        self.assertEqual(g.__class__.__name__, 'GroupData')
+        self.assertEqual(g.aq_parent.__class__.__name__, 'PloneGroup')
+        self.assertEqual(g.aq_parent.aq_parent.__class__.__name__,
+                         'GroupManager')
+
+    def testGetGroupInfo(self):
+        self.groups.addGroup('foo', title='Foo', description='Bar',
+                             email='foo@foo.com')
+        info = self.groups.getGroupInfo('foo')
+        self.assertEqual(info.get('title'), 'Foo')
+        self.assertEqual(info.get('description'), 'Bar')
+        self.assertEqual(info.get('email'), None)  # No email!
+
+    def testGetGroupInfoAsAnonymous(self):
+        self.groups.addGroup('foo', title='Foo', description='Bar')
+        self.logout()
+        info = self.groups.restrictedTraverse('getGroupInfo')('foo')
+        self.assertEqual(info.get('title'), 'Foo')
+        self.assertEqual(info.get('description'), 'Bar')
+
+    def testGetBadGroupInfo(self):
+        info = self.groups.getGroupInfo('foo')
+        self.assertEqual(info, None)
+
+    def beforeTearDown(self):
+        self._free_warning_output()
+
diff --git a/src/Products/PlonePAS/tests/test_memberdatatool.py b/src/Products/PlonePAS/tests/test_memberdatatool.py
new file mode 100644
index 0000000..b7ae400
--- /dev/null
+++ b/src/Products/PlonePAS/tests/test_memberdatatool.py
@@ -0,0 +1,70 @@
+# -*- coding: utf-8 -*-
+from DateTime import DateTime
+from OFS.Image import Image
+from Products.PlonePAS.tests import base
+from Products.PlonePAS.tests import dummy
+from plone.app.testing import TEST_USER_ID as default_user
+
+
+class TestMemberDataTool(base.TestCase):
+
+    def afterSetUp(self):
+        self.memberdata = self.portal.portal_memberdata
+        self.membership = self.portal.portal_membership
+        self.membership.memberareaCreationFlag = 0
+        # Don't let default_user disturb results
+        self.portal.acl_users._doDelUsers([default_user])
+        # Add some members
+        self.addMember('fred', 'Fred Flintstone', 'fred@bedrock.com',
+                       ['Member', 'Reviewer'], '2002-01-01')
+        self.addMember('barney', 'Barney Rubble', 'barney@bedrock.com',
+                       ['Member'], '2002-01-01')
+        self.addMember('brubble', 'Bambam Rubble', 'bambam@bambam.net',
+                       ['Member'], '2003-12-31')
+        # MUST reset this
+        self.memberdata._v_temps = None
+
+    def addMember(self, username, fullname, email, roles, last_login_time):
+        self.membership.addMember(username, 'secret', roles, [])
+        member = self.membership.getMemberById(username)
+        member.setMemberProperties({
+            'fullname': fullname,
+            'email': email,
+            'last_login_time': DateTime(last_login_time), })
+
+    def testSetPortrait(self):
+        self.memberdata._setPortrait(
+            Image(id=default_user, file=dummy.File(), title=''),
+            default_user)
+        self.assertEqual(self.memberdata._getPortrait(default_user).getId(),
+                         default_user)
+        self.assertEqual(self.memberdata._getPortrait(default_user).meta_type,
+                         'Image')
+
+    def testDeletePortrait(self):
+        self.memberdata._setPortrait(
+            Image(id=default_user, file=dummy.File(), title=''),
+            default_user)
+        self.memberdata._deletePortrait(default_user)
+        self.assertEqual(self.memberdata._getPortrait(default_user), None)
+
+    def testPruneMemberDataContents(self):
+        # Only test what is not already tested elswhere
+        self.memberdata._setPortrait(
+            Image(id=default_user, file=dummy.File(), title=''),
+            default_user)
+        self.memberdata._setPortrait(
+            Image(id=default_user, file=dummy.File(), title=''),
+            'dummy')
+        self.memberdata.pruneMemberDataContents()
+        self.assertEqual(len(self.memberdata.portraits), 1)
+
+    def testFulltextMemberSearch(self):
+        # Search for a user by id, name, email, ...
+        search = self.memberdata.searchFulltextForMembers
+        self.assertEqual(len(search('')), 3)
+        self.assertEqual(len(search('rubble')), 2)
+        self.assertEqual(len(search('stone')), 1)
+        self.assertEqual(len(search('bambam.net')), 1)
+        self.assertEqual(len(search('bedrock.com')), 2)
+        self.assertEqual(len(search('brubble')), 1)
diff --git a/src/Products/PlonePAS/tests/test_membershiptool.py b/src/Products/PlonePAS/tests/test_membershiptool.py
new file mode 100644
index 0000000..29d309d
--- /dev/null
+++ b/src/Products/PlonePAS/tests/test_membershiptool.py
@@ -0,0 +1,968 @@
+# -*- coding: utf-8 -*-
+from AccessControl import Unauthorized
+from AccessControl import getSecurityManager
+from AccessControl.User import nobody
+from Acquisition import aq_base
+from Acquisition import aq_parent
+from DateTime import DateTime
+from OFS.Image import Image
+from Products.CMFCore.interfaces import IPropertiesTool
+from Products.CMFCore.tests.base.testcase import WarningInterceptor
+from Products.CMFCore.utils import getToolByName
+from Products.PlonePAS.browser.member import PASMemberView
+from Products.PlonePAS.interfaces.membership import IMembershipTool
+from Products.PlonePAS.plugins.ufactory import PloneUser
+from Products.PlonePAS.tests import base
+from Products.PlonePAS.tests import dummy
+from Products.PlonePAS.tools.memberdata import MemberData
+from Products.PlonePAS.tools.membership import MembershipTool
+from Products.PlonePAS.utils import getGroupsForPrincipal
+from cStringIO import StringIO
+from plone.app.testing import PLONE_SITE_ID
+from plone.app.testing import SITE_OWNER_NAME
+from plone.app.testing import TEST_USER_ID
+from plone.app.testing import TEST_USER_NAME
+from plone.app.testing import TEST_USER_PASSWORD
+from zExceptions import BadRequest
+from zope.component import getUtility
+import os
+
+
+class MembershipToolTest(base.TestCase):
+
+    def afterSetUp(self):
+        self.mt = getToolByName(self.portal, 'portal_membership')
+        self.md = getToolByName(self.portal, 'portal_memberdata')
+
+        self.member_id = 'member1'
+        # Create a new Member
+        self.mt.addMember(
+            self.member_id,
+            'pw',
+            ['Member'],
+            [],
+            {'email': 'member1@host.com', 'title': 'Member #1'}
+        )
+
+    def test_get_member(self):
+        member = self.portal.acl_users.getUserById(self.member_id)
+        self.assertFalse(member is None)
+
+        # Should be wrapped into the PAS.
+        got = aq_base(aq_parent(member))
+        expected = aq_base(self.portal.acl_users)
+        self.assertEqual(got, expected)
+
+        self.assertTrue(isinstance(member, PloneUser))
+
+    def test_get_member_by_id(self):
+        # Use tool way of getting member by id. This returns a
+        # MemberData object wrapped by the member
+        member = self.mt.getMemberById(self.member_id)
+        self.assertFalse(member is None)
+        self.assertTrue(isinstance(member, MemberData))
+        self.assertTrue(isinstance(aq_parent(member), PloneUser))
+
+    def test_id_clean(self):
+        from Products.PlonePAS.utils import cleanId, decleanId
+        a = [
+             "asdfasdf",
+             "asdf-asdf",
+             "asdf--asdf",
+             "asdf---asdf",
+             "asdf----asdf",
+             "asdf-----asdf",
+             "asdf%asdf",
+             "asdf%%asdf",
+             "asdf%%%asdf",
+             "asdf%%%%asdf",
+             "asdf%%%%%asdf",
+             "asdf-%asdf",
+             "asdf%-asdf",
+             "asdf-%-asdf",
+             "asdf%-%asdf",
+             "asdf--%asdf",
+             "asdf%--asdf",
+             "asdf--%-asdf",
+             "asdf-%--asdf",
+             "asdf--%--asdf",
+             "asdf%-%asdf",
+             "asdf%--%asdf",
+             "asdf%---%asdf",
+             "-asdf",
+             "--asdf",
+             "---asdf",
+             "----asdf",
+             "-----asdf",
+             "asdf-",
+             "asdf--",
+             "asdf---",
+             "asdf----",
+             "asdf-----",
+             "%asdf",
+             "%%asdf",
+             "%%%asdf",
+             "%%%%asdf",
+             "%%%%%asdf",
+             "asdf%",
+             "asdf%%",
+             "asdf%%%",
+             "asdf%%%%",
+             "asdf%%%%%",
+             "asdf\x00asdf",
+        ]
+        b = [cleanId(id) for id in a]
+        c = [decleanId(id) for id in b]
+        ac = zip(a, c)
+        for aa, cc in ac:
+            self.assertTrue(aa == cc)
+
+
+class MemberAreaTest(base.TestCase):
+
+    def afterSetUp(self):
+        self.mt = getToolByName(self.portal, 'portal_membership')
+        self.md = getToolByName(self.portal, 'portal_memberdata')
+        # Enable member-area creation
+        self.mt.memberareaCreationFlag = 1
+        # Those are all valid chars in Zope.
+        self.mid = "Member #1 - Houston, TX. ($100)"
+        self.pas = self.portal.acl_users
+        self.loginAsPortalOwner()
+
+    def test_funky_member_ids_1(self):
+        mid = self.mid
+        minfo = (mid, 'pw', ['Member'], [])
+
+        # Create a new User
+        self.pas._doAddUser(*minfo)
+        self.mt.createMemberArea, (mid)
+
+    def test_funky_member_ids_2(self):
+        # Forward-slash is not allowed
+        mid = self.mid + '/'
+        minfo = (mid, 'pw', ['Member'], [])
+
+        # Create a new User
+        self.pas._doAddUser(*minfo)
+        self.mt.createMemberArea(mid)
+
+    def test_memberareaCreationFlag_respected(self):
+        self.pas._doAddUser('foo', 'pw', ['Member'], [])
+        self.pas._doAddUser('bar', 'pw', ['Member'], [])
+
+        self.assertFalse('foo' in self.portal.Members)
+        self.assertFalse('bar' in self.portal.Members)
+
+        self.mt.createMemberarea('foo')
+        self.assertTrue('foo' in self.portal.Members)
+
+        self.mt.memberareaCreationFlag = 0
+        self.mt.createMemberArea('bar')
+        self.assertFalse('bar' in self.portal.Members)
+
+
+class TestMembershipTool(base.TestCase, WarningInterceptor):
+
+    def afterSetUp(self):
+        self.membership = self.portal.portal_membership
+        self.groups = self.portal.portal_groups
+        self._trap_warning_output()
+
+    def test_interface(self):
+        from zope.interface.verify import verifyClass
+        verifyClass(IMembershipTool, MembershipTool)
+
+    def addMember(self, username, fullname, email, roles, last_login_time):
+        self.membership.addMember(username, 'secret', roles, [])
+        member = self.membership.getMemberById(username)
+        member.setMemberProperties({
+            'fullname': fullname, 'email': email,
+            'last_login_time': DateTime(last_login_time), })
+
+    def makeRealImage(self):
+        import Products.PlonePAS as ppas
+        pas_path = os.path.dirname(ppas.__file__)
+        path = os.path.join(pas_path, 'tool.gif')
+        image = open(path, 'rb')
+        image_upload = dummy.FileUpload(dummy.FieldStorage(image))
+        return image_upload
+
+    def testNoMorePersonalFolder(self):
+        # .personal folders are history
+        personal = getattr(self.folder, self.membership.personal_id, None)
+        self.assertEqual(personal, None)
+        self.assertEqual(self.membership.getPersonalFolder(TEST_USER_ID), None)
+
+    def testGetPersonalFolderIfNoHome(self):
+        # Should return None as the user has no home folder
+        members = self.membership.getMembersFolder()
+        members._delObject(TEST_USER_ID)
+        self.assertEqual(self.membership.getPersonalFolder(TEST_USER_ID), None)
+
+    def testGetPersonalPortrait(self):
+        # Should return the default portrait
+        self.assertEqual(
+            self.membership.getPersonalPortrait(TEST_USER_ID).getId(),
+            'defaultUser.png')
+
+    def testChangeOwnMemberPortrait(self):
+        # Should change the portrait image
+        # first we need a valid image
+        image = self.makeRealImage()
+        self.membership.changeMemberPortrait(image, TEST_USER_ID)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(TEST_USER_ID).getId(),
+            TEST_USER_ID)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(TEST_USER_ID).meta_type,
+            'Image')
+
+    def testChangeOwnMemberPortraitWithEmailUsers(self):
+        member_id = 'member2@host.com'
+        self.membership.addMember(
+            member_id,
+            'pw',
+            ['Member'],
+            [],
+            {'email': 'member2@host.com', 'title': 'Member #2'}
+        )
+
+        self.login(member_id)
+        image = self.makeRealImage()
+        safe_member_id = self.membership._getSafeMemberId(member_id)
+
+        self.membership.changeMemberPortrait(image, member_id)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(member_id).getId(),
+            safe_member_id)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(member_id).meta_type,
+            'Image')
+
+    def testCannotChangeOtherMemberPortrait(self):
+        # A normal member should not be able to change the portrait of
+        # another member.
+        image = self.makeRealImage()
+        self.membership.addMember('joe', 'secret', ['Member'], [])
+        self.assertRaises(Unauthorized, self.membership.changeMemberPortrait,
+                          image, 'joe')
+
+    def testChangeMemberPortraitAsManager(self):
+        # Managers should be able to change the portrait of another
+        # member.
+        image = self.makeRealImage()
+        self.membership.addMember('joe', 'secret', ['Member'], [])
+        self.setRoles(['Manager'])
+        # This should not raise Unauthorized:
+        self.membership.changeMemberPortrait(image, 'joe')
+        self.assertEqual(self.membership.getPersonalPortrait('joe').getId(),
+                         'joe')
+        self.assertEqual(self.membership.getPersonalPortrait('joe').meta_type,
+                         'Image')
+
+    def testDeleteOwnPersonalPortrait(self):
+        # Should delete the portrait image
+        image = self.makeRealImage()
+        self.membership.changeMemberPortrait(image, TEST_USER_ID)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(TEST_USER_ID).getId(),
+            TEST_USER_ID)
+        self.membership.deletePersonalPortrait(TEST_USER_ID)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(TEST_USER_ID).getId(),
+            'defaultUser.png')
+
+    def testCannotDeleteOtherPersonalPortrait(self):
+        # A normal member should not be able to delete the portrait of
+        # another member.
+        image = self.makeRealImage()
+        self.membership.addMember('joe', 'secret', ['Member'], [])
+        self.setRoles(['Manager'])
+        self.membership.changeMemberPortrait(image, 'joe')
+        self.setRoles(['Member'])
+        self.assertRaises(Unauthorized, self.membership.deletePersonalPortrait,
+                          'joe')
+
+    def testDeleteOtherPersonalPortraitAsManager(self):
+        # Managers should be able to change the portrait of another
+        # member.
+        image = self.makeRealImage()
+        self.membership.addMember('joe', 'secret', ['Member'], [])
+        self.setRoles(['Manager'])
+        self.membership.changeMemberPortrait(image, 'joe')
+        self.membership.deletePersonalPortrait('joe')
+        self.assertEqual(
+            self.membership.getPersonalPortrait('joe').getId(),
+            'defaultUser.png'
+        )
+
+    def testGetPersonalPortraitWithoutPassingId(self):
+        # Should return the logged in users portrait if no id is given
+        image = self.makeRealImage()
+        self.membership.changeMemberPortrait(image, TEST_USER_ID)
+        self.assertEqual(self.membership.getPersonalPortrait().getId(),
+                         TEST_USER_ID)
+        self.assertEqual(self.membership.getPersonalPortrait().meta_type,
+                         'Image')
+
+    def testPortraitForNonStandardUserId(self):
+        # Some characters in a user id can give problems for getting
+        # or saving a portrait, especially '-', '+', '@'.
+        image = self.makeRealImage()
+        user_id = 'bob-jones+test@example.org'
+        safe_id = self.membership._getSafeMemberId(user_id)
+        self.assertEqual(safe_id, 'bob--jones-2Btest-40example.org')
+        self.membership.addMember(user_id, 'secret', ['Member'], [])
+        self.login(user_id)
+
+        # Should return the default portrait
+        self.assertEqual(
+            self.membership.getPersonalPortrait(user_id).getId(),
+            'defaultUser.png')
+
+        # Change your own portrait.
+        self.membership.changeMemberPortrait(image, user_id)
+        self.assertEqual(self.membership.getPersonalPortrait().getId(),
+                         safe_id)
+        self.assertEqual(self.membership.getPersonalPortrait().meta_type,
+                         'Image')
+
+        # Other users should be able to see your portrait.
+        self.login(TEST_USER_NAME)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(user_id).getId(),
+            safe_id)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(user_id).meta_type,
+            'Image')
+
+        # You can delete your own portrait.
+        self.login(user_id)
+        self.membership.deletePersonalPortrait(user_id)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(user_id).getId(),
+            'defaultUser.png')
+
+        # Managers should be able to change the portrait of another
+        # member and delete it.
+        manager_image = self.makeRealImage()
+        self.loginAsPortalOwner()
+        # This should not raise Unauthorized:
+        self.membership.changeMemberPortrait(manager_image, user_id)
+        self.assertEqual(self.membership.getPersonalPortrait(user_id).getId(),
+                         safe_id)
+        self.membership.deletePersonalPortrait(user_id)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(user_id).getId(),
+            'defaultUser.png'
+        )
+
+    def testListMembers(self):
+        # Should return the members list
+        members = self.membership.listMembers()
+        self.assertEqual(len(members), 1)
+        self.assertEqual(members[0].getId(), TEST_USER_ID)
+
+    def testListMembersSkipsGroups(self):
+        # Should only return real members, not groups
+        uf = self.portal.acl_users
+        self.groups.addGroup('Foo')
+        self.groups.addGroup('Bar')
+        self.assertEqual(len(uf.getUserNames()), 1)
+        members = self.membership.listMembers()
+        self.assertEqual(len(members), 1)
+        self.assertEqual(members[0].getId(), TEST_USER_ID)
+
+    def testListMemberIds(self):
+        # Should return the members ids list
+        memberids = self.membership.listMemberIds()
+        self.assertEqual(len(memberids), 1)
+        self.assertEqual(memberids[0], TEST_USER_ID)
+
+    def testListMemberIdsSkipsGroups(self):
+        # Should only return real members, not groups
+        uf = self.portal.acl_users
+        self.groups.addGroup('Foo')
+        self.groups.addGroup('Bar')
+        self.assertEqual(len(uf.getUserNames()), 1)
+        memberids = self.membership.listMemberIds()
+        self.assertEqual(len(memberids), 1)
+        self.assertEqual(memberids[0], TEST_USER_ID)
+
+    def testCurrentPassword(self):
+        # Password checking should work
+        self.assertTrue(self.membership.testCurrentPassword('secret'))
+        self.assertFalse(self.membership.testCurrentPassword('geheim'))
+
+    def testSetPassword(self):
+        # Password should be changed
+        self.membership.setPassword('geheim')
+        self.assertTrue(self.membership.testCurrentPassword('geheim'))
+
+    def testSetPasswordIfAnonymous(self):
+        # Anonymous should not be able to change password
+        self.logout()
+        try:
+            self.membership.setPassword('geheim')
+        except BadRequest:
+            import sys
+            e, v, tb = sys.exc_info()
+            del tb
+            if str(v) == 'Not logged in.':
+                pass
+            else:
+                raise
+
+    def testSetPasswordAndKeepGroups(self):
+        # Password should be changed and user must not change group membership
+        group2 = 'g2'
+        groups = self.groups
+        groups.addGroup(group2, None, [], [])
+        group = groups.getGroupById(group2)
+        self.loginAsPortalOwner()
+        group.addMember(TEST_USER_ID)
+        self.login(TEST_USER_NAME)  # Back to normal
+        ugroups = self.portal.acl_users.getUserById(TEST_USER_ID).getGroups()
+        self.membership.setPassword('geheim')
+        t_groups = self.portal.acl_users.getUserById(TEST_USER_ID).getGroups()
+        self.assertTrue(t_groups == ugroups)
+
+    def testGetMemberById(self):
+        # This should work for portal users,
+        self.assertNotEqual(self.membership.getMemberById(TEST_USER_ID), None)
+        self.assertEqual(self.membership.getMemberById('foo'), None)
+        self.assertNotEqual(
+            self.membership.getMemberById(SITE_OWNER_NAME),
+            None
+        )
+
+    def testGetMemberByIdIsWrapped(self):
+        member = self.membership.getMemberById(TEST_USER_ID)
+        self.assertNotEqual(member, None)
+        self.assertEqual(member.__class__.__name__, 'MemberData')
+        self.assertEqual(member.aq_parent.__class__.__name__, 'PloneUser')
+
+    def testGetAuthenticatedMember(self):
+        member = self.membership.getAuthenticatedMember()
+        self.assertEqual(member.getUserName(), TEST_USER_NAME)
+
+    def testGetAuthenticatedMemberIsWrapped(self):
+        member = self.membership.getAuthenticatedMember()
+        self.assertEqual(member.getUserName(), TEST_USER_NAME)
+        self.assertEqual(member.__class__.__name__, 'MemberData')
+        self.assertEqual(member.aq_parent.__class__.__name__, 'PloneUser')
+
+    def testGetAuthenticatedMemberIfAnonymous(self):
+        self.logout()
+        member = self.membership.getAuthenticatedMember()
+        self.assertEqual(member.getUserName(), 'Anonymous User')
+
+    def testAnonymousMemberIsNotWrapped(self):
+        # Also see http://dev.plone.org/plone/ticket/1851
+        self.logout()
+        member = self.membership.getAuthenticatedMember()
+        self.assertNotEqual(member.__class__.__name__, 'MemberData')
+        self.assertEqual(member.__class__.__name__, 'SpecialUser')
+
+    def testIsAnonymousUser(self):
+        self.assertFalse(self.membership.isAnonymousUser())
+        self.logout()
+        self.assertTrue(self.membership.isAnonymousUser())
+
+    def testWrapUserWrapsBareUser(self):
+        user = self.portal.acl_users.getUserById(TEST_USER_ID)
+        # TODO: GRUF users are wrapped
+        self.assertTrue(hasattr(user, 'aq_base'))
+        user = aq_base(user)
+        user = self.membership.wrapUser(user)
+        self.assertEqual(user.__class__.__name__, 'MemberData')
+        self.assertEqual(user.aq_parent.__class__.__name__, 'PloneUser')
+        self.assertEqual(user.aq_parent.aq_parent.__class__.__name__,
+                         'PluggableAuthService')
+
+    def testWrapUserWrapsWrappedUser(self):
+        user = self.portal.acl_users.getUserById(TEST_USER_ID)
+        # TODO: GRUF users are wrapped
+        self.assertTrue(hasattr(user, 'aq_base'))
+        user = self.membership.wrapUser(user)
+        self.assertEqual(user.__class__.__name__, 'MemberData')
+        self.assertEqual(user.aq_parent.__class__.__name__, 'PloneUser')
+        self.assertEqual(user.aq_parent.aq_parent.__class__.__name__,
+                         'PluggableAuthService')
+
+    def testWrapUserDoesntWrapMemberData(self):
+        user = self.portal.acl_users.getUserById(TEST_USER_ID)
+        user.getMemberId = lambda x: 1
+        user = self.membership.wrapUser(user)
+        self.assertEqual(user.__class__.__name__, 'PloneUser')
+
+    def testWrapUserDoesntWrapAnonymous(self):
+        user = self.membership.wrapUser(nobody)
+        self.assertEqual(user.__class__.__name__, 'SpecialUser')
+
+    def testWrapUserWrapsAnonymous(self):
+        self.assertFalse(hasattr(nobody, 'aq_base'))
+        user = self.membership.wrapUser(nobody, wrap_anon=1)
+        self.assertEqual(user.__class__.__name__, 'MemberData')
+        self.assertEqual(user.aq_parent.__class__.__name__, 'SpecialUser')
+        self.assertEqual(user.aq_parent.aq_parent.__class__.__name__,
+                         'PluggableAuthService')
+
+    def testGetCandidateLocalRoles(self):
+        self.assertEqual(self.membership.getCandidateLocalRoles(self.folder),
+                         ('Owner',))
+        self.setRoles(['Member', 'Reviewer'])
+        self.assertEqual(self.membership.getCandidateLocalRoles(self.folder),
+                         ('Owner', 'Reviewer'))
+
+    def testSetLocalRoles(self):
+        self.assertTrue(
+            'Owner' in self.folder.get_local_roles_for_userid(TEST_USER_ID))
+        self.setRoles(['Member', 'Reviewer'])
+        self.membership.setLocalRoles(self.folder, [TEST_USER_ID, 'user2'],
+                                      'Reviewer')
+        self.assertEqual(self.folder.get_local_roles_for_userid(TEST_USER_ID),
+                         ('Owner', 'Reviewer'))
+        self.assertEqual(self.folder.get_local_roles_for_userid('user2'),
+                         ('Reviewer',))
+
+    def testDeleteLocalRoles(self):
+        self.setRoles(['Member', 'Reviewer'])
+        self.membership.setLocalRoles(self.folder, ['user2'], 'Reviewer')
+        self.assertEqual(self.folder.get_local_roles_for_userid('user2'),
+                         ('Reviewer',))
+        self.membership.deleteLocalRoles(self.folder, ['user2'])
+        self.assertEqual(self.folder.get_local_roles_for_userid('user2'), ())
+
+    def testGetHomeFolder(self):
+        self.assertNotEqual(self.membership.getHomeFolder(), None)
+        self.assertEqual(self.membership.getHomeFolder('user2'), None)
+
+    def testGetHomeUrl(self):
+        self.assertNotEqual(self.membership.getHomeUrl(), None)
+        self.assertEqual(self.membership.getHomeUrl('user2'), None)
+
+    def testGetAuthenticatedMemberInfo(self):
+        member = self.membership.getAuthenticatedMember()
+        member.setMemberProperties({'fullname': 'Test user'})
+        info = self.membership.getMemberInfo()
+        self.assertEqual(info['fullname'], 'Test user')
+
+    def testGetMemberInfo(self):
+        self.membership.addMember('user2', 'secret', ['Member'], [],
+                                  properties={'fullname': 'Second user'})
+        info = self.membership.getMemberInfo('user2')
+        self.assertEqual(info['fullname'], 'Second user')
+
+    def testGetCandidateLocalRolesIncludesLocalRolesOnObjectForManager(self):
+        self.folder._addRole('my_test_role')
+        self.folder.manage_setLocalRoles(TEST_USER_ID,
+                                         ('Manager', 'Owner'))
+        roles = self.membership.getCandidateLocalRoles(self.folder)
+        self.assertTrue('my_test_role' in roles,
+                        'my_test_role not in: %s' % str(roles))
+
+    def testGetCandidateLocalRolesIncludesLocalRolesOnObjectForAssignees(self):
+        self.folder._addRole('my_test_role')
+        self.folder.manage_setLocalRoles(TEST_USER_ID,
+                                         ('my_test_role', 'Owner'))
+        roles = self.membership.getCandidateLocalRoles(self.folder)
+        self.assertTrue('Owner' in roles)
+        self.assertTrue('my_test_role' in roles)
+        self.assertEqual(len(roles), 2)
+
+    def testGetCandidateLocalRolesForManager(self):
+        self.folder._addRole('my_test_role')
+        self.folder.manage_setLocalRoles(TEST_USER_ID, ('Manager', 'Owner'))
+        roles = self.membership.getCandidateLocalRoles(self.folder)
+        self.assertTrue('Manager' in roles)
+        self.assertTrue('Owner' in roles)
+        self.assertTrue('Reviewer' in roles)
+
+    def testGetCandidateLocalRolesForOwner(self):
+        self.folder._addRole('my_test_role')
+        roles = self.membership.getCandidateLocalRoles(self.folder)
+        self.assertTrue('Owner' in roles)
+        self.assertEqual(len(roles), 1)
+
+    def testGetCandidateLocalRolesForAssigned(self):
+        self.folder._addRole('my_test_role')
+        self.folder.manage_setLocalRoles(TEST_USER_ID, ('Reviewer', 'Owner'))
+        roles = self.membership.getCandidateLocalRoles(self.folder)
+        self.assertTrue('Owner' in roles)
+        self.assertTrue('Reviewer' in roles)
+        self.assertEqual(len(roles), 2)
+
+    def test_bug4333_delete_user_remove_memberdata(self):
+        # delete user should delete portal_memberdata
+        memberdata = self.portal.portal_memberdata
+        self.setRoles(['Manager'])
+        self.addMember('barney', 'Barney Rubble', 'barney@bedrock.com',
+                       ['Member'], '2002-01-01')
+        barney = self.membership.getMemberById('barney')
+        self.assertEqual(barney.getProperty('email'), 'barney@bedrock.com')
+        del barney
+
+        self.membership.deleteMembers(['barney'])
+        md = memberdata._members
+        self.assertFalse('barney' in md)
+
+        # There is an _v_ variable that is killed at the end of each request
+        # which stores a temporary version of the member object, this is
+        # a problem in this test.  In fact, this test does not really
+        # demonstrate the bug, which is actually caused by the script not
+        # using the tool.
+        memberdata._v_temps = None
+
+        self.membership.addMember('barney', 'secret', ['Member'], [])
+        barney = self.membership.getMemberById('barney')
+        self.assertNotEqual(barney.getProperty('fullname'), 'Barney Rubble')
+        self.assertNotEqual(barney.getProperty('email'), 'barney@bedrock.com')
+
+    def testBogusMemberPortrait(self):
+        # Should change the portrait image
+        bad_file = dummy.File(data='<div>This is a lie!!!</div>',
+                              headers={'content_type': 'image/jpeg'})
+        self.assertRaises(IOError, self.membership.changeMemberPortrait,
+                          bad_file, TEST_USER_ID)
+
+    def testGetBadMembers(self):
+        # Should list members with bad images
+        # We should not have any bad images out of the box
+        self.assertEqual(self.membership.getBadMembers(), [])
+        # Let's add one
+        bad_file = Image(
+            id=TEST_USER_ID,
+            title='',
+            file=StringIO('<div>This is a lie!!!</div>')
+        )
+        # Manually set a bad image using private methods
+        self.portal.portal_memberdata._setPortrait(bad_file, TEST_USER_ID)
+        self.assertEqual(self.membership.getBadMembers(), [TEST_USER_ID])
+        # Try an empty image
+        empty_file = Image(id=TEST_USER_ID, title='', file=StringIO(''))
+        self.portal.portal_memberdata._setPortrait(empty_file, TEST_USER_ID)
+        self.assertEqual(self.membership.getBadMembers(), [])
+        # And a good image
+        self.membership.changeMemberPortrait(self.makeRealImage(),
+                                             TEST_USER_ID)
+        self.assertEqual(self.membership.getBadMembers(), [])
+
+    def beforeTearDown(self):
+        self._free_warning_output()
+
+
+class TestCreateMemberarea(base.TestCase):
+
+    def afterSetUp(self):
+        self.membership = self.portal.portal_membership
+        self.membership.addMember('user2', 'secret', ['Member'], [])
+
+    def testCreateMemberarea(self):
+        # Should create a memberarea for user2
+        if self.membership.memberareaCreationFlag is True:
+            self.membership.createMemberarea('user2')
+            memberfolder = self.membership.getHomeFolder('user2')
+            self.assertTrue(memberfolder,
+                            'createMemberarea failed to create memberarea')
+            # member area creation should be on by default
+            self.assertTrue(self.membership.getMemberareaCreationFlag())
+
+    def testCreatMemberareaUsesCurrentUser(self):
+        if self.membership.memberareaCreationFlag is True:
+            # Should create a memberarea for user2
+            self.login('user2')
+            self.membership.createMemberarea()
+            memberfolder = self.membership.getHomeFolder('user2')
+            self.assertTrue(
+                memberfolder,
+                'createMemberarea failed to create memberarea for current '
+                'user'
+            )
+        else:
+            pass
+
+    def testNoMemberareaIfNoMembersFolder(self):
+        # Should not create a memberarea if the Members folder is missing
+        self.portal._delObject('Members')
+        self.membership.createMemberarea('user2')
+        memberfolder = self.membership.getHomeFolder('user2')
+        self.assertFalse(
+            memberfolder,
+            'createMemberarea unexpectedly created a memberarea'
+        )
+
+    def testNoMemberareaIfMemberareaExists(self):
+        # Should not attempt to create a memberarea if a memberarea already
+        # exists
+        self.membership.createMemberarea('user2')
+        # The second call should do nothing (not cause an error)
+        self.membership.createMemberarea('user2')
+
+    def testNotifyScriptIsCalled(self):
+        # The notify script should be called
+        if self.membership.memberareaCreationFlag is True:
+            self.portal.notifyMemberAreaCreated = dummy.Raiser(dummy.Error)
+            self.assertRaises(dummy.Error, self.membership.createMemberarea,
+                              'user2')
+
+    def testCreateMemberareaAlternateName(self):
+        # Alternate method name 'createMemberaArea' should work
+        if self.membership.memberareaCreationFlag is True:
+            self.membership.createMemberArea('user2')
+            memberfolder = self.membership.getHomeFolder('user2')
+            self.assertTrue(memberfolder,
+                            'createMemberArea failed to create memberarea')
+
+    def testCreateMemberareaAlternateType(self):
+        # Should be able to create another type instead of a normal Folder
+        if self.membership.memberareaCreationFlag is True:
+            self.membership.setMemberAreaType('Document')
+            self.membership.createMemberarea('user2')
+            memberfolder = self.membership.getHomeFolder('user2')
+            self.assertEqual(memberfolder.getPortalTypeName(), 'Document')
+
+    def testCreateMemberareaWhenDisabled(self):
+        # Should not create a member area
+        self.membership.setMemberareaCreationFlag = False
+        self.assertFalse(self.membership.getMemberareaCreationFlag())
+        self.membership.createMemberarea('user2')
+        memberfolder = self.membership.getHomeFolder('user2')
+        self.assertFalse(
+            memberfolder,
+            'createMemberarea created memberarea despite flag'
+        )
+
+
+class TestMemberareaSetup(base.TestCase):
+
+    def afterSetUp(self):
+        self.membership = self.portal.portal_membership
+        self.membership.addMember('user2', 'secret', ['Member'], [])
+        self.membership.createMemberarea('user2')
+        self.home = self.membership.getHomeFolder('user2')
+
+    def testMemberareaIsFolder(self):
+        if self.membership.memberareaCreationFlag is True:
+            # Memberarea should be a folder
+            self.assertEqual(self.home.meta_type, 'ATFolder')
+            self.assertEqual(self.home.portal_type, 'Folder')
+
+    def testMemberareaIsOwnedByMember(self):
+        if self.membership.memberareaCreationFlag is True:
+            # Memberarea should be owned by member
+            try:
+                owner_info = self.home.getOwnerTuple()
+            except AttributeError:
+                owner_info = self.home.getOwner(info=1)
+            self.assertEqual(owner_info[0], [PLONE_SITE_ID, 'acl_users'])
+            self.assertEqual(owner_info[1], 'user2')
+            self.assertEqual(len(self.home.get_local_roles()), 1)
+            self.assertEqual(self.home.get_local_roles_for_userid('user2'),
+                             ('Owner',))
+
+    def testMemberareaIsCataloged(self):
+        if self.membership.memberareaCreationFlag is True:
+            # Memberarea should be cataloged
+            catalog = self.portal.portal_catalog
+            self.assertTrue(catalog(id='user2', Type='Folder', Title="user2"),
+                            "Could not find user2's home folder in the "
+                            "catalog")
+
+    def testHomePageNotExists(self):
+        if self.membership.memberareaCreationFlag is True:
+            # Should not have an index_html document anymore
+            self.assertFalse('index_html' in self.home)
+
+
+class TestSearchForMembers(base.TestCase, WarningInterceptor):
+
+    def afterSetUp(self):
+        self.memberdata = self.portal.portal_memberdata
+        self.membership = self.portal.portal_membership
+        # Don't let default_user disturb results
+        self.portal.acl_users._doDelUsers([TEST_USER_ID])
+        # Add some members
+        self.addMember('fred', 'Fred Flintstone',
+                       'fred@bedrock.com', ['Member', 'Reviewer'],
+                       '2002-01-01')
+        self.addMember('barney', 'Barney Rubble',
+                       'barney@bedrock.com', ['Member'],
+                       '2002-01-01')
+        self.addMember('brubble', 'Bambam Rubble',
+                       'bambam@bambam.net', ['Member'],
+                       '2003-12-31')
+        # MUST reset this
+        self.memberdata._v_temps = None
+        self._trap_warning_output()
+
+    def addMember(self, username, fullname, email, roles, last_login_time):
+        self.membership.addMember(username, 'secret', roles, [])
+        member = self.membership.getMemberById(username)
+        member.setMemberProperties({
+            'fullname': fullname,
+            'email': email,
+            'last_login_time': DateTime(last_login_time), })
+
+    def testSearchById(self):
+        # Should search id and fullname
+        search = self.membership.searchForMembers
+        self.assertEqual(len(search(name='brubble')), 0)
+        self.assertEqual(len(search(name='barney')), 1)
+        self.assertEqual(len(search(name='rubble')), 2)
+
+    def testSearchByName(self):
+        # Should search id and fullname
+        search = self.membership.searchForMembers
+        self.assertEqual(len(search(name='rubble')), 2)
+        self.assertEqual(len(search(name='stone')), 1)
+
+    def testSearchByEmail(self):
+        search = self.membership.searchForMembers
+        self.assertEqual(len(search(email='bedrock')), 2)
+        self.assertEqual(len(search(email='bambam')), 1)
+
+    def testSearchByRoles(self):
+        search = self.membership.searchForMembers
+        self.assertEqual(len(search(roles=['Member'])), 3)
+        self.assertEqual(len(search(roles=['Reviewer'])), 1)
+
+    def testSearchByNameAndEmail(self):
+        search = self.membership.searchForMembers
+        self.assertEqual(len(search(name='rubble', email='bedrock')), 1)
+        self.assertEqual(len(search(name='bambam', email='bedrock')), 0)
+
+    def testSearchByNameAndRoles(self):
+        search = self.membership.searchForMembers
+        self.assertEqual(len(search(name='fred', roles=['Reviewer'])), 1)
+        self.assertEqual(len(search(name='fred', roles=['Manager'])), 0)
+
+    def testSearchByEmailAndRoles(self):
+        search = self.membership.searchForMembers
+        self.assertEqual(len(search(email='fred', roles=['Reviewer'])), 1)
+        self.assertEqual(len(search(email='fred', roles=['Manager'])), 0)
+
+    def testSearchByRequestObj(self):
+        search = self.membership.searchForMembers
+        self.addMember(u'jürgen', u'Jürgen Internationalist',
+                       'juergen@example.com', ['Member'],
+                       '2014-02-03')
+
+        self.assertEqual(len(search(
+            REQUEST=dict(name=u'jürgen'))), 1)
+
+        ptool = getUtility(IPropertiesTool)
+        ptool._setProperty('default_charset', 'iso8859-1')
+        self.assertEqual(len(search(
+            REQUEST=dict(name=u'jürgen'.encode('iso8859-1')))), 1)
+
+    def beforeTearDown(self):
+        self._free_warning_output()
+
+
+class TestDefaultUserAndPasswordNotChanged(base.TestCase):
+    # A test for a silly transaction/persistency bug in PlonePAS
+
+    def afterSetUp(self):
+        self.membership = self.portal.portal_membership
+
+    def testDefaultUserAndPasswordUnchanged(self):
+        member = self.membership.getAuthenticatedMember()
+        self.assertEqual(member.getUserName(), TEST_USER_NAME)
+        self.assertTrue(
+            self.membership.testCurrentPassword(TEST_USER_PASSWORD)
+        )
+        self.assertFalse(self.membership.testCurrentPassword('geheim'))
+
+
+class TestMethodProtection(base.TestCase):
+    # MembershipTool is missing security declarations
+    # http://dev.plone.org/plone/ticket/5432
+
+    _unprotected = (
+        'changeMemberPortrait',
+        'deletePersonalPortrait',
+        'testCurrentPassword',
+        'searchForMembers',
+    )
+
+    def afterSetUp(self):
+        self.membership = self.portal.portal_membership
+
+    def assertUnprotected(self, object, method):
+        self.logout()
+        object.restrictedTraverse(method)
+
+    def assertProtected(self, object, method):
+        self.logout()
+        self.assertRaises(Unauthorized, object.restrictedTraverse, method)
+
+    for method in _unprotected:
+        exec "def testUnprotected_%s(self):" \
+             "    self.assertProtected(self.membership, '%s')" \
+                % (method, method)
+
+        exec "def testMemberAccessible_%s(self):" \
+             "    self.membership.restrictedTraverse('%s')" % (method, method)
+
+
+class TestMemberInfoView(base.TestCase):
+
+    def afterSetUp(self):
+        self.membership = self.portal.portal_membership
+        self.view = PASMemberView(self.portal, self.portal.REQUEST)
+
+    def testMemberInfoViewForAuthenticated(self):
+        member = self.membership.getAuthenticatedMember()
+        member.setMemberProperties({'fullname': 'Test user'})
+        info = self.view.info()
+        self.assertEqual(info['username'], 'test-user')
+        self.assertEqual(info['fullname'], 'Test user')
+        self.assertEqual(info['name_or_id'], 'Test user')
+
+    def testGetMemberInfoViewForMember(self):
+        self.membership.addMember('user2', 'secret', ['Member'], [],
+                                  properties={'fullname': 'Second user'})
+        info = self.view.info('user2')
+        self.assertEqual(info['username'], 'user2')
+        self.assertEqual(info['fullname'], 'Second user')
+        self.assertEqual(info['name_or_id'], 'Second user')
+
+    def testGetMemberInfoViewForNonMember(self):
+        # When content is owned by a user who has meanwhile been
+        # removed, we do not want to throw an exception when asking
+        # for his member info.
+        self.assertFalse(self.membership.getMemberById('charon'))
+        info = self.view.info('charon')
+        self.assertEqual(info['username'], 'charon')
+        self.assertEqual(info['fullname'], '')
+        self.assertEqual(info['name_or_id'], 'charon')
+
+    def testGetMemberInfoViewForAnonymous(self):
+        self.logout()
+        self.assertTrue(self.membership.isAnonymousUser())
+        info = self.view.info()
+        self.assertEqual(info['username'], 'Anonymous User')
+        self.assertEqual(info['fullname'], None)
+        self.assertEqual(info['name_or_id'], 'Anonymous User')
+
+    def testSetGroupsWithUserNameIdDifference(self):
+        pas = self.portal['acl_users']
+        self.portal.portal_groups.addGroup('Editors', [], [])
+        self.setGroups(['Editors'], name=TEST_USER_ID)
+        self.login(TEST_USER_NAME)
+        user = getSecurityManager().getUser()
+        self.assertTrue(
+            'Editors' in getGroupsForPrincipal(user, pas['plugins'])
+        )
+        self.login()
+
+    def testSetGroupsWithSameUserNameAndId(self):
+        pas = self.portal['acl_users']
+        self.portal.portal_groups.addGroup('Editors', [], [])
+        self.setGroups(['Editors'])
+        user = getSecurityManager().getUser()
+        self.assertTrue(
+            'Editors' in getGroupsForPrincipal(user, pas['plugins'])
+        )
diff --git a/src/Products/PlonePAS/tests/test_properties.py b/src/Products/PlonePAS/tests/test_properties.py
new file mode 100644
index 0000000..d2e808f
--- /dev/null
+++ b/src/Products/PlonePAS/tests/test_properties.py
@@ -0,0 +1,287 @@
+# -*- coding: utf-8 -*-
+from Products.CMFCore.utils import getToolByName
+from Products.PlonePAS.plugins.property import ZODBMutablePropertyProvider
+from Products.PlonePAS.tests import base
+from Products.PluggableAuthService.interfaces.plugins import \
+    IUserEnumerationPlugin
+
+
+class PropertiesTest(base.TestCase):
+
+    def test_user_properties(self):
+        mt = getToolByName(self.portal, 'portal_membership')
+        md = getToolByName(self.portal, 'portal_memberdata')
+
+        # Create a new Member
+        mt.addMember('user1', 'u1', ['Member'], [],
+                     {'email': 'user1@host.com',
+                      'fullname': 'User #1'})
+        member = mt.getMemberById('user1')
+        self.assertFalse(member is None)
+
+        # Assert user doesn't have the property yet
+        self.assertFalse(member.hasProperty('age'))
+
+        # Add new property
+        md.manage_addProperty('age', 20, 'int')
+
+        # Assert user has the property now
+        self.assertTrue(member.hasProperty('age'))
+
+        # Get the property, should have the default value
+        got = member.getProperty('age', None)
+        expected = 20
+        self.assertEqual(got, expected)
+
+        # get a handle on the member
+        member = mt.getMemberById('user1')
+
+        # Set some member properties. Needs to be logged in as the user.
+        self.login('user1')
+        member.setMemberProperties({'age': 30, 'fullname': 'User #1 Is Cool',
+                                    'email': 'user1@anotherhost.qa'})
+
+        # Check the properties have been set
+        got = member.getProperty('age', None)
+        expected = 30
+        self.assertEqual(got, expected)
+
+        got = member.getProperty('fullname', None)
+        expected = 'User #1 Is Cool'
+        self.assertEqual(got, expected)
+
+        got = member.getProperty('email', None)
+        expected = 'user1@anotherhost.qa'
+        self.assertEqual(got, expected)
+
+        # Delete the property
+        md.manage_delProperties(ids=('age',))
+
+        # re-get the member to reflect the new memberdata schema
+        member = mt.getMemberById('user1')
+
+        # Assert property is gone
+        self.assertFalse(member.hasProperty('age'))
+
+        # Get the property, should return default (None)
+        got = member.getProperty('age', None)
+        expected = None
+        self.assertEqual(got, expected)
+
+        # Other properties should still be there.
+        got = member.getProperty('fullname', None)
+        expected = 'User #1 Is Cool'
+        self.assertEqual(got, expected)
+
+        got = member.getProperty('email', None)
+        expected = 'user1@anotherhost.qa'
+        self.assertEqual(got, expected)
+
+    def test_group_properties(self):
+        gt = getToolByName(self.portal, 'portal_groups')
+        gd = getToolByName(self.portal, 'portal_groupdata')
+
+        self.loginAsPortalOwner()
+
+        # Create a new Group
+        gt.addGroup(
+            'group1',
+            ['Reviewer'],
+            [],
+            {'email': 'group1@host.com', 'title': 'Group #1'}
+        )
+        group = gt.getGroupById('group1')
+        self.assertFalse(group is None)
+
+        # Assert group doesn't have the property yet
+        self.assertFalse(group.hasProperty('karma'))
+
+        # Add new property
+        gd.manage_addProperty('karma', 20, 'int')
+
+        # get group again to re-create with new groupdata schema
+        group = gt.getGroupById('group1')
+
+        # Assert group has the property now
+        self.assertTrue(group.hasProperty('karma'))
+
+        # Get the property, should have the default value
+        got = group.getProperty('karma', None)
+        expected = 20
+
+        self.assertEqual(got, expected)
+
+        # Set some group properties
+        group.setGroupProperties({'karma': 30, 'title': 'Group #1 Is Cool',
+                                  'email': 'group1@anotherhost.qa'})
+
+        # Check the properties have been set
+        got = group.getProperty('karma', None)
+        expected = 30
+        self.assertEqual(got, expected)
+
+        got = group.getProperty('title', None)
+        expected = 'Group #1 Is Cool'
+        self.assertEqual(got, expected)
+
+        got = group.getProperty('email', None)
+        expected = 'group1@anotherhost.qa'
+        self.assertEqual(got, expected)
+
+        # Delete the property
+        gd.manage_delProperties(ids=('karma',))
+
+        # get group again to re-create with new groupdata schema
+        group = gt.getGroupById('group1')
+
+        # Assert property is gone
+        self.assertFalse(group.hasProperty('karma'))
+
+        # Get the property, should return default (None)
+        got = group.getProperty('karma', None)
+        expected = None
+        self.assertEqual(got, expected)
+
+        # Other properties should still be there.
+        got = group.getProperty('title', None)
+        expected = 'Group #1 Is Cool'
+        self.assertEqual(got, expected)
+
+        got = group.getProperty('email', None)
+        expected = 'group1@anotherhost.qa'
+        self.assertEqual(got, expected)
+
+    def test_schema_for_mutable_property_provider(self):
+        """Add a schema to a ZODBMutablePropertyProvider.
+        """
+
+        # Schema is list of tuples with name, type (string), value.
+        # From the types it seems only 'lines' is handled differently.
+        address_schema = [
+            ('addresses', 'lines', ['Here', 'There']),
+            ('city', 'str', 'Somewhere'),
+            ('telephone', 'int', 1234567),
+            ]
+
+        # This used to give a ValueError, so we just check that it
+        # does not.
+        provider = ZODBMutablePropertyProvider(
+            'address_plugin', "Address Plugin", schema=address_schema)
+
+        # When this test passes, we are happy already, but let's add a
+        # few more basic tests.
+
+        # Create a new Member
+        mt = getToolByName(self.portal, 'portal_membership')
+        mt.addMember('user1', 'u1', ['Member'], [],
+                     {'email': 'user1@host.com',
+                      'fullname': 'User #1'})
+        member = mt.getMemberById('user1')
+        sheet = provider.getPropertiesForUser(member)
+        self.assertEqual(
+            sheet.propertyIds(), ['addresses', 'city', 'telephone'])
+        self.assertEqual(sheet.propertyInfo('city'),
+                         {'type': 'str', 'id': 'city', 'mode': ''})
+        self.assertEqual(sheet.getProperty('addresses'), ('Here', 'There'))
+
+
+class PropertySearchTest(base.TestCase):
+
+    def afterSetUp(self):
+        self.mt = getToolByName(self.portal, 'portal_membership')
+        self.md = getToolByName(self.portal, 'portal_memberdata')
+        self.gt = getToolByName(self.portal, 'portal_groups')
+
+        # Create a new Member
+        self.mt.addMember(
+            'member1',
+            'pw',
+            ['Member'],
+            [],
+            {'email': 'member1@host.com', 'title': 'Member #1'}
+        )
+        member = self.mt.getMemberById('member1')
+        self.assertFalse(member is None)
+
+        self.mt.addMember(
+            'member2',
+            'pw',
+            ['Member'],
+            [],
+            {'email': 'user2@otherhost.com', 'fullname': 'User #2'}
+        )
+        member = self.mt.getMemberById('member2')
+        self.assertFalse(member is None)
+
+        # Add a Group to make sure searchUsers isn't returning them in results.
+        self.gt.addGroup('group1', title="Group 1")
+        group = self.gt.getGroupById('group1')
+        self.assertFalse(group is None)
+
+        self.pas = getToolByName(self.portal, "acl_users")
+        for plugin in self.pas.plugins \
+                          .getAllPlugins('IUserEnumerationPlugin')['active']:
+            if plugin != 'mutable_properties':
+                self.pas.plugins.deactivatePlugin(IUserEnumerationPlugin,
+                                                  plugin)
+
+    def testPluginActivated(self):
+        plugins = self.pas.plugins \
+                      .getAllPlugins('IUserEnumerationPlugin')['active']
+        self.assertEqual(plugins, ('mutable_properties',))
+
+    def testEmptySearch(self):
+        results = self.pas.searchUsers()
+        self.assertEqual(len(results), 2)
+
+    def testInexactStringSearch(self):
+        results = self.pas.searchUsers(email="something@somewhere.tld")
+        self.assertEqual(results, ())
+
+        results = self.pas.searchUsers(email="member1@host.com",
+                                       exact_match=False)
+        results = [info['userid'] for info in results]
+        self.assertEqual(results, ['member1'])
+
+        results = self.pas.searchUsers(email="@host.com", exact_match=False)
+        results = [info['userid'] for info in results]
+        self.assertEqual(results, ['member1'])
+
+        results = self.pas.searchUsers(email="member1@host.com",
+                                       exact_match=True)
+        results = [info['userid'] for info in results]
+        self.assertEqual(results, ['member1'])
+
+        results = self.pas.searchUsers(email="@host.com", exact_match=True)
+        results = [info['userid'] for info in results]
+        self.assertEqual(results, [])
+
+    def testBooleanSearch(self):
+        results = self.pas.searchUsers(visible_ids=True)
+        results = [info['userid'] for info in results]
+        self.assertEqual(results, [])
+
+        results = self.pas.searchUsers(visible_ids=False)
+        results = [info['userid'] for info in results]
+        self.assertEqual(results, ['member1', 'member2'])
+
+    def testGroupsNotReturnedByEnumerateUsers(self):
+        """Check to make sure that groups aren't returned by a enumerateUsers
+           call.
+           See http://dev.plone.org/plone/ticket/9435"""
+        results = self.pas.searchUsers()
+        resultIds = [a['id'] for a in results]
+        self.assertFalse('group1' in resultIds)
+
+    def testSearchEmptyId(self):
+        self.assertEqual(self.pas.mutable_properties.enumerateUsers(id=''), ())
+        self.assertEqual(
+                self.pas.mutable_properties.enumerateUsers(login=''), ())
+
+    def testCantSearchByIdOrLogin(self):
+        # we can't search by id
+        results = self.pas.searchUsers(id='member1')
+        self.assertEqual(results, ())
+        # or login
+        results = self.pas.searchUsers(login='member1')
+        self.assertEqual(results, ())
diff --git a/src/Products/PlonePAS/tests/test_role_plugin.py b/src/Products/PlonePAS/tests/test_role_plugin.py
new file mode 100644
index 0000000..00ec703
--- /dev/null
+++ b/src/Products/PlonePAS/tests/test_role_plugin.py
@@ -0,0 +1,86 @@
+# -*- coding: utf-8 -*-
+# $Id$
+"""Tests for Products.PlonePAS.plugins.role.GroupAwareRoleManager"""
+
+from Products.PlonePAS.tests import base
+from Products.PluggableAuthService.PluggableAuthService import \
+    _PLUGIN_TYPE_INFO
+from Products.PluggableAuthService.interfaces.plugins import IGroupsPlugin
+from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from Products.PluggableAuthService.plugins.tests.helpers import DummyUser
+from Products.PluggableAuthService.plugins.tests.helpers import FauxPAS
+from Products.PluggableAuthService.plugins.tests.helpers import \
+    makeRequestAndResponse
+from Products.PluginRegistry.PluginRegistry import PluginRegistry
+from zope.interface import implementer
+
+
+@implementer(IGroupsPlugin)
+class FauxGroupsPlugin(BasePlugin):
+
+    def getGroupsForPrincipal(self, principal, request=None):
+        return principal._groups
+
+
+class GroupAwareRoleManagerTests(base.TestCase):
+    """Roles manager that takes care of goup of principal"""
+
+    def _getTargetClass(self):
+
+        from Products.PlonePAS.plugins.role import GroupAwareRoleManager
+        return GroupAwareRoleManager
+
+    def _makeOne(self, id='test', *args, **kw):
+
+        plugin = self._getTargetClass()(id=id, *args, **kw)
+        # We need to bind a fake request to this plugin
+        request, dummy_response = makeRequestAndResponse()
+        setattr(plugin, 'REQUEST', request)
+        return plugin
+
+    def test_roles_for_control_panel(self):
+        """There's a special case, the users control panel for which
+        we should never grant to users the roles they have got through
+        the groups they belong.
+        In that intent, the control panels view pushes
+        '__ignore_group_roles__' = True
+        in the request.
+        """
+        root = FauxPAS()
+
+        # Add a minimal PluginRegistry with a mock IGroupsPlugin, because the
+        # roles plugin depends on it:
+        root._setObject('plugins', PluginRegistry(_PLUGIN_TYPE_INFO))
+        root._setObject('groups', FauxGroupsPlugin())
+        root['plugins'].activatePlugin(IGroupsPlugin, 'groups')
+
+        garm = self._makeOne('garm').__of__(root)
+
+        # 2 roles
+        garm.addRole('foo_role')
+        garm.addRole('bar_role')
+
+        # Group 'somegroup' has 'bar_role'
+        garm.assignRoleToPrincipal('bar_role', 'somegroup')
+
+        # 'johndoe' has 'foo_role'
+        johndoe = DummyUser('johndoe', ('somegroup',))
+        garm.assignRoleToPrincipal('foo_role', 'johndoe')
+
+        # 'johndoe' should have 'foo_role' and 'bar_roles'
+        got = garm.getRolesForPrincipal(johndoe)
+        expected = ['foo_role', 'bar_role']
+        self.assertEqual(set(got), set(expected))
+
+        # For the users control panel, johndoe has only the 'foo_role'
+        garm.REQUEST.set('__ignore_group_roles__', True)
+        got = garm.getRolesForPrincipal(johndoe)
+        self.assertEqual(got, ('foo_role',))
+
+        # Confirm we can get only the inherited roles
+        garm.REQUEST.set('__ignore_group_roles__', False)
+        garm.REQUEST.set('__ignore_direct_roles__', True)
+        got = garm.getRolesForPrincipal(johndoe)
+        self.assertEqual(got, ('bar_role',))
+
+        return
diff --git a/src/Products/PlonePAS/tests/test_views.py b/src/Products/PlonePAS/tests/test_views.py
new file mode 100644
index 0000000..d0a7f60
--- /dev/null
+++ b/src/Products/PlonePAS/tests/test_views.py
@@ -0,0 +1,19 @@
+# -*- encoding: utf-8 -*-
+from Products.PlonePAS.tests import base
+
+
+class TestPASSearchView(base.TestCase):
+
+    def test_sort(self):
+        pas_search = self.portal.restrictedTraverse('@@pas_search')
+        values = [{'title': u'Sociologie'}, {'title': u'Économie'},
+                  {'title': u'anthropologie'}]
+        sorted_values = pas_search.sort(values, 'title')
+        # do not modify original
+        self.assertEqual(values,
+                         [{'title': u'Sociologie'}, {'title': u'Économie'},
+                          {'title': u'anthropologie'}])
+        # sorted here
+        self.assertEqual(sorted_values,
+                         [{'title': u'anthropologie'}, {'title': u'Économie'},
+                          {'title': u'Sociologie'}])
diff --git a/src/Products/PlonePAS/tool.gif b/src/Products/PlonePAS/tool.gif
new file mode 100644
index 0000000..2d866bb
Binary files /dev/null and b/src/Products/PlonePAS/tool.gif differ
diff --git a/src/Products/PlonePAS/tools/__init__.py b/src/Products/PlonePAS/tools/__init__.py
new file mode 100644
index 0000000..40a96af
--- /dev/null
+++ b/src/Products/PlonePAS/tools/__init__.py
@@ -0,0 +1 @@
+# -*- coding: utf-8 -*-
diff --git a/src/Products/PlonePAS/tools/groupdata.py b/src/Products/PlonePAS/tools/groupdata.py
new file mode 100644
index 0000000..615223e
--- /dev/null
+++ b/src/Products/PlonePAS/tools/groupdata.py
@@ -0,0 +1,523 @@
+# -*- coding: utf-8 -*-
+from AccessControl import ClassSecurityInfo
+from AccessControl import Permissions
+from AccessControl import Unauthorized
+from AccessControl import getSecurityManager
+from AccessControl.requestmethod import postonly
+from Acquisition import aq_base
+from Acquisition import aq_inner
+from Acquisition import aq_parent
+from App.class_init import InitializeClass
+from BTrees.OOBTree import OOBTree
+from OFS.PropertyManager import PropertyManager
+from OFS.SimpleItem import SimpleItem
+from Products.CMFCore.utils import UniqueObject
+from Products.CMFCore.utils import getToolByName
+from Products.CMFCore.utils import registerToolInterface
+from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
+from Products.PlonePAS.interfaces.capabilities import IManageCapabilities
+from Products.PlonePAS.interfaces.group import IGroupData
+from Products.PlonePAS.interfaces.group import IGroupDataTool
+from Products.PlonePAS.interfaces.group import IGroupManagement
+from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
+from Products.PlonePAS.tools.memberdata import MemberData
+from Products.PlonePAS.utils import CleanupTemp
+from Products.PluggableAuthService.PluggableAuthService import \
+    _SWALLOWABLE_PLUGIN_EXCEPTIONS
+from Products.PluggableAuthService.interfaces.authservice import \
+    IPluggableAuthService
+from ZPublisher.Converters import type_converters
+from zope.interface import implementer
+
+import logging
+
+logger = logging.getLogger('PlonePAS')
+_marker = object()
+
+
+@implementer(IGroupDataTool)
+class GroupDataTool(UniqueObject, SimpleItem, PropertyManager):
+    """This tool wraps group objects, allowing transparent access to
+    properties.
+    """
+
+    id = 'portal_groupdata'
+    meta_type = "PlonePAS GroupData Tool"
+    toolicon = 'tool.gif'
+
+    _v_temps = None
+    _properties = ({'id': 'title', 'type': 'string', 'mode': 'wd'},)
+    security = ClassSecurityInfo()
+
+    def __init__(self):
+        self._members = OOBTree()
+        # Create the default properties.
+        self._setProperty('description', '', 'text')
+        self._setProperty('email', '', 'string')
+
+    def wrapGroup(self, g):
+        """Returns an object implementing the GroupData interface."""
+
+        gid = g.getId()
+        members = self._members
+        if gid not in members:
+            # Get a temporary member that might be
+            # registered later via registerMemberData().
+            temps = self._v_temps
+            if temps is not None and gid in temps:
+                portal_group = temps[gid]
+            else:
+                base = aq_base(self)
+                portal_group = GroupData(base, gid)
+                if temps is None:
+                    self._v_temps = {gid: portal_group}
+                    if hasattr(self, 'REQUEST'):
+                        self.REQUEST._hold(CleanupTemp(self))
+                else:
+                    temps[gid] = portal_group
+        else:
+            portal_group = members[gid]
+        # Return a wrapper with self as containment and
+        # the user as context.
+        return portal_group.__of__(self).__of__(g)
+
+    @security.private
+    def registerGroupData(self, g, id):
+        '''
+        Adds the given member data to the _members dict.
+        This is done as late as possible to avoid side effect
+        transactions and to reduce the necessary number of
+        entries.
+        '''
+        self._members[id] = aq_base(g)
+
+
+InitializeClass(GroupDataTool)
+registerToolInterface('portal_groupdata', IGroupDataTool)
+
+
+@implementer(IGroupData, IManageCapabilities)
+class GroupData(SimpleItem):
+
+    security = ClassSecurityInfo()
+
+    id = None
+    _tool = None
+
+    def __init__(self, tool, id):
+        self.id = id
+        # Make a temporary reference to the tool.
+        # The reference will be removed by notifyModified().
+        self._tool = tool
+
+    def _getGRUF(self,):
+        return self.acl_users
+
+    @security.private
+    def notifyModified(self):
+        # Links self to parent for full persistence.
+        tool = getattr(self, '_tool', None)
+        if tool is not None:
+            del self._tool
+            tool.registerGroupData(self, self.getId())
+
+    @security.public
+    def getGroup(self):
+        """ Returns the actual group implementation. Varies by group
+        implementation (GRUF/Nux/et al). In GRUF this is a user object."""
+        # The user object is our context, but it's possible for
+        # restricted code to strip context while retaining
+        # containment.  Therefore we need a simple security check.
+        parent = aq_parent(self)
+        bcontext = aq_base(parent)
+        bcontainer = aq_base(aq_parent(aq_inner(self)))
+        if bcontext is bcontainer or not hasattr(bcontext, 'getUserName'):
+            raise 'GroupDataError', "Can't find group data"
+        # Return the user object, which is our context.
+        return parent
+
+    def getTool(self):
+        return aq_parent(aq_inner(self))
+
+    @security.public
+    def getGroupMemberIds(self):
+        """
+        Return a list of group member ids
+        """
+        return map(lambda x: x.getMemberId(), self.getGroupMembers())
+
+    @security.public
+    def getAllGroupMemberIds(self):
+        """
+        Return a list of group member ids
+        """
+        return map(lambda x: x.getMemberId(), self.getAllGroupMembers())
+
+    @security.public
+    def getGroupMembers(self):
+        """
+        Returns a list of the portal_memberdata-ish members of the group.
+        This doesn't include TRANSITIVE groups/users.
+        """
+        md = self.portal_memberdata
+        gtool = self.portal_groups
+        ret = []
+        for u_name in gtool.getGroupMembers(self.getId()):
+            usr = self._getGRUF().getUserById(u_name)
+            # getUserById from
+            #   Products.PluggableAuthService.PluggableAuthService
+            # The returned object is not wrapped, we wrapped it below
+            if not usr:
+                usr = self._getGRUF().getGroupById(u_name)
+                # getGroupById from Products.PlonePAS.pas
+                # The returned object is already wrapped
+                if not usr:
+                    logger.debug(
+                        "Group has a non-existing principal {0}".format(u_name)
+                    )
+                    continue
+                ret.append(usr)
+            else:
+                ret.append(md.wrapUser(usr))
+        return ret
+
+    @security.public
+    def getAllGroupMembers(self):
+        """
+        Returns a list of the portal_memberdata-ish members of the group.
+        This will include transitive groups / users
+        """
+        md = self.portal_memberdata
+        ret = []
+        for u_name in self.getGroup().getMemberIds():
+            usr = self._getGRUF().getUserById(u_name)
+            if not usr:
+                usr = self._getGRUF().getGroupById(u_name)
+                if not usr:
+                    logger.debug(
+                        "Group has a non-existing principal {0}".format(u_name)
+                    )
+                    continue
+                ret.append(usr)
+            else:
+                ret.append(md.wrapUser(usr))
+        return ret
+
+    def _getGroup(self):
+        """Get the underlying group object in a PAS-acceptable way.
+        (I don't even know why there's the two different ways for GRUF. Speed?)
+        """
+        return self.getGroup()
+
+    @security.private
+    def canAdministrateGroup(self):
+        """
+        Return true if the #current# user can administrate this group
+        """
+        user = getSecurityManager().getUser()
+        tool = self.getTool()
+        portal = getToolByName(tool, 'portal_url').getPortalObject()
+
+        # Has manager users pemission?
+        if user.has_permission(Permissions.manage_users, portal):
+            return True
+
+        # Is explicitly mentioned as a group administrator?
+        managers = self.getProperty('delegated_group_member_managers', ())
+        if user.getId() in managers:
+            return True
+
+        # Belongs to a group which is explicitly mentionned as a group
+        # administrator
+        meth = getattr(user, "getAllGroupNames", None)
+        if meth:
+            groups = meth()
+        else:
+            groups = ()
+        for v in groups:
+            if v in managers:
+                return True
+
+        # No right to edit this: we complain.
+        return False
+
+    @security.public
+    @postonly
+    def addMember(self, id, REQUEST=None):
+        """ Add the existing member with the given id to the group"""
+        if not self.canAdministrateGroup():
+            raise Unauthorized("You cannot add a member to the group.")
+
+        plugins = self._getPlugins()
+        managers = plugins.listPlugins(IGroupManagement)
+        for mid, manager in managers:
+            try:
+                if manager.addPrincipalToGroup(id, self.getId()):
+                    break
+            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+                pass
+
+    @security.public
+    @postonly
+    def removeMember(self, id, REQUEST=None):
+        """Remove the member with the provided id from the group.
+        """
+        if not self.canAdministrateGroup():
+            raise Unauthorized("You cannot remove a member from the group.")
+
+        plugins = self._getPlugins()
+        managers = plugins.listPlugins(IGroupManagement)
+        for mid, manager in managers:
+            try:
+                if manager.removePrincipalFromGroup(id, self.getId()):
+                    break
+            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+                pass
+
+    @security.protected(Permissions.manage_users)
+    def setProperties(self, properties=None, **kw):
+        """Allows the manager group to set his/her own properties.
+        Accepts either keyword arguments or a mapping for the "properties"
+        argument.
+        """
+        if properties is None:
+            properties = kw
+        return self.setGroupProperties(properties)
+
+    @security.protected(Permissions.manage_users)
+    def setGroupProperties(self, mapping):
+        """PAS-specific method to set the properties of a group.
+        """
+        sheets = None
+
+        if not IPluggableAuthService.providedBy(self.acl_users):
+            # Defer to base impl in absence of PAS, a PAS group, or
+            # property sheets
+            return self._gruf_setGroupProperties(mapping)
+        else:
+            # It's a PAS! Whee!
+            group = self.getGroup()
+            sheets = getattr(group, 'getOrderedPropertySheets', lambda: [])()
+
+            # We won't always have PlonePAS groups, due to acquisition,
+            # nor are guaranteed property sheets
+            if not sheets:
+                # Defer to base impl if we have a PAS but no property
+                # sheets.
+                return self._gruf_setGroupProperties(mapping)
+
+        # If we got this far, we have a PAS and some property sheets.
+        # XXX track values set to defer to default impl
+        # property routing?
+        modified = False
+        for k, v in mapping.items():
+            for sheet in sheets:
+                if not sheet.hasProperty(k):
+                    continue
+                if IMutablePropertySheet.providedBy(sheet):
+                    sheet.setProperty(group, k, v)
+                    modified = True
+                else:
+                    raise RuntimeError("Mutable property provider "
+                                       "shadowed by read only provider")
+        if modified:
+            self.notifyModified()
+
+    def _gruf_setGroupProperties(self, mapping):
+        '''Sets the properties of the member.
+        '''
+        # Sets the properties given in the MemberDataTool.
+        tool = self.getTool()
+        for id in tool.propertyIds():
+            if id in mapping:
+                if id not in self.__class__.__dict__:
+                    value = mapping[id]
+                    if isinstance(value, str):
+                        proptype = tool.getPropertyType(id) or 'string'
+                        if proptype in type_converters:
+                            value = type_converters[proptype](value)
+                    setattr(self, id, value)
+
+        # Hopefully we can later make notifyModified() implicit.
+        self.notifyModified()
+
+    @security.public
+    def getProperties(self):
+        """ Return the properties of this group. Properties are as usual
+            in Zope.
+        """
+        tool = self.getTool()
+        ret = {}
+        for pty in tool.propertyIds():
+            try:
+                ret[pty] = self.getProperty(pty)
+            except ValueError:
+                # We ignore missing ptys
+                continue
+        return ret
+
+    @security.public
+    def getProperty(self, id, default=None):
+        """PAS-specific method to fetch a group's properties. Looks
+        through the ordered property sheets.
+        """
+        group = self.getGroup()
+        sheets = getattr(group, 'getOrderedPropertySheets', lambda: [])()
+
+        # If we made this far, we found a PAS and some property sheets.
+        for sheet in sheets:
+            if sheet.hasProperty(id):
+                # Return the first one that has the property.
+                return sheet.getProperty(id)
+        # we won't always have PlonePAS groups, due to acquisition,
+        # nor are guaranteed property sheets
+        # Couldn't find the property in the property sheets. Try to
+        # delegate back to the base implementation.
+
+        tool = self.getTool()
+        base = aq_base(self)
+
+        # Then, check the user object, the tool, and attrs of myself for a
+        # value:
+        user_value = getattr(aq_base(self.getGroup()), id, _marker)
+        tool_value = tool.getProperty(id, _marker)
+        value = getattr(base, id, _marker)
+
+        # Take the first of the above that is filled out:
+        for v in [user_value, tool_value, value]:
+            if v is not _marker:
+                return v
+
+        return default
+
+    def __str__(self):
+        return self.getGroupId()
+
+    @security.public
+    def isGroup(self):
+        """
+        isGroup(self,) => Return true if this is a group.
+        Will always return true for groups.
+        As MemberData objects do not support this method, it is quite useless
+        by now.
+        So one can use groupstool.isGroup(g) instead to get this information.
+        """
+        return 1
+
+    # Group object interface ###
+
+    @security.public
+    def getGroupName(self):
+        return self.getName()
+
+    @security.public
+    def getGroupId(self):
+        """Get the ID of the group. The ID can be used, at least from
+        Python, to get the user from the user's UserDatabase.
+        Within Plone, all group ids are UNPREFIXED."""
+        return self.getGroup().getId()
+
+    def getGroupTitleOrName(self):
+        """Get the Title property of the group. If there is none
+        then return the name """
+        title = self.getProperty('title', None)
+        return title or self.getGroupName()
+
+    @security.public
+    def getMemberId(self):
+        """This exists only for a basic user/group API compatibility
+        """
+        return self.getGroupId()
+
+    @security.public
+    def getRoles(self):
+        """Return the list of roles assigned to a user."""
+        return self.getGroup().getRoles()
+
+    @security.public
+    def getRolesInContext(self, object):
+        """Return the list of roles assigned to the user,  including local
+        roles assigned in context of the passed in object."""
+        return self.getGroup().getRolesInContext(object)
+
+    @security.public
+    def getDomains(self):
+        """Return the list of domain restrictions for a user"""
+        return self.getGroup().getDomains()
+
+    @security.public
+    def has_role(self, roles, object=None):
+        """Check to see if a user has a given role or roles."""
+        return self.getGroup().has_role(roles, object)
+
+    ## GRUF 3.2 methods...
+
+    def getUserName(self):
+        return self.getName()
+    getUserNameWithoutGroupPrefix = getUserName
+
+    ## IManageCapabilities methods
+    def canDelete(self):
+        """True iff user can be removed from the Plone UI.
+        """
+        # IGroupManagement provides removeGroup
+        plugins = self._getPlugins()
+        managers = plugins.listPlugins(IGroupManagement)
+        if managers:
+            for mid, manager in managers:
+                if (IDeleteCapability.providedBy(manager) and
+                        manager.allowDeletePrincipal(self.getId())):
+                    return True
+        return False
+
+    def canPasswordSet(self):
+        """Always false for groups, which have no password.
+        """
+        return False
+
+    def passwordInClear(self):
+        """True iff password can be retrieved in the clear (not hashed.)
+
+        False for PAS. It provides no API for getting passwords,
+        though it would be possible to add one in the future.
+        """
+        return False
+
+    def _groupdataHasProperty(self, prop_name):
+        gdata = getToolByName(self, 'portal_groupdata', None)
+        if gdata:
+            return gdata.hasProperty(prop_name)
+        return 0
+
+    def canWriteProperty(self, prop_name):
+        """True iff the group property named in 'prop_name'
+        can be changed.
+        """
+        # this looks almost exactly like in memberdata. refactor?
+        if not IPluggableAuthService.providedBy(self.acl_users):
+            # not PAS; Groupdata is writable
+            return self._groupdataHasProperty(prop_name)
+        else:
+            # it's PAS
+            group = self.getGroup()
+            sheets = getattr(group, 'getOrderedPropertySheets', lambda: [])()
+            for sheet in sheets:
+                if not sheet.hasProperty(prop_name):
+                    continue
+                if IMutablePropertySheet.providedBy(sheet):
+                    return 1
+                else:
+                    break  # shadowed by read-only
+        return 0
+
+    canAddToGroup = MemberData.canAddToGroup.im_func
+    canRemoveFromGroup = MemberData.canRemoveFromGroup.im_func
+    canAssignRole = MemberData.canAssignRole.im_func
+
+    ## plugin getters
+
+    @security.private
+    def _getPlugins(self):
+        return self.acl_users.plugins
+
+InitializeClass(GroupData)
diff --git a/src/Products/PlonePAS/tools/groups.py b/src/Products/PlonePAS/tools/groups.py
new file mode 100644
index 0000000..90be6f0
--- /dev/null
+++ b/src/Products/PlonePAS/tools/groups.py
@@ -0,0 +1,440 @@
+# -*- coding: utf-8 -*-
+from AccessControl import ClassSecurityInfo
+from AccessControl.User import nobody
+from AccessControl.requestmethod import postonly
+from Acquisition import aq_base
+from App.class_init import InitializeClass
+from OFS.SimpleItem import SimpleItem
+from Products.CMFCore.utils import UniqueObject
+from Products.CMFCore.utils import getToolByName
+from Products.CMFCore.utils import registerToolInterface
+from Products.PlonePAS.interfaces import group as igroup
+from Products.PlonePAS.permissions import AddGroups
+from Products.PlonePAS.permissions import DeleteGroups
+from Products.PlonePAS.permissions import ManageGroups
+from Products.PlonePAS.permissions import SetGroupOwnership
+from Products.PlonePAS.permissions import ViewGroups
+from Products.PlonePAS.utils import getGroupsForPrincipal
+from Products.PluggableAuthService.PluggableAuthService import \
+    _SWALLOWABLE_PLUGIN_EXCEPTIONS
+from Products.PluggableAuthService.interfaces.plugins import \
+    IRoleAssignerPlugin
+from ZODB.POSException import ConflictError
+from zope.interface import implementer
+import logging
+
+logger = logging.getLogger('PluggableAuthService')
+
+
+class NotSupported(Exception):
+    pass
+
+
+@implementer(igroup.IGroupTool)
+class GroupsTool(UniqueObject, SimpleItem):
+    """ This tool accesses group data through a acl_users object.
+
+    It can be replaced with something that groups member data in a
+    different way.
+    """
+
+    id = 'portal_groups'
+    meta_type = 'PlonePAS Groups Tool'
+    security = ClassSecurityInfo()
+    toolicon = 'tool.gif'
+
+    ##
+    # basic group mgmt
+    ##
+
+    @security.protected(AddGroups)
+    @postonly
+    def addGroup(self, id, roles=[], groups=[], properties=None,
+                 REQUEST=None, *args, **kw):
+        """Create a group, with the supplied id, roles, and domains.
+
+        Underlying user folder must support adding users via the usual
+        Zope API.
+        """
+        group = None
+        success = 0
+        managers = self._getGroupManagers()
+        if roles is None:
+            roles = []
+        if groups is None:
+            groups = []
+
+        # Check to see if a user with the id already exists fail if it does
+        results = self.acl_users.searchPrincipals(id=id, exact_match=True)
+        if results:
+            return 0
+
+        if not managers:
+            raise NotSupported('No plugins allow for group management')
+        for mid, manager in managers:
+            success = manager.addGroup(id, title=kw.get('title', id),
+                                       description=kw.get('description', ''))
+            if success:
+                self.setRolesForGroup(id, roles)
+                for g in groups:
+                    manager.addPrincipalToGroup(g, id)
+                break
+
+        if success:
+            group = self.getGroupById(id)
+            group.setGroupProperties(properties or kw)
+
+        return success
+
+    @security.protected(ManageGroups)
+    @postonly
+    def editGroup(self, id, roles=None, groups=None, REQUEST=None,
+                  *args, **kw):
+        """Edit the given group with the supplied roles.
+
+        Passwords for groups seem to be irrelevant.
+        PlonePAS doesn't deal with domains either.
+
+        If group is not present, returns without exception.
+        """
+        g = self.getGroupById(id)
+        if not g:
+            raise KeyError('Trying to edit a non-existing group: %s' % id)
+
+        # Update title/description properties of original group
+        gTools = self._getGroupTools()
+        if not gTools:
+            raise NotSupported('No plugins allow for both group management '
+                               'and introspection')
+
+        for tid, tool in gTools:
+            if id in tool.getGroupIds():
+                tool.updateGroup(
+                    id,
+                    title=kw.get('title'),
+                    description=kw.get('description')
+                )
+                break
+
+        if roles is not None:
+            self.setRolesForGroup(id, roles)
+
+        g.setGroupProperties(kw)
+        if groups:
+            # remove absent groups
+            groupset = set(groups)
+            p_groups = set(self.getGroupsForPrincipal(g))
+            rmgroups = p_groups - groupset
+            for gid in rmgroups:
+                if gid != 'AuthenticatedUsers':
+                    self.removePrincipalFromGroup(g, gid)
+
+            # add groups
+            try:
+                groupmanagers = self.acl_users.plugins.listPlugins(
+                    igroup.IGroupManagement
+                )
+            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+                logger.exception('Plugin listing error')
+                groupmanagers = ()
+
+            for group in groups:
+                for gm_id, gm in groupmanagers:
+                    try:
+                        if gm.addPrincipalToGroup(id, group):
+                            break
+                    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+                        logger.exception(
+                            'AuthenticationPlugin {0} error'.format(gm_id)
+                        )
+
+    @security.protected(DeleteGroups)
+    @postonly
+    def removeGroup(self, group_id, REQUEST=None):
+        """Remove a single group.
+        """
+        retval = False
+        managers = self._getGroupManagers()
+        if not managers:
+            raise NotSupported('No plugins allow for group management')
+
+        for mid, manager in managers:
+            if manager.removeGroup(group_id):
+                retval = True
+
+        return retval
+
+    @security.protected(DeleteGroups)
+    @postonly
+    def removeGroups(self, ids, REQUEST=None):
+        """Remove the group in the provided list (if possible).
+        """
+        for gid in ids:
+            self.removeGroup(gid)
+
+    @security.protected(ManageGroups)
+    @postonly
+    def setRolesForGroup(self, group_id, roles=(), REQUEST=None):
+        rmanagers = self._getPlugins().listPlugins(IRoleAssignerPlugin)
+        if not (rmanagers):
+            raise NotImplementedError(
+                'There is no plugin that can assign roles to groups'
+            )
+        for rid, rmanager in rmanagers:
+            rmanager.assignRolesToPrincipal(roles, group_id)
+
+    ##
+    # basic principal mgmt
+    ##
+
+    @security.protected(ManageGroups)
+    @postonly
+    def addPrincipalToGroup(self, principal_id, group_id, REQUEST=None):
+        managers = self._getGroupManagers()
+        if not managers:
+            raise NotSupported('No plugins allow for group management')
+        for mid, manager in managers:
+            if manager.addPrincipalToGroup(principal_id, group_id):
+                return True
+        return False
+
+    @security.protected(ManageGroups)
+    @postonly
+    def removePrincipalFromGroup(self, principal_id, group_id, REQUEST=None):
+        managers = self._getGroupManagers()
+        if not managers:
+            raise NotSupported('No plugins allow for group management')
+        for mid, manager in managers:
+            if manager.removePrincipalFromGroup(principal_id, group_id):
+                return True
+        return False
+
+    ##
+    # group getters
+    ##
+
+    @security.protected(ViewGroups)
+    def getGroupById(self, group_id):
+        group = self.acl_users.getGroup(group_id)
+        if group is not None:
+            group = self.wrapGroup(group)
+        return group
+
+    @security.protected(ManageGroups)
+    def searchGroups(self, *args, **kw):
+        return self.acl_users.searchGroups(*args, **kw)
+
+    def searchForGroups(self, REQUEST={}, **kw):
+        """Search for groups by keyword.
+        The following properties can be searched:
+        - name
+        #- email
+        #- title
+
+        Only id/title search is implemented for groups. Is the rest of
+        this junk used anywhere?
+
+        This is an 'AND' request.
+
+        When it takes 'name' as keyword (or in REQUEST) and searches on
+        Full name and id.
+
+        Simple name searches are "fast".
+        """
+        acl_users = self.acl_users
+        if REQUEST:
+            dict = REQUEST
+        else:
+            dict = kw
+
+        name = dict.get('name', None)
+        title_or_name = dict.get('title_or_name', None)
+        if name:
+            name = name.strip().lower()
+        if name is not None:
+            name = None
+        if title_or_name is not None:
+            name = title_or_name
+
+        md_groups = []
+        uf_groups = []
+
+        if name is not None:
+            # This will allow us to retrieve groups by their id only
+            uf_groups = acl_users.searchGroups(id=name)
+
+            # PAS allows search to return dupes. We must winnow...
+            uf_groups_new = []
+            for group in uf_groups:
+                if group not in uf_groups_new:
+                    uf_groups_new.append(group)
+            uf_groups = uf_groups_new
+
+        groups = []
+        if md_groups or uf_groups:
+            getGroupById = self.getGroupById
+
+            for groupid in md_groups:
+                groups.append(getGroupById(groupid))
+            for group in uf_groups:
+                groupid = group['groupid']
+                if groupid in md_groups:
+                    continue             # Kill dupes
+                groups.append(getGroupById(groupid))
+
+        return groups
+
+    @security.protected(ViewGroups)
+    def listGroups(self):
+        # potentially not all groups may be found by this interface
+        # if the underlying group source doesn't support introspection
+        groups = []
+        introspectors = self._getGroupIntrospectors()
+        for iid, introspector in introspectors:
+            groups.extend(introspector.getGroups())
+        return [self.wrapGroup(elt) for elt in groups]
+
+    @security.protected(ViewGroups)
+    def getGroupIds(self):
+        groups = []
+        introspectors = self._getGroupIntrospectors()
+        for iid, introspector in introspectors:
+            groups.extend(introspector.getGroupIds())
+        return groups
+
+    listGroupIds = getGroupIds
+
+    @security.protected(ViewGroups)
+    def getGroupMembers(self, group_id):
+        members = set()
+        introspectors = self._getGroupIntrospectors()
+        for iid, introspector in introspectors:
+            members.update(introspector.getGroupMembers(group_id))
+        return list(members)
+
+    @security.protected(ViewGroups)
+    def getGroupsForPrincipal(self, principal):
+        return getGroupsForPrincipal(principal, self._getPlugins())
+
+    ##
+    # plugin getters
+    ##
+
+    @security.private
+    def _getPlugins(self):
+        return self.acl_users.plugins
+
+    @security.private
+    def _getGroupManagers(self):
+        return self._getPlugins().listPlugins(
+            igroup.IGroupManagement
+            )
+
+    @security.private
+    def _getGroupIntrospectors(self):
+        return self._getPlugins().listPlugins(
+            igroup.IGroupIntrospection
+            )
+
+    @security.private
+    def _getGroupTools(self):
+        managers = self._getPlugins().listPlugins(
+                        igroup.IGroupManagement)
+        return [(id, manager) for (id, manager) in managers
+                if igroup.IGroupIntrospection.providedBy(manager)]
+
+    ##
+    # BBB
+    ##
+
+    @security.public
+    def getGroupInfo(self, groupId):
+        """
+        Return default group info of any group
+        """
+        group = self.getGroupById(groupId)
+
+        if group is None:
+            return None
+
+        groupinfo = {'title': group.getProperty('title'),
+                     'description': group.getProperty('description')}
+
+        return groupinfo
+
+    @security.protected(ViewGroups)
+    def getGroupsByUserId(self, userid):
+        """Return a list of the groups the user corresponding to 'userid'
+        belongs to."""
+        user = self.acl_users.getUserById(userid)
+        if user:
+            groups = user.getGroups() or []
+        else:
+            groups = []
+        return [self.getGroupById(elt) for elt in groups]
+
+    @security.protected(ViewGroups)
+    def listGroupNames(self):
+        """Return a list of the available groups' ids as entered
+        (without group prefixes)."""
+        return self.acl_users.getGroupNames()
+
+    @security.public
+    def isGroup(self, u):
+        """Test if a user/group object is a group or not.
+        You must pass an object you get earlier with wrapUser() or wrapGroup()
+        """
+        base = aq_base(u)
+        if hasattr(base, "isGroup") and base.isGroup():
+            return 1
+        return 0
+
+    @security.protected(SetGroupOwnership)
+    @postonly
+    def setGroupOwnership(self, group, object, REQUEST=None):
+        """Make the object  'object' owned by group 'group'
+        (a portal_groupdata-ish object).
+
+        For GRUF this is easy. Others may have to re-implement."""
+        user = group.getGroup()
+        if user is None:
+            raise ValueError("Invalid group: '%s'." % (group, ))
+        object.changeOwnership(user)
+        object.manage_setLocalRoles(user.getId(), ['Owner'])
+
+    @security.private
+    def wrapGroup(self, g, wrap_anon=0):
+        ''' Sets up the correct acquisition wrappers for a group
+        object and provides an opportunity for a portal_memberdata
+        tool to retrieve and store member data independently of
+        the user object.
+        '''
+        b = getattr(g, 'aq_base', None)
+        if b is None:
+            # u isn't wrapped at all.  Wrap it in self.acl_users.
+            b = g
+            g = g.__of__(self.acl_users)
+        if (b is nobody and not wrap_anon) or hasattr(b, 'getMemberId'):
+            # This user is either not recognized by acl_users or it is
+            # already registered with something that implements the
+            # member data tool at least partially.
+            return g
+
+        parent = self.aq_inner.aq_parent
+        base = getattr(parent, 'aq_base', None)
+        if hasattr(base, 'portal_groupdata'):
+            # Get portal_groupdata to do the wrapping.
+            gd = getToolByName(parent, 'portal_groupdata')
+            try:
+                portal_group = gd.wrapGroup(g)
+                return portal_group
+            except ConflictError:
+                raise
+            except:
+                logger.exception('Error during wrapGroup')
+        # Failed.
+        return g
+
+
+InitializeClass(GroupsTool)
+registerToolInterface('portal_groups', igroup.IGroupTool)
diff --git a/src/Products/PlonePAS/tools/memberdata.py b/src/Products/PlonePAS/tools/memberdata.py
new file mode 100644
index 0000000..6d62f45
--- /dev/null
+++ b/src/Products/PlonePAS/tools/memberdata.py
@@ -0,0 +1,448 @@
+# -*- coding: utf-8 -*-
+from AccessControl import ClassSecurityInfo
+from AccessControl.requestmethod import postonly
+from Acquisition import aq_base
+from App.class_init import InitializeClass
+from Products.BTreeFolder2.BTreeFolder2 import BTreeFolder2
+from Products.CMFCore.MemberDataTool import MemberData as BaseMemberData
+from Products.CMFCore.MemberDataTool import MemberDataTool as BaseTool
+from Products.CMFCore.permissions import ManagePortal
+from Products.CMFCore.utils import getToolByName
+from Products.PlonePAS.interfaces.capabilities import IAssignRoleCapability
+from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
+from Products.PlonePAS.interfaces.capabilities import IGroupCapability
+from Products.PlonePAS.interfaces.capabilities import IManageCapabilities
+from Products.PlonePAS.interfaces.capabilities import IPasswordSetCapability
+from Products.PlonePAS.interfaces.group import IGroupManagement
+from Products.PlonePAS.interfaces.plugins import IUserManagement
+from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
+from Products.PluggableAuthService.interfaces.authservice import \
+    IPluggableAuthService
+from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
+from Products.PluggableAuthService.interfaces.plugins import \
+    IRoleAssignerPlugin
+from zope.interface import implementer
+
+_marker = object()
+
+
+class MemberDataTool(BaseTool):
+    """PAS-specific implementation of memberdata tool.
+    """
+
+    meta_type = "PlonePAS MemberData Tool"
+    security = ClassSecurityInfo()
+    toolicon = 'tool.gif'
+
+    def __init__(self):
+        BaseTool.__init__(self)
+        self.portraits = BTreeFolder2(id='portraits')
+
+    def _getPortrait(self, member_id):
+        "return member_id's portrait if you can "
+        return self.portraits.get(member_id, None)
+
+    def _setPortrait(self, portrait, member_id):
+        " store portrait which must be a raw image in _portrais "
+        if member_id in self.portraits:
+            self.portraits._delObject(member_id)
+        self.portraits._setObject(id=member_id, object=portrait)
+
+    def _deletePortrait(self, member_id):
+        " remove member_id's portrait "
+        if member_id in self.portraits:
+            self.portraits._delObject(member_id)
+
+    @security.private
+    def pruneMemberDataContents(self):
+        '''
+        Compare the user IDs stored in the member data
+        tool with the list in the actual underlying acl_users
+        and delete anything not in acl_users
+        '''
+        BaseTool.pruneMemberDataContents(self)
+        membertool = getToolByName(self, 'portal_membership')
+        portraits = self.portraits
+        user_list = membertool.listMemberIds()
+
+        for tuple in portraits.items():
+            member_id = tuple[0]
+            if member_id not in user_list:
+                self.portraits._delObject(member_id)
+
+    @security.protected(ManagePortal)
+    def purgeMemberDataContents(self):
+        '''
+        Delete ALL MemberData information. This is required for us as we change
+        the MemberData class.
+        '''
+        members = self._members
+
+        for tuple in members.items():
+            member_name = tuple[0]
+            del members[member_name]
+
+        return "Done."
+
+    @security.private
+    def updateMemberDataContents(self,):
+        """Update former MemberData objects to new MemberData objects
+        """
+        count = 0
+        members = self._members
+        properties = self.propertyIds()
+
+        # Scan members for old MemberData
+        for member_name, member_obj in members.items():
+            values = {}
+            if getattr(member_obj, "_is_new_kind", None):
+                continue        # Do not have to upgrade that object
+
+            # Have to upgrade. Create the values mapping.
+            for pty_name in properties:
+                user_value = getattr(member_obj, pty_name, _marker)
+                if user_value is not _marker:
+                    values[pty_name] = user_value
+
+            # Wrap a new user object of the RIGHT class
+            u = self.acl_users.getUserById(member_name, None)
+            if not u:
+                continue                # User is not in main acl_users anymore
+            self.wrapUser(u)
+
+            # Set its properties
+            mbr = self._members.get(member_name, None)
+            if not mbr:
+                raise RuntimeError(
+                    "Error while upgrading user '{0}'.".format(member_name)
+                )
+            mbr.setProperties(values, force_local=1)
+            count += 1
+
+        return count
+
+    @security.private
+    def searchMemberDataContents(self, search_param, search_term):
+        """
+        Search members.
+        This is the same as CMFCore except that it doesn't check term case.
+        """
+        res = []
+
+        search_term = search_term.strip().lower()
+
+        if search_param == 'username':
+            search_param = 'id'
+
+        mtool = getToolByName(self, 'portal_membership')
+
+        for member_id in self._members.keys():
+            user_wrapper = mtool.getMemberById(member_id)
+
+            if user_wrapper is not None:
+                memberProperty = user_wrapper.getProperty
+                searched = memberProperty(search_param, None)
+
+                if searched is not None:
+                    if searched.strip().lower().find(search_term) != -1:
+
+                        res.append({'username': memberProperty('id'),
+                                    'email': memberProperty('email', '')})
+        return res
+
+    @security.public
+    def searchFulltextForMembers(self, s):
+        """search for members which do have string 's' in name, email or full
+        name (if defined)
+
+        this is mainly used for the localrole form
+        """
+        s = s.strip().lower()
+        mu = getToolByName(self, 'portal_membership')
+
+        res = []
+        for member in mu.listMembers():
+            u = member.getUser()
+            if u.getUserName().lower().find(s) != -1 \
+               or member.getProperty('fullname').lower().find(s) != -1 \
+               or member.getProperty('email').lower().find(s) != -1:
+                res.append(member)
+        return res
+
+    # check to see if we can add users. Need to be careful here
+    # so we do not write on read
+    def canAddMemberData(self):
+        try:
+            if self.REQUEST.REQUEST_METHOD != 'POST':
+                return False
+            if getattr(self, '_p_jar', None) and \
+                    len(self._p_jar._registered_objects) > 0:
+                # XXX do not write on read
+                return True
+        except AttributeError:
+            pass
+        return False
+
+    # an exact copy from the base, so that we pick up the new MemberData.
+    # wrapUser should have a MemberData factory method to over-ride (or even
+    # set at run-time!) so that we don't have to do this.
+    def wrapUser(self, u):
+        '''
+        If possible, returns the Member object that corresponds
+        to the given User object.
+        We override this to ensure OUR MemberData class is used
+        '''
+        user_id = u.getId()
+        members = self._members
+        if user_id not in members:
+            base = aq_base(self)
+            md = MemberData(base, user_id)
+            if self.canAddMemberData():
+                # XXX do not write on read
+                members[user_id] = md
+            return md.__of__(self).__of__(u)
+        else:
+            # Return a wrapper with self as containment and
+            # the user as context.
+            return members[user_id].__of__(self).__of__(u)
+
+    @postonly
+    def deleteMemberData(self, member_id, REQUEST=None):
+        """ Delete member data of specified member.
+        """
+        if IPluggableAuthService.providedBy(self.acl_users):
+            # It's a PAS! Whee!
+            # XXX: can we safely assume that user name == member_id
+            plugins = self._getPlugins()
+            prop_managers = plugins.listPlugins(IPropertiesPlugin)
+            for mid, prop_manager in prop_managers:
+                # Not all PropertiesPlugins support user deletion
+                try:
+                    prop_manager.deleteUser(member_id)
+                except AttributeError:
+                    pass
+
+        # we won't always have PlonePAS users, due to acquisition,
+        # nor are guaranteed property sheets
+        members = self._members
+        if member_id in members:
+            del members[member_id]
+            return 1
+        else:
+            return 0
+
+    # plugin getter
+    def _getPlugins(self):
+        return self.acl_users.plugins
+
+InitializeClass(MemberDataTool)
+
+
+@implementer(IManageCapabilities)
+class MemberData(BaseMemberData):
+
+    security = ClassSecurityInfo()
+
+    # setProperties uses setMemberProperties. no need to override.
+
+    def setMemberProperties(self, mapping, force_local=0):
+        """PAS-specific method to set the properties of a
+        member. Ignores 'force_local', which is not reliably present.
+        """
+        sheets = None
+
+        # We could pay attention to force_local here...
+        if not IPluggableAuthService.providedBy(self.acl_users):
+            # Defer to base impl in absence of PAS, a PAS user, or
+            # property sheets
+            return BaseMemberData.setMemberProperties(self, mapping)
+        else:
+            # It's a PAS! Whee!
+            user = self.getUser()
+            sheets = getattr(user, 'getOrderedPropertySheets', lambda: None)()
+
+            # We won't always have PlonePAS users, due to acquisition,
+            # nor are guaranteed property sheets
+            if not sheets:
+                # Defer to base impl if we have a PAS but no property
+                # sheets.
+                return BaseMemberData.setMemberProperties(self, mapping)
+
+        # If we got this far, we have a PAS and some property sheets.
+        # XXX track values set to defer to default impl
+        # property routing?
+        modified = False
+        for k, v in mapping.items():
+            if v is None:
+                continue
+            for sheet in sheets:
+                if not sheet.hasProperty(k):
+                    continue
+                if IMutablePropertySheet.providedBy(sheet):
+                    sheet.setProperty(user, k, v)
+                    modified = True
+                else:
+                    break
+        if modified:
+            self.notifyModified()
+
+    def getProperty(self, id, default=_marker):
+        """PAS-specific method to fetch a user's properties. Looks
+        through the ordered property sheets.
+        """
+        sheets = None
+        if not IPluggableAuthService.providedBy(self.acl_users):
+            return BaseMemberData.getProperty(self, id)
+        else:
+            # It's a PAS! Whee!
+            user = self.getUser()
+            sheets = getattr(user, 'getOrderedPropertySheets', lambda: None)()
+
+            # we won't always have PlonePAS users, due to acquisition,
+            # nor are guaranteed property sheets
+            if not sheets:
+                return BaseMemberData.getProperty(self, id, default)
+
+        # If we made this far, we found a PAS and some property sheets.
+        for sheet in sheets:
+            if sheet.hasProperty(id):
+                # Return the first one that has the property.
+                value = sheet.getProperty(id)
+                if isinstance(value, unicode):
+                    # XXX Temporarily work around the fact that
+                    # property sheets blindly store and return
+                    # unicode. This is sub-optimal and should be
+                    # dealed with at the property sheets level by
+                    # using Zope's converters.
+                    return value.encode('utf-8')
+                return value
+
+        # Couldn't find the property in the property sheets. Try to
+        # delegate back to the base implementation.
+        return BaseMemberData.getProperty(self, id, default)
+
+    def getPassword(self):
+        """Returns None. Present to avoid NotImplementedError."""
+        return None
+
+    # IManageCapabilities methods
+
+    def canDelete(self):
+        """True iff user can be removed from the Plone UI."""
+        # IUserManagement provides doDeleteUser
+        plugins = self._getPlugins()
+        managers = plugins.listPlugins(IUserManagement)
+        for mid, manager in managers:
+            if (IDeleteCapability.providedBy(manager) and
+                    manager.allowDeletePrincipal(self.getId())):
+                return True
+        return False
+
+    def canPasswordSet(self):
+        """True iff user can change password."""
+        # IUserManagement provides doChangeUser
+        plugins = self._getPlugins()
+        managers = plugins.listPlugins(IUserManagement)
+        for mid, manager in managers:
+            if (IPasswordSetCapability.providedBy(manager) and
+                    manager.allowPasswordSet(self.getId())):
+                return True
+        return False
+
+    def passwordInClear(self):
+        """True iff password can be retrieved in the clear (not hashed.)
+
+        False for PAS. It provides no API for getting passwords,
+        though it would be possible to add one in the future.
+        """
+        return 0
+
+    def _memberdataHasProperty(self, prop_name):
+        mdata = getToolByName(self, 'portal_memberdata', None)
+        if mdata:
+            return mdata.hasProperty(prop_name)
+        return 0
+
+    def canWriteProperty(self, prop_name):
+        """True iff the member/group property named in 'prop_name'
+        can be changed.
+        """
+        if not IPluggableAuthService.providedBy(self.acl_users):
+            # not PAS; Memberdata is writable
+            return self._memberdataHasProperty(prop_name)
+        else:
+            # it's PAS
+            user = self.getUser()
+            sheets = getattr(user, 'getOrderedPropertySheets', lambda: None)()
+            if not sheets:
+                return self._memberdataHasProperty(prop_name)
+
+            for sheet in sheets:
+                if not sheet.hasProperty(prop_name):
+                    continue
+                if IMutablePropertySheet.providedBy(sheet):
+                    # BBB for plugins implementing an older version of
+                    # IMutablePropertySheet
+                    if hasattr(sheet, 'canWriteProperty'):
+                        return sheet.canWriteProperty(user, prop_name)
+                    return True
+                else:
+                    break  # shadowed by read-only
+        return False
+
+    def canAddToGroup(self, group_id):
+        """True iff member can be added to group."""
+        # IGroupManagement provides IGroupCapability
+        plugins = self._getPlugins()
+        managers = plugins.listPlugins(IGroupManagement)
+        for mid, manager in managers:
+            if (IGroupCapability.providedBy(manager) and
+                    manager.allowGroupAdd(self.getId(), group_id)):
+                return True
+        return False
+
+    def canRemoveFromGroup(self, group_id):
+        """True iff member can be removed from group."""
+        # IGroupManagement provides IGroupCapability
+        plugins = self._getPlugins()
+        managers = plugins.listPlugins(IGroupManagement)
+        for mid, manager in managers:
+            if (IGroupCapability.providedBy(manager) and
+                    manager.allowGroupRemove(self.getId(), group_id)):
+                return True
+        return False
+
+    def canAssignRole(self, role_id):
+        """True iff member can be assigned role. Role id is string."""
+        # IRoleAssignerPlugin provides IAssignRoleCapability
+        plugins = self._getPlugins()
+        managers = plugins.listPlugins(IRoleAssignerPlugin)
+        for mid, manager in managers:
+            if (IAssignRoleCapability.providedBy(manager) and
+                    manager.allowRoleAssign(self.getId(), role_id)):
+                return True
+        return False
+
+    @security.private
+    def setSecurityProfile(self, password=None, roles=None, domains=None):
+        """Set the user's basic security profile"""
+        u = self.getUser()
+
+        # The Zope User API is stupid, it should check for None.
+        if roles is None:
+            roles = list(u.getRoles())
+            if 'Authenticated' in roles:
+                roles.remove('Authenticated')
+        if domains is None:
+            domains = u.getDomains()
+
+        u.userFolderEditUser(u.getUserId(), password, roles, domains)
+
+    # plugin getters
+
+    @security.private
+    def _getPlugins(self):
+        return self.acl_users.plugins
+
+
+InitializeClass(MemberData)
diff --git a/src/Products/PlonePAS/tools/membership.py b/src/Products/PlonePAS/tools/membership.py
new file mode 100644
index 0000000..4fe629f
--- /dev/null
+++ b/src/Products/PlonePAS/tools/membership.py
@@ -0,0 +1,762 @@
+# -*- coding: utf-8 -*-
+from AccessControl import ClassSecurityInfo
+from AccessControl import Unauthorized
+from AccessControl import getSecurityManager
+from AccessControl.SecurityManagement import noSecurityManager
+from AccessControl.requestmethod import postonly
+from Acquisition import aq_get
+from Acquisition import aq_inner
+from Acquisition import aq_parent
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from DateTime import DateTime
+from OFS.Image import Image
+from Products.CMFCore.MembershipTool import MembershipTool as BaseTool
+from Products.CMFCore.interfaces import IPropertiesTool
+from Products.CMFCore.permissions import ListPortalMembers
+from Products.CMFCore.permissions import ManagePortal
+from Products.CMFCore.permissions import ManageUsers
+from Products.CMFCore.permissions import SetOwnPassword
+from Products.CMFCore.permissions import SetOwnProperties
+from Products.CMFCore.permissions import View
+from Products.CMFCore.utils import _checkPermission
+from Products.CMFCore.utils import getToolByName
+from Products.PlonePAS.config import HAS_PIL
+from Products.PlonePAS.events import UserInitialLoginInEvent
+from Products.PlonePAS.events import UserLoggedInEvent
+from Products.PlonePAS.events import UserLoggedOutEvent
+from Products.PlonePAS.interfaces import membership
+from Products.PlonePAS.utils import cleanId
+from Products.PlonePAS.utils import scale_image
+from ZODB.POSException import ConflictError
+from cStringIO import StringIO
+from zExceptions import BadRequest
+from zope import event
+from zope.component import getUtility
+from zope.interface import implementer
+import logging
+import transaction
+
+default_portrait = 'defaultUser.png'
+logger = logging.getLogger('PlonePAS')
+
+_marker = dict()
+
+
+def _unicodify_structure(value, charset=_marker):
+    """ Convert value to unicode.
+    """
+    if charset is _marker:
+        ptool = getUtility(IPropertiesTool)
+        charset = ptool.getProperty('default_charset', None)
+
+    if isinstance(value, str):
+        return charset and unicode(value, charset) or unicode(value)
+    if isinstance(value, list):
+        return [_unicodify_structure(val, charset) for val in value]
+    if isinstance(value, tuple):
+        return tuple([_unicodify_structure(entry, charset) for entry in value])
+    if isinstance(value, dict):
+        for key, val in value.items():
+            value[key] = _unicodify_structure(val, charset)
+        return value
+    return value
+
+
+@implementer(membership.IMembershipTool)
+class MembershipTool(BaseTool):
+    """PAS-based customization of MembershipTool.
+    """
+
+    meta_type = "PlonePAS Membership Tool"
+    toolicon = 'tool.gif'
+    personal_id = '.personal'
+    portrait_id = 'MyPortrait'
+    default_portrait = 'defaultUser.gif'
+    memberarea_type = 'Folder'
+    membersfolder_id = 'Members'
+    memberareaCreationFlag = False
+    security = ClassSecurityInfo()
+
+    user_search_keywords = ('login', 'fullname', 'email', 'exact_match',
+                            'sort_by', 'max_results')
+
+    _properties = (getattr(BaseTool, '_properties', ()) +
+                   ({'id': 'user_search_keywords',
+                     'type': 'lines',
+                     'mode': 'rw',
+                     },))
+
+    manage_options = (BaseTool.manage_options +
+                      ({'label': 'Portraits',
+                        'action': 'manage_portrait_fix'},))
+
+    # TODO I'm not quite sure why getPortalRoles is declared 'Managed'
+    #    in CMFCore.MembershipTool - but in Plone we are not so anal ;-)
+    security.declareProtected(View, 'getPortalRoles')
+
+    security.declareProtected(ManagePortal, 'manage_mapRoles')
+    manage_mapRoles = DTMLFile('../zmi/membershipRolemapping', globals())
+
+    security.declareProtected(ManagePortal, 'manage_portrait_fix')
+    manage_portrait_fix = DTMLFile('../zmi/portrait_fix', globals())
+
+    @security.protected(ManagePortal)
+    def manage_setMemberAreaType(self, type_name, REQUEST=None):
+        """ ZMI method to set the home folder type by its type name.
+        """
+        self.setMemberAreaType(type_name)
+        if REQUEST is not None:
+            REQUEST['RESPONSE'].redirect(
+                self.absolute_url() +
+                '/manage_mapRoles'
+                '?manage_tabs_message=Member+area+type+changed.'
+            )
+
+    @security.protected(ManagePortal)
+    def manage_setMembersFolderById(self, id, REQUEST=None):
+        """ ZMI method to set the members folder object by its id.
+        """
+        self.setMembersFolderById(id)
+        if REQUEST is not None:
+            REQUEST['RESPONSE'].redirect(
+                self.absolute_url() +
+                '/manage_mapRoles'
+                '?manage_tabs_message=Members+folder+id+changed.'
+            )
+
+    @security.protected(ManagePortal)
+    def setMemberAreaType(self, type_name):
+        """ Sets the portal type to use for new home folders.
+        """
+        # No check for folderish since someone somewhere may actually want
+        # members to have objects instead of folders as home "directory".
+        self.memberarea_type = str(type_name).strip()
+
+    @security.protected(ManagePortal)
+    def setMembersFolderById(self, id=''):
+        """ Set the members folder object by its id.
+        """
+        self.membersfolder_id = id.strip()
+
+    @security.public
+    def getMembersFolder(self):
+        """ Get the members folder object.
+        """
+        parent = aq_parent(aq_inner(self))
+        members = getattr(parent, self.membersfolder_id, None)
+        return members
+
+    @security.private
+    def addMember(self, id, password, roles, domains, properties=None):
+        """Adds a new member to the user folder.
+
+        Security checks will have already been performed.  Called by
+        portal_registration.  This one specific to PAS. PAS ignores
+        domains. Adding members with login_name also not yet
+        supported.
+        """
+        acl_users = self.acl_users
+        acl_users._doAddUser(id, password, roles, domains)
+
+        if properties is not None:
+            member = self.getMemberById(id)
+            member.setMemberProperties(properties)
+
+    @security.protected(ListPortalMembers)
+    def searchForMembers(self, REQUEST=None, **kw):
+        """Hacked up version of Plone searchForMembers.
+
+        The following properties can be provided:
+        - name
+        - email
+        - last_login_time
+        - before_specified_time
+        - roles (any role will cause a match)
+        - groupname
+
+        This is an 'AND' request.
+
+        Simple name searches are "fast".
+        """
+        logger.debug('searchForMembers: started.')
+
+        acl_users = getToolByName(self, "acl_users")
+
+        if REQUEST is not None:
+            searchmap = REQUEST
+            for key, value in searchmap.items():
+                if isinstance(value, str):
+                    searchmap[key] = _unicodify_structure(value)
+        else:
+            searchmap = kw
+
+        # While the parameter is called name it is actually used to search a
+        # users name, which is stored in the fullname property. We need to fix
+        # that here so the right name is used when calling into PAS plugins.
+        if 'name' in searchmap:
+            searchmap['fullname'] = searchmap['name']
+            del searchmap['name']
+
+        user_search = dict(
+            [x for x in searchmap.items()
+             if x[0] in self.user_search_keywords and x[1]]
+        )
+
+        fullname = searchmap.get('fullname', None)
+        email = searchmap.get('email', None)
+        roles = searchmap.get('roles', None)
+        last_login_time = searchmap.get('last_login_time', None)
+        before_specified_time = searchmap.get('before_specified_time', None)
+        groupname = searchmap.get('groupname', '').strip()
+
+        if fullname:
+            fullname = fullname.strip().lower()
+        if not fullname:
+            fullname = None
+        if email:
+            email = email.strip().lower()
+        if not email:
+            email = None
+
+        uf_users = []
+
+        logger.debug(
+            'searchForMembers: searching PAS '
+            'with arguments %r.' % user_search)
+        for user in acl_users.searchUsers(**user_search):
+            uf_users.append(user['userid'])
+
+        if not uf_users:
+            return []
+
+        getUserById = acl_users.getUserById
+
+        def dedupe(seq):
+            # Thanks http://www.peterbe.com/plog/uniqifiers-benchmark
+            seen = set()
+            seen_add = seen.add
+            # nice trick! set.add() does always return None
+            return [x for x in seq if x not in seen and not seen_add(x)]
+
+        uf_users = dedupe(uf_users)
+        members = [getUserById(userid) for userid in uf_users]
+        members = [member for member in members if member is not None]
+
+        if not (email or fullname or roles or groupname or last_login_time):
+            logger.debug(
+                'searchForMembers: searching users '
+                'with no extra filter, immediate return.')
+            return members
+
+        # Now perform individual checks on each user
+        res = []
+
+        for member in members:
+            if groupname and groupname not in member.getGroupIds():
+                continue
+
+            if roles:
+                user_roles = member.getRoles()
+                found = 0
+                for r in roles:
+                    if r in user_roles:
+                        found = 1
+                        break
+                if not found:
+                    continue
+
+            if last_login_time:
+                last_login = member.getProperty('last_login_time', '')
+
+                if isinstance(last_login, basestring):
+                    # value is a string when member hasn't yet logged in
+                    last_login = DateTime(last_login or '2000/01/01')
+
+                if before_specified_time:
+                    if last_login >= last_login_time:
+                        continue
+                elif last_login < last_login_time:
+                    continue
+
+            res.append(member)
+
+        logger.debug('searchForMembers: finished.')
+        return res
+
+    ############
+    # sanitize home folders (we may get URL-illegal ids)
+
+    @security.public
+    def createMemberarea(self, member_id=None, minimal=None):
+        """
+        Create a member area for 'member_id' or the authenticated
+        user, but don't assume that member_id is url-safe.
+        """
+        if not self.getMemberareaCreationFlag():
+            return None
+        membership = getToolByName(self, 'portal_membership')
+        members = self.getMembersFolder()
+
+        if not member_id:
+            # member_id is optional (see CMFCore.interfaces.portal_membership:
+            #     Create a member area for 'member_id' or authenticated user.)
+            member = membership.getAuthenticatedMember()
+            member_id = member.getId()
+
+        if hasattr(members, 'aq_explicit'):
+            members = members.aq_explicit
+
+        if members is None:
+            # no members area
+            logger.debug('createMemberarea: members area does not exist.')
+            return
+
+        safe_member_id = cleanId(member_id)
+        if hasattr(members, safe_member_id):
+            # has already this member
+            logger.debug(
+                'createMemberarea: member area '
+                'for %r already exists.' % safe_member_id)
+            return
+
+        if not safe_member_id:
+            # Could be one of two things:
+            # - A Emergency User
+            # - cleanId made a empty string out of member_id
+            logger.debug(
+                'createMemberarea: empty member id '
+                '(%r, %r), skipping member area creation.' %
+                (member_id, safe_member_id)
+            )
+            return
+
+        # Create member area without security checks
+        typesTool = getToolByName(members, 'portal_types')
+        fti = typesTool.getTypeInfo(self.memberarea_type)
+        member_folder = fti._constructInstance(members, safe_member_id)
+
+        # Get the user object from acl_users
+        acl_users = getToolByName(self, "acl_users")
+        user = acl_users.getUserById(member_id)
+        if user is not None:
+            user = user.__of__(acl_users)
+        else:
+            user = getSecurityManager().getUser()
+            # check that we do not do something wrong
+            if user.getId() != member_id:
+                raise NotImplementedError(
+                        'cannot get user for member area creation')
+
+        member_object = self.getMemberById(member_id)
+
+        # Modify member folder
+        member_folder = self.getHomeFolder(member_id)
+        # Grant Ownership and Owner role to Member
+        member_folder.changeOwnership(user)
+        member_folder.__ac_local_roles__ = None
+        member_folder.manage_setLocalRoles(member_id, ['Owner'])
+        # We use ATCT now use the mutators
+        fullname = member_object.getProperty('fullname')
+        member_folder.setTitle(fullname or member_id)
+        member_folder.reindexObject()
+
+        # Hook to allow doing other things after memberarea creation.
+        notify_script = getattr(member_folder, 'notifyMemberAreaCreated', None)
+        if notify_script is not None:
+            notify_script()
+
+    # deal with ridiculous API change in CMF
+    security.declarePublic('createMemberArea')
+    createMemberArea = createMemberarea
+
+    @security.public
+    def getMemberInfo(self, memberId=None):
+        # Return 'harmless' Memberinfo of any member, such as Full name,
+        # Location, etc
+        if not memberId:
+            member = self.getAuthenticatedMember()
+        else:
+            member = self.getMemberById(memberId)
+
+        if member is None:
+            return None
+
+        memberinfo = {
+            'fullname': member.getProperty('fullname'),
+            'description': member.getProperty('description'),
+            'location': member.getProperty('location'),
+            'language': member.getProperty('language'),
+            'home_page': member.getProperty('home_page'),
+            'username': member.getUserName(),
+            'has_email': bool(member.getProperty('email')),
+        }
+
+        return memberinfo
+
+    def _getSafeMemberId(self, id=None):
+        """Return a safe version of a member id.
+
+        If no id is given return the id for the currently authenticated user.
+        """
+
+        if id is None:
+            member = self.getAuthenticatedMember()
+            if not hasattr(member, 'getMemberId'):
+                return None
+            id = member.getMemberId()
+
+        return cleanId(id)
+
+    @security.public
+    def getHomeFolder(self, id=None, verifyPermission=0):
+        """ Return a member's home folder object, or None.
+
+        Specially instrumented for URL-quoted-member-id folder
+        names.
+        """
+        safe_id = self._getSafeMemberId(id)
+        if safe_id is None:
+            member = self.getAuthenticatedMember()
+            if not hasattr(member, 'getMemberId'):
+                return None
+            safe_id = member.getMemberId()
+        members = self.getMembersFolder()
+        if members:
+            try:
+                folder = members._getOb(safe_id)
+                if verifyPermission and not _checkPermission(View, folder):
+                    # Don't return the folder if the user can't get to it.
+                    return None
+                return folder
+            # KeyError added to deal with btree member folders
+            except (AttributeError, KeyError, TypeError):
+                pass
+        return None
+
+    def getHomeUrl(self, id=None, verifyPermission=0):
+        """ Return the URL to a member's home folder, or None.
+        """
+        home = self.getHomeFolder(id, verifyPermission)
+        if home is not None:
+            return home.absolute_url()
+        else:
+            return None
+
+    @security.public
+    def getPersonalFolder(self, member_id=None):
+        """
+        returns the Personal Item folder for a member
+        if no Personal Folder exists will return None
+        """
+        home = self.getHomeFolder(member_id)
+        personal = None
+        if home:
+            personal = getattr(home, self.personal_id, None)
+        return personal
+
+    @security.public
+    def getPersonalPortrait(self, id=None, verifyPermission=0):
+        """Return a members personal portait.
+
+        Modified from CMFPlone version to URL-quote the member id.
+        """
+        if not id:
+            id = self.getAuthenticatedMember().getId()
+        safe_id = self._getSafeMemberId(id)
+        membertool = getToolByName(self, 'portal_memberdata')
+        portrait = membertool._getPortrait(safe_id)
+        if isinstance(portrait, str):
+            portrait = None
+        if portrait is not None:
+            if verifyPermission and not _checkPermission('View', portrait):
+                # Don't return the portrait if the user can't get to it
+                portrait = None
+        if portrait is None:
+            portal = getToolByName(self, 'portal_url').getPortalObject()
+            portrait = getattr(portal, default_portrait, None)
+
+        return portrait
+
+    @security.protected(SetOwnProperties)
+    def deletePersonalPortrait(self, id=None):
+        """deletes the Portait of a member.
+        """
+        authenticated_id = self.getAuthenticatedMember().getId()
+        if not id:
+            id = authenticated_id
+        safe_id = self._getSafeMemberId(id)
+        if id != authenticated_id and not _checkPermission(
+                ManageUsers, self):
+            raise Unauthorized
+
+        membertool = getToolByName(self, 'portal_memberdata')
+        return membertool._deletePortrait(safe_id)
+
+    @security.protected(SetOwnProperties)
+    def changeMemberPortrait(self, portrait, id=None):
+        """update the portait of a member.
+
+        We URL-quote the member id if needed.
+
+        Note that this method might be called by an anonymous user who
+        is getting registered.  This method will then be called from
+        plone.app.users and this is fine.  When called from restricted
+        python code or with a curl command by a hacker, the
+        declareProtected line will kick in and prevent use of this
+        method.
+        """
+        authenticated_id = self.getAuthenticatedMember().getId()
+        if not id:
+            id = authenticated_id
+        safe_id = self._getSafeMemberId(id)
+        if authenticated_id and id != authenticated_id:
+            # Only Managers can change portraits of others.
+            if not _checkPermission(ManageUsers, self):
+                raise Unauthorized
+        if portrait and portrait.filename:
+            scaled, mimetype = scale_image(portrait)
+            portrait = Image(id=safe_id, file=scaled, title='')
+            membertool = getToolByName(self, 'portal_memberdata')
+            membertool._setPortrait(portrait, safe_id)
+
+    @security.protected(ManageUsers)
+    def listMembers(self):
+        '''Gets the list of all members.
+        THIS METHOD MIGHT BE VERY EXPENSIVE ON LARGE USER FOLDERS AND MUST
+        BE USED WITH CARE! We plan to restrict its use in the future (ie.
+        force large requests to use searchForMembers instead of listMembers,
+        so that it will not be possible anymore to have a method returning
+        several hundred of users :)
+        '''
+        return BaseTool.listMembers(self)
+
+    @security.protected(ManageUsers)
+    def listMemberIds(self):
+        '''Lists the ids of all members.  This may eventually be
+        replaced with a set of methods for querying pieces of the
+        list rather than the entire list at once.
+        '''
+        return self.acl_users.getUserIds()
+
+    @security.protected(SetOwnPassword)
+    def testCurrentPassword(self, password):
+        """ test to see if password is current """
+        REQUEST = getattr(self, 'REQUEST', {})
+        member = self.getAuthenticatedMember()
+        acl_users = self._findUsersAclHome(member.getUserId())
+        if not acl_users:
+            return 0
+        return acl_users.authenticate(member.getUserName(), password, REQUEST)
+
+    def _findUsersAclHome(self, userid):
+        portal = getToolByName(self, 'portal_url').getPortalObject()
+        acl_users = portal.acl_users
+        parent = acl_users
+        while parent:
+            if acl_users.aq_explicit.getUserById(userid, None) is not None:
+                break
+            parent = aq_parent(aq_inner(parent)).aq_parent
+            acl_users = getattr(parent, 'acl_users')
+        if parent:
+            return acl_users
+        else:
+            return None
+
+    @security.protected(SetOwnPassword)
+    def setPassword(self, password, domains=None, REQUEST=None):
+        '''Allows the authenticated member to set his/her own password.
+        '''
+        registration = getToolByName(self, 'portal_registration', None)
+        if not self.isAnonymousUser():
+            member = self.getAuthenticatedMember()
+            acl_users = self._findUsersAclHome(member.getUserId())
+            if not acl_users:
+                # should not possibly ever happen
+                raise BadRequest('did not find current user in any '
+                                 'user folder')
+            if registration:
+                failMessage = registration.testPasswordValidity(password)
+                if failMessage is not None:
+                    raise BadRequest(failMessage)
+
+            if domains is None:
+                domains = []
+            user = acl_users.getUserById(member.getUserId(), None)
+            # we must change the users password trough grufs changepassword
+            # to keep her  group settings
+            if hasattr(user, 'changePassword'):
+                user.changePassword(password)
+            else:
+                acl_users._doChangeUser(member.getUserId(), password,
+                                        member.getRoles(), domains)
+            if REQUEST is None:
+                REQUEST = aq_get(self, 'REQUEST', None)
+            self.credentialsChanged(password, REQUEST=REQUEST)
+        else:
+            raise BadRequest('Not logged in.')
+    setPassword = postonly(setPassword)
+
+    @security.protected(View)
+    def getCandidateLocalRoles(self, obj):
+        """ What local roles can I assign?
+            Override the CMFCore version so that we can see the local roles on
+            an object, and so that local managers can assign all roles locally.
+        """
+        member = self.getAuthenticatedMember()
+        # Use getRolesInContext as someone may be a local manager
+        if 'Manager' in member.getRolesInContext(obj):
+            # Use valid_roles as we may want roles defined only on a subobject
+            local_roles = [r for r in obj.valid_roles() if r not in
+                           ('Anonymous', 'Authenticated', 'Shared')]
+        else:
+            local_roles = [role for role in member.getRolesInContext(obj)
+                           if role not in ('Member', 'Authenticated')]
+        local_roles.sort()
+        return tuple(local_roles)
+
+    @security.protected(View)
+    def loginUser(self, REQUEST=None):
+        """ Handle a login for the current user.
+
+        This method takes care of all the standard work that needs to be
+        done when a user logs in:
+        - clear the copy/cut/paste clipboard
+        - PAS credentials update
+        - sending a logged-in event
+        - storing the login time
+        - create the member area if it does not exist
+        """
+        user = getSecurityManager().getUser()
+        if user is None:
+            return
+
+        if self.setLoginTimes():
+            event.notify(UserInitialLoginInEvent(user))
+        else:
+            event.notify(UserLoggedInEvent(user))
+
+        if REQUEST is None:
+            REQUEST = getattr(self, 'REQUEST', None)
+        if REQUEST is None:
+            return
+
+        # Expire the clipboard
+        if REQUEST.get('__cp', None) is not None:
+            REQUEST.RESPONSE.expireCookie('__cp', path='/')
+
+        self.createMemberArea()
+
+        try:
+            pas = getToolByName(self, 'acl_users')
+            pas.credentials_cookie_auth.login()
+        except AttributeError:
+            # The cookie plugin may not be present
+            pass
+
+    @security.protected(View)
+    def logoutUser(self, REQUEST=None):
+        """Process a user logout.
+
+        This takes care of all the standard logout work:
+        - ask the user folder to logout
+        - expire a skin selection cookie
+        - invalidate a Zope session if there is one
+        """
+        # Invalidate existing sessions, but only if they exist.
+        sdm = getToolByName(self, 'session_data_manager', None)
+        if sdm is not None:
+                session = sdm.getSessionData(create=0)
+                if session is not None:
+                            session.invalidate()
+
+        if REQUEST is None:
+            REQUEST = getattr(self, 'REQUEST', None)
+        if REQUEST is not None:
+            pas = getToolByName(self, 'acl_users')
+            try:
+                pas.logout(REQUEST)
+            except:
+                # XXX Bare except copied from logout.cpy. This should be
+                # changed in the next Plone release.
+                pass
+
+            # Expire the skin cookie if it is not configured to persist
+            st = getToolByName(self, "portal_skins")
+            skinvar = st.getRequestVarname()
+            if skinvar in REQUEST and not st.getCookiePersistence():
+                    portal = getToolByName(self, "portal_url") \
+                                .getPortalObject()
+                    path = '/' + portal.absolute_url(1)
+                    # XXX check if this path is sane
+                    REQUEST.RESPONSE.expireCookie(skinvar, path=path)
+
+        user = getSecurityManager().getUser()
+        if user is not None:
+            event.notify(UserLoggedOutEvent(user))
+
+    @security.protected(View)
+    def immediateLogout(self):
+        """ Log the current user out immediately.  Used by logout.py so that
+            we do not have to do a redirect to show the logged out status. """
+        noSecurityManager()
+
+    @security.public
+    def setLoginTimes(self):
+        """ Called by logged_in to set the login time properties
+            even if members lack the "Set own properties" permission.
+
+            The return value indicates if this is the first logged
+            login time.
+        """
+        res = False
+        if not self.isAnonymousUser():
+            member = self.getAuthenticatedMember()
+            default = DateTime('2000/01/01')
+            login_time = member.getProperty('login_time', default)
+            if login_time == default:
+                res = True
+                login_time = DateTime()
+            member.setProperties(login_time=self.ZopeTime(),
+                                 last_login_time=login_time)
+        return res
+
+    @security.protected(ManagePortal)
+    def getBadMembers(self):
+        """Will search for members with bad images in the portal_memberdata
+        delete their portraits and return their member ids"""
+        memberdata = getToolByName(self, 'portal_memberdata')
+        portraits = getattr(memberdata, 'portraits', None)
+        if portraits is None:
+            return []
+        bad_member_ids = []
+        TXN_THRESHOLD = 50
+        counter = 1
+        for member_id in tuple(portraits.keys()):
+            portrait = portraits[member_id]
+            portrait_data = str(portrait.data)
+            if portrait_data == '':
+                continue
+            if not HAS_PIL:
+                raise RuntimeError(
+                    'No Python Imaging Libraries (PIL) found. '
+                    'Unable to validate profile image. '
+                )
+            try:
+                import PIL
+                PIL.Image.open(StringIO(portrait_data))
+            except ConflictError:
+                pass
+            except:
+                # Anything else we have a bad bad image and we destroy it
+                # and ask questions later.
+                portraits._delObject(member_id)
+                bad_member_ids.append(member_id)
+            if not counter % TXN_THRESHOLD:
+                transaction.savepoint(optimistic=True)
+            counter = counter + 1
+
+        return bad_member_ids
+
+
+InitializeClass(MembershipTool)
diff --git a/src/Products/PlonePAS/tools/plonetool.py b/src/Products/PlonePAS/tools/plonetool.py
new file mode 100644
index 0000000..8e3bd6a
--- /dev/null
+++ b/src/Products/PlonePAS/tools/plonetool.py
@@ -0,0 +1,3 @@
+# This is a backwards compatibility alias. It can be removed once Plone
+# doesn't support upgrading from Plone 2.5 anymore.
+from Products.CMFPlone.PloneTool import PloneTool
diff --git a/src/Products/PlonePAS/utils.py b/src/Products/PlonePAS/utils.py
new file mode 100644
index 0000000..4a7d55c
--- /dev/null
+++ b/src/Products/PlonePAS/utils.py
@@ -0,0 +1,198 @@
+# -*- coding: utf-8 -*-
+from Products.PlonePAS.config import IMAGE_SCALE_PARAMS
+from Products.PluggableAuthService.interfaces.plugins import IGroupsPlugin
+from cStringIO import StringIO
+from urllib import quote as url_quote
+from urllib import unquote as url_unquote
+
+
+def unique(iterable):
+    d = {}
+    for i in iterable:
+        d[i] = None
+    return d.keys()
+
+
+def cleanId(id):
+    """'url_quote' turns strange chars into '%xx', which is not a valid char
+    for ObjectManager. Here we encode '%' into '-' (and '-' into '--' as
+    escaping).
+    De-clean is possible; see 'decleanId'.
+    Assumes that id can start with non-alpha(numeric), which is true.
+    """
+    __traceback_info__ = (id,)
+    if id:
+        # note: we provide the 'safe' param to get '/' encoded
+        return url_quote(id, '').replace('-', '--').replace('%', '-')
+    return ''
+
+
+def decleanId(id):
+    """Reverse cleanId."""
+    if id:
+        id = id.replace('--', '\x00').replace('-', '%').replace('\x00', '-')
+        return url_unquote(id)
+    return ''
+
+
+def scale_image(image_file, max_size=None, default_format=None):
+    """Scales an image down to at most max_size preserving aspect ratio
+    from an input file
+
+        >>> from Products.PlonePAS import config
+        >>> import os
+        >>> from StringIO import StringIO
+        >>> from Products.PlonePAS.utils import scale_image
+        >>> from PIL import Image
+
+    Let's make a couple test images and see how it works (all are
+    100x100), the gif is palletted mode::
+
+        >>> pas_path = os.path.dirname(config.__file__)
+        >>> pjoin = os.path.join
+        >>> path = pjoin(pas_path, 'tests', 'images')
+        >>> orig_jpg = open(pjoin(path, 'test.jpg'), 'rb')
+        >>> orig_png = open(pjoin(path, 'test.png'), 'rb')
+        >>> orig_gif = open(pjoin(path, 'test.gif'), 'rb')
+
+    We'll also make some evil non-images, including one which
+    masquerades as a jpeg (which would trick OFS.Image)::
+
+        >>> invalid = StringIO('<div>Evil!!!</div>')
+        >>> sneaky = StringIO('\377\330<div>Evil!!!</div>')
+
+    OK, let's get to it, first check that our bad images fail:
+
+        >>> scale_image(invalid, (50, 50))
+        Traceback (most recent call last):
+        ...
+        IOError: cannot identify image file...
+        >>> scale_image(sneaky, (50, 50))
+        Traceback (most recent call last):
+        ...
+        IOError: cannot identify image file...
+
+    Now that that's out of the way we check on our real images to make
+    sure the format and mode are preserved, that they are scaled, and that they
+    return the correct mimetype::
+
+        >>> new_jpg, mimetype = scale_image(orig_jpg, (50, 50))
+        >>> img = Image.open(new_jpg)
+        >>> img.size
+        (50, 50)
+        >>> img.format
+        'JPEG'
+        >>> mimetype
+        'image/jpeg'
+
+        >>> new_png, mimetype = scale_image(orig_png, (50, 50))
+        >>> img = Image.open(new_png)
+        >>> img.size
+        (50, 50)
+        >>> img.format
+        'PNG'
+        >>> mimetype
+        'image/png'
+
+        >>> new_gif, mimetype = scale_image(orig_gif, (50, 50))
+        >>> img = Image.open(new_gif)
+        >>> img.size
+        (50, 50)
+        >>> img.format
+        'GIF'
+        >>> img.mode
+        'P'
+        >>> mimetype
+        'image/gif'
+
+    We should also preserve the aspect ratio by scaling to the given
+    width only unless told not to (we need to reset out files before
+    trying again though::
+
+        >>> orig_jpg.seek(0)
+        >>> new_jpg, mimetype = scale_image(orig_jpg, (70, 100))
+        >>> img = Image.open(new_jpg)
+        >>> img.size
+        (70, 70)
+
+        >>> orig_jpg.seek(0)
+        >>> new_jpg, mimetype = scale_image(orig_jpg, (70, 50))
+        >>> img = Image.open(new_jpg)
+        >>> img.size
+        (50, 50)
+
+    """
+    from PIL import Image
+
+    if max_size is None:
+        max_size = IMAGE_SCALE_PARAMS['scale']
+    if default_format is None:
+        default_format = IMAGE_SCALE_PARAMS['default_format']
+    # Make sure we have ints
+    size = (int(max_size[0]), int(max_size[1]))
+    # Load up the image, don't try to catch errors, we want to fail miserably
+    # on invalid images
+    image = Image.open(image_file)
+    # When might image.format not be true?
+    format = image.format
+    mimetype = 'image/%s' % format.lower()
+
+    # from Archetypes ImageField
+    # consider image mode when scaling
+    # source images can be mode '1','L,','P','RGB(A)'
+    # convert to greyscale or RGBA before scaling
+    # preserve palletted mode (but not pallette)
+    # for palletted-only image formats, e.g. GIF
+    # PNG compression is OK for RGBA thumbnails
+    original_mode = image.mode
+    if original_mode == '1':
+        image = image.convert('L')
+    elif original_mode == 'P':
+        image = image.convert('RGBA')
+    # Rescale in place with an method that will not alter the aspect ratio
+    # and will only shrink the image not enlarge it.
+    image.thumbnail(size, resample=IMAGE_SCALE_PARAMS['algorithm'])
+    # preserve palletted mode for GIF and PNG
+    if original_mode == 'P' and format in ('GIF', 'PNG'):
+        image = image.convert('P')
+    # Save
+    new_file = StringIO()
+    image.save(new_file, format, quality=IMAGE_SCALE_PARAMS['quality'])
+    new_file.seek(0)
+    # Return the file data and the new mimetype
+    return new_file, mimetype
+
+
+def getGroupsForPrincipal(principal, plugins, request=None):
+    groups = set()
+    for iid, plugin in plugins.listPlugins(IGroupsPlugin):
+        groups.update(plugin.getGroupsForPrincipal(principal, request))
+    return list(groups)
+
+
+def safe_unicode(value, encoding='utf-8'):
+    """Converts a value to unicode, even it is already a unicode string.
+    """
+    if isinstance(value, unicode):
+        return value
+    elif isinstance(value, basestring):
+        try:
+            value = unicode(value, encoding)
+        except UnicodeDecodeError:
+            value = value.decode('utf-8', 'replace')
+    return value
+
+
+# Imported from Products.CMFCore.MemberdataTool as it has now been removed.
+class CleanupTemp:
+    """Used to cleanup _v_temps at the end of the request."""
+
+    def __init__(self, tool):
+        self._tool = tool
+
+    def __del__(self):
+        try:
+            del self._tool._v_temps
+        except (AttributeError, KeyError):
+            # The object has already been deactivated.
+            pass
diff --git a/src/Products/PlonePAS/zmi/AutoGroupForm.zpt b/src/Products/PlonePAS/zmi/AutoGroupForm.zpt
new file mode 100644
index 0000000..187abc6
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/AutoGroupForm.zpt
@@ -0,0 +1,66 @@
+<h1 tal:replace="structure here/manage_page_header">Header</h1>
+
+<h2 tal:define="form_title string:Add Auto Group plugin"
+    tal:replace="structure here/manage_form_title">Form Title</h2>
+
+<p class="form-help">
+The Auto Group plugin automatically puts all authenticated users in a virtual
+group.
+</p>
+
+<form action="manage_addAutoGroup" method="post">
+<table cellspacing="0" cellpadding="2" border="0">
+  <tr>
+    <td align="left" valign="top">
+    <div class="form-label">
+    Id
+    </div>
+    </td>
+    <td align="left" valign="top">
+    <input type="text" name="id" size="40" />
+    </td>
+  </tr>
+  <tr>
+    <td align="left" valign="top">
+    <div class="form-optional">
+    Title
+    </div>
+    </td>
+    <td align="left" valign="top">
+    <input type="text" name="title" size="40" />
+    </td>
+  </tr>
+  <tr>
+    <td align="left" valign="top">
+    <div class="form-label">
+    Group id
+    </div>
+    </td>
+    <td align="left" valign="top">
+    <input type="text" name="group" size="40" />
+    </td>
+  </tr>
+  <tr>
+    <td align="left" valign="top">
+    <div class="form-label">
+    Description
+    </div>
+    </td>
+    <td align="left" valign="top">
+    <input type="text" name="description" size="40" />
+    </td>
+  </tr>
+  <tr>
+    <td align="left" valign="top">
+    </td>
+    <td align="left" valign="top">
+    <div class="form-element">
+    <input class="form-element" type="submit" name="submit" 
+     value=" Add " /> 
+    </div>
+    </td>
+  </tr>
+</table>
+</form>
+
+<h1 tal:replace="structure here/manage_page_footer">Footer</h1>
diff --git a/src/Products/PlonePAS/zmi/CookieCrumblingPluginForm.dtml b/src/Products/PlonePAS/zmi/CookieCrumblingPluginForm.dtml
new file mode 100644
index 0000000..56facac
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/CookieCrumblingPluginForm.dtml
@@ -0,0 +1,39 @@
+<dtml-var manage_page_header>
+
+<h2> Add A CookieCrumblingPlugin For PAS</h2>
+
+<p class="form-help">
+ This user factory allows form-based logins to be authenticated against regular user folders
+ in parent folders. Otherwise, users from, say, the root's <code>acl_users</code> won't be able
+ to log in via a form
+</p>
+
+<p>
+ It does this by injecting form-provided credentials into the REQUEST as CookieCrumbler does.
+</p>
+
+<form action="manage_addCookieCrumblingPlugin" method="POST">
+
+<table>
+<tr>
+   <td class="form-label"> Id </td>
+   <td> <input type="text" name="id" /> </td>
+</tr>
+<tr>
+   <td class="form-label"> Title </td>
+   <td> <input type="text" name="title" /> </td>
+</tr>
+<tr>
+   <td colspan="2"> 
+    <div class="form-element">
+     <input type="submit" value="submit"/>
+     </div>
+   </td>
+</tr>
+
+</table>
+
+</form>
+
+</body>
+</html>
diff --git a/src/Products/PlonePAS/zmi/ExtendedCookieAuthHelperForm.dtml b/src/Products/PlonePAS/zmi/ExtendedCookieAuthHelperForm.dtml
new file mode 100644
index 0000000..285c6d3
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/ExtendedCookieAuthHelperForm.dtml
@@ -0,0 +1,30 @@
+<dtml-var manage_page_header>
+
+<h2> Add An ExtendedCookieAuthHelper For PAS</h2>
+
+
+<form action="manage_addExtendedCookieAuthHelper" method="POST">
+
+<table>
+<tr>
+   <td class="form-label"> Id </td>
+   <td> <input type="text" name="id" /> </td>
+</tr>
+<tr>
+   <td class="form-label"> Title </td>
+   <td> <input type="text" name="title" /> </td>
+</tr>
+<tr>
+   <td colspan="2"> 
+    <div class="form-element">
+     <input type="submit" value="submit"/>
+     </div>
+   </td>
+</tr>
+
+</table>
+
+</form>
+
+</body>
+</html>
diff --git a/src/Products/PlonePAS/zmi/GroupAwareRoleManagerForm.dtml b/src/Products/PlonePAS/zmi/GroupAwareRoleManagerForm.dtml
new file mode 100644
index 0000000..cf2c5f2
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/GroupAwareRoleManagerForm.dtml
@@ -0,0 +1,35 @@
+<dtml-var manage_page_header>
+
+<h2> Add A Group Aware Role Manager For PAS </h2>
+
+<p class="form-help">
+  install a group aware role manager. returns roles assigned to group 
+  a principal is a member of, in addition to the explicit roles
+  assigned directly to the principal.
+</p>
+
+<form action="manage_addGroupAwareRoleManager" method="POST">
+
+<table>
+
+<tr>
+   <td class="form-label"> Id </td>
+   <td> <input type="text" name="id" /> </td>
+</tr>
+<tr>
+   <td class="form-label"> Title </td>
+   <td> <input type="text" name="title" /> </td>
+</tr>
+<tr>
+   <td colspan="2"> 
+   <div class="form-element">
+    <input type="submit" value="add group aware role manager"/>
+   </div>
+   </td>
+</tr>
+</table>   
+
+</form>
+
+</body>
+</html>
diff --git a/src/Products/PlonePAS/zmi/GroupManagerForm.dtml b/src/Products/PlonePAS/zmi/GroupManagerForm.dtml
new file mode 100644
index 0000000..fcb2974
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/GroupManagerForm.dtml
@@ -0,0 +1,35 @@
+<dtml-var manage_page_header>
+
+<h2> Add A Group Manager For PAS </h2>
+
+<p class="form-help">
+ This group manager allows for zodb based storage of groups, as well
+ exposing a management interface for adding, deleting, modifying, and
+ introspecting groups. 
+</p>
+
+<form action="manage_addGroupManager" method="POST">
+
+<table>
+<tr>
+   <td class="form-label"> Id </td>
+   <td> <input type="text" name="id" /> </td>
+</tr>
+<tr>
+   <td class="form-label"> Title </td>
+   <td> <input type="text" name="title" /> </td>
+</tr>
+<tr>
+   <td colspan="2"> 
+    <div class="form-element">
+     <input type="submit" value="submit"/>
+     </div>
+   </td>
+</tr>
+
+</table>
+
+</form>
+
+</body>
+</html>
diff --git a/src/Products/PlonePAS/zmi/LocalRolesManagerForm.dtml b/src/Products/PlonePAS/zmi/LocalRolesManagerForm.dtml
new file mode 100644
index 0000000..1a136b6
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/LocalRolesManagerForm.dtml
@@ -0,0 +1,34 @@
+<dtml-var manage_page_header>
+
+<h2> Add A Local Roles Manager For PAS </h2>
+
+<p class="form-help">
+ This local roles manager checks for both user and the user's groups
+ local roles as well allowing for local roles blocking on containers.
+</p>
+
+<form action="manage_addLocalRolesManager" method="POST">
+
+<table>
+<tr>
+   <td class="form-label"> Id </td>
+   <td> <input type="text" name="id" /> </td>
+</tr>
+<tr>
+   <td class="form-label"> Title </td>
+   <td> <input type="text" name="title" /> </td>
+</tr>
+<tr>
+   <td colspan="2"> 
+    <div class="form-element">
+     <input type="submit" value="submit"/>
+     </div>
+   </td>
+</tr>
+
+</table>
+
+</form>
+
+</body>
+</html>
diff --git a/src/Products/PlonePAS/zmi/MutablePropertyProviderForm.dtml b/src/Products/PlonePAS/zmi/MutablePropertyProviderForm.dtml
new file mode 100644
index 0000000..53731fa
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/MutablePropertyProviderForm.dtml
@@ -0,0 +1,34 @@
+<dtml-var manage_page_header>
+
+<h2> Add A Mutable Property Provider For PAS </h2>
+
+<p class="form-help">
+  install a ZODB-based mutable property provider. provides property sheets like
+  a regular property manager, but allows writing as well.
+</p>
+
+<form action="manage_addZODBMutablePropertyProvider" method="POST">
+
+<table>
+
+<tr>
+   <td class="form-label"> Id </td>
+   <td> <input type="text" name="id" /> </td>
+</tr>
+<tr>
+   <td class="form-label"> Title </td>
+   <td> <input type="text" name="title" /> </td>
+</tr>
+<tr>
+   <td colspan="2"> 
+   <div class="form-element">
+    <input type="submit" value="add mutable property provider"/>
+   </div>
+   </td>
+</tr>
+</table>   
+
+</form>
+
+</body>
+</html>
diff --git a/src/Products/PlonePAS/zmi/PasswordPolicyForm.zpt b/src/Products/PlonePAS/zmi/PasswordPolicyForm.zpt
new file mode 100644
index 0000000..43a2726
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/PasswordPolicyForm.zpt
@@ -0,0 +1,45 @@
+<h1 tal:replace="structure here/manage_page_header">Header</h1>
+
+<h2 tal:define="form_title string:Add Default Plone Password Policy plugin"
+    tal:replace="structure here/manage_form_title">Form Title</h2>
+
+<p class="form-help">
+The Default Plone Password Policy validates passwords to be at least 5 chars long
+</p>
+
+<form action="manage_addPasswordPolicyPlugin" method="post">
+<table cellspacing="0" cellpadding="2" border="0">
+  <tr>
+    <td align="left" valign="top">
+    <div class="form-label">
+    Id
+    </div>
+    </td>
+    <td align="left" valign="top">
+    <input type="text" name="id" size="40" />
+    </td>
+  </tr>
+  <tr>
+    <td align="left" valign="top">
+    <div class="form-optional">
+    Title
+    </div>
+    </td>
+    <td align="left" valign="top">
+    <input type="text" name="title" size="40" />
+    </td>
+  </tr>
+  <tr>
+    <td align="left" valign="top">
+    </td>
+    <td align="left" valign="top">
+    <div class="form-element">
+    <input class="form-element" type="submit" name="submit"
+     value=" Add " />
+    </div>
+    </td>
+  </tr>
+</table>
+</form>
+
+<h1 tal:replace="structure here/manage_page_footer">Footer</h1>
diff --git a/src/Products/PlonePAS/zmi/PloneUserFactoryForm.dtml b/src/Products/PlonePAS/zmi/PloneUserFactoryForm.dtml
new file mode 100644
index 0000000..a4b8a08
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/PloneUserFactoryForm.dtml
@@ -0,0 +1,35 @@
+<dtml-var manage_page_header>
+
+<h2> Add A PloneUser Factory For PAS </h2>
+
+<p class="form-help">
+ This user factory allows for creation of plone compatible users from
+ PAS, specifically it performs name/id demangling and allows for local
+ roles black listing.
+</p>
+
+<form action="manage_addPloneUserFactory" method="POST">
+
+<table>
+<tr>
+   <td class="form-label"> Id </td>
+   <td> <input type="text" name="id" /> </td>
+</tr>
+<tr>
+   <td class="form-label"> Title </td>
+   <td> <input type="text" name="title" /> </td>
+</tr>
+<tr>
+   <td colspan="2"> 
+    <div class="form-element">
+     <input type="submit" value="submit"/>
+     </div>
+   </td>
+</tr>
+
+</table>
+
+</form>
+
+</body>
+</html>
diff --git a/src/Products/PlonePAS/zmi/UserManagerForm.dtml b/src/Products/PlonePAS/zmi/UserManagerForm.dtml
new file mode 100644
index 0000000..1601847
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/UserManagerForm.dtml
@@ -0,0 +1,35 @@
+<dtml-var manage_page_header>
+
+<h2> Add A User Manager For PAS </h2>
+
+<p class="form-help">
+ This user manager allows for zodb based storage of users, as well
+ exposing a management interface for adding, deleting, and modifying
+ users. 
+</p>
+
+<form action="manage_addUserManager" method="POST">
+
+<table>
+<tr>
+   <td class="form-label"> Id </td>
+   <td> <input type="text" name="id" /> </td>
+</tr>
+<tr>
+   <td class="form-label"> Title </td>
+   <td> <input type="text" name="title" /> </td>
+</tr>
+<tr>
+   <td colspan="2"> 
+    <div class="form-element">
+     <input type="submit" value="submit"/>
+     </div>
+   </td>
+</tr>
+
+</table>
+
+</form>
+
+</body>
+</html>
diff --git a/src/Products/PlonePAS/zmi/membershipRolemapping.dtml b/src/Products/PlonePAS/zmi/membershipRolemapping.dtml
new file mode 100644
index 0000000..1b535af
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/membershipRolemapping.dtml
@@ -0,0 +1,136 @@
+<dtml-let form_title="'Membership Tool Role Mappings'">
+<dtml-if manage_page_header>
+ <dtml-var manage_page_header>
+<dtml-else>
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.or
+ <html lang="en">
+ <head>
+ <title>&dtml-form_title;</title>
+ </head>
+ <body bgcolor="#FFFFFF" link="#000099" vlink="#555555">
+ <h3>&dtml-form_title;</h3>
+</dtml-if>
+</dtml-let>
+
+<dtml-var name="manage_tabs">
+
+<h2>Membership role mappings</h2>
+
+<p>Use this screen if you are using a userfolder other than the built-in folder
+existing role names to roles understood by the CMF.</p>
+
+<dtml-in expr="getPortalRoles()">
+  <dtml-if name="sequence-start">
+    <table border="1" cellpadding="3">
+      <tr>
+        <td class="form-label"><b>Portal Role</b></td>
+        <td class="form-label"><b>User Folder-defined Role</b></td>
+        <td>&nbsp;</td>
+      </tr>
+  </dtml-if>
+
+  <tr>
+    <form method="post" action="setRoleMapping">
+
+    <td class="form-label"><dtml-var name="sequence-item"><input type="hidden"
+        name="portal_role" value="&dtml-sequence-item;"></td>
+    <td class="form-element"><input type="text" size="30" name="userfolder_role"
+              value="<dtml-var expr="getMappedRole(_['sequence-item'])">"></td>
+    <td><input type="submit" value="Set Mapping"></td>
+    </form>
+  </tr>
+
+  <dtml-if name="sequence-end">
+    </table>
+  </dtml-if>
+</dtml-in>
+
+<p><hr></p>
+
+<h2>Control creation of member areas</h2>
+
+<p>This feature controls whether users
+will have their own folder created upon first login or not.</p>
+
+<form method="post" action="setMemberareaCreationFlag">
+
+<dtml-if expr="getMemberareaCreationFlag() == 1">
+  <p><b>Member areas are created upon first login.</b>
+  <input type="submit" value=" Turn folder creation off ">
+<dtml-else>
+  <p><b>No member areas are created.</b>
+  <input type="submit" value=" Turn folder creation on ">
+</dtml-if>
+
+</form>
+
+<p><hr></p>
+
+<h2>Set member area type</h2>
+
+<p>Select the (folderish) type to use when creating new
+member areas. You have all the freedom you want but be aware that
+non-folderish types may cause problems.</p>
+
+<form action="manage_setMemberAreaType" method="post">
+<table cellspacing="2">
+<tr>
+  <td align="left" valign="top">
+    <div class="form-label">Member area type</div>
+  </td>
+  <td align="left" valign="top">
+    <select name="type_name">
+      <dtml-let types="[x.getId() for x in portal_types.listTypeInfo()]"
+                dummy="types.sort()">
+        <dtml-in types>
+          <dtml-let id="_['sequence-item']">
+            <option
+              <dtml-if expr="id == memberarea_type">
+                selected="selected"
+              </dtml-if>
+              name="<dtml-var id>"><dtml-var id></option>
+          </dtml-let>
+        </dtml-in>
+      </dtml-let>
+    </select>
+  </td>
+</tr>
+<tr>
+  <td>
+  </td>
+  <td align="left" valign="top">
+    <input class="form-element" type="submit" value=" Change ">
+  </td>
+</tr>
+</table>
+</form>
+
+<p><hr></p>
+
+<h2>Set members folder</h2>
+
+<p>The members folder has to be in the same container as the membership tool.</p>
+
+<form action="manage_setMembersFolderById" method="post">
+<table cellspacing="2">
+<tr>
+  <td align="left" valign="top">
+    <div class="form-label">Members folder id</div>
+  </td>
+  <td align="left" valign="top">
+    <input class="form-element" type="text" name="id"
+        value="&dtml-membersfolder_id;">
+  </td>
+</tr>
+<tr>
+  <td>
+  </td>
+  <td align="left" valign="top">
+    <input class="form-element" type="submit" value=" Change ">
+  </td>
+</tr>
+</table>
+</form>
+
+</body>
+</html>
diff --git a/src/Products/PlonePAS/zmi/portrait_fix.dtml b/src/Products/PlonePAS/zmi/portrait_fix.dtml
new file mode 100644
index 0000000..6109e31
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/portrait_fix.dtml
@@ -0,0 +1,55 @@
+<dtml-var manage_page_header>
+<dtml-var manage_tabs>
+
+<p>This is a simple tool for purging members who have uploaded non-image files
+as their member portraits in an attempted cross site scripting attack.  The
+issue which allowed such portraits to be uploaded has been resolved, and this
+tool will remove any existing bad portraits and give you the option of removing
+the members to whom those portraits belonged.
+</p>
+
+<hr />
+<dtml-if search_for_bad_members>
+  <dtml-let ids="getBadMembers()">
+    <dtml-if ids>
+      <p>Found <dtml-var "len(ids)"> bad member portraits and removed them.
+         You may optionally delete these members as well using the form below.
+      </p>
+      <form name="purge_bad_members"
+            method="POST"
+            action="manage_portrait_fix">
+        <ul>
+          <dtml-in ids>
+            <li><dtml-var sequence-item></li>
+            <input type="hidden"
+                   name="member_ids:list"
+                   value="&dtml-sequence-item;"/>
+          </dtml-in>
+        </ul>
+        <input type="checkbox"
+               name="delete_memberareas:bool"
+               checked="true">Delete member areas
+        <br />
+        <input type="submit"
+               name="purge_bad_members"
+               value="Remove These Members" />
+      </form>
+    <dtml-else>
+      <p>No bad members found</p>
+    </dtml-if>
+  </dtml-let>
+<dtml-elif purge_bad_members>
+  
+  <dtml-let deleted="deleteMembers(member_ids, REQUEST.get('delete_memberareas', False), REQUEST=REQUEST)">
+    <dtml-call "portal_memberdata.pruneMemberDataContents()">
+    <p>Deleted <dtml-var "len(deleted)"> bad members</p>
+  </dtml-let>
+<dtml-else>
+  <form name="get_bad_members"
+        method="POST"
+        action="manage_portrait_fix">
+
+    <input type="submit" name="search_for_bad_members"
+           value="Remove Bad Portraits" />
+  </form>
+</dtml-if>
diff --git a/src/Products/__init__.py b/src/Products/__init__.py
new file mode 100644
index 0000000..68c04af
--- /dev/null
+++ b/src/Products/__init__.py
@@ -0,0 +1,2 @@
+# -*- coding: utf-8 -*-
+__import__('pkg_resources').declare_namespace(__name__)


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:44:14+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/0f17c0a98589d849351b95c4eeaea518eef109d0

there is no direct upgrade path from Plone 2.5 in Plone 5

Files changed:
D src/Products/PlonePAS/tools/plonetool.py

diff --git a/src/Products/PlonePAS/tools/plonetool.py b/src/Products/PlonePAS/tools/plonetool.py
deleted file mode 100644
index 8e3bd6a..0000000
--- a/src/Products/PlonePAS/tools/plonetool.py
+++ /dev/null
@@ -1,3 +0,0 @@
-# This is a backwards compatibility alias. It can be removed once Plone
-# doesn't support upgrading from Plone 2.5 anymore.
-from Products.CMFPlone.PloneTool import PloneTool


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:44:14+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/f675efdacfa7e940554786464eefed088d3e5c0f

flake8 fixes after running code-analysis, still some C901 (too complex) left

Files changed:
M src/Products/PlonePAS/interfaces/group.py
M src/Products/PlonePAS/ldapmp.py
M src/Products/PlonePAS/pas.py
M src/Products/PlonePAS/patch.py
M src/Products/PlonePAS/plugins/autogroup.py
M src/Products/PlonePAS/plugins/group.py
M src/Products/PlonePAS/plugins/local_role.py
M src/Products/PlonePAS/plugins/role.py
M src/Products/PlonePAS/setuphandlers.py
M src/Products/PlonePAS/sheet.py
M src/Products/PlonePAS/tests/base.py
M src/Products/PlonePAS/tests/test_groupdatatool.py
M src/Products/PlonePAS/tests/test_groupstool.py
M src/Products/PlonePAS/tests/test_membershiptool.py
M src/Products/PlonePAS/tests/test_properties.py
M src/Products/PlonePAS/tools/groupdata.py
M src/Products/PlonePAS/tools/groups.py
M src/Products/PlonePAS/tools/membership.py

diff --git a/src/Products/PlonePAS/interfaces/group.py b/src/Products/PlonePAS/interfaces/group.py
index 537eca1..991c13b 100644
--- a/src/Products/PlonePAS/interfaces/group.py
+++ b/src/Products/PlonePAS/interfaces/group.py
@@ -79,8 +79,8 @@ def wrapGroup(group):
 
 
 class IGroupTool(IGroupIntrospection,
-                  IGroupManagement,
-                  plugins.IGroupsPlugin):
+                 IGroupManagement,
+                 plugins.IGroupsPlugin):
 
     """
     Defines an interface for managing and introspecting and
diff --git a/src/Products/PlonePAS/ldapmp.py b/src/Products/PlonePAS/ldapmp.py
index dd25b1a..c5511b3 100644
--- a/src/Products/PlonePAS/ldapmp.py
+++ b/src/Products/PlonePAS/ldapmp.py
@@ -10,7 +10,7 @@
               'cn',),
     'description': ('description', ),
     'email': ('mail', ),
-    }
+}
 
 KNOWN_ATTRS = []
 for attrs in GROUP_PROPERTY_MAP.values():
diff --git a/src/Products/PlonePAS/pas.py b/src/Products/PlonePAS/pas.py
index 52ba319..696378a 100644
--- a/src/Products/PlonePAS/pas.py
+++ b/src/Products/PlonePAS/pas.py
@@ -442,8 +442,10 @@ def authenticate(self, name, password, request):
                 break
         except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
             logger.info(
-                    'PluggableAuthService: AuthenticationPlugin %s error',
-                    authenticator_id, exc_info=1)
+                'PluggableAuthService: AuthenticationPlugin %s error',
+                authenticator_id,
+                exc_info=1
+            )
             continue
 
     if not user_id:
@@ -470,8 +472,10 @@ def getUserIds(self):
             results.extend(introspector.getUserIds())
         except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
             logger.info(
-                    'PluggableAuthService: UserIntrospection %s error',
-                    introspector_id, exc_info=1)
+                'PluggableAuthService: UserIntrospection %s error',
+                introspector_id,
+                exc_info=1
+            )
 
     return results
 
diff --git a/src/Products/PlonePAS/patch.py b/src/Products/PlonePAS/patch.py
index 0c95d31..e53febf 100644
--- a/src/Products/PlonePAS/patch.py
+++ b/src/Products/PlonePAS/patch.py
@@ -34,7 +34,7 @@ def wrap_method(klass, name, method,
                 'PlonePAS: *NOT* wrapping already wrapped method at '
                 '{0}.{1}'.format(
                     klass.__name__, name)
-                )
+            )
 
             return
         logger.info('PlonePAS: Wrapping method at %s.%s', klass.__name__, name)
diff --git a/src/Products/PlonePAS/plugins/autogroup.py b/src/Products/PlonePAS/plugins/autogroup.py
index 4b21b79..8ec0ee3 100644
--- a/src/Products/PlonePAS/plugins/autogroup.py
+++ b/src/Products/PlonePAS/plugins/autogroup.py
@@ -62,10 +62,10 @@ def isGroup(self):
 
 
 @implementer(
-        IGroupEnumerationPlugin,
-        IGroupsPlugin,
-        IGroupIntrospection,
-        IPropertiesPlugin
+    IGroupEnumerationPlugin,
+    IGroupsPlugin,
+    IGroupIntrospection,
+    IPropertiesPlugin
 )
 class AutoGroup(BasePlugin):
     meta_type = "Automatic Group Plugin"
diff --git a/src/Products/PlonePAS/plugins/group.py b/src/Products/PlonePAS/plugins/group.py
index cb46c5d..1c70fa9 100644
--- a/src/Products/PlonePAS/plugins/group.py
+++ b/src/Products/PlonePAS/plugins/group.py
@@ -219,8 +219,11 @@ def _verifyGroup(self, plugins, group_id=None, title=None):
 
                 except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
                     logger.info(
-                       'PluggableAuthService: GroupEnumerationPlugin %s error',
-                       enumerator_id, exc_info=1)
+                        'PluggableAuthService: GroupEnumerationPlugin %s '
+                        'error',
+                        enumerator_id,
+                        exc_info=1
+                    )
 
         return 0
 
diff --git a/src/Products/PlonePAS/plugins/local_role.py b/src/Products/PlonePAS/plugins/local_role.py
index 7748ece..f963081 100644
--- a/src/Products/PlonePAS/plugins/local_role.py
+++ b/src/Products/PlonePAS/plugins/local_role.py
@@ -42,7 +42,7 @@ def __init__(self, id, title=None):
         self._id = self.id = id
         self.title = title
 
-    #security.declarePrivate( 'getRolesInContext' )
+    # security.declarePrivate( 'getRolesInContext' )
     def getRolesInContext(self, user, object):
         user_id = user.getId()
         group_ids = user.getGroups()
@@ -86,7 +86,7 @@ def getRolesInContext(self, user, object):
 
         return local.keys()
 
-    #security.declarePrivate( 'checkLocalRolesAllowed' )
+    # security.declarePrivate('checkLocalRolesAllowed')
     def checkLocalRolesAllowed(self, user, object, object_roles):
         # Still have not found a match, so check local roles. We do
         # this manually rather than call getRolesInContext so that
diff --git a/src/Products/PlonePAS/plugins/role.py b/src/Products/PlonePAS/plugins/role.py
index 5684ed3..82cb295 100644
--- a/src/Products/PlonePAS/plugins/role.py
+++ b/src/Products/PlonePAS/plugins/role.py
@@ -64,12 +64,18 @@ def manage_afterAdd(self, item, container):
     def assignRoleToPrincipal(self, role_id, principal_id, REQUEST=None):
         try:
             return ZODBRoleManager.assignRoleToPrincipal(
-                                        self, role_id, principal_id)
+                self,
+                role_id,
+                principal_id
+            )
         except KeyError:
             # Lazily update our roles list and try again
             self.updateRolesList()
             return ZODBRoleManager.assignRoleToPrincipal(
-                                        self, role_id, principal_id)
+                self,
+                role_id,
+                principal_id
+            )
 
     @security.protected(ManageUsers)
     def assignRolesToPrincipal(self, roles, principal_id, REQUEST=None):
diff --git a/src/Products/PlonePAS/setuphandlers.py b/src/Products/PlonePAS/setuphandlers.py
index 4e3637f..df107e2 100644
--- a/src/Products/PlonePAS/setuphandlers.py
+++ b/src/Products/PlonePAS/setuphandlers.py
@@ -72,7 +72,7 @@ def registerPluginTypes(pas):
         'title': 'user_management',
         'description': ("The User Management plugins allow the "
                         "Pluggable Auth Service to add/delete/modify users")
-        }
+    }
 
     registerPluginType(pas, IUserManagement, PluginInfo)
 
@@ -81,7 +81,7 @@ def registerPluginTypes(pas):
         'title': 'user_introspection',
         'description': ("The User Introspection plugins allow the "
                         "Pluggable Auth Service to provide lists of users")
-        }
+    }
 
     registerPluginType(pas, IUserIntrospection, PluginInfo)
 
@@ -90,7 +90,7 @@ def registerPluginTypes(pas):
         'title': 'group_management',
         'description': ("Group Management provides add/write/deletion "
                         "of groups and member management")
-        }
+    }
 
     registerPluginType(pas, igroup.IGroupManagement, PluginInfo)
 
@@ -99,7 +99,7 @@ def registerPluginTypes(pas):
         'title': 'group_introspection',
         'description': ("Group Introspection provides listings "
                         "of groups and membership")
-        }
+    }
 
     registerPluginType(pas, igroup.IGroupIntrospection, PluginInfo)
 
@@ -107,7 +107,7 @@ def registerPluginTypes(pas):
         'id': 'ILocalRolesPlugin',
         'title': 'local_roles',
         'description': "Defines Policy for getting Local Roles"
-        }
+    }
 
     registerPluginType(pas, ILocalRolesPlugin, PluginInfo)
 
@@ -160,8 +160,8 @@ def setupPlugins(portal):
     found = uf.objectIds(['Automatic Group Plugin'])
     if not found:
         plone_pas.manage_addAutoGroup(
-                "auto_group", "Authenticated Users (Virtual Group)",
-                "AuthenticatedUsers", "Automatic Group Provider")
+            "auto_group", "Authenticated Users (Virtual Group)",
+            "AuthenticatedUsers", "Automatic Group Provider")
         logger.debug("Added Automatic Group.")
         activatePluginInterfaces(portal, "auto_group")
 
@@ -319,7 +319,7 @@ def migrate_root_uf(self):
 
 def pas_fixup(self):
     from Products.PluggableAuthService.PluggableAuthService \
-         import _PLUGIN_TYPE_INFO
+        import _PLUGIN_TYPE_INFO
 
     pas = getToolByName(self, 'acl_users')
     if not IPluggableAuthService.providedBy(pas):
@@ -339,7 +339,7 @@ def pas_fixup(self):
             'id': id,
             'title': title,
             'description': description,
-            }
+        }
     # Make it ordered
     plugin_types.sort()
 
diff --git a/src/Products/PlonePAS/sheet.py b/src/Products/PlonePAS/sheet.py
index 8b05083..570fd21 100644
--- a/src/Products/PlonePAS/sheet.py
+++ b/src/Products/PlonePAS/sheet.py
@@ -56,19 +56,19 @@ def validate(self, property_type, value):
 )
 PropertySchema.addType(
     'int',
-    lambda x:  x is None or isinstance(x, int)
+    lambda x: x is None or isinstance(x, int)
 )
 PropertySchema.addType(
     'long',
-    lambda x:  x is None or isinstance(x, long)
+    lambda x: x is None or isinstance(x, long)
 )
 PropertySchema.addType(
     'float',
-    lambda x:  x is None or isinstance(x, float)
+    lambda x: x is None or isinstance(x, float)
 )
 PropertySchema.addType(
     'lines',
-    lambda x:  x is None or isinstance(x, _SequenceTypes)
+    lambda x: x is None or isinstance(x, _SequenceTypes)
 )
 PropertySchema.addType(
     'selection',
@@ -76,7 +76,7 @@ def validate(self, property_type, value):
 )
 PropertySchema.addType(
     'multiple selection',
-    lambda x:  x is None or isinstance(x, _SequenceTypes)
+    lambda x: x is None or isinstance(x, _SequenceTypes)
 )
 PropertySchema.addType(
     'date',
diff --git a/src/Products/PlonePAS/tests/base.py b/src/Products/PlonePAS/tests/base.py
index f274012..2003845 100644
--- a/src/Products/PlonePAS/tests/base.py
+++ b/src/Products/PlonePAS/tests/base.py
@@ -1,3 +1,3 @@
 # -*- coding: utf-8 -*-
-from plone.app.testing.bbb import PloneTestCase as TestCase
-from plone.app.testing.bbb import PloneTestCase as FunctionalTestCase
+from plone.app.testing.bbb import PloneTestCase as TestCase  # noqa
+from plone.app.testing.bbb import PloneTestCase as FunctionalTestCase  # noqa
diff --git a/src/Products/PlonePAS/tests/test_groupdatatool.py b/src/Products/PlonePAS/tests/test_groupdatatool.py
index 6bb8600..adf6b3d 100644
--- a/src/Products/PlonePAS/tests/test_groupdatatool.py
+++ b/src/Products/PlonePAS/tests/test_groupdatatool.py
@@ -127,11 +127,15 @@ def testGetRolesInContext(self):
         g = self.groups.getGroupById('foo')
         self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
         user = self.acl_users.getUser(TEST_USER_NAME)
-        self.assertEqual(user.getRolesInContext(self.folder).sort(),
-                        ['Member', 'Authenticated', 'Owner'].sort())
+        self.assertEqual(
+            user.getRolesInContext(self.folder).sort(),
+            ['Member', 'Authenticated', 'Owner'].sort()
+        )
         self.folder.manage_setLocalRoles(g.getId(), ['NewRole'])
-        self.assertEqual(user.getRolesInContext(self.folder).sort(),
-                        ['Member', 'Authenticated', 'Owner', 'NewRole'].sort())
+        self.assertEqual(
+            user.getRolesInContext(self.folder).sort(),
+            ['Member', 'Authenticated', 'Owner', 'NewRole'].sort()
+        )
 
     def testGetDomains(self):
         g = self.groups.getGroupById('foo')
@@ -178,4 +182,3 @@ def testManagerRemoveMember(self):
         self.setPermissions([Permissions.manage_users])
         self.groupdata.addMember(TEST_USER_ID)
         self.groupdata.removeMember(TEST_USER_ID)
-
diff --git a/src/Products/PlonePAS/tests/test_groupstool.py b/src/Products/PlonePAS/tests/test_groupstool.py
index cdac9c0..dba2052 100644
--- a/src/Products/PlonePAS/tests/test_groupstool.py
+++ b/src/Products/PlonePAS/tests/test_groupstool.py
@@ -256,4 +256,3 @@ def testGetBadGroupInfo(self):
 
     def beforeTearDown(self):
         self._free_warning_output()
-
diff --git a/src/Products/PlonePAS/tests/test_membershiptool.py b/src/Products/PlonePAS/tests/test_membershiptool.py
index 29d309d..42b3b98 100644
--- a/src/Products/PlonePAS/tests/test_membershiptool.py
+++ b/src/Products/PlonePAS/tests/test_membershiptool.py
@@ -66,50 +66,50 @@ def test_get_member_by_id(self):
     def test_id_clean(self):
         from Products.PlonePAS.utils import cleanId, decleanId
         a = [
-             "asdfasdf",
-             "asdf-asdf",
-             "asdf--asdf",
-             "asdf---asdf",
-             "asdf----asdf",
-             "asdf-----asdf",
-             "asdf%asdf",
-             "asdf%%asdf",
-             "asdf%%%asdf",
-             "asdf%%%%asdf",
-             "asdf%%%%%asdf",
-             "asdf-%asdf",
-             "asdf%-asdf",
-             "asdf-%-asdf",
-             "asdf%-%asdf",
-             "asdf--%asdf",
-             "asdf%--asdf",
-             "asdf--%-asdf",
-             "asdf-%--asdf",
-             "asdf--%--asdf",
-             "asdf%-%asdf",
-             "asdf%--%asdf",
-             "asdf%---%asdf",
-             "-asdf",
-             "--asdf",
-             "---asdf",
-             "----asdf",
-             "-----asdf",
-             "asdf-",
-             "asdf--",
-             "asdf---",
-             "asdf----",
-             "asdf-----",
-             "%asdf",
-             "%%asdf",
-             "%%%asdf",
-             "%%%%asdf",
-             "%%%%%asdf",
-             "asdf%",
-             "asdf%%",
-             "asdf%%%",
-             "asdf%%%%",
-             "asdf%%%%%",
-             "asdf\x00asdf",
+            "asdfasdf",
+            "asdf-asdf",
+            "asdf--asdf",
+            "asdf---asdf",
+            "asdf----asdf",
+            "asdf-----asdf",
+            "asdf%asdf",
+            "asdf%%asdf",
+            "asdf%%%asdf",
+            "asdf%%%%asdf",
+            "asdf%%%%%asdf",
+            "asdf-%asdf",
+            "asdf%-asdf",
+            "asdf-%-asdf",
+            "asdf%-%asdf",
+            "asdf--%asdf",
+            "asdf%--asdf",
+            "asdf--%-asdf",
+            "asdf-%--asdf",
+            "asdf--%--asdf",
+            "asdf%-%asdf",
+            "asdf%--%asdf",
+            "asdf%---%asdf",
+            "-asdf",
+            "--asdf",
+            "---asdf",
+            "----asdf",
+            "-----asdf",
+            "asdf-",
+            "asdf--",
+            "asdf---",
+            "asdf----",
+            "asdf-----",
+            "%asdf",
+            "%%asdf",
+            "%%%asdf",
+            "%%%%asdf",
+            "%%%%%asdf",
+            "asdf%",
+            "asdf%%",
+            "asdf%%%",
+            "asdf%%%%",
+            "asdf%%%%%",
+            "asdf\x00asdf",
         ]
         b = [cleanId(id) for id in a]
         c = [decleanId(id) for id in b]
@@ -901,7 +901,7 @@ def assertProtected(self, object, method):
     for method in _unprotected:
         exec "def testUnprotected_%s(self):" \
              "    self.assertProtected(self.membership, '%s')" \
-                % (method, method)
+             % (method, method)
 
         exec "def testMemberAccessible_%s(self):" \
              "    self.membership.restrictedTraverse('%s')" % (method, method)
diff --git a/src/Products/PlonePAS/tests/test_properties.py b/src/Products/PlonePAS/tests/test_properties.py
index d2e808f..3dab964 100644
--- a/src/Products/PlonePAS/tests/test_properties.py
+++ b/src/Products/PlonePAS/tests/test_properties.py
@@ -161,7 +161,7 @@ def test_schema_for_mutable_property_provider(self):
             ('addresses', 'lines', ['Here', 'There']),
             ('city', 'str', 'Somewhere'),
             ('telephone', 'int', 1234567),
-            ]
+        ]
 
         # This used to give a ValueError, so we just check that it
         # does not.
@@ -276,7 +276,9 @@ def testGroupsNotReturnedByEnumerateUsers(self):
     def testSearchEmptyId(self):
         self.assertEqual(self.pas.mutable_properties.enumerateUsers(id=''), ())
         self.assertEqual(
-                self.pas.mutable_properties.enumerateUsers(login=''), ())
+            self.pas.mutable_properties.enumerateUsers(login=''),
+            ()
+        )
 
     def testCantSearchByIdOrLogin(self):
         # we can't search by id
diff --git a/src/Products/PlonePAS/tools/groupdata.py b/src/Products/PlonePAS/tools/groupdata.py
index 615223e..a7b74e6 100644
--- a/src/Products/PlonePAS/tools/groupdata.py
+++ b/src/Products/PlonePAS/tools/groupdata.py
@@ -450,13 +450,13 @@ def has_role(self, roles, object=None):
         """Check to see if a user has a given role or roles."""
         return self.getGroup().has_role(roles, object)
 
-    ## GRUF 3.2 methods...
+    # GRUF 3.2 methods...
 
     def getUserName(self):
         return self.getName()
     getUserNameWithoutGroupPrefix = getUserName
 
-    ## IManageCapabilities methods
+    # IManageCapabilities methods
     def canDelete(self):
         """True iff user can be removed from the Plone UI.
         """
@@ -514,7 +514,7 @@ def canWriteProperty(self, prop_name):
     canRemoveFromGroup = MemberData.canRemoveFromGroup.im_func
     canAssignRole = MemberData.canAssignRole.im_func
 
-    ## plugin getters
+    # plugin getters
 
     @security.private
     def _getPlugins(self):
diff --git a/src/Products/PlonePAS/tools/groups.py b/src/Products/PlonePAS/tools/groups.py
index 90be6f0..1e1d5e1 100644
--- a/src/Products/PlonePAS/tools/groups.py
+++ b/src/Products/PlonePAS/tools/groups.py
@@ -328,18 +328,19 @@ def _getPlugins(self):
     def _getGroupManagers(self):
         return self._getPlugins().listPlugins(
             igroup.IGroupManagement
-            )
+        )
 
     @security.private
     def _getGroupIntrospectors(self):
         return self._getPlugins().listPlugins(
             igroup.IGroupIntrospection
-            )
+        )
 
     @security.private
     def _getGroupTools(self):
         managers = self._getPlugins().listPlugins(
-                        igroup.IGroupManagement)
+            igroup.IGroupManagement
+        )
         return [(id, manager) for (id, manager) in managers
                 if igroup.IGroupIntrospection.providedBy(manager)]
 
diff --git a/src/Products/PlonePAS/tools/membership.py b/src/Products/PlonePAS/tools/membership.py
index 4fe629f..d8d8acb 100644
--- a/src/Products/PlonePAS/tools/membership.py
+++ b/src/Products/PlonePAS/tools/membership.py
@@ -346,7 +346,8 @@ def createMemberarea(self, member_id=None, minimal=None):
             # check that we do not do something wrong
             if user.getId() != member_id:
                 raise NotImplementedError(
-                        'cannot get user for member area creation')
+                    'cannot get user for member area creation'
+                )
 
         member_object = self.getMemberById(member_id)
 
@@ -685,11 +686,10 @@ def logoutUser(self, REQUEST=None):
             st = getToolByName(self, "portal_skins")
             skinvar = st.getRequestVarname()
             if skinvar in REQUEST and not st.getCookiePersistence():
-                    portal = getToolByName(self, "portal_url") \
-                                .getPortalObject()
-                    path = '/' + portal.absolute_url(1)
-                    # XXX check if this path is sane
-                    REQUEST.RESPONSE.expireCookie(skinvar, path=path)
+                portal = getToolByName(self, "portal_url") .getPortalObject()
+                path = '/' + portal.absolute_url(1)
+                # XXX check if this path is sane
+                REQUEST.RESPONSE.expireCookie(skinvar, path=path)
 
         user = getSecurityManager().getUser()
         if user is not None:


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:44:14+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/366551f63bbc7ec8c78c71aab6de3aa1e7d66408

trim code-analysis and fixed in code what still was wrong

Files changed:
M src/Products/PlonePAS/Extensions/__init__.py
M src/Products/PlonePAS/browser/__init__.py
M src/Products/PlonePAS/browser/info.py
M src/Products/PlonePAS/interfaces/group.py
M src/Products/PlonePAS/pas.py
M src/Products/PlonePAS/patch.py
M src/Products/PlonePAS/plugins/group.py
M src/Products/PlonePAS/plugins/local_role.py
M src/Products/PlonePAS/plugins/passwordpolicy.py
M src/Products/PlonePAS/plugins/property.py
M src/Products/PlonePAS/plugins/role.py
M src/Products/PlonePAS/tests/test_basic_ops.py
M travis.cfg

diff --git a/src/Products/PlonePAS/Extensions/__init__.py b/src/Products/PlonePAS/Extensions/__init__.py
index 691ba77..40a96af 100644
--- a/src/Products/PlonePAS/Extensions/__init__.py
+++ b/src/Products/PlonePAS/Extensions/__init__.py
@@ -1 +1 @@
-# poof!
+# -*- coding: utf-8 -*-
diff --git a/src/Products/PlonePAS/browser/__init__.py b/src/Products/PlonePAS/browser/__init__.py
index 792d600..40a96af 100644
--- a/src/Products/PlonePAS/browser/__init__.py
+++ b/src/Products/PlonePAS/browser/__init__.py
@@ -1 +1 @@
-#
+# -*- coding: utf-8 -*-
diff --git a/src/Products/PlonePAS/browser/info.py b/src/Products/PlonePAS/browser/info.py
index 353228f..01a0342 100644
--- a/src/Products/PlonePAS/browser/info.py
+++ b/src/Products/PlonePAS/browser/info.py
@@ -1,13 +1,13 @@
 # -*- coding: utf-8 -*-
-from zope.interface import implementer
-from plone.memoize.instance import memoize
 from Acquisition import aq_inner
+from Products.CMFCore.utils import getToolByName
+from Products.Five import BrowserView
 from Products.PlonePAS.interfaces.browser import IPASInfoView
 from Products.PluggableAuthService.interfaces.plugins import IExtractionPlugin
 from Products.PluggableAuthService.interfaces.plugins \
     import ILoginPasswordExtractionPlugin
-from Products.CMFCore.utils import getToolByName
-from Products.Five import BrowserView
+from plone.memoize.instance import memoize
+from zope.interface import implementer
 
 
 @implementer(IPASInfoView)
diff --git a/src/Products/PlonePAS/interfaces/group.py b/src/Products/PlonePAS/interfaces/group.py
index 991c13b..53ea92c 100644
--- a/src/Products/PlonePAS/interfaces/group.py
+++ b/src/Products/PlonePAS/interfaces/group.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
-from zope.interface import Interface
 from Products.PluggableAuthService.interfaces import plugins
+from zope.interface import Interface
 
 
 class IGroupManagement(Interface):
diff --git a/src/Products/PlonePAS/pas.py b/src/Products/PlonePAS/pas.py
index 696378a..1c34a9c 100644
--- a/src/Products/PlonePAS/pas.py
+++ b/src/Products/PlonePAS/pas.py
@@ -15,8 +15,8 @@
 from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
 from Products.PlonePAS.interfaces.plugins import IUserIntrospection
 from Products.PlonePAS.interfaces.plugins import IUserManagement
-from Products.PlonePAS.patch import wrap_method
 from Products.PlonePAS.patch import ORIG_NAME
+from Products.PlonePAS.patch import wrap_method
 from Products.PluggableAuthService.PluggableAuthService import \
     PluggableAuthService
 from Products.PluggableAuthService.PluggableAuthService import \
diff --git a/src/Products/PlonePAS/patch.py b/src/Products/PlonePAS/patch.py
index e53febf..fce6d38 100644
--- a/src/Products/PlonePAS/patch.py
+++ b/src/Products/PlonePAS/patch.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
-import logging
 from zope.deprecation import deprecation
+import logging
 
 logger = logging.getLogger('PlonePAS')
 
diff --git a/src/Products/PlonePAS/plugins/group.py b/src/Products/PlonePAS/plugins/group.py
index 1c70fa9..1e24d5c 100644
--- a/src/Products/PlonePAS/plugins/group.py
+++ b/src/Products/PlonePAS/plugins/group.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 """
 ZODB Group Implementation with basic introspection and
 management (ie. rw) capabilities.
@@ -6,7 +7,8 @@
 from AccessControl import ClassSecurityInfo
 from App.class_init import InitializeClass
 from App.special_dtml import DTMLFile
-from BTrees.OOBTree import OOBTree, OOSet
+from BTrees.OOBTree import OOBTree
+from BTrees.OOBTree import OOSet
 from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
 from Products.PlonePAS.interfaces.capabilities import IGroupCapability
 from Products.PlonePAS.interfaces.group import IGroupIntrospection
diff --git a/src/Products/PlonePAS/plugins/local_role.py b/src/Products/PlonePAS/plugins/local_role.py
index f963081..f09ef38 100644
--- a/src/Products/PlonePAS/plugins/local_role.py
+++ b/src/Products/PlonePAS/plugins/local_role.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 """
 A Local Roles Plugin Implementation that respects Black Listing markers.
 
@@ -6,7 +7,8 @@
 
 """
 from AccessControl import ClassSecurityInfo
-from Acquisition import aq_inner, aq_parent
+from Acquisition import aq_inner
+from Acquisition import aq_parent
 from App.class_init import InitializeClass
 from App.special_dtml import DTMLFile
 from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
diff --git a/src/Products/PlonePAS/plugins/passwordpolicy.py b/src/Products/PlonePAS/plugins/passwordpolicy.py
index b0eee47..0b3c29a 100644
--- a/src/Products/PlonePAS/plugins/passwordpolicy.py
+++ b/src/Products/PlonePAS/plugins/passwordpolicy.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 """
 Password Validation plugin (IValidationPlugin)
 Mutable Property Provider
diff --git a/src/Products/PlonePAS/plugins/property.py b/src/Products/PlonePAS/plugins/property.py
index 3d6cb6b..25e8ee5 100644
--- a/src/Products/PlonePAS/plugins/property.py
+++ b/src/Products/PlonePAS/plugins/property.py
@@ -8,7 +8,8 @@
 from BTrees.OOBTree import OOBTree
 from Products.CMFCore.utils import getToolByName
 from Products.PlonePAS.interfaces.plugins import IMutablePropertiesPlugin
-from Products.PlonePAS.sheet import MutablePropertySheet, validateValue
+from Products.PlonePAS.sheet import MutablePropertySheet
+from Products.PlonePAS.sheet import validateValue
 from Products.PlonePAS.utils import safe_unicode
 from Products.PluggableAuthService.UserPropertySheet import _guessSchema
 from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
diff --git a/src/Products/PlonePAS/plugins/role.py b/src/Products/PlonePAS/plugins/role.py
index 82cb295..8a0b444 100644
--- a/src/Products/PlonePAS/plugins/role.py
+++ b/src/Products/PlonePAS/plugins/role.py
@@ -7,9 +7,9 @@
 """
 from AccessControl import ClassSecurityInfo
 from AccessControl.requestmethod import postonly
-from Acquisition import aq_parent
-from Acquisition import aq_inner
 from Acquisition import aq_get
+from Acquisition import aq_inner
+from Acquisition import aq_parent
 from App.class_init import InitializeClass
 from App.special_dtml import DTMLFile
 from Products.PlonePAS.interfaces.capabilities import IAssignRoleCapability
diff --git a/src/Products/PlonePAS/tests/test_basic_ops.py b/src/Products/PlonePAS/tests/test_basic_ops.py
index e70540d..5518805 100644
--- a/src/Products/PlonePAS/tests/test_basic_ops.py
+++ b/src/Products/PlonePAS/tests/test_basic_ops.py
@@ -145,6 +145,8 @@ def test_setProperties(self):
         self.assertEqual(user.getProperty('fullname'), 'Test User')
         self.assertEqual(user.getProperty('email'), 'test@example.org')
 
-        user.setProperties(properties={'fullname': 'Test User2', 'email': 'test2@example.org'})
+        user.setProperties(
+            properties={'fullname': 'Test User2', 'email': 'test2@example.org'}
+        )
         self.assertEqual(user.getProperty('fullname'), 'Test User2')
         self.assertEqual(user.getProperty('email'), 'test2@example.org')
diff --git a/travis.cfg b/travis.cfg
index 2330dff..3d64c92 100644
--- a/travis.cfg
+++ b/travis.cfg
@@ -9,3 +9,9 @@ package-extras = [test]
 [versions]
 setuptools =
 zc.buildout =
+
+[code-analysis]
+flake8-ignore = C901
+utf8-header = True
+imports = True
+debug-statements = True


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:44:14+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/738897e6e3308525ee278a4cd1139365517639db

activate code-analysis

Files changed:
M .travis.yml

diff --git a/.travis.yml b/.travis.yml
index 875913a..c7b6f40 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -4,4 +4,4 @@ install:
   - mkdir -p buildout-cache/downloads
   - pip install zc.buildout
   - buildout -c travis.cfg -N -q -t 3
-script: bin/test
+script: bin/code-analysis && bin/test


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:44:14+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/e2f47944709103868d94bbd07287dcd6c03cbe65

fixup buildout

Files changed:
M buildout.cfg
M travis.cfg
D bootstrap.py

diff --git a/bootstrap.py b/bootstrap.py
deleted file mode 100644
index 1b28969..0000000
--- a/bootstrap.py
+++ /dev/null
@@ -1,170 +0,0 @@
-##############################################################################
-#
-# Copyright (c) 2006 Zope Foundation and Contributors.
-# All Rights Reserved.
-#
-# This software is subject to the provisions of the Zope Public License,
-# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
-# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
-# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
-# FOR A PARTICULAR PURPOSE.
-#
-##############################################################################
-"""Bootstrap a buildout-based project
-
-Simply run this script in a directory containing a buildout.cfg.
-The script accepts buildout command-line options, so you can
-use the -c option to specify an alternate configuration file.
-"""
-
-import os
-import shutil
-import sys
-import tempfile
-
-from optparse import OptionParser
-
-tmpeggs = tempfile.mkdtemp()
-
-usage = '''\
-[DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]
-
-Bootstraps a buildout-based project.
-
-Simply run this script in a directory containing a buildout.cfg, using the
-Python that you want bin/buildout to use.
-
-Note that by using --find-links to point to local resources, you can keep 
-this script from going over the network.
-'''
-
-parser = OptionParser(usage=usage)
-parser.add_option("-v", "--version", help="use a specific zc.buildout version")
-
-parser.add_option("-t", "--accept-buildout-test-releases",
-                  dest='accept_buildout_test_releases',
-                  action="store_true", default=False,
-                  help=("Normally, if you do not specify a --version, the "
-                        "bootstrap script and buildout gets the newest "
-                        "*final* versions of zc.buildout and its recipes and "
-                        "extensions for you.  If you use this flag, "
-                        "bootstrap and buildout will get the newest releases "
-                        "even if they are alphas or betas."))
-parser.add_option("-c", "--config-file",
-                  help=("Specify the path to the buildout configuration "
-                        "file to be used."))
-parser.add_option("-f", "--find-links",
-                  help=("Specify a URL to search for buildout releases"))
-
-
-options, args = parser.parse_args()
-
-######################################################################
-# load/install setuptools
-
-to_reload = False
-try:
-    import pkg_resources
-    import setuptools
-except ImportError:
-    ez = {}
-
-    try:
-        from urllib.request import urlopen
-    except ImportError:
-        from urllib2 import urlopen
-
-    # XXX use a more permanent ez_setup.py URL when available.
-    exec(urlopen('https://bitbucket.org/pypa/setuptools/raw/0.7.2/ez_setup.py'
-                ).read(), ez)
-    setup_args = dict(to_dir=tmpeggs, download_delay=0)
-    ez['use_setuptools'](**setup_args)
-
-    if to_reload:
-        reload(pkg_resources)
-    import pkg_resources
-    # This does not (always?) update the default working set.  We will
-    # do it.
-    for path in sys.path:
-        if path not in pkg_resources.working_set.entries:
-            pkg_resources.working_set.add_entry(path)
-
-######################################################################
-# Install buildout
-
-ws = pkg_resources.working_set
-
-cmd = [sys.executable, '-c',
-       'from setuptools.command.easy_install import main; main()',
-       '-mZqNxd', tmpeggs]
-
-find_links = os.environ.get(
-    'bootstrap-testing-find-links',
-    options.find_links or
-    ('http://downloads.buildout.org/'
-     if options.accept_buildout_test_releases else None)
-    )
-if find_links:
-    cmd.extend(['-f', find_links])
-
-setuptools_path = ws.find(
-    pkg_resources.Requirement.parse('setuptools')).location
-
-requirement = 'zc.buildout'
-version = options.version
-if version is None and not options.accept_buildout_test_releases:
-    # Figure out the most recent final version of zc.buildout.
-    import setuptools.package_index
-    _final_parts = '*final-', '*final'
-
-    def _final_version(parsed_version):
-        for part in parsed_version:
-            if (part[:1] == '*') and (part not in _final_parts):
-                return False
-        return True
-    index = setuptools.package_index.PackageIndex(
-        search_path=[setuptools_path])
-    if find_links:
-        index.add_find_links((find_links,))
-    req = pkg_resources.Requirement.parse(requirement)
-    if index.obtain(req) is not None:
-        best = []
-        bestv = None
-        for dist in index[req.project_name]:
-            distv = dist.parsed_version
-            if _final_version(distv):
-                if bestv is None or distv > bestv:
-                    best = [dist]
-                    bestv = distv
-                elif distv == bestv:
-                    best.append(dist)
-        if best:
-            best.sort()
-            version = best[-1].version
-if version:
-    requirement = '=='.join((requirement, version))
-cmd.append(requirement)
-
-import subprocess
-if subprocess.call(cmd, env=dict(os.environ, PYTHONPATH=setuptools_path)) != 0:
-    raise Exception(
-        "Failed to execute command:\n%s",
-        repr(cmd)[1:-1])
-
-######################################################################
-# Import and run buildout
-
-ws.add_entry(tmpeggs)
-ws.require(requirement)
-import zc.buildout.buildout
-
-if not [a for a in args if '=' not in a]:
-    args.append('bootstrap')
-
-# if -c was provided, we push it back into args for buildout' main function
-if options.config_file is not None:
-    args[0:0] = ['-c', options.config_file]
-
-zc.buildout.buildout.main(args)
-shutil.rmtree(tmpeggs)
diff --git a/buildout.cfg b/buildout.cfg
index f839b65..93e9d85 100644
--- a/buildout.cfg
+++ b/buildout.cfg
@@ -1,4 +1,9 @@
 [buildout]
+# run with:
+#     virtualenv .
+#     pip install zc.buildout
+#     ./bin/buildout
+
 extends =
     https://raw.github.com/collective/buildout.plonetest/master/test-4.x.cfg
 parts +=
@@ -6,6 +11,8 @@ parts +=
 package-name = Products.PlonePAS
 package-extras = [test]
 
+develop = .
+
 [coverage]
 recipe = zc.recipe.testrunner
 eggs = ${test:eggs}
diff --git a/travis.cfg b/travis.cfg
index 3d64c92..c6b1471 100644
--- a/travis.cfg
+++ b/travis.cfg
@@ -1,4 +1,5 @@
 [buildout]
+develop = .
 extends =
     https://raw.githubusercontent.com/collective/buildout.plonetest/master/qa.cfg
     https://raw.githubusercontent.com/collective/buildout.plonetest/master/travis-5.x.cfg


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:44:14+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/65c29251aea8d7c623d9b5919c7082685b87d036

fix MANIFEST.in

Files changed:
M MANIFEST.in

diff --git a/MANIFEST.in b/MANIFEST.in
index 5477c06..913322e 100644
--- a/MANIFEST.in
+++ b/MANIFEST.in
@@ -1,4 +1,4 @@
-recursive-include Products *
+recursive-include src *
 recursive-include docs *
 include *
-global-exclude *.pyc
+global-exclude *.py?


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:44:14+01:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.PlonePAS/commit/7c929a7b0787263a2fe3f048b0f8f4fd47a1c9c2

fix link to PAS sources in README

Files changed:
M README.rst

diff --git a/README.rst b/README.rst
index ced3638..0f7ff23 100644
--- a/README.rst
+++ b/README.rst
@@ -1,7 +1,7 @@
 Overview
 ========
 
-This product extends "PluggableAuthService":http://svn.zope.org/PluggableAuthService/ (PAS) for use in Plone.
+This product extends `PluggableAuthService <https://github.com/zopefoundation/Products.PluggableAuthService>'_ (PAS) for use in Plone.
 
 It adds
 


Repository: Products.PlonePAS
Branch: refs/heads/master
Date: 2015-03-11T16:47:06+01:00
Author: Daniel Widerin (saily) <daniel@widerin.net>
Commit: https://github.com/plone/Products.PlonePAS/commit/af4351caf96fc189cad0ec7c60d253eb23b81900

Merge pull request #7 from plone/jensens-cleanup-and-review

pep8 et al, review and code modernization, zca and security decorators, remove Plone4+Py2.6 code, overhaul

Files changed:
A .travis.yml
A CHANGES.rst
A README.rst
A src/Products/PlonePAS/Extensions/Install.py
A src/Products/PlonePAS/Extensions/__init__.py
A src/Products/PlonePAS/__init__.py
A src/Products/PlonePAS/browser/__init__.py
A src/Products/PlonePAS/browser/configure.zcml
A src/Products/PlonePAS/browser/info.py
A src/Products/PlonePAS/browser/member.py
A src/Products/PlonePAS/browser/search.py
A src/Products/PlonePAS/config.py
A src/Products/PlonePAS/configure.zcml
A src/Products/PlonePAS/events.py
A src/Products/PlonePAS/exportimport.zcml
A src/Products/PlonePAS/interfaces/__init__.py
A src/Products/PlonePAS/interfaces/browser.py
A src/Products/PlonePAS/interfaces/capabilities.py
A src/Products/PlonePAS/interfaces/events.py
A src/Products/PlonePAS/interfaces/group.py
A src/Products/PlonePAS/interfaces/membership.py
A src/Products/PlonePAS/interfaces/plugins.py
A src/Products/PlonePAS/interfaces/propertysheets.py
A src/Products/PlonePAS/ldapmp.py
A src/Products/PlonePAS/pas.py
A src/Products/PlonePAS/patch.py
A src/Products/PlonePAS/permissions.py
A src/Products/PlonePAS/plugins/__init__.py
A src/Products/PlonePAS/plugins/autogroup.py
A src/Products/PlonePAS/plugins/cookie_handler.py
A src/Products/PlonePAS/plugins/crumbler.py
A src/Products/PlonePAS/plugins/group.py
A src/Products/PlonePAS/plugins/local_role.py
A src/Products/PlonePAS/plugins/passwordpolicy.py
A src/Products/PlonePAS/plugins/property.py
A src/Products/PlonePAS/plugins/role.py
A src/Products/PlonePAS/plugins/ufactory.py
A src/Products/PlonePAS/plugins/user.py
A src/Products/PlonePAS/profiles.zcml
A src/Products/PlonePAS/profiles/default/metadata.xml
A src/Products/PlonePAS/profiles/default/plone-pas.txt
A src/Products/PlonePAS/setuphandlers.py
A src/Products/PlonePAS/sheet.py
A src/Products/PlonePAS/tests/__init__.py
A src/Products/PlonePAS/tests/base.py
A src/Products/PlonePAS/tests/cookie_auth.rst
A src/Products/PlonePAS/tests/dummy.py
A src/Products/PlonePAS/tests/images/test.gif
A src/Products/PlonePAS/tests/images/test.jpg
A src/Products/PlonePAS/tests/images/test.png
A src/Products/PlonePAS/tests/test_basic_ops.py
A src/Products/PlonePAS/tests/test_doctests.py
A src/Products/PlonePAS/tests/test_groupdatatool.py
A src/Products/PlonePAS/tests/test_groupstool.py
A src/Products/PlonePAS/tests/test_memberdatatool.py
A src/Products/PlonePAS/tests/test_membershiptool.py
A src/Products/PlonePAS/tests/test_properties.py
A src/Products/PlonePAS/tests/test_role_plugin.py
A src/Products/PlonePAS/tests/test_views.py
A src/Products/PlonePAS/tool.gif
A src/Products/PlonePAS/tools/__init__.py
A src/Products/PlonePAS/tools/groupdata.py
A src/Products/PlonePAS/tools/groups.py
A src/Products/PlonePAS/tools/memberdata.py
A src/Products/PlonePAS/tools/membership.py
A src/Products/PlonePAS/utils.py
A src/Products/PlonePAS/zmi/AutoGroupForm.zpt
A src/Products/PlonePAS/zmi/CookieCrumblingPluginForm.dtml
A src/Products/PlonePAS/zmi/ExtendedCookieAuthHelperForm.dtml
A src/Products/PlonePAS/zmi/GroupAwareRoleManagerForm.dtml
A src/Products/PlonePAS/zmi/GroupManagerForm.dtml
A src/Products/PlonePAS/zmi/LocalRolesManagerForm.dtml
A src/Products/PlonePAS/zmi/MutablePropertyProviderForm.dtml
A src/Products/PlonePAS/zmi/PasswordPolicyForm.zpt
A src/Products/PlonePAS/zmi/PloneUserFactoryForm.dtml
A src/Products/PlonePAS/zmi/UserManagerForm.dtml
A src/Products/PlonePAS/zmi/membershipRolemapping.dtml
A src/Products/PlonePAS/zmi/portrait_fix.dtml
A src/Products/__init__.py
A travis.cfg
M .gitignore
M MANIFEST.in
M buildout.cfg
M setup.py
D CHANGES.txt
D Products/PlonePAS/Extensions/Install.py
D Products/PlonePAS/Extensions/__init__.py
D Products/PlonePAS/__init__.py
D Products/PlonePAS/browser/__init__.py
D Products/PlonePAS/browser/configure.zcml
D Products/PlonePAS/browser/info.py
D Products/PlonePAS/browser/member.py
D Products/PlonePAS/browser/search.py
D Products/PlonePAS/config.py
D Products/PlonePAS/configure.zcml
D Products/PlonePAS/events.py
D Products/PlonePAS/exportimport.zcml
D Products/PlonePAS/gruf_support.py
D Products/PlonePAS/interfaces/__init__.py
D Products/PlonePAS/interfaces/browser.py
D Products/PlonePAS/interfaces/capabilities.py
D Products/PlonePAS/interfaces/events.py
D Products/PlonePAS/interfaces/group.py
D Products/PlonePAS/interfaces/membership.py
D Products/PlonePAS/interfaces/plugins.py
D Products/PlonePAS/interfaces/propertysheets.py
D Products/PlonePAS/ldapmp.py
D Products/PlonePAS/pas.py
D Products/PlonePAS/patch.py
D Products/PlonePAS/permissions.py
D Products/PlonePAS/plugins/__init__.py
D Products/PlonePAS/plugins/autogroup.py
D Products/PlonePAS/plugins/cookie_handler.py
D Products/PlonePAS/plugins/crumbler.py
D Products/PlonePAS/plugins/group.py
D Products/PlonePAS/plugins/local_role.py
D Products/PlonePAS/plugins/passwordpolicy.py
D Products/PlonePAS/plugins/property.py
D Products/PlonePAS/plugins/role.py
D Products/PlonePAS/plugins/ufactory.py
D Products/PlonePAS/plugins/user.py
D Products/PlonePAS/profiles.zcml
D Products/PlonePAS/profiles/default/metadata.xml
D Products/PlonePAS/profiles/default/plone-pas.txt
D Products/PlonePAS/setuphandlers.py
D Products/PlonePAS/sheet.py
D Products/PlonePAS/storage.py
D Products/PlonePAS/tests/__init__.py
D Products/PlonePAS/tests/base.py
D Products/PlonePAS/tests/cookie_auth.rst
D Products/PlonePAS/tests/dummy.py
D Products/PlonePAS/tests/images/test.gif
D Products/PlonePAS/tests/images/test.jpg
D Products/PlonePAS/tests/images/test.png
D Products/PlonePAS/tests/test_basic_ops.py
D Products/PlonePAS/tests/test_doctests.py
D Products/PlonePAS/tests/test_groupdatatool.py
D Products/PlonePAS/tests/test_groupstool.py
D Products/PlonePAS/tests/test_memberdatatool.py
D Products/PlonePAS/tests/test_membershiptool.py
D Products/PlonePAS/tests/test_properties.py
D Products/PlonePAS/tests/test_role_plugin.py
D Products/PlonePAS/tests/test_views.py
D Products/PlonePAS/tool.gif
D Products/PlonePAS/tools/__init__.py
D Products/PlonePAS/tools/groupdata.py
D Products/PlonePAS/tools/groups.py
D Products/PlonePAS/tools/memberdata.py
D Products/PlonePAS/tools/membership.py
D Products/PlonePAS/tools/plonetool.py
D Products/PlonePAS/utils.py
D Products/PlonePAS/zmi/AutoGroupForm.zpt
D Products/PlonePAS/zmi/CookieCrumblingPluginForm.dtml
D Products/PlonePAS/zmi/ExtendedCookieAuthHelperForm.dtml
D Products/PlonePAS/zmi/GroupAwareRoleManagerForm.dtml
D Products/PlonePAS/zmi/GroupManagerForm.dtml
D Products/PlonePAS/zmi/LocalRolesManagerForm.dtml
D Products/PlonePAS/zmi/MutablePropertyProviderForm.dtml
D Products/PlonePAS/zmi/PasswordPolicyForm.zpt
D Products/PlonePAS/zmi/PloneUserFactoryForm.dtml
D Products/PlonePAS/zmi/UserManagerForm.dtml
D Products/PlonePAS/zmi/membershipRolemapping.dtml
D Products/PlonePAS/zmi/portrait_fix.dtml
D Products/__init__.py
D README.txt
D bootstrap.py

diff --git a/.gitignore b/.gitignore
index 937f590..0c6cba1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,11 +1,19 @@
 *.pyc
-/bin/
+/bin
+/devsrc/
 /parts/
 /var/
-/*.egg-info
+/src/*.egg-info
+.mrsd
 /*eggs/
 .*.cfg
 /coverage/
 /.project
 /.pydevproject
 /.settings/
+/local/
+/lib/
+/include/
+/dist/
+/.Python
+/buildout-cache/
diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 0000000..c7b6f40
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,7 @@
+language: python
+python: 2.7
+install:
+  - mkdir -p buildout-cache/downloads
+  - pip install zc.buildout
+  - buildout -c travis.cfg -N -q -t 3
+script: bin/code-analysis && bin/test
diff --git a/CHANGES.rst b/CHANGES.rst
new file mode 100644
index 0000000..271f321
--- /dev/null
+++ b/CHANGES.rst
@@ -0,0 +1,910 @@
+Changelog
+=========
+
+6.0 (unreleased)
+------------------
+
+- Add a integrated test setup with codeanalysis and travis. For this moved
+  ``Products`` folder to a ``src`` folder in order to follow the package
+  structure expected by ``buildout.plonetest``'s ``qa.cfg``.
+  [jensens]
+
+- Make patching of LDAPMultiPlugin explizit. Code using those must call
+  ``Products.PlonePAS.ldapmp.patch_ldapmp`` with no parameters in order
+  to activate the patches.
+  [jensens]
+
+- Removed (optional) Archetypes Storage (used in past with CMFMember, which
+  itself was long time ago superseeded by Membrane). Probably dead code. If
+  theres someone out there needing it in Plone 5 please copy the code from
+  git/Plone4 in your addon/project.
+  [jensens]
+
+- Moved ``Extensions/Install.py`` functions to setuphandlers, kept BBB import
+  for ``activatePluginInterfaces`` since this is imported by ``borg.localrole``.
+  [jensens]
+
+- Expect Python 2.7 with ``collections.OrderedDict``.
+  [jensens]
+
+- Remove nasty dependency to Products.CMFDefault.
+  [jensens]
+
+- Cleanup patches, allow introspection by using wrap_method, add roles using wrap_method,
+  add deprecation and merge ``gruf_support.py`` in ``pas,py`` to have a better overview
+  what is patched.
+  [jensens]
+
+- Cleanup: PEP8 et all, zca decorators, rough code review
+  [jensens]
+
+- In searchForMembers, ensure that request parameters are properly
+  decoded to unicode
+  [do3cc]
+
+
+5.0 (2014-04-05)
+----------------
+
+- Do not write member data on read
+  [vangheem]
+
+- Allow ``properties`` to be passed to ``PloneUser.setProperties``.
+  This was previously ignored as ``setProperties`` solely utilised
+  keyword arguments.
+  [davidjb]
+
+
+4.1.2 (2014-01-27)
+------------------
+
+- Don't try to migrate the root user folder if the portal has no parent.
+  [davisagli]
+
+- Use batteries included odict implementation in favour of homegrown one.
+  [tomgross]
+
+- Use correct methods for getting users from id or names
+  [tomgross]
+
+- Ported tests to plone.app.testing
+  [tomgross]
+
+4.1.1 (2013-03-05)
+------------------
+
+- Fix a bug in setSecurityProfile where the login name was passed
+  instead of the user id.
+  [davisagli]
+
+- Added empty updateUser and updateEveryLoginName methods in
+  ZODBMutablePropertyProvider to fulfill the new standards of the
+  IUserEnumerationPlugin.
+  [maurits]
+
+
+4.1 (2013-01-01)
+----------------
+
+- Fix assignRoleToPrincipal to work with new Products.PluggableAuthService 1.10.0.
+  [maurits]
+
+- Fix saving, getting and deleting the user portrait for non-standard
+  user ids like 'bob-jones' or 'bob-jones+test@example.org'.
+  [maurits]
+
+- Fix the test for the current password if the user id differs from
+  the login name.
+  [maurits]
+
+
+4.1a2 (2012-08-29)
+------------------
+
+- Bug fix: User with e-mail login got 'Insufficient Privileges' when
+  trying to delete own portrait. Fixes http://dev.plone.org/ticket/12819.
+  [patch by kagesenshi, applied by kleist]
+
+- MembershipTool.searchForMembers() now preserves sort order.
+  Fixes http://dev.plone.org/ticket/11716.
+  [patch by neaj, applied by kleist]
+
+- Changed deprecated getSiteEncoding to hardcoded `utf-8`
+  [tom_gross]
+
+
+4.1a1 (2012-06-29)
+------------------
+
+- Allow members with usernames that contain special characters
+  (such as @ when use email to login), set their own member portrait
+  [erral]
+
+- PEP8 Cleanup
+  [pbdiode]
+
+- Add a default password validation policy as PAS plugin,
+  see http://dev.plone.org/ticket/10959
+
+- Extensions/Install.py: Don't use list as default argument value
+  to activatePluginInterfaces()
+  [patch by rossp, applied by kleist]
+
+
+4.0.13 (2012-05-07)
+-------------------
+
+- Require ListPortalMembers permission for searchForMembers
+  so anonymous users can not get a list of site users.
+  [vangheem]
+
+
+4.0.12 (2012-04-09)
+-------------------
+
+- Make sure that during registration you can change your member
+  portrait (if this has been enabled the member registration config).
+  Refs http://dev.plone.org/ticket/5432
+  [maurits]
+
+
+4.0.11 (2012-02-08)
+-------------------
+
+- Do some more checks when changing or deleting a member portrait.
+  Fixes http://dev.plone.org/ticket/5432
+  [maurits]
+
+- Pass request along to getGroupsForPrincipal for caching purposes.
+  [esteele]
+
+
+4.0.10 (2012-01-04)
+-------------------
+
+- Fixed typo in method name hasOpenIDExtractor, keeping the old name
+  (hasOpenIDdExtractor) around for backwards compatibility.
+  Fixes http://dev.plone.org/ticket/11040
+  [maurits]
+
+
+4.0.9 (2011-11-24)
+------------------
+
+- Avoid a failure when we try to add a role to principal that is managed by
+  an other plugin.
+  [thomasdesvenain]
+
+- Cleaned up and reduced dependencies. New extra ``atstorage`` for the rare case
+  someone uses PlonePAS w/o Plone but with Archetypes (if this is this
+  possible). [jensens]
+
+4.0.8 - 2011-06-30
+------------------
+
+- Fire IPrincipalDeleted when a user is deleted.
+  [stefan, ggozad]
+
+4.0.7 - 2011-05-12
+------------------
+
+- Copy in CleanupTemp from CMFCore as it has been removed from CMFCore 2.3.
+  [elro]
+
+- Move import step to be registered in ZCML rather than XML.
+  Remove the non-existent dependency on `plonepas-content`.
+  [kiorky]
+
+4.0.6 - 2011-02-25
+------------------
+
+- Fix missing and broken security declarations.
+  [davisagli]
+
+4.0.5 - 2011-02-14
+------------------
+
+- Avoid breaking on startup if PIL isn't present.
+  [davisagli]
+
+- Use 'defaultUser.png' as the default user portrait, since the .gif version
+  has been deprecated for a long time now. See
+  http://dev.plone.org/plone/changeset/36350
+  [mj]
+
+4.0.4 - 2011-01-03
+------------------
+
+- Remove plone.openid dependency in setup.py, import errors are already caught
+  in PASInfoView.
+  [elro]
+
+- The code to search by id in mutable_properties.enumerateUsers didn't work at
+  all, an exception was always raised and it was actually a good thing.
+  We tried to implement it in 3.10 and we had strange listing in Plone UI. Then
+  we reverted it in the next version so the behavior was backward compatible
+  with previous versions.
+  If we allow search by id, we can potentially break other part of the code. For
+  example acl_users/portal_role_manager/manage_roles will break because
+  Products.PluggableAuthService.plugins.ZODBRoleManager.listAssignedPrincipals
+  raises MultiplePrincipalError, and maybe it will break somewhere else.
+  Versions 4.0.4 and 3.13 use now the same algorithm.
+  References http://dev.plone.org/plone/ticket/9361
+  [vincenfretin]
+
+- When calling editGroup method, avoid error
+  while trying to remove dynamic 'AuthenticatedUsers' group.
+  [thomasdesvenain]
+
+- In Plone 4.1+, create a Site Administrators group with the new Site
+  Administrator role.
+  [davisagli]
+
+- Fix critical error on groupprefs page
+  when some groups have a non-ascii character in their title.
+  Sort groups on their title normalized.
+  This fixes http://dev.plone.org/plone/ticket/11301
+  [thomasdesvenain]
+
+- Fix interface error: doChangeUser takes a user id as parameter,
+  not a login name.
+  [wichert]
+
+4.0.3 - 2010-09-09
+------------------
+
+- Check we have a REQUEST attribute before accessing it in
+  getRolesForPrincipal.
+  [vincentfretin]
+
+- Use safe_unicode to correctly find users with
+  non-ascii properties, regardless of the sys.defaultencoding.
+  This fixes http://dev.plone.org/plone/ticket/10898
+  [mr_savage]
+
+4.0.2 - 2010-08-08
+------------------
+
+- Made last_login_time logic compatible with DateTime 2.12.5.
+  [hannosch]
+
+4.0.1 - 2010-07-31
+------------------
+
+- Clean up some unused imports and variable assigments.
+  [esteele]
+
+- Stop looking to GRUF to check if group properties can be edited.
+  [esteele]
+
+4.0 - 2010-07-18
+----------------
+
+- Avoid a deprecation warning for the credentialsChanged method.
+  [hannosch]
+
+- Fixed problems with missing user cache invalidation. This closes
+  http://dev.plone.org/plone/ticket/10715.
+  [fafhrd, hannosch]
+
+- Make VirtualGroup inherit from PropertiedUser so it gets wrapped correctly.
+  Have getGroupsForPrincipal not return the AutoGroup as a member of itself.
+  Closes http://dev.plone.org/plone/ticket/10568.
+  [cah190]
+
+- PluggableAuthService expects a list of group ids from getGroups, don't pass a
+  list of wrapped groups instead.
+  [cah190, esteele]
+
+- Added a custom `IMembershipTool` interface to PlonePAS extending the base one
+  from CMFCore. It adds the `getMemberInfo` method to the mix. This closes
+  http://dev.plone.org/plone/ticket/10240.
+  [hannosch]
+
+4.0b9 - 2010-06-03
+------------------
+
+- Fixed a test to no longer use removed Large Plone Folder type.
+  [davisagli]
+
+4.0b8 - 2010-05-01
+------------------
+
+- Removed special unauthorized view workaround, after the underlying issue
+  has been fixed in Zope2.
+  [davisagli, hannosch]
+
+4.0b7 - 2010-04-07
+------------------
+
+- Added manage_setMembersFolderById method for ZMI.
+  Fixes http://dev.plone.org/plone/ticket/10400
+  [daftdog]
+
+4.0b6 - 2010-03-05
+------------------
+
+- Revert incorrect PIL import change.
+  [hannosch]
+
+4.0b5 - 2010-03-03
+------------------
+
+- Install recursive_groups in new sites by default. Make it the last
+  IGroupsPlugin installed.
+  [esteele]
+
+- Remove caching of utils.py's getGroupsForPrincipal method as it was nastily
+  overzealous.
+  [esteele, cah190]
+
+- Use sets instead of util.py's 'unique' method.
+  [esteele]
+
+4.0b4 - 2010-02-18
+------------------
+
+- Properly import from PIL 1.1.7
+  [tom_gross]
+
+- Cache getGroupsForPrincipal per principal id per request (when available).
+  [esteele]
+
+4.0b3 - 2010-01-31
+------------------
+
+- Role plugin's tests no longer subclass (and run all of) ZODBRoleManagerTests
+  as they cannot properly handle the plugin's expectation of finding a
+  PluginRegistry with IGroupsPlugin
+  [erikrose, esteele]
+
+- Revert changes made to ZODBMutablePropertyProvider's enumerateUsers method
+  which prevented lookup of users by id. Some refactoring.
+  Refs http://dev.plone.org/plone/ticket/9361
+  [erikrose, esteele]
+
+- GroupAwareRoleManager now properly computes the roles of deeply-nested
+  principals.
+  [erikrose, esteele]
+
+- Factor up getGroupsForPrincipal call.
+  [erikrose, esteele]
+
+- AutoGroup now implements IPropertiesPlugin to return group title and description.
+  [erikrose, esteele]
+
+- GroupsTool's getGroupsForPrincipal and getGroupMembers now return a list
+  made up of groups/members from all responding plugins instead of just the
+  first responder.
+  [erikrose, esteele]
+
+- Remove GroupData's _gruf_getProperty method, move remaining functionality
+  into getProperty. getProperty now searches for properties in the following
+  places: property sheets directly on the group object, PAS
+  IPropertyProviders, portal_groupdata properties, and attributes on its
+  GroupData entry. It returns the first piece of data found.
+  Closes http://dev.plone.org/plone/ticket/9828
+  [erikrose, esteele]
+
+- Added __ignore_direct_roles__ request flag to getRolesForPrincipal() to
+  permit retrieval of only group-provided (inherited) roles.
+  [cah190]
+
+- getGroupsForPrincipal is a method of PAS' IGroupsPlugin, adjust the groups
+  tool's plugin lookup accordingly.
+  [esteele]
+
+- Rework the group detection of the ZODBMutablePropertyProvider so that
+  enumerateUsers only returns users.
+  [esteele]
+
+- Add, but don't activate, a recursive groups plugin on installation.
+  [esteele]
+
+- Set proper titles for default groups.
+  [esteele]
+
+- Avoid the use of the classImplements helper from PAS. It dealt with the now
+  gone Zope2 Interface variants and is no longer needed.
+  [hannosch]
+
+- Fix a misnamed kwarg in autogroup plugin.
+  [cah190]
+
+- Allow the groups tool's searchForGroups to handle an empty search string as
+  'find all'.
+  [esteele, cah190]
+
+- Allow PASSearchView's searchGroups method to accept a sorting option.
+  [esteele]
+
+- Apply deiter's patch from http://dev.plone.org/plone/ticket/9460 to prevent
+  GroupManager's 'getGroupById' from returning groups managed by other group
+  managers.
+  [esteele]
+
+- GroupsTool.editGroup() now stores title and description in PAS
+  propertysheets in addition to Plone-specific tools. This helps us not pave
+  over group titles with IDs.
+  [erikrose]
+
+- Query the correct keyword variable for the group's description.
+  [esteele]
+
+- Fix an incorrect setdefault syntax.
+  Closes http://dev.plone.org/plone/ticket/7345
+  [esteele]
+
+4.0b2 - 2010-01-02
+------------------
+
+- Don't specify PIL as a direct dependencies. It is not installed as an egg on
+  all platforms.
+  [hannosch]
+
+4.0b1 - 2009-12-27
+------------------
+
+- Fixed package dependencies declaration.
+  [hannosch]
+
+4.0a2 - 2009-12-16
+------------------
+
+- Added backwards compatibility alias for PloneTool to support upgrades from
+  Plone 2.5 to work.
+  [hannosch]
+
+- Added 'has_email' to the info returned by getMemberInfo.
+  Refs http://dev.plone.org/plone/ticket/8707
+  [maurits]
+
+4.0a1 - 2009-11-14
+------------------
+
+- Simplified ``pas_member`` view.  Also return info when no member
+  with the requested id exists, so this can be safely used also to get
+  "member info" for deleted members.
+  [maurits]
+
+- Added new ``pas_member`` view, which provides easy access to the membership
+  tools getMemberInfo method but caches the result on the request.
+  [hannosch]
+
+- Changed the default value of `memberareaCreationFlag` for the membership
+  tool to False, as it was done during Plone site creation so far.
+  [hannosch]
+
+- Removed patch on ZODBUserManager.enumerateUsers which was introduced
+  historical because of a former missing release of PluggableAuthService 1.5.
+  This now superfluous patch also reduced the functionality of the
+  patched method and introduced different behavior compared to i.e in
+  a similar method on LDAPMultiPlugins. For details on the former
+  patch see:
+  http://dev.plone.org/collective/changeset/41512/PlonePAS/trunk/pas.py
+  [jensens]
+
+- Moved a couple DTML files here from CMFPlone that got left out of the earlier
+  refactoring.
+  [davisagli]
+
+- Added a view of the Unauthorized exception which re-raises that exception
+  in order to make sure that it triggers PAS' challenge plugin rather than
+  rendering the standard_error_message.
+  [davisagli]
+
+- Removed deprecation warnings for various methods. These never happened.
+  [hannosch]
+
+- Removed half-done ZCacheable caching for users and groups.
+  [hannosch]
+
+- Removed the CMFDefault dependency of the membership tool. We only need the
+  CMFCore functionality.
+  [hannosch]
+
+- PlonePAS.gruf_support.authenticate method was not breaking out of
+  the loop upon successful authenticateCredentials.
+  [runyaga]
+
+- Changed objectIds and objectValues calls to use the IContainer API.
+  [hannosch]
+
+- Removed parts of the outdated Extensions.Install code.
+  [hannosch]
+
+- Removed a dependency on CMFPlone's `_createObjectByType` method.
+  [hannosch]
+
+- Removed magical `homePageText` lookup for initial memberarea content. You
+  can use the `notifyMemberAreaCreated` hook for any kind of custom behavior.
+  [hannosch]
+
+- Moved the `scale_image` function from CMFPlone.utils into our own utils
+  module, as we are the only user of it. Also made the tests independent of
+  any CMFPlone code.
+  [hannosch]
+
+- Cleaned up package metadata.
+  [hannosch]
+
+- Declare test dependencies in an extra and fixed deprecation warnings
+  for use of Globals.
+  [hannosch]
+
+- Switched the installation progress reporting to the logging framework.
+  [hannosch]
+
+- Cleaned up annoying license headers in all files. We have a central place
+  to state the license.
+  [hannosch]
+
+- Started cleaning up deprecated methods and comments.
+  [hannosch]
+
+- Removed support for group workspaces. This part from GRUF hasn't been
+  supported for many releases anymore.
+  [hannosch]
+
+- Merged all code for the groups tool from GRUF into this package, we are
+  officially GRUF-dependency-free :)
+  [hannosch]
+
+- Merged all code for the group data tool from GRUF into this package.
+  [hannosch]
+
+- Removed the GRUFBridge plugin. PAS inside GRUF isn't supported anymore.
+  [hannosch]
+
+- Merged tests moved from CMFPlone into the same modules as the existing
+  tests and normalized file names.
+  [hannosch]
+
+- Modernized tests and introduce a proper base testcase and layer.
+  [hannosch]
+
+- Removed cookie auth tests, these don't work anymore with plone.session.
+  [hannosch]
+
+- Moved over all tests for the four tools from CMFPlone.
+  [hannosch]
+
+- Removed the user folder migration code and cleaned up tests.
+  [hannosch]
+
+- Moved all code from the four tools from CMFPlone into this package.
+  [hannosch]
+
+- Removed 'listed' member property support from one of the many search
+  functions following Plone.
+  [hannosch]
+
+- Copied setLoginFormInCookieAuth from CMFPlone migrations.
+  [hannosch]
+
+- Purged old Zope 2 Interface interfaces for Zope 2.12 compatibility.
+  (only a test in this case)
+  [elro]
+
+
+3.12 - 2009-10-16
+-----------------
+
+- Fixed the performance fix again. enumerateUsers from mutable_properties
+  plugin should return all the users if kw is empty. And it returns empty
+  tuple if login or id parameter is used.
+  [vincentfretin]
+
+
+3.11 - 2009-10-05
+-----------------
+
+- Revert performance fix introduced in 3.10 for the mutable properties plugin.
+  enumerateUsers shouldn't return results if id or login is not None like in
+  3.9 (data dict doesn't contain id or login key, so testMemberData returns
+  always False). The search should be performed only if kw parameter is not
+  empty. This is the new optimization fix.
+  [vincentfretin]
+
+
+3.10 - 2009-09-06
+-----------------
+
+- Performance fix for searching in the mutable properties plugin:
+  when only searching on user id do not walk over all properties,
+  but only test if the user id is known. This fixes
+  http://dev.plone.org/plone/ticket/9361
+  [toutpt]
+
+- Nested groups are now visible in prefs_group_members. This closes
+  http://dev.plone.org/plone/ticket/8557
+  [vincentfretin]
+
+- Add sort and merge PASSearchView's interface to prevent code duplication.
+  [csenger]
+
+
+3.9 - 2009-04-21
+----------------
+
+- Fix the cookie plugin's login handler to not trust the username
+  from the request. Instead we use the login name of the currently
+  authenticated user. This fixes CVE-2009-0662 (see
+  http://plone.org/products/plone/security/advisories/cve-2009-0662
+  for more information).
+  [wichert]
+
+
+3.8 - 2009-02-13
+----------------
+
+- Update the role manager's assignRoleToPrincipal method to lazily
+  update the cached list of portal roles. This fixes problems with
+  adding users with GenericSetup-created roles.
+  [wichert]
+
+- Fixed our OrderedDict to be unpickable with pickle protocol 2. On
+  unpickling a __init__ method is not called and an optimization in
+  protocol 2 would call __setitem__ without the _list to be initialized.
+  Even using a __getstate__ / __setstate__ combination wouldn't work
+  around that. This change was found in using membrane and
+  MemcachedManager.
+  [hannosch, tesdal]
+
+
+3.7 - 2008-09-28
+----------------
+
+- Removed deprecation zcml statements for PluggableAuthService components:
+  these are now in PluggableAuthService itself.
+  [wichert]
+
+- Adjusted deprecation warnings to point to Plone 4.0 instead of Plone 3.5
+  since we changed the version numbering again.
+  [hannosch]
+
+
+3.6 - 2008-06-25
+----------------
+
+- Modify PloneGroup.getMemberIds to use all IGroupIntrospection plugins
+  to get the group members. This makes it possible to list members in
+  an LDAP group.
+  [wichert]
+
+
+3.5 - 2008-06-25
+----------------
+
+- Make PASSearchView.merge actually merge search results. Its previous
+  behaviour was quite nasty: it preferred search results from the
+  enumeration plugin with the lowest priority!
+  [wichert]
+
+
+3.4 - 2008-03-26
+----------------
+
+- Added BBB code for changed setLoginFormInCookieAuth upgrade method.
+  [hannosch]
+
+- Ignore but log users without passwords during migration from pre-PAS, as
+  these cannot be added to any standard user source.
+  [hannosch]
+
+- Fix listRoleInfo on the role plugin to also lazily update the list
+  of portal roles.
+  [wichert]
+
+3.3 - 2007-03-07
+----------------
+
+- Added metadata.xml file to the profile.
+  [hannosch]
+
+- Move global role lookup out of the local role plugin. Part of the
+  PLIP 127 merge for Plone 3.1.
+  [alecm]
+
+
+3.2 - 2008-02-15
+----------------
+
+- Fix schema handling for ZODBMutablePropertyProvider initialization.
+  [maurits]
+
+- Remove some exception swallowing from the installation logic so errors
+  are not hidden.
+  [hannosch]
+
+- Correct handling an empty roles list when modifying groups.
+  This fixes http://dev.plone.org/plone/ticket/6994
+  [rsantos]
+
+
+3.1 - 2007-10-08
+----------------
+
+- Improve handing of sorting for searches.
+  [csenger]
+
+- Updating the roles for a group did not invalidate the _findGroup cache.
+  [wichert]
+
+- Fixed some tool icons to point to existing icons.
+  [hannosch]
+
+
+3.0 - 2007-08-16
+----------------
+
+- Fix check for authenticateCredentials return value
+  [rossp]
+
+
+3.0rc2 - 2007-07-27
+-------------------
+
+- Fake a getPhysicalPath on our search view so ZCacheing works properly
+  everywhere.
+  [wichert]
+
+- Add event classes for logged-in and logged-out events.
+  [wichert]
+
+
+3.0rc1 - 2007-07-08
+-------------------
+
+- Correct logic in MemberData capability methods: any plugin is
+  allowed to (re)set a password, delete the user or add roles.
+  [wichert]
+
+- Use the proper API to get the containing PAS in the group plugin
+  [wichert]
+
+- Fix setting user properties on the user object.
+  [wichert]
+
+
+3.0b7 - 2007-05-05
+------------------
+
+- Removed the five:registerPackage statement again. It causes problems in a
+  ZEO environment.
+  [hannosch]
+
+- Removed our version of the Plone tool from ToolInit. It won't get an icon
+  anymore and you cannot add it, but existing instances still work. We
+  migrate all instances back to the regular tool anyways.
+  [hannosch]
+
+
+3.0b6 - 2007-05-05
+------------------
+
+- Fixed two migration related test failures.
+  [hannosch]
+
+- Spring cleaning, removed some cruft, pyflaked and corrected some more
+  undefined names.
+  [hannosch]
+
+- New package layout, following standard Python package conventions.
+  [hannosch]
+
+- Fixed tool names in ToolInit, so the permission has a proper name. This
+  closes http://dev.plone.org/plone/ticket/6525.
+  [hannosch]
+
+
+3.0-beta5 - 2007-05-02
+----------------------
+
+- Modify the roles plugin to lazily update its roles list from the portal.
+  [wichert]
+
+- Filter duplicate search results.
+  [laz, wichert]
+
+- Add a sort_by option to the search methods to allow sorting of results
+  by a property.
+  [laz, wichert]
+
+- Modify login method for the cookie plugin to perform the credential
+  update in the PAS of the user instead of the PAS of the plugin. This
+  helps in making sure that users will only authenticate against their
+  own user folder, so we get all their roles, properties, etc. correctly.
+  [wichert]
+
+- Update installation logic to use plone.session for cookies
+  [wichert]
+
+- Add pas_info and pas_search browser views.
+  [wichert]
+
+- Deprecate the PlonePAS PloneTool; its changes have been merged in the
+  standard Plone version.
+  [wichert]
+
+- Use getUtility to get the portal object.
+  [wichert]
+
+- Deprecate user and group searching through CMF member and group tools
+  in favour of PAS enumeration.
+  [wichert]
+
+- Refactor user searching in the membership tool to use standard PAS
+  searches.
+  [wichert]
+
+- Add user enumeration capabilities to the mutable properties plugin.
+  [wichert]
+
+- Add a new automatic group plugin which puts all users in a virtual
+  group. This is useful for permissions handling: since it is not
+  possible to add roles to users with the Authenticated role a
+  virtual group can be used instead.
+  [wichert]
+
+- Added support to import PloneUserFactory and added stub
+  for ZODBMutableProperties. Attention: Latter needs a real
+  export and import! At the moment it do not export the
+  propertysheets. This is a TODO. At least with this two
+  additions PlonePAS import runs. Additional I needed to
+  hack PluginRegistry and and PluggableAuthService slightly.
+  [jensens]
+
+- Added HISTORY.txt and updated version information.
+  [hannosch]
+
+
+2.4 - 2007-04-15
+----------------
+
+- Optomise the local roles plugin for the common case where
+  local_roles is empty
+  [dreamcatcher]
+
+- the plone user was assuming a one to one mapping between property plugin
+  and user property sheet, and stripping away additional ones as part of
+  the retrieval of ordered sheets, instead, it now stores all
+  propertysheets in an ordered dictionary, so this assumption is not needed
+  [k_vertigo]
+
+- More postonly security changes
+  [alecm, ramon]
+
+
+2.3 - 2007-05-30
+----------------
+
+- Use a local postonly decorator so PlonePAS can be used with Plone
+  2.5, 2.5.1 and 2.5.2.
+  [wichert]
+
+- Protect the tools with postonly security modifiers.
+  [mj]
+
+- Update GRUF compatibility functions to use the same security checks
+  as GRUF itself uses.
+  [mj]
+
+- Fix migration to handle properties of selection or multiple selection
+  types.
+  [reinout]
+
+- Correct creation of groups wich default group managers.
+  [dreamcatcher]
+
+- Fix migration from GRUF sites: also include the member properties in the
+  migration.
+  [tesdal]
+
+- Correct the test for creation of groups with the same id as users: search
+  for the exact id, not substrings.
+  [tesdal]
+
+- Fix bad form action which made it impossible to add a plone user factory
+  plugin through the ZMI. Backported from trunk.
+  [wichert]
diff --git a/CHANGES.txt b/CHANGES.txt
deleted file mode 100644
index 3c74db1..0000000
--- a/CHANGES.txt
+++ /dev/null
@@ -1,876 +0,0 @@
-Changelog
-=========
-
-5.0.1 (unreleased)
-------------------
-
-- In searchForMembers, ensure that request parameters are properly
-  decoded to unicode
-  [do3cc]
-
-
-5.0 (2014-04-05)
-----------------
-
-- Do not write member data on read
-  [vangheem]
-
-- Allow ``properties`` to be passed to ``PloneUser.setProperties``.
-  This was previously ignored as ``setProperties`` solely utilised
-  keyword arguments.
-  [davidjb]
-
-
-4.1.2 (2014-01-27)
-------------------
-
-- Don't try to migrate the root user folder if the portal has no parent.
-  [davisagli]
-
-- Use batteries included odict implementation in favour of homegrown one.
-  [tomgross]
-
-- Use correct methods for getting users from id or names
-  [tomgross]
-
-- Ported tests to plone.app.testing
-  [tomgross]
-
-4.1.1 (2013-03-05)
-------------------
-
-- Fix a bug in setSecurityProfile where the login name was passed
-  instead of the user id.
-  [davisagli]
-
-- Added empty updateUser and updateEveryLoginName methods in
-  ZODBMutablePropertyProvider to fulfill the new standards of the
-  IUserEnumerationPlugin.
-  [maurits]
-
-
-4.1 (2013-01-01)
-----------------
-
-- Fix assignRoleToPrincipal to work with new Products.PluggableAuthService 1.10.0.
-  [maurits]
-
-- Fix saving, getting and deleting the user portrait for non-standard
-  user ids like 'bob-jones' or 'bob-jones+test@example.org'.
-  [maurits]
-
-- Fix the test for the current password if the user id differs from
-  the login name.
-  [maurits]
-
-
-4.1a2 (2012-08-29)
-------------------
-
-- Bug fix: User with e-mail login got 'Insufficient Privileges' when
-  trying to delete own portrait. Fixes http://dev.plone.org/ticket/12819.
-  [patch by kagesenshi, applied by kleist]
-
-- MembershipTool.searchForMembers() now preserves sort order.
-  Fixes http://dev.plone.org/ticket/11716.
-  [patch by neaj, applied by kleist]
-
-- Changed deprecated getSiteEncoding to hardcoded `utf-8`
-  [tom_gross]
-
-
-4.1a1 (2012-06-29)
-------------------
-
-- Allow members with usernames that contain special characters
-  (such as @ when use email to login), set their own member portrait
-  [erral]
-
-- PEP8 Cleanup
-  [pbdiode]
-
-- Add a default password validation policy as PAS plugin,
-  see http://dev.plone.org/ticket/10959
-
-- Extensions/Install.py: Don't use list as default argument value
-  to activatePluginInterfaces()
-  [patch by rossp, applied by kleist]
-
-
-4.0.13 (2012-05-07)
--------------------
-
-- Require ListPortalMembers permission for searchForMembers
-  so anonymous users can not get a list of site users.
-  [vangheem]
-
-
-4.0.12 (2012-04-09)
--------------------
-
-- Make sure that during registration you can change your member
-  portrait (if this has been enabled the member registration config).
-  Refs http://dev.plone.org/ticket/5432
-  [maurits]
-
-
-4.0.11 (2012-02-08)
--------------------
-
-- Do some more checks when changing or deleting a member portrait.
-  Fixes http://dev.plone.org/ticket/5432
-  [maurits]
-
-- Pass request along to getGroupsForPrincipal for caching purposes.
-  [esteele]
-
-
-4.0.10 (2012-01-04)
--------------------
-
-- Fixed typo in method name hasOpenIDExtractor, keeping the old name
-  (hasOpenIDdExtractor) around for backwards compatibility.
-  Fixes http://dev.plone.org/ticket/11040
-  [maurits]
-
-
-4.0.9 (2011-11-24)
-------------------
-
-- Avoid a failure when we try to add a role to principal that is managed by
-  an other plugin.
-  [thomasdesvenain]
-
-- Cleaned up and reduced dependencies. New extra ``atstorage`` for the rare case
-  someone uses PlonePAS w/o Plone but with Archetypes (if this is this
-  possible). [jensens]
-
-4.0.8 - 2011-06-30
-------------------
-
-- Fire IPrincipalDeleted when a user is deleted.
-  [stefan, ggozad]
-
-4.0.7 - 2011-05-12
-------------------
-
-- Copy in CleanupTemp from CMFCore as it has been removed from CMFCore 2.3.
-  [elro]
-
-- Move import step to be registered in ZCML rather than XML.
-  Remove the non-existent dependency on `plonepas-content`.
-  [kiorky]
-
-4.0.6 - 2011-02-25
-------------------
-
-- Fix missing and broken security declarations.
-  [davisagli]
-
-4.0.5 - 2011-02-14
-------------------
-
-- Avoid breaking on startup if PIL isn't present.
-  [davisagli]
-
-- Use 'defaultUser.png' as the default user portrait, since the .gif version
-  has been deprecated for a long time now. See
-  http://dev.plone.org/plone/changeset/36350
-  [mj]
-
-4.0.4 - 2011-01-03
-------------------
-
-- Remove plone.openid dependency in setup.py, import errors are already caught
-  in PASInfoView.
-  [elro]
-
-- The code to search by id in mutable_properties.enumerateUsers didn't work at
-  all, an exception was always raised and it was actually a good thing.
-  We tried to implement it in 3.10 and we had strange listing in Plone UI. Then
-  we reverted it in the next version so the behavior was backward compatible
-  with previous versions.
-  If we allow search by id, we can potentially break other part of the code. For
-  example acl_users/portal_role_manager/manage_roles will break because
-  Products.PluggableAuthService.plugins.ZODBRoleManager.listAssignedPrincipals
-  raises MultiplePrincipalError, and maybe it will break somewhere else.
-  Versions 4.0.4 and 3.13 use now the same algorithm.
-  References http://dev.plone.org/plone/ticket/9361
-  [vincenfretin]
-
-- When calling editGroup method, avoid error
-  while trying to remove dynamic 'AuthenticatedUsers' group.
-  [thomasdesvenain]
-
-- In Plone 4.1+, create a Site Administrators group with the new Site
-  Administrator role.
-  [davisagli]
-
-- Fix critical error on groupprefs page
-  when some groups have a non-ascii character in their title.
-  Sort groups on their title normalized.
-  This fixes http://dev.plone.org/plone/ticket/11301
-  [thomasdesvenain]
-
-- Fix interface error: doChangeUser takes a user id as parameter,
-  not a login name.
-  [wichert]
-
-4.0.3 - 2010-09-09
-------------------
-
-- Check we have a REQUEST attribute before accessing it in
-  getRolesForPrincipal.
-  [vincentfretin]
-
-- Use safe_unicode to correctly find users with
-  non-ascii properties, regardless of the sys.defaultencoding.
-  This fixes http://dev.plone.org/plone/ticket/10898
-  [mr_savage]
-
-4.0.2 - 2010-08-08
-------------------
-
-- Made last_login_time logic compatible with DateTime 2.12.5.
-  [hannosch]
-
-4.0.1 - 2010-07-31
-------------------
-
-- Clean up some unused imports and variable assigments.
-  [esteele]
-
-- Stop looking to GRUF to check if group properties can be edited.
-  [esteele]
-
-4.0 - 2010-07-18
-----------------
-
-- Avoid a deprecation warning for the credentialsChanged method.
-  [hannosch]
-
-- Fixed problems with missing user cache invalidation. This closes
-  http://dev.plone.org/plone/ticket/10715.
-  [fafhrd, hannosch]
-
-- Make VirtualGroup inherit from PropertiedUser so it gets wrapped correctly.
-  Have getGroupsForPrincipal not return the AutoGroup as a member of itself.
-  Closes http://dev.plone.org/plone/ticket/10568.
-  [cah190]
-
-- PluggableAuthService expects a list of group ids from getGroups, don't pass a
-  list of wrapped groups instead.
-  [cah190, esteele]
-
-- Added a custom `IMembershipTool` interface to PlonePAS extending the base one
-  from CMFCore. It adds the `getMemberInfo` method to the mix. This closes
-  http://dev.plone.org/plone/ticket/10240.
-  [hannosch]
-
-4.0b9 - 2010-06-03
-------------------
-
-- Fixed a test to no longer use removed Large Plone Folder type.
-  [davisagli]
-
-4.0b8 - 2010-05-01
-------------------
-
-- Removed special unauthorized view workaround, after the underlying issue
-  has been fixed in Zope2.
-  [davisagli, hannosch]
-
-4.0b7 - 2010-04-07
-------------------
-
-- Added manage_setMembersFolderById method for ZMI.
-  Fixes http://dev.plone.org/plone/ticket/10400
-  [daftdog]
-
-4.0b6 - 2010-03-05
-------------------
-
-- Revert incorrect PIL import change.
-  [hannosch]
-
-4.0b5 - 2010-03-03
-------------------
-
-- Install recursive_groups in new sites by default. Make it the last
-  IGroupsPlugin installed.
-  [esteele]
-
-- Remove caching of utils.py's getGroupsForPrincipal method as it was nastily
-  overzealous.
-  [esteele, cah190]
-
-- Use sets instead of util.py's 'unique' method.
-  [esteele]
-
-4.0b4 - 2010-02-18
-------------------
-
-- Properly import from PIL 1.1.7
-  [tom_gross]
-
-- Cache getGroupsForPrincipal per principal id per request (when available).
-  [esteele]
-
-4.0b3 - 2010-01-31
-------------------
-
-- Role plugin's tests no longer subclass (and run all of) ZODBRoleManagerTests
-  as they cannot properly handle the plugin's expectation of finding a
-  PluginRegistry with IGroupsPlugin
-  [erikrose, esteele]
-
-- Revert changes made to ZODBMutablePropertyProvider's enumerateUsers method
-  which prevented lookup of users by id. Some refactoring.
-  Refs http://dev.plone.org/plone/ticket/9361
-  [erikrose, esteele]
-
-- GroupAwareRoleManager now properly computes the roles of deeply-nested
-  principals.
-  [erikrose, esteele]
-
-- Factor up getGroupsForPrincipal call.
-  [erikrose, esteele]
-
-- AutoGroup now implements IPropertiesPlugin to return group title and description.
-  [erikrose, esteele]
-
-- GroupsTool's getGroupsForPrincipal and getGroupMembers now return a list
-  made up of groups/members from all responding plugins instead of just the
-  first responder.
-  [erikrose, esteele]
-
-- Remove GroupData's _gruf_getProperty method, move remaining functionality
-  into getProperty. getProperty now searches for properties in the following
-  places: property sheets directly on the group object, PAS
-  IPropertyProviders, portal_groupdata properties, and attributes on its
-  GroupData entry. It returns the first piece of data found.
-  Closes http://dev.plone.org/plone/ticket/9828
-  [erikrose, esteele]
-
-- Added __ignore_direct_roles__ request flag to getRolesForPrincipal() to
-  permit retrieval of only group-provided (inherited) roles.
-  [cah190]
-
-- getGroupsForPrincipal is a method of PAS' IGroupsPlugin, adjust the groups
-  tool's plugin lookup accordingly.
-  [esteele]
-
-- Rework the group detection of the ZODBMutablePropertyProvider so that
-  enumerateUsers only returns users.
-  [esteele]
-
-- Add, but don't activate, a recursive groups plugin on installation.
-  [esteele]
-
-- Set proper titles for default groups.
-  [esteele]
-
-- Avoid the use of the classImplements helper from PAS. It dealt with the now
-  gone Zope2 Interface variants and is no longer needed.
-  [hannosch]
-
-- Fix a misnamed kwarg in autogroup plugin.
-  [cah190]
-
-- Allow the groups tool's searchForGroups to handle an empty search string as
-  'find all'.
-  [esteele, cah190]
-
-- Allow PASSearchView's searchGroups method to accept a sorting option.
-  [esteele]
-
-- Apply deiter's patch from http://dev.plone.org/plone/ticket/9460 to prevent
-  GroupManager's 'getGroupById' from returning groups managed by other group
-  managers.
-  [esteele]
-
-- GroupsTool.editGroup() now stores title and description in PAS
-  propertysheets in addition to Plone-specific tools. This helps us not pave
-  over group titles with IDs.
-  [erikrose]
-
-- Query the correct keyword variable for the group's description.
-  [esteele]
-
-- Fix an incorrect setdefault syntax.
-  Closes http://dev.plone.org/plone/ticket/7345
-  [esteele]
-
-4.0b2 - 2010-01-02
-------------------
-
-- Don't specify PIL as a direct dependencies. It is not installed as an egg on
-  all platforms.
-  [hannosch]
-
-4.0b1 - 2009-12-27
-------------------
-
-- Fixed package dependencies declaration.
-  [hannosch]
-
-4.0a2 - 2009-12-16
-------------------
-
-- Added backwards compatibility alias for PloneTool to support upgrades from
-  Plone 2.5 to work.
-  [hannosch]
-
-- Added 'has_email' to the info returned by getMemberInfo.
-  Refs http://dev.plone.org/plone/ticket/8707
-  [maurits]
-
-4.0a1 - 2009-11-14
-------------------
-
-- Simplified ``pas_member`` view.  Also return info when no member
-  with the requested id exists, so this can be safely used also to get
-  "member info" for deleted members.
-  [maurits]
-
-- Added new ``pas_member`` view, which provides easy access to the membership
-  tools getMemberInfo method but caches the result on the request.
-  [hannosch]
-
-- Changed the default value of `memberareaCreationFlag` for the membership
-  tool to False, as it was done during Plone site creation so far.
-  [hannosch]
-
-- Removed patch on ZODBUserManager.enumerateUsers which was introduced
-  historical because of a former missing release of PluggableAuthService 1.5.
-  This now superfluous patch also reduced the functionality of the
-  patched method and introduced different behavior compared to i.e in
-  a similar method on LDAPMultiPlugins. For details on the former
-  patch see:
-  http://dev.plone.org/collective/changeset/41512/PlonePAS/trunk/pas.py
-  [jensens]
-
-- Moved a couple DTML files here from CMFPlone that got left out of the earlier
-  refactoring.
-  [davisagli]
-
-- Added a view of the Unauthorized exception which re-raises that exception
-  in order to make sure that it triggers PAS' challenge plugin rather than
-  rendering the standard_error_message.
-  [davisagli]
-
-- Removed deprecation warnings for various methods. These never happened.
-  [hannosch]
-
-- Removed half-done ZCacheable caching for users and groups.
-  [hannosch]
-
-- Removed the CMFDefault dependency of the membership tool. We only need the
-  CMFCore functionality.
-  [hannosch]
-
-- PlonePAS.gruf_support.authenticate method was not breaking out of
-  the loop upon successful authenticateCredentials.
-  [runyaga]
-
-- Changed objectIds and objectValues calls to use the IContainer API.
-  [hannosch]
-
-- Removed parts of the outdated Extensions.Install code.
-  [hannosch]
-
-- Removed a dependency on CMFPlone's `_createObjectByType` method.
-  [hannosch]
-
-- Removed magical `homePageText` lookup for initial memberarea content. You
-  can use the `notifyMemberAreaCreated` hook for any kind of custom behavior.
-  [hannosch]
-
-- Moved the `scale_image` function from CMFPlone.utils into our own utils
-  module, as we are the only user of it. Also made the tests independent of
-  any CMFPlone code.
-  [hannosch]
-
-- Cleaned up package metadata.
-  [hannosch]
-
-- Declare test dependencies in an extra and fixed deprecation warnings
-  for use of Globals.
-  [hannosch]
-
-- Switched the installation progress reporting to the logging framework.
-  [hannosch]
-
-- Cleaned up annoying license headers in all files. We have a central place
-  to state the license.
-  [hannosch]
-
-- Started cleaning up deprecated methods and comments.
-  [hannosch]
-
-- Removed support for group workspaces. This part from GRUF hasn't been
-  supported for many releases anymore.
-  [hannosch]
-
-- Merged all code for the groups tool from GRUF into this package, we are
-  officially GRUF-dependency-free :)
-  [hannosch]
-
-- Merged all code for the group data tool from GRUF into this package.
-  [hannosch]
-
-- Removed the GRUFBridge plugin. PAS inside GRUF isn't supported anymore.
-  [hannosch]
-
-- Merged tests moved from CMFPlone into the same modules as the existing
-  tests and normalized file names.
-  [hannosch]
-
-- Modernized tests and introduce a proper base testcase and layer.
-  [hannosch]
-
-- Removed cookie auth tests, these don't work anymore with plone.session.
-  [hannosch]
-
-- Moved over all tests for the four tools from CMFPlone.
-  [hannosch]
-
-- Removed the user folder migration code and cleaned up tests.
-  [hannosch]
-
-- Moved all code from the four tools from CMFPlone into this package.
-  [hannosch]
-
-- Removed 'listed' member property support from one of the many search
-  functions following Plone.
-  [hannosch]
-
-- Copied setLoginFormInCookieAuth from CMFPlone migrations.
-  [hannosch]
-
-- Purged old Zope 2 Interface interfaces for Zope 2.12 compatibility.
-  (only a test in this case)
-  [elro]
-
-
-3.12 - 2009-10-16
------------------
-
-- Fixed the performance fix again. enumerateUsers from mutable_properties
-  plugin should return all the users if kw is empty. And it returns empty
-  tuple if login or id parameter is used.
-  [vincentfretin]
-
-
-3.11 - 2009-10-05
------------------
-
-- Revert performance fix introduced in 3.10 for the mutable properties plugin.
-  enumerateUsers shouldn't return results if id or login is not None like in
-  3.9 (data dict doesn't contain id or login key, so testMemberData returns
-  always False). The search should be performed only if kw parameter is not
-  empty. This is the new optimization fix.
-  [vincentfretin]
-
-
-3.10 - 2009-09-06
------------------
-
-- Performance fix for searching in the mutable properties plugin:
-  when only searching on user id do not walk over all properties,
-  but only test if the user id is known. This fixes
-  http://dev.plone.org/plone/ticket/9361
-  [toutpt]
-
-- Nested groups are now visible in prefs_group_members. This closes
-  http://dev.plone.org/plone/ticket/8557
-  [vincentfretin]
-
-- Add sort and merge PASSearchView's interface to prevent code duplication.
-  [csenger]
-
-
-3.9 - 2009-04-21
-----------------
-
-- Fix the cookie plugin's login handler to not trust the username
-  from the request. Instead we use the login name of the currently
-  authenticated user. This fixes CVE-2009-0662 (see
-  http://plone.org/products/plone/security/advisories/cve-2009-0662
-  for more information).
-  [wichert]
-
-
-3.8 - 2009-02-13
-----------------
-
-- Update the role manager's assignRoleToPrincipal method to lazily
-  update the cached list of portal roles. This fixes problems with
-  adding users with GenericSetup-created roles.
-  [wichert]
-
-- Fixed our OrderedDict to be unpickable with pickle protocol 2. On
-  unpickling a __init__ method is not called and an optimization in
-  protocol 2 would call __setitem__ without the _list to be initialized.
-  Even using a __getstate__ / __setstate__ combination wouldn't work
-  around that. This change was found in using membrane and
-  MemcachedManager.
-  [hannosch, tesdal]
-
-
-3.7 - 2008-09-28
-----------------
-
-- Removed deprecation zcml statements for PluggableAuthService components:
-  these are now in PluggableAuthService itself.
-  [wichert]
-
-- Adjusted deprecation warnings to point to Plone 4.0 instead of Plone 3.5
-  since we changed the version numbering again.
-  [hannosch]
-
-
-3.6 - 2008-06-25
-----------------
-
-- Modify PloneGroup.getMemberIds to use all IGroupIntrospection plugins
-  to get the group members. This makes it possible to list members in
-  an LDAP group.
-  [wichert]
-
-
-3.5 - 2008-06-25
-----------------
-
-- Make PASSearchView.merge actually merge search results. Its previous
-  behaviour was quite nasty: it preferred search results from the
-  enumeration plugin with the lowest priority!
-  [wichert]
-
-
-3.4 - 2008-03-26
-----------------
-
-- Added BBB code for changed setLoginFormInCookieAuth upgrade method.
-  [hannosch]
-
-- Ignore but log users without passwords during migration from pre-PAS, as
-  these cannot be added to any standard user source.
-  [hannosch]
-
-- Fix listRoleInfo on the role plugin to also lazily update the list
-  of portal roles.
-  [wichert]
-
-3.3 - 2007-03-07
-----------------
-
-- Added metadata.xml file to the profile.
-  [hannosch]
-
-- Move global role lookup out of the local role plugin. Part of the
-  PLIP 127 merge for Plone 3.1.
-  [alecm]
-
-
-3.2 - 2008-02-15
-----------------
-
-- Fix schema handling for ZODBMutablePropertyProvider initialization.
-  [maurits]
-
-- Remove some exception swallowing from the installation logic so errors
-  are not hidden.
-  [hannosch]
-
-- Correct handling an empty roles list when modifying groups.
-  This fixes http://dev.plone.org/plone/ticket/6994
-  [rsantos]
-
-
-3.1 - 2007-10-08
-----------------
-
-- Improve handing of sorting for searches.
-  [csenger]
-
-- Updating the roles for a group did not invalidate the _findGroup cache.
-  [wichert]
-
-- Fixed some tool icons to point to existing icons.
-  [hannosch]
-
-
-3.0 - 2007-08-16
-----------------
-
-- Fix check for authenticateCredentials return value
-  [rossp]
-
-
-3.0rc2 - 2007-07-27
--------------------
-
-- Fake a getPhysicalPath on our search view so ZCacheing works properly
-  everywhere.
-  [wichert]
-
-- Add event classes for logged-in and logged-out events.
-  [wichert]
-
-
-3.0rc1 - 2007-07-08
--------------------
-
-- Correct logic in MemberData capability methods: any plugin is
-  allowed to (re)set a password, delete the user or add roles.
-  [wichert]
-
-- Use the proper API to get the containing PAS in the group plugin
-  [wichert]
-
-- Fix setting user properties on the user object.
-  [wichert]
-
-
-3.0b7 - 2007-05-05
-------------------
-
-- Removed the five:registerPackage statement again. It causes problems in a
-  ZEO environment.
-  [hannosch]
-
-- Removed our version of the Plone tool from ToolInit. It won't get an icon
-  anymore and you cannot add it, but existing instances still work. We
-  migrate all instances back to the regular tool anyways.
-  [hannosch]
-
-
-3.0b6 - 2007-05-05
-------------------
-
-- Fixed two migration related test failures.
-  [hannosch]
-
-- Spring cleaning, removed some cruft, pyflaked and corrected some more
-  undefined names.
-  [hannosch]
-
-- New package layout, following standard Python package conventions.
-  [hannosch]
-
-- Fixed tool names in ToolInit, so the permission has a proper name. This
-  closes http://dev.plone.org/plone/ticket/6525.
-  [hannosch]
-
-
-3.0-beta5 - 2007-05-02
-----------------------
-
-- Modify the roles plugin to lazily update its roles list from the portal.
-  [wichert]
-
-- Filter duplicate search results.
-  [laz, wichert]
-
-- Add a sort_by option to the search methods to allow sorting of results
-  by a property.
-  [laz, wichert]
-
-- Modify login method for the cookie plugin to perform the credential
-  update in the PAS of the user instead of the PAS of the plugin. This
-  helps in making sure that users will only authenticate against their
-  own user folder, so we get all their roles, properties, etc. correctly.
-  [wichert]
-
-- Update installation logic to use plone.session for cookies
-  [wichert]
-
-- Add pas_info and pas_search browser views.
-  [wichert]
-
-- Deprecate the PlonePAS PloneTool; its changes have been merged in the
-  standard Plone version.
-  [wichert]
-
-- Use getUtility to get the portal object.
-  [wichert]
-
-- Deprecate user and group searching through CMF member and group tools
-  in favour of PAS enumeration.
-  [wichert]
-
-- Refactor user searching in the membership tool to use standard PAS
-  searches.
-  [wichert]
-
-- Add user enumeration capabilities to the mutable properties plugin.
-  [wichert]
-
-- Add a new automatic group plugin which puts all users in a virtual
-  group. This is useful for permissions handling: since it is not
-  possible to add roles to users with the Authenticated role a
-  virtual group can be used instead.
-  [wichert]
-
-- Added support to import PloneUserFactory and added stub
-  for ZODBMutableProperties. Attention: Latter needs a real
-  export and import! At the moment it do not export the
-  propertysheets. This is a TODO. At least with this two
-  additions PlonePAS import runs. Additional I needed to
-  hack PluginRegistry and and PluggableAuthService slightly.
-  [jensens]
-
-- Added HISTORY.txt and updated version information.
-  [hannosch]
-
-
-2.4 - 2007-04-15
-----------------
-
-- Optomise the local roles plugin for the common case where
-  local_roles is empty
-  [dreamcatcher]
-
-- the plone user was assuming a one to one mapping between property plugin
-  and user property sheet, and stripping away additional ones as part of
-  the retrieval of ordered sheets, instead, it now stores all
-  propertysheets in an ordered dictionary, so this assumption is not needed
-  [k_vertigo]
-
-- More postonly security changes
-  [alecm, ramon]
-
-
-2.3 - 2007-05-30
-----------------
-
-- Use a local postonly decorator so PlonePAS can be used with Plone
-  2.5, 2.5.1 and 2.5.2.
-  [wichert]
-
-- Protect the tools with postonly security modifiers.
-  [mj]
-
-- Update GRUF compatibility functions to use the same security checks
-  as GRUF itself uses.
-  [mj]
-
-- Fix migration to handle properties of selection or multiple selection
-  types.
-  [reinout]
-
-- Correct creation of groups wich default group managers.
-  [dreamcatcher]
-
-- Fix migration from GRUF sites: also include the member properties in the
-  migration.
-  [tesdal]
-
-- Correct the test for creation of groups with the same id as users: search
-  for the exact id, not substrings.
-  [tesdal]
-
-- Fix bad form action which made it impossible to add a plone user factory
-  plugin through the ZMI. Backported from trunk.
-  [wichert]
diff --git a/MANIFEST.in b/MANIFEST.in
index 5477c06..913322e 100644
--- a/MANIFEST.in
+++ b/MANIFEST.in
@@ -1,4 +1,4 @@
-recursive-include Products *
+recursive-include src *
 recursive-include docs *
 include *
-global-exclude *.pyc
+global-exclude *.py?
diff --git a/Products/PlonePAS/Extensions/Install.py b/Products/PlonePAS/Extensions/Install.py
deleted file mode 100644
index 2251b91..0000000
--- a/Products/PlonePAS/Extensions/Install.py
+++ /dev/null
@@ -1,396 +0,0 @@
-from Products.CMFCore.utils import getToolByName
-
-from Products.PluggableAuthService.interfaces.authservice \
-        import IPluggableAuthService
-from Products.PluggableAuthService.interfaces.plugins \
-     import ICredentialsResetPlugin
-from Products.PluggableAuthService.interfaces.plugins \
-     import IChallengePlugin
-from Products.PluggableAuthService.Extensions.upgrade \
-     import replace_acl_users
-from Products.PluggableAuthService.plugins.RecursiveGroupsPlugin \
-     import addRecursiveGroupsPlugin
-
-from Products.PlonePAS import config
-from Products.PlonePAS.interfaces.plugins import IUserManagement
-from Products.PlonePAS.interfaces.plugins import IUserIntrospection
-from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
-from Products.PlonePAS.interfaces import group as igroup
-
-from plone.session.plugins.session import manage_addSessionPlugin
-
-import logging
-logger = logging.getLogger('PlonePAS setup')
-
-
-def activatePluginInterfaces(portal, plugin, disable=None):
-    if disable is None:
-        disable=[]
-    pas = portal.acl_users
-    plugin_obj = pas[plugin]
-
-    activatable = []
-
-    for info in plugin_obj.plugins.listPluginTypeInfo():
-        interface = info['interface']
-        interface_name = info['id']
-        if plugin_obj.testImplements(interface):
-            if interface_name in disable:
-                disable.append(interface_name)
-                logger.debug("Disabling: " + info['title'])
-            else:
-                activatable.append(interface_name)
-                logger.debug("Activating: " + info['title'])
-    plugin_obj.manage_activateInterfaces(activatable)
-    logger.debug(plugin + " activated.")
-
-
-def setupRoles(portal):
-    rmanager = portal.acl_users.role_manager
-    rmanager.addRole('Member', title="Portal Member")
-    rmanager.addRole('Reviewer', title="Content Reviewer")
-
-
-def registerPluginType(pas, plugin_type, plugin_info):
-    # Make sure there's no dupes in _plugin_types, otherwise your PAS
-    # will *CRAWL*
-    plugin_types = list(set(pas.plugins._plugin_types))
-    if not plugin_type in plugin_types:
-        plugin_types.append(plugin_type)
-
-    # Order doesn't seem to matter, but let's store it ordered.
-    plugin_types.sort()
-
-    # Re-assign to the object, because this is a non-persistent list.
-    pas.plugins._plugin_types = plugin_types
-
-    # It's safe to assign over a existing key here.
-    pas.plugins._plugin_type_info[plugin_type] = plugin_info
-
-
-def registerPluginTypes(pas):
-
-    PluginInfo = {
-        'id': 'IUserManagement',
-        'title': 'user_management',
-        'description': ("The User Management plugins allow the "
-                        "Pluggable Auth Service to add/delete/modify users")
-        }
-
-    registerPluginType(pas, IUserManagement, PluginInfo)
-
-    PluginInfo = {
-        'id': 'IUserIntrospection',
-        'title': 'user_introspection',
-        'description': ("The User Introspection plugins allow the "
-                        "Pluggable Auth Service to provide lists of users")
-        }
-
-    registerPluginType(pas, IUserIntrospection, PluginInfo)
-
-    PluginInfo = {
-        'id': 'IGroupManagement',
-        'title': 'group_management',
-        'description': ("Group Management provides add/write/deletion "
-                        "of groups and member management")
-        }
-
-    registerPluginType(pas, igroup.IGroupManagement, PluginInfo)
-
-    PluginInfo = {
-        'id': 'IGroupIntrospection',
-        'title': 'group_introspection',
-        'description': ("Group Introspection provides listings "
-                        "of groups and membership")
-        }
-
-    registerPluginType(pas, igroup.IGroupIntrospection, PluginInfo)
-
-    PluginInfo = {
-        'id': 'ILocalRolesPlugin',
-        'title': 'local_roles',
-        'description': "Defines Policy for getting Local Roles"
-        }
-
-    registerPluginType(pas, ILocalRolesPlugin, PluginInfo)
-
-
-def setupPlugins(portal):
-    uf = portal.acl_users
-    logger.debug("\nPlugin setup")
-
-    pas = uf.manage_addProduct['PluggableAuthService']
-    plone_pas = uf.manage_addProduct['PlonePAS']
-
-    setupAuthPlugins(portal, pas, plone_pas)
-
-    found = uf.objectIds(['User Manager'])
-    if not found:
-        plone_pas.manage_addUserManager('source_users')
-        logger.debug("Added User Manager.")
-    activatePluginInterfaces(portal, 'source_users')
-
-    found = uf.objectIds(['Group Aware Role Manager'])
-    if not found:
-        plone_pas.manage_addGroupAwareRoleManager('portal_role_manager')
-        logger.debug("Added Group Aware Role Manager.")
-        activatePluginInterfaces(portal, 'portal_role_manager')
-
-    found = uf.objectIds(['Local Roles Manager'])
-    if not found:
-        plone_pas.manage_addLocalRolesManager('local_roles')
-        logger.debug("Added Group Aware Role Manager.")
-        activatePluginInterfaces(portal, 'local_roles')
-
-    found = uf.objectIds(['Group Manager'])
-    if not found:
-        plone_pas.manage_addGroupManager('source_groups')
-        logger.debug("Added ZODB Group Manager.")
-        activatePluginInterfaces(portal, 'source_groups')
-
-    found = uf.objectIds(['Plone User Factory'])
-    if not found:
-        plone_pas.manage_addPloneUserFactory('user_factory')
-        logger.debug("Added Plone User Factory.")
-        activatePluginInterfaces(portal, "user_factory")
-
-    found = uf.objectIds(['ZODB Mutable Property Provider'])
-    if not found:
-        plone_pas.manage_addZODBMutablePropertyProvider('mutable_properties')
-        logger.debug("Added Mutable Property Manager.")
-        activatePluginInterfaces(portal, "mutable_properties")
-
-    found = uf.objectIds(['Automatic Group Plugin'])
-    if not found:
-        plone_pas.manage_addAutoGroup(
-                "auto_group", "Authenticated Users (Virtual Group)",
-                "AuthenticatedUsers", "Automatic Group Provider")
-        logger.debug("Added Automatic Group.")
-        activatePluginInterfaces(portal, "auto_group")
-
-    found = uf.objectIds(['Plone Session Plugin'])
-    if not found:
-        manage_addSessionPlugin(plone_pas, 'session')
-        logger.debug("Added Plone Session Plugin.")
-        activatePluginInterfaces(portal, "session")
-
-    found = uf.objectIds(['Recursive Groups Plugin'])
-    if not found:
-        addRecursiveGroupsPlugin(plone_pas, 'recursive_groups',
-                                 "Recursive Groups Plugin")
-        activatePluginInterfaces(portal, 'recursive_groups')
-        logger.debug("Added Recursive Groups plugin.")
-
-    setupPasswordPolicyPlugin(portal)
-
-
-def setupAuthPlugins(portal, pas, plone_pas,
-                     deactivate_basic_reset=True,
-                     deactivate_cookie_challenge=False):
-    uf = portal.acl_users
-    logger.debug("Cookie plugin setup")
-
-    login_path = 'login_form'
-    logout_path = 'logged_out'
-    cookie_name = '__ac'
-
-    crumbler = getToolByName(portal, 'cookie_authentication', None)
-    if crumbler is not None:
-        login_path = crumbler.auto_login_page
-        logout_path = crumbler.logout_page
-        cookie_name = crumbler.auth_cookie
-
-    found = uf.objectIds(['Extended Cookie Auth Helper'])
-    if not found:
-        plone_pas.manage_addExtendedCookieAuthHelper('credentials_cookie_auth',
-                                                     cookie_name=cookie_name)
-    logger.debug("Added Extended Cookie Auth Helper.")
-    if deactivate_basic_reset:
-        disable = ['ICredentialsResetPlugin', 'ICredentialsUpdatePlugin']
-    else:
-        disable = []
-    activatePluginInterfaces(portal, 'credentials_cookie_auth',
-            disable=disable)
-
-    credentials_cookie_auth = uf._getOb('credentials_cookie_auth')
-    if 'login_form' in credentials_cookie_auth:
-        credentials_cookie_auth.manage_delObjects(ids=['login_form'])
-        logger.debug("Removed default login_form from credentials cookie "
-                     "auth.")
-    credentials_cookie_auth.cookie_name = cookie_name
-    credentials_cookie_auth.login_path = login_path
-
-    # remove cookie crumbler(s)
-    if 'cookie_authentication' in portal:
-        portal.manage_delObjects(['cookie_authentication'])
-    logger.debug("Removed old Cookie Crumbler")
-
-    found = uf.objectIds(['HTTP Basic Auth Helper'])
-    if not found:
-        pas.addHTTPBasicAuthHelper('credentials_basic_auth',
-                               title="HTTP Basic Auth")
-    logger.debug("Added Basic Auth Helper.")
-    activatePluginInterfaces(portal, 'credentials_basic_auth')
-
-    if deactivate_basic_reset:
-        uf.plugins.deactivatePlugin(ICredentialsResetPlugin,
-                                     'credentials_basic_auth')
-    if deactivate_cookie_challenge:
-        uf.plugins.deactivatePlugin(IChallengePlugin,
-                                     'credentials_cookie_auth')
-
-
-def updateProperties(tool, properties):
-    propsWithNoDeps = [prop for prop in properties
-                            if prop['type']
-                                not in ('selection', 'multiple selection')]
-    propsWithDeps = [prop for prop in properties
-                          if prop['type']
-                              in ('selection', 'multiple selection')]
-    for prop in propsWithNoDeps:
-        updateProp(tool, prop)
-    for prop in propsWithDeps:
-        updateProp(tool, prop)
-
-
-def updateProp(prop_manager, prop_dict):
-    """Provided a PropertyManager and a property dict of {id, value,
-    type}, set or update that property as applicable.
-
-    Doesn't deal with existing properties changing type.
-    """
-    id = prop_dict['id']
-    value = prop_dict['value']
-    type = prop_dict['type']
-    if type in ('selection', 'multiple selection'):
-        value = prop_dict['select_variable']
-    if prop_manager.hasProperty(id):
-        prop_manager._updateProperty(id, value)
-    else:
-        prop_manager._setProperty(id, value, type)
-    if type in ('selection', 'multiple selection'):
-        prop_manager._updateProperty(id, prop_dict['value'])
-
-
-def addPAS(portal):
-    logger.debug("Adding PAS user folder")
-    portal.manage_addProduct['PluggableAuthService'].addPluggableAuthService()
-
-
-def migrate_root_uf(self):
-    # Acquire parent user folder.
-    parent = self.getPhysicalRoot()
-    uf = getToolByName(parent, 'acl_users')
-    if IPluggableAuthService.providedBy(uf):
-        # It's a PAS already, fixup if needed.
-        pas_fixup(parent)
-
-        # Configure Challenge Chooser plugin if available
-        challenge_chooser_setup(parent)
-        return
-
-    if not uf.meta_type == 'User Folder':
-        # It's not a standard User Folder at the root. Nothing we can do.
-        return
-
-    # It's a standard User Folder, replace it.
-    replace_acl_users(parent)
-
-    # Get the new uf
-    uf = getToolByName(parent, 'acl_users')
-
-    pas = uf.manage_addProduct['PluggableAuthService']
-    plone_pas = uf.manage_addProduct['PlonePAS']
-    # Setup authentication plugins
-    setupAuthPlugins(parent, pas, plone_pas,
-                     deactivate_basic_reset=False,
-                     deactivate_cookie_challenge=True)
-
-    # Activate *all* interfaces for user manager. IUserAdder is not
-    # activated for some reason by default.
-    activatePluginInterfaces(parent, 'users')
-
-    # Configure Challenge Chooser plugin if available
-    challenge_chooser_setup(parent)
-
-
-def pas_fixup(self):
-    from Products.PluggableAuthService.PluggableAuthService \
-         import _PLUGIN_TYPE_INFO
-
-    pas = getToolByName(self, 'acl_users')
-    if not IPluggableAuthService.providedBy(pas):
-        logger.debug('PAS UF not found, skipping PAS fixup.')
-        return
-
-    plugins = pas['plugins']
-
-    plugin_types = list(set(plugins._plugin_types))
-    for key, id, title, description in _PLUGIN_TYPE_INFO:
-        if key in plugin_types:
-            logger.debug("Plugin type '%s' already registered." % id)
-            continue
-        logger.debug("Plugin type '%s' was not registered." % id)
-        plugin_types.append(key)
-        plugins._plugin_type_info[key] = {
-            'id': id,
-            'title': title,
-            'description': description,
-            }
-    # Make it ordered
-    plugin_types.sort()
-
-    # Re-assign because it's a non-persistent property.
-    plugins._plugin_types = plugin_types
-
-
-def challenge_chooser_setup(self):
-    uf = getToolByName(self, 'acl_users')
-    plugins = uf['plugins']
-    pas = uf.manage_addProduct['PluggableAuthService']
-
-    # Only install plugins if available
-    req = ('addChallengeProtocolChooserPlugin',
-           'addRequestTypeSnifferPlugin')
-    for m in req:
-        if getattr(pas, m, None) is None:
-            logger.debug('Needed plugins have not been found, ignoring')
-            return
-
-    found = uf.objectIds(['Challenge Protocol Chooser Plugin'])
-    if not found:
-        logger.debug('Adding Challenge Protocol Chooser Plugin.')
-        pas.addChallengeProtocolChooserPlugin(
-            'chooser',
-            mapping=config.DEFAULT_PROTO_MAPPING)
-        activatePluginInterfaces(self, 'chooser')
-    else:
-        assert len(found) == 1, 'Found extra plugins %s' % found
-        logger.debug('Found existing Challenge Protocol Chooser Plugin.')
-        plugin = uf[found[0]]
-        plugin.manage_updateProtocolMapping(
-            mapping=config.DEFAULT_PROTO_MAPPING)
-        activatePluginInterfaces(self, found[0])
-
-    found = uf.objectIds(['Request Type Sniffer Plugin'])
-    if not found:
-        logger.debug('Adding Request Type Sniffer Plugin.')
-        pas.addRequestTypeSnifferPlugin('sniffer')
-        activatePluginInterfaces(self, 'sniffer')
-    else:
-        assert len(found) == 1, 'Found extra plugins %s' % found
-        logger.debug('Found existing Request Type Sniffer Plugin.')
-        activatePluginInterfaces(self, found[0])
-
-
-def setupPasswordPolicyPlugin(portal):
-    uf = portal.acl_users
-    plone_pas = uf.manage_addProduct['PlonePAS']
-
-    found = uf.objectIds(['Default Plone Password Policy'])
-    logger.debug("\nDefault Password Ploicy Plugin setup")
-    if not found:
-        plone_pas.manage_addPasswordPolicyPlugin('password_policy',
-                               title="Default Plone Password Policy")
-        logger.debug("Added Default Plone Password Policy.")
-        activatePluginInterfaces(portal, 'password_policy')
diff --git a/Products/PlonePAS/Extensions/__init__.py b/Products/PlonePAS/Extensions/__init__.py
deleted file mode 100644
index 691ba77..0000000
--- a/Products/PlonePAS/Extensions/__init__.py
+++ /dev/null
@@ -1 +0,0 @@
-# poof!
diff --git a/Products/PlonePAS/__init__.py b/Products/PlonePAS/__init__.py
deleted file mode 100644
index 5a98e20..0000000
--- a/Products/PlonePAS/__init__.py
+++ /dev/null
@@ -1,148 +0,0 @@
-from AccessControl.Permissions import add_user_folders
-from Products.CMFCore.utils import ToolInit
-from Products.PluggableAuthService import registerMultiPlugin
-
-import config
-
-#################################
-# plugins
-from plugins import user
-from plugins import group
-from plugins import role
-from plugins import local_role
-from plugins import ufactory
-from plugins import property
-from plugins import crumbler
-from plugins import cookie_handler
-from plugins import autogroup
-from plugins import passwordpolicy
-
-#################################
-# pas monkies
-import pas
-
-#################################
-# ldapmp monkies if available
-
-try:
-    from Products import LDAPMultiPlugins
-    from Products import LDAPUserFolder
-except ImportError:
-    pass
-else:
-    import ldapmp
-
-#################################
-# pas monkies 2 play w/ gruf
-if config.PAS_INSIDE_GRUF:
-    import gruf_support
-
-#################################
-# new groups tool
-from tools.membership import MembershipTool
-from tools.memberdata import MemberDataTool
-from tools.groups import GroupsTool
-from tools.groupdata import GroupDataTool
-
-#################################
-# register plugins with pas
-try:
-    registerMultiPlugin(user.UserManager.meta_type)
-    registerMultiPlugin(group.GroupManager.meta_type)
-    registerMultiPlugin(role.GroupAwareRoleManager.meta_type)
-    registerMultiPlugin(local_role.LocalRolesManager.meta_type)
-    registerMultiPlugin(ufactory.PloneUserFactory.meta_type)
-    registerMultiPlugin(property.ZODBMutablePropertyProvider.meta_type)
-    registerMultiPlugin(crumbler.CookieCrumblingPlugin.meta_type)
-    registerMultiPlugin(cookie_handler.ExtendedCookieAuthHelper.meta_type)
-    registerMultiPlugin(autogroup.AutoGroup.meta_type)
-    registerMultiPlugin( passwordpolicy.PasswordPolicyPlugin.meta_type )
-except RuntimeError:
-    # make refresh users happy
-    pass
-
-
-def initialize(context):
-
-    tools = (GroupsTool, GroupDataTool, MembershipTool, MemberDataTool)
-
-    ToolInit('PlonePAS Tool',
-                         tools=tools,
-                         icon='tool.gif',
-                         ).initialize(context)
-
-    context.registerClass(role.GroupAwareRoleManager,
-                          permission=add_user_folders,
-                          constructors=(
-                              role.manage_addGroupAwareRoleManagerForm,
-                              role.manage_addGroupAwareRoleManager),
-                          visibility=None
-                          )
-
-    context.registerClass(user.UserManager,
-                          permission=add_user_folders,
-                          constructors=(user.manage_addUserManagerForm,
-                                        user.manage_addUserManager),
-                          visibility=None
-                          )
-
-    context.registerClass(group.GroupManager,
-                          permission=add_user_folders,
-                          constructors=(group.manage_addGroupManagerForm,
-                                        group.manage_addGroupManager),
-                          visibility=None
-                          )
-
-    context.registerClass(ufactory.PloneUserFactory,
-                          permission=add_user_folders,
-                          constructors=(
-                              ufactory.manage_addPloneUserFactoryForm,
-                              ufactory.manage_addPloneUserFactory),
-                          visibility=None
-                          )
-
-    context.registerClass(local_role.LocalRolesManager,
-                          permission=add_user_folders,
-                          constructors=(
-                              local_role.manage_addLocalRolesManagerForm,
-                              local_role.manage_addLocalRolesManager),
-                          visibility=None
-                          )
-
-    context.registerClass(property.ZODBMutablePropertyProvider,
-                          permission=add_user_folders,
-                          constructors=(
-                            property.manage_addZODBMutablePropertyProviderForm,
-                            property.manage_addZODBMutablePropertyProvider),
-                          visibility=None
-                          )
-
-    context.registerClass(crumbler.CookieCrumblingPlugin,
-                          permission=add_user_folders,
-                          constructors=(
-                              crumbler.manage_addCookieCrumblingPluginForm,
-                              crumbler.manage_addCookieCrumblingPlugin),
-                          visibility=None
-                          )
-
-    context.registerClass(cookie_handler.ExtendedCookieAuthHelper,
-                          permission=add_user_folders,
-                          constructors=(
-                            cookie_handler.manage_addExtendedCookieAuthHelperForm,
-                            cookie_handler.manage_addExtendedCookieAuthHelper),
-                          visibility=None
-                          )
-
-    context.registerClass(autogroup.AutoGroup,
-                          permission=add_user_folders,
-                          constructors=(autogroup.manage_addAutoGroupForm,
-                                        autogroup.manage_addAutoGroup),
-                          visibility=None
-                          )
-
-    context.registerClass( passwordpolicy.PasswordPolicyPlugin,
-                           permission = add_user_folders,
-                           constructors = ( passwordpolicy.manage_addPasswordPolicyForm,
-                                            passwordpolicy.manage_addPasswordPolicyPlugin ),
-                           visibility = None
-                           )
diff --git a/Products/PlonePAS/browser/__init__.py b/Products/PlonePAS/browser/__init__.py
deleted file mode 100644
index 792d600..0000000
--- a/Products/PlonePAS/browser/__init__.py
+++ /dev/null
@@ -1 +0,0 @@
-#
diff --git a/Products/PlonePAS/browser/configure.zcml b/Products/PlonePAS/browser/configure.zcml
deleted file mode 100644
index a18f818..0000000
--- a/Products/PlonePAS/browser/configure.zcml
+++ /dev/null
@@ -1,34 +0,0 @@
-<configure xmlns="http://namespaces.zope.org/zope"
-           xmlns:browser="http://namespaces.zope.org/browser"
-           xmlns:five="http://namespaces.zope.org/five"
-           i18n_domain="Five">
-
-  <permission
-     id="PAS.SearchPrincipals"
-     title="Search for principals" />
-
-  <browser:page
-      for="*"
-      name="pas_info"
-      class=".info.PASInfoView"
-      permission="zope2.View"
-      allowed_interface="Products.PlonePAS.interfaces.browser.IPASInfoView"
-      />
-
-  <browser:page
-      for="*"
-      name="pas_member"
-      class=".member.PASMemberView"
-      permission="zope2.View"
-      allowed_interface="Products.PlonePAS.interfaces.browser.IPASMemberView"
-      />
-
-  <browser:page
-      for="*"
-      name="pas_search"
-      class=".search.PASSearchView"
-      permission="zope2.View"
-      allowed_interface="Products.PlonePAS.interfaces.browser.IPASSearchView"
-      />
-
-</configure>
diff --git a/Products/PlonePAS/browser/info.py b/Products/PlonePAS/browser/info.py
deleted file mode 100644
index 68b70f6..0000000
--- a/Products/PlonePAS/browser/info.py
+++ /dev/null
@@ -1,40 +0,0 @@
-from zope.interface import implements
-from plone.memoize.instance import memoize
-
-from Acquisition import aq_inner
-from Products.PlonePAS.interfaces.browser import IPASInfoView
-from Products.PluggableAuthService.interfaces.plugins \
-                import IExtractionPlugin, ILoginPasswordExtractionPlugin
-from Products.CMFCore.utils import getToolByName
-from Products.Five import BrowserView
-
-
-class PASInfoView(BrowserView):
-    implements(IPASInfoView)
-
-    def checkExtractorForInterface(self, interface):
-        acl = getToolByName(aq_inner(self.context), "acl_users")
-        plugins = acl.plugins.listPlugins(IExtractionPlugin)
-
-        for plugin in plugins:
-            if interface.providedBy(plugin[1]):
-                return True
-
-        return False
-
-    @memoize
-    def hasLoginPasswordExtractor(self):
-        return self.checkExtractorForInterface(ILoginPasswordExtractionPlugin)
-
-    @memoize
-    def hasOpenIDExtractor(self):
-        try:
-            from plone.openid.interfaces import IOpenIdExtractionPlugin
-        except ImportError:
-            return False
-
-        return self.checkExtractorForInterface(IOpenIdExtractionPlugin)
-
-    def hasOpenIDdExtractor(self):
-        # BBB Keeping method name with typo for backwards compatibility.
-        return self.hasOpenIDExtractor()
diff --git a/Products/PlonePAS/browser/member.py b/Products/PlonePAS/browser/member.py
deleted file mode 100644
index cc71fd2..0000000
--- a/Products/PlonePAS/browser/member.py
+++ /dev/null
@@ -1,24 +0,0 @@
-from plone.memoize.instance import memoize
-from zope.interface import implements
-from zope.publisher.browser import BrowserView
-
-from Products.CMFCore.utils import getToolByName
-
-from Products.PlonePAS.interfaces.browser import IPASMemberView
-
-
-class PASMemberView(BrowserView):
-    implements(IPASMemberView)
-
-    @memoize
-    def info(self, userid=None):
-        pm = getToolByName(self.context, 'portal_membership')
-        result = pm.getMemberInfo(memberId=userid)
-        if result is None:
-            # No such member: removed?  We return something useful anyway.
-            return {'username': userid, 'description': '', 'language': '',
-                    'home_page': '', 'name_or_id': userid, 'location': '',
-                    'fullname': ''}
-        result['name_or_id'] = result.get('fullname') or \
-            result.get('username') or userid
-        return result
diff --git a/Products/PlonePAS/browser/search.py b/Products/PlonePAS/browser/search.py
deleted file mode 100644
index e19d64d..0000000
--- a/Products/PlonePAS/browser/search.py
+++ /dev/null
@@ -1,75 +0,0 @@
-from zope.interface import implements
-from zope.component import queryUtility
-from Products.Five import BrowserView
-from Products.CMFCore.utils import getToolByName
-from plone.i18n.normalizer.interfaces import IIDNormalizer
-from Products.PlonePAS.interfaces.browser import IPASSearchView
-
-
-class PASSearchView(BrowserView):
-    implements(IPASSearchView)
-
-    @staticmethod
-    def extractCriteriaFromRequest(request):
-        criteria = request.form.copy()
-
-        for key in ["form.submitted", "submit", 'b_start', 'b_size']:
-            if key in criteria:
-                del criteria[key]
-
-        for (key, value) in criteria.items():
-            if not value:
-                del criteria[key]
-
-        return criteria
-
-    @staticmethod
-    def merge(results, key):
-        output = {}
-        for entry in results:
-            id = entry[key]
-            if id not in output:
-                output[id] = entry.copy()
-            else:
-                buf = entry.copy()
-                buf.update(output[id])
-                output[id] = buf
-
-        return output.values()
-
-    def sort(self, results, sort_key):
-        idnormalizer = queryUtility(IIDNormalizer)
-
-        def key_func(a):
-            return idnormalizer.normalize(a.get(sort_key, a))
-        return sorted(results, key=key_func)
-
-    def searchUsers(self, sort_by=None, **criteria):
-        self.pas = getToolByName(self.context, "acl_users")
-        results = self.merge(self.pas.searchUsers(**criteria), "userid")
-        if sort_by is not None:
-            results = self.sort(results, sort_by)
-        return results
-
-    def searchUsersByRequest(self, request, sort_by=None):
-        criteria = self.extractCriteriaFromRequest(request)
-        return self.searchUsers(sort_by=sort_by, **criteria)
-
-    def searchGroups(self, sort_by=None, **criteria):
-        self.pas = getToolByName(self.context, "acl_users")
-        results = self.merge(self.pas.searchGroups(**criteria), "groupid")
-        if sort_by is not None:
-            results = self.sort(results, sort_by)
-        return results
-
-    def searchGroupsByRequest(self, request):
-        criteria = self.extractCriteriaFromRequest(request)
-        return self.searchGroups(**criteria)
-
-    def getPhysicalPath(self):
-        # We call various PAS methods which can be ZCached. The ZCache
-        # infrastructure relies on getPhysicalPath on the context being
-        # available, which this view does not have, it not being a
-        # persistent object. So we fake things and return the physical path
-        # for our context.
-        return self.context.getPhysicalPath()
diff --git a/Products/PlonePAS/config.py b/Products/PlonePAS/config.py
deleted file mode 100644
index a8ccf5f..0000000
--- a/Products/PlonePAS/config.py
+++ /dev/null
@@ -1,23 +0,0 @@
-PROJECTNAME = 'PlonePAS'
-GLOBALS = globals()
-
-PAS_INSIDE_GRUF = True
-
-DEFAULT_CHALLENGE_PROTOCOL = ['http']
-DEFAULT_PROTO_MAPPING = {'WebDAV': DEFAULT_CHALLENGE_PROTOCOL,
-                         'FTP': DEFAULT_CHALLENGE_PROTOCOL,
-                         'XML-RPC': DEFAULT_CHALLENGE_PROTOCOL}
-
-# Settings for member image resize quality
-try:
-    from PIL import Image
-    PIL_SCALING_ALGO = Image.ANTIALIAS
-except ImportError:
-    PIL_SCALING_ALGO = None
-
-PIL_QUALITY = 88
-MEMBER_IMAGE_SCALE = (75, 100)
-IMAGE_SCALE_PARAMS = {'scale': MEMBER_IMAGE_SCALE,
-                      'quality': PIL_QUALITY,
-                      'algorithm': PIL_SCALING_ALGO,
-                      'default_format': 'PNG'}
diff --git a/Products/PlonePAS/configure.zcml b/Products/PlonePAS/configure.zcml
deleted file mode 100644
index 4527549..0000000
--- a/Products/PlonePAS/configure.zcml
+++ /dev/null
@@ -1,30 +0,0 @@
-<configure xmlns="http://namespaces.zope.org/zope"
-    xmlns:genericsetup="http://namespaces.zope.org/genericsetup"
-    xmlns:five="http://namespaces.zope.org/five"
-    xmlns:i18n="http://namespaces.zope.org/i18n"
-    i18n_domain="plone">
-
-  <include package=".browser" />
-
-  <include file="profiles.zcml"/>
-
-  <include file="exportimport.zcml" />
-
-  <genericsetup:importStep
-      name="plonepas"
-      title="PlonePAS setup"
-      description="Configure PlonePas"
-      handler="Products.PlonePAS.setuphandlers.setupPlonePAS">
-    <depends name="componentregistry"/>
-    <depends name="controlpanel"/>
-    <depends name="memberdata-properties"/>
-    <depends name="rolemap"/>
-  </genericsetup:importStep>
-
-  <five:deprecatedManageAddDelete
-      class=".plugins.cookie_handler.ExtendedCookieAuthHelper" />
-
-  <five:deprecatedManageAddDelete
-      class=".plugins.role.GroupAwareRoleManager" />
-
-</configure>
diff --git a/Products/PlonePAS/events.py b/Products/PlonePAS/events.py
deleted file mode 100644
index 41b6394..0000000
--- a/Products/PlonePAS/events.py
+++ /dev/null
@@ -1,18 +0,0 @@
-from Products.PluggableAuthService.interfaces.events import IUserLoggedInEvent
-from Products.PluggableAuthService.interfaces.events import IUserLoggedOutEvent
-from Products.PlonePAS.interfaces.events import IUserInitialLoginInEvent
-from Products.PluggableAuthService.events import PASEvent
-from zope.interface import implements
-
-class UserLoggedInEvent(PASEvent):
-    implements(IUserLoggedInEvent)
-
-
-class UserInitialLoginInEvent(UserLoggedInEvent):
-    implements(IUserInitialLoginInEvent)
-
-
-class UserLoggedOutEvent(PASEvent):
-    implements(IUserLoggedOutEvent)
-
-
diff --git a/Products/PlonePAS/exportimport.zcml b/Products/PlonePAS/exportimport.zcml
deleted file mode 100644
index 09968e8..0000000
--- a/Products/PlonePAS/exportimport.zcml
+++ /dev/null
@@ -1,26 +0,0 @@
-<configure xmlns="http://namespaces.zope.org/zope">
-
-  <adapter
-      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
-      provides="Products.GenericSetup.interfaces.IFilesystemExporter"
-      for="Products.PluggableAuthService.interfaces.plugins.IUserFactoryPlugin"
-      />
-  <adapter
-      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
-      provides="Products.GenericSetup.interfaces.IFilesystemImporter"
-      for="Products.PluggableAuthService.interfaces.plugins.IUserFactoryPlugin"
-      /> 
-
-<!-- XXX This should point to an own export/import class! TitleOnly is far not enough -->
-  <adapter
-      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
-      provides="Products.GenericSetup.interfaces.IFilesystemExporter"
-      for="Products.PlonePAS.interfaces.plugins.IMutablePropertiesPlugin"
-      />
-  <adapter
-      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
-      provides="Products.GenericSetup.interfaces.IFilesystemImporter"
-      for="Products.PlonePAS.interfaces.plugins.IMutablePropertiesPlugin"
-      /> 
-
-</configure>
diff --git a/Products/PlonePAS/gruf_support.py b/Products/PlonePAS/gruf_support.py
deleted file mode 100644
index d6417c7..0000000
--- a/Products/PlonePAS/gruf_support.py
+++ /dev/null
@@ -1,143 +0,0 @@
-# gruf specific hacks to pas, to make it play well in gruf
-
-import logging
-
-from Products.PluggableAuthService.PluggableAuthService import \
-          PluggableAuthService, _SWALLOWABLE_PLUGIN_EXCEPTIONS
-from Products.PluggableAuthService.interfaces.plugins \
-     import IAuthenticationPlugin
-from Products.PlonePAS.interfaces.group import IGroupManagement
-from Products.PlonePAS.interfaces.plugins import IUserIntrospection
-
-from Products.CMFCore.utils import getToolByName
-
-logger = logging.getLogger('PlonePAS')
-
-
-def authenticate(self, name, password, request):
-    """See AccessControl.User.BasicUserFolder.authenticate
-
-    Products.PluggableAuthService.PluggableAuthService does not provide this
-    method, BasicUserFolder documents it as "Private UserFolder object
-    interface". GRUF does provide the method, so not marked as private.
-    """
-
-    plugins = self.plugins
-
-    try:
-        authenticators = plugins.listPlugins(IAuthenticationPlugin)
-    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
-        authenticators = ()
-
-    credentials = {'login': name,
-                   'password': password}
-
-    user_id = None
-
-    for authenticator_id, auth in authenticators:
-        try:
-            uid_and_name = auth.authenticateCredentials(credentials)
-            if uid_and_name is not None:
-                user_id, name = uid_and_name
-                break
-        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-            logger.info(
-                    'PluggableAuthService: AuthenticationPlugin %s error',
-                    authenticator_id, exc_info=1)
-            continue
-
-    if not user_id:
-        return
-
-    return self._findUser(plugins, user_id, name, request)
-
-PluggableAuthService.authenticate = authenticate
-PluggableAuthService.authenticate__roles__ = ()
-
-
-#################################
-# compat code galore
-def userSetGroups(self, id, groupnames):
-    plugins = self.plugins
-    gtool = getToolByName(self, "portal_groups")
-
-    member = self.getUserById(id)
-    groupnameset = set(groupnames)
-
-    # remove absent groups
-    groups = set(gtool.getGroupsForPrincipal(member))
-    rmgroups = groups - groupnameset
-    for gid in rmgroups:
-        try:
-            gtool.removePrincipalFromGroup(id, gid)
-        except KeyError:
-            # We could hit a group which does not allow user removal, such as
-            # created by our AutoGroup plugin.
-            pass
-
-    # add groups
-    try:
-        groupmanagers = plugins.listPlugins(IGroupManagement)
-    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
-        groupmanagers = ()
-
-    for group in groupnames:
-        for gm_id, gm in groupmanagers:
-            try:
-                if gm.addPrincipalToGroup(id, group):
-                    break
-            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-                logger.info('PluggableAuthService: GroupManagement %s error',
-                            gm_id, exc_info=1)
-
-PluggableAuthService.userSetGroups = userSetGroups
-
-#################################
-# monkies for the diehard introspection.. all these should die, imho - kt
-
-
-def getUserIds(self):
-    plugins = self.plugins
-
-    try:
-        introspectors = plugins.listPlugins(IUserIntrospection)
-    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
-        introspectors = ()
-
-    results = []
-    for introspector_id, introspector in introspectors:
-        try:
-            results.extend(introspector.getUserIds())
-        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-            logger.info(
-                    'PluggableAuthService: UserIntrospection %s error',
-                    introspector_id, exc_info=1)
-
-    return results
-
-
-def getUserNames(self):
-    plugins = self.plugins
-
-    try:
-        introspectors = plugins.listPlugins(IUserIntrospection)
-    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
-        introspectors = ()
-
-    results = []
-    for introspector_id, introspector in introspectors:
-        try:
-            results.extend(introspector.getUserNames())
-        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-            logger.info(
-                'PluggableAuthService: UserIntroSpection plugin %s error',
-                introspector_id, exc_info=1)
-
-    return results
-
-PluggableAuthService.getUserIds = getUserIds
-PluggableAuthService.getUserNames = getUserNames
diff --git a/Products/PlonePAS/interfaces/__init__.py b/Products/PlonePAS/interfaces/__init__.py
deleted file mode 100644
index 4287ca8..0000000
--- a/Products/PlonePAS/interfaces/__init__.py
+++ /dev/null
@@ -1 +0,0 @@
-#
\ No newline at end of file
diff --git a/Products/PlonePAS/interfaces/browser.py b/Products/PlonePAS/interfaces/browser.py
deleted file mode 100644
index c27eee5..0000000
--- a/Products/PlonePAS/interfaces/browser.py
+++ /dev/null
@@ -1,88 +0,0 @@
-from zope.interface import Interface
-
-
-class IPASInfoView(Interface):
-
-    def hasLoginPasswordExtractor():
-        """Check if a login & password extraction plugin is active.
-
-        Check if there is a plugin with an enabled
-        ILoginPasswordExtractionPlugin interface. This can be used to
-        conditionally show username & password logins.
-        """
-
-    def hasOpenIDExtractor():
-        """Check if an OpenID extraction plugin is active.
-        """
-
-    def hasOpenIDdExtractor():
-        """Check if an OpenID extraction plugin is active.
-
-        BBB Keeping method name with typo for backwards compatibility.
-        """
-
-
-class IPASMemberView(Interface):
-
-    def info(userid=None):
-        """Return 'harmless' member info of any user, such as full name,
-        location, etc.
-        """
-
-
-class IPASSearchView(Interface):
-
-    def searchUsers(sort_by=None, any_field=None, **criteria):
-        """Search for users matching a set of criteria.
-
-        The criteria are a dictionary mapping user properties to values and
-        have the semantics declared by IPluggableAuthService.searchUsers().
-        Duplicate results returned by PAS are filtered so only the first
-        result remains in the result set. The results can be sorted on
-        sort_bys (case insensitive).
-
-        In addition, a single search string can be sought in multiple
-        fields at a time by passing any_field='your-string'. The fields
-        that will be searched are not explicitly enumerated but will be the
-        user-facing ones a user would expect to search, such as login name
-        and full name. (Perhaps any_field should/could be moved into PAS
-        proper. This could be done without breaking code that depends on
-        this interface.)
-
-        If you specify both any_field and other criteria that include a
-        field that any_field would typically search (such as login name),
-        the other criteria will be enforced at the expense of any_field.
-        """
-
-    def searchUsersByRequest(request, sort_by=None):
-        """Search for users matching a set of criteria found in a request.
-
-        This method will look remove any obvious values from the request
-        which are not search criteria. It will also remove any fields
-        which have an empty string value.
-        Duplicate results returned by PAS are filtered so only the first
-        result remains in the result set. The results can be sorted on
-        sort_by (case insensitive).
-        """
-
-    def searchGroups(**criteria):
-        """Search for groups matching a set of criteria.
-
-        The criteria are a dictionary mapping group properties
-        to values and have the semantics declared by
-        IPluggableAuthService.searchGroups().
-        """
-
-    def searchGroupsByRequest(request):
-        """Search for groups matching a set of criteria found in a request.
-
-        This method will look remove any obvious values from the request
-        which are not search criteria. It will also remove any fields
-        which have an empty string value.
-        """
-
-    def merge(results, key):
-        """merge two search results based on key as the unique criterion"""
-
-    def sort(results, key):
-        """sort results on a key"""
diff --git a/Products/PlonePAS/interfaces/capabilities.py b/Products/PlonePAS/interfaces/capabilities.py
deleted file mode 100644
index 5d31c25..0000000
--- a/Products/PlonePAS/interfaces/capabilities.py
+++ /dev/null
@@ -1,78 +0,0 @@
-# Define certain interfaces that a plugin must meet if it is to allow
-# certain operations to be done by the Plone UI.
-
-from Products.PluggableAuthService.interfaces.plugins import Interface
-
-
-class IDeleteCapability(Interface):
-    """Interface for plugin to say if it allows for deletion of a user.
-    Expected to be found on IUserManagement plugins.
-    For Plone UI.
-    """
-
-    def allowDeletePrincipal(id):
-        """True iff this plugin can delete a certain user/group."""
-
-
-class IPasswordSetCapability(Interface):
-    """Interface for plugin to say if it allows for setting the password of a
-    user.
-    Expected to be found on IUserManagement plugins.
-    For Plone UI.
-    """
-
-    def allowPasswordSet(id):
-        """True iff this plugin can set the password of a certain user."""
-
-
-class IGroupCapability(Interface):
-    """Interface for plugin to say if it allows for deletion of a user.
-    For Plone UI.
-    """
-
-    def allowGroupAdd(principal_id, group_id):
-        """True iff this plugin will allow adding a certain principal to a
-        certain group."""
-
-    def allowGroupRemove(principal_id, group_id):
-        """True iff this plugin will allow removing a certain principal from a
-        certain group."""
-
-
-class IAssignRoleCapability(Interface):
-    """Interface for plugin to say if it allows for deletion of a user.
-    For Plone UI.
-    """
-
-    def allowRoleAssign(id, role):
-        """True iff this plugin will allow assigning a certain principal a
-        certain role."""
-
-
-class IManageCapabilities(Interface):
-    """Interface for MemberData/GroupData to provide information as to whether
-    or not the member can be deleted, reset password, modify a property.
-    """
-
-    def canDelete():
-        """True iff user can be removed from the Plone UI."""
-
-    def canPasswordSet():
-        """True iff user can change password."""
-
-    def passwordInClear():
-        """True iff password can be retrieved in the clear (not hashed.)"""
-
-    def canWriteProperty(prop_name):
-        """True iff the member/group property named in 'prop_name'
-        can be changed.
-        """
-
-    def canAddToGroup(group_id):
-        """True iff member can be added to group."""
-
-    def canRemoveFromGroup(group_id):
-        """True iff member can be removed from group."""
-
-    def canAssignRole(role):
-        """True iff member can be assigned role."""
diff --git a/Products/PlonePAS/interfaces/events.py b/Products/PlonePAS/interfaces/events.py
deleted file mode 100644
index 88c68be..0000000
--- a/Products/PlonePAS/interfaces/events.py
+++ /dev/null
@@ -1,6 +0,0 @@
-from Products.PluggableAuthService.interfaces.events import IUserLoggedInEvent
-
-
-class IUserInitialLoginInEvent(IUserLoggedInEvent):
-    """A user logs in for the first time in the portal.
-    """
diff --git a/Products/PlonePAS/interfaces/group.py b/Products/PlonePAS/interfaces/group.py
deleted file mode 100644
index 49acfac..0000000
--- a/Products/PlonePAS/interfaces/group.py
+++ /dev/null
@@ -1,139 +0,0 @@
-from zope.interface import Interface
-from Products.PluggableAuthService.interfaces import plugins
-
-
-class IGroupManagement(Interface):
-
-    def addGroup(id, **kw):
-        """
-        Create a group with the supplied id, roles, and groups.
-        return True if the operation suceeded
-        """
-
-    def addPrincipalToGroup(principal_id, group_id):
-        """
-        Add a given principal to the group.
-        return True on success
-        """
-
-    def updateGroup(id, **kw):
-        """
-        Edit the given group. plugin specific
-        return True on success
-        """
-
-    def setRolesForGroup(group_id, roles=()):
-        """
-        set roles for group
-        return True on success
-        """
-
-    def removeGroup(group_id):
-        """
-        Remove the given group
-        return True on success
-        """
-
-    def removePrincipalFromGroup(principal_id, group_id):
-        """
-        remove the given principal from the group
-        return True on success
-        """
-
-
-class IGroupIntrospection(Interface):
-
-    def getGroupById(group_id):
-        """
-        Returns the portal_groupdata-ish object for a group
-        corresponding to this id.
-        """
-
-    #################################
-    # these interface methods are suspect for scalability.
-    #################################
-
-    def getGroups():
-        """
-        Returns an iteration of the available groups
-        """
-
-    def getGroupIds():
-        """
-        Returns a list of the available groups
-        """
-
-    def getGroupMembers(group_id):
-        """
-        return the members of the given group
-        """
-
-
-class IGroupDataTool(Interface):
-
-    def wrapGroup(group):
-        """
-        decorate a group with property management capabilities if needed
-        """
-
-
-class IGroupTool(IGroupIntrospection,
-                  IGroupManagement,
-                  plugins.IGroupsPlugin):
-
-    """
-    Defines an interface for managing and introspecting and
-    groups and group membership.
-    """
-
-
-class IGroupData(Interface):
-    """ An abstract interface for accessing properties on a group object"""
-
-    def setProperties(properties=None, **kw):
-        """Allows setting of group properties en masse.
-        Properties can be given either as a dict or a keyword parameters
-        list"""
-
-    def getProperty(id):
-        """ Return the value of the property specified by 'id' """
-
-    def getProperties():
-        """ Return the properties of this group. Properties are as usual in
-        Zope."""
-
-    def getGroupId():
-        """ Return the string id of this group, WITHOUT group prefix."""
-
-    def getMemberId():
-        """This exists only for a basic user/group API compatibility
-        """
-
-    def getGroupName():
-        """ Return the name of the group."""
-
-    def getGroupMembers():
-        """ Return a list of the portal_memberdata-ish members of the group."""
-
-    def getAllGroupMembers():
-        """ Return a list of the portal_memberdata-ish members of the group
-        including transitive ones (ie. users or groups of a group in that
-        group)."""
-
-    def getGroupMemberIds():
-        """ Return a list of the user ids of the group."""
-
-    def getAllGroupMemberIds():
-        """ Return a list of the user ids of the group.
-        including transitive ones (ie. users or groups of a group in that
-        group)."""
-
-    def addMember(id):
-        """ Add the existing member with the given id to the group"""
-
-    def removeMember(id):
-        """ Remove the member with the provided id from the group """
-
-    def getGroup():
-        """ Returns the actual group implementation. Varies by group
-        implementation (GRUF/Nux/et al)."""
diff --git a/Products/PlonePAS/interfaces/membership.py b/Products/PlonePAS/interfaces/membership.py
deleted file mode 100644
index 4f3b3af..0000000
--- a/Products/PlonePAS/interfaces/membership.py
+++ /dev/null
@@ -1,11 +0,0 @@
-from Products.CMFCore import interfaces
-
-
-class IMembershipTool(interfaces.IMembershipTool):
-
-    def getMemberInfo(memberId=None):
-        """Return 'harmless' Memberinfo of any member, such as full name,
-        location, etc
-        """
-
-__all__ = (IMembershipTool, )
diff --git a/Products/PlonePAS/interfaces/plugins.py b/Products/PlonePAS/interfaces/plugins.py
deleted file mode 100644
index 76bbe74..0000000
--- a/Products/PlonePAS/interfaces/plugins.py
+++ /dev/null
@@ -1,126 +0,0 @@
-from Products.PluggableAuthService.interfaces import plugins
-from Products.PluggableAuthService.interfaces.plugins import Interface
-
-
-class IUserIntrospection(Interface):
-    """
-    Introspect users in a user source, api users need to be careful as
-    all sources may or not support this interface.
-
-    Realistically this can only be done by authentication sources, or
-    plugins which have intimate knowledge of such.
-    """
-
-    def getUserIds():
-        """
-        Return a list of user ids
-        """
-
-    def getUserNames():
-        """
-        Return a list of usernames
-        """
-
-    def getUsers():
-        """
-        Return a list of users
-        """
-
-
-class ILocalRolesPlugin(Interface):
-    """
-    Plugin for determining a user's local roles and object access
-    based on local roles.
-    """
-
-    def getRolesInContext(user, object):
-        """
-        Return the list of roles assigned to the user.
-
-        o Include local roles assigned in context of the passed-in object.
-
-        o Include *both* local roles assigned directly to us *and* those
-          assigned to our groups.
-
-        o Ripped off from AccessControl.User.BasicUser, which provides
-          no other extension mechanism. :(
-        """
-
-    def checkLocalRolesAllowed(user, object, object_roles):
-        """
-        Check whether the user has access to object based
-        on local roles. access is determined by a user's local roles
-        including one of the object roles.
-        """
-
-    def getAllLocalRolesInContext(object):
-        """
-        Return active all local roles in a context.
-
-        The roles are returned in a dictionary mapping a principal (a
-        user or a group) to the set of roles assigned to it.
-        """
-
-
-class IUserManagement(plugins.IUserAdderPlugin):
-    """
-    Manage users
-    """
-
-    def doChangeUser(user_id, password, **kw):
-        """
-        Change a user's password (differs from role) roles are set in
-        the pas engine api for the same but are set via a role
-        manager)
-        """
-
-    def doDeleteUser(login):
-        """
-        Remove a user record from a User Manager, with the given login
-        and password
-
-        o Return a Boolean indicating whether a user was removed or
-          not
-        """
-
-
-class IMutablePropertiesPlugin(Interface):
-    """
-    Return a property set for a user. Property set can either an
-    object conforming to the IMutable property sheet interface or a
-    dictionary (in which case the properties are not persistently
-    mutable).
-    """
-
-    def getPropertiesForUser(user, request=None):
-        """
-        User -> IMutablePropertySheet || {}
-
-        o User will implement IPropertiedUser.
-
-        o Plugin may scribble on the user, if needed (but must still
-          return a mapping, even if empty).
-
-        o May assign properties based on values in the REQUEST object, if
-          present
-        """
-
-    def setPropertiesForUser(user, propertysheet):
-        """
-        Set modified properties on the user persistently.
-
-        Raise a ValueError if the property or property value is invalid
-        """
-
-    def deleteUser(user_id):
-        """
-        Remove properties stored for a user
-        """
-
-
-class ISchemaMutablePropertiesPlugin(Interface):
-
-    def addProperty(property_type, property_name, default=None):
-        """
-        Add a new property to a property provider.
-        """
diff --git a/Products/PlonePAS/interfaces/propertysheets.py b/Products/PlonePAS/interfaces/propertysheets.py
deleted file mode 100644
index 195d0a6..0000000
--- a/Products/PlonePAS/interfaces/propertysheets.py
+++ /dev/null
@@ -1,21 +0,0 @@
-from Products.PluggableAuthService.interfaces.propertysheets \
-    import IPropertySheet
-
-
-class IMutablePropertySheet(IPropertySheet):
-
-    def canWriteProperty(object, id):
-        """ Check if a property can be modified.
-        """
-
-    def setProperty(object, id, value):
-        """
-        """
-
-    def setProperties(object, mapping):
-        """
-        """
-
-
-class ISchemaMutablePropertySheet(IMutablePropertySheet):
-    pass
diff --git a/Products/PlonePAS/ldapmp.py b/Products/PlonePAS/ldapmp.py
deleted file mode 100644
index 9c4522e..0000000
--- a/Products/PlonePAS/ldapmp.py
+++ /dev/null
@@ -1,60 +0,0 @@
-from Products.PlonePAS.patch import call, wrap_method
-from Products.PlonePAS.plugins.group import PloneGroup
-from Products.LDAPMultiPlugins.LDAPPluginBase import LDAPPluginBase
-from Products.LDAPMultiPlugins.LDAPMultiPlugin import LDAPMultiPlugin
-
-GROUP_PROPERTY_MAP = {
-    # target property: (possible key, ...)
-    'title': ('name',
-              'displayName',
-              'cn',),
-    'description': ('description', ),
-    'email': ('mail', ),
-    }
-
-KNOWN_ATTRS = []
-for attrs in GROUP_PROPERTY_MAP.values():
-    for attr in attrs:
-        KNOWN_ATTRS.append(attr)
-KNOWN_ATTRS = set(KNOWN_ATTRS)
-
-
-def getPropertiesForUser(self, user, request=None):
-    """Fullfill PropertiesPlugin requirements
-    """
-
-    if not isinstance(user, PloneGroup):
-        # It's not a PloneGroup, continue as usual
-        return call(self, 'getPropertiesForUser', user=user, request=request)
-
-    # We've got a PloneGroup.
-    # Search for groups instead of users
-    groups = self.enumerateGroups(id=user.getId(), exact_match=True)
-    # XXX Should we assert there's only one group?
-    properties = {}
-    for group in groups:
-        for pname, attrs in GROUP_PROPERTY_MAP.items():
-            for attr in attrs:
-                value = group.get(attr)
-                if value:
-                    # Break on first found
-                    properties[pname] = value
-                    break
-
-    return properties
-
-wrap_method(LDAPPluginBase, 'getPropertiesForUser', getPropertiesForUser)
-
-
-def getGroupsForPrincipal(self, user, request=None, attr=None):
-    """ Fulfill GroupsPlugin requirements, but don't return any groups for
-    groups """
-
-    if not isinstance(user, PloneGroup):
-        # It's not a PloneGroup, continue as usual
-        return call(self, 'getGroupsForPrincipal', user,
-                    request=request, attr=attr)
-
-    return ()
-
-wrap_method(LDAPMultiPlugin, 'getGroupsForPrincipal', getGroupsForPrincipal)
diff --git a/Products/PlonePAS/pas.py b/Products/PlonePAS/pas.py
deleted file mode 100644
index e22f98f..0000000
--- a/Products/PlonePAS/pas.py
+++ /dev/null
@@ -1,462 +0,0 @@
-# pas alterations and monkies
-from zope.event import notify
-
-from Products.CMFCore.utils import getToolByName
-
-from AccessControl import Unauthorized, getSecurityManager
-from AccessControl.Permissions import manage_users as ManageUsers
-from AccessControl.Permissions import manage_properties, change_permissions
-from AccessControl.PermissionRole import PermissionRole
-
-from Products.PluggableAuthService.PluggableAuthService import \
-     PluggableAuthService, _SWALLOWABLE_PLUGIN_EXCEPTIONS
-from Products.PluggableAuthService.interfaces.plugins \
-    import IRoleAssignerPlugin
-from Products.PluggableAuthService.interfaces.plugins \
-    import IUserEnumerationPlugin
-from Products.PluggableAuthService.interfaces.plugins \
-    import IGroupEnumerationPlugin
-from Products.PluggableAuthService.events import PrincipalDeleted
-
-from Products.PlonePAS.interfaces.plugins \
-    import IUserManagement, ILocalRolesPlugin
-from Products.PlonePAS.interfaces.group import IGroupIntrospection
-from Products.PlonePAS.interfaces.plugins import IUserIntrospection
-from AccessControl.requestmethod import postonly
-
-# Register the PAS acl_users as a utility
-from Products.CMFCore.utils import registerToolInterface
-from Products.PluggableAuthService.interfaces.authservice \
-    import IPluggableAuthService
-registerToolInterface('acl_users', IPluggableAuthService)
-
-
-#################################
-# pas folder monkies - standard zope user folder api
-
-_old_doAddUser = PluggableAuthService._doAddUser
-
-
-def _doAddUser(self, login, password, roles, domains, groups=None, **kw):
-    """Masking of PAS._doAddUser to add groups param."""
-    retval = _old_doAddUser(self, login, password, roles, domains)
-    if groups is not None:
-        self.userSetGroups(login, groups)
-    return retval
-
-PluggableAuthService._doAddUser = _doAddUser
-
-
-def _doDelUsers(self, names, REQUEST=None):
-    """
-    Delete users given by a list of user ids.
-    Has no return value, like the original (GRUF).
-    """
-    for name in names:
-        self._doDelUser(name)
-
-PluggableAuthService._doDelUsers = _doDelUsers
-
-
-def _doDelUser(self, id):
-    """
-    Given a user id, hand off to a deleter plugin if available.
-    """
-    plugins = self._getOb('plugins')
-    userdeleters = plugins.listPlugins(IUserManagement)
-
-    if not userdeleters:
-        raise NotImplementedError("There is no plugin that can "
-                                   " delete users.")
-
-    for userdeleter_id, userdeleter in userdeleters:
-        try:
-            userdeleter.doDeleteUser(id)
-        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-            pass
-        else:
-            notify(PrincipalDeleted(id))
-
-
-PluggableAuthService._doDelUser = _doDelUser
-
-PluggableAuthService.userFolderDelUsers = \
-    postonly(PluggableAuthService._doDelUsers)
-PluggableAuthService.userFolderDelUsers__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
-
-def _doChangeUser(self, principal_id, password, roles, domains=(), groups=None,
-                  REQUEST=None, **kw):
-    """
-    Given a principal id, change its password, roles, domains, if
-    respective plugins for such exist.
-
-    XXX domains are currently ignored.
-    """
-    # Might be called with 'None' as password from the Plone UI, in
-    # prefs_users_overview when resetPassword is not set.
-    if password is not None:
-        self.userSetPassword(principal_id, password)
-
-    plugins = self._getOb('plugins')
-    rmanagers = plugins.listPlugins(IRoleAssignerPlugin)
-
-    if not (rmanagers):
-        raise NotImplementedError("There is no plugin that can modify roles")
-
-    for rid, rmanager in rmanagers:
-        rmanager.assignRolesToPrincipal(roles, principal_id)
-
-    if groups is not None:
-        self.userSetGroups(principal_id, groups)
-
-    return True
-
-PluggableAuthService._doChangeUser = _doChangeUser
-
-PluggableAuthService.userFolderEditUser = \
-    postonly(PluggableAuthService._doChangeUser)
-PluggableAuthService.userFolderEditUser__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
-
-def userFolderAddUser(self, login, password, roles, domains,
-                      groups=None, REQUEST=None, **kw):
-    self._doAddUser(login, password, roles, domains, **kw)
-    if groups is not None:
-        self.userSetGroups(login, groups)
-
-PluggableAuthService.userFolderAddUser = postonly(userFolderAddUser)
-PluggableAuthService.userFolderAddUser__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
-
-def _doAddGroup(self, id, roles, groups=None, **kw):
-    gtool = getToolByName(self, 'portal_groups')
-    return gtool.addGroup(id, roles, groups, **kw)
-
-PluggableAuthService._doAddGroup = _doAddGroup
-
-
-# for prefs_group_manage compatibility. really should be using tool.
-def _doDelGroups(self, names, REQUEST=None):
-    gtool = getToolByName(self, 'portal_groups')
-    for group_id in names:
-        gtool.removeGroup(group_id)
-
-PluggableAuthService._doDelGroups = _doDelGroups
-
-PluggableAuthService.userFolderDelGroups = \
-    postonly(PluggableAuthService._doDelGroups)
-PluggableAuthService.userFolderDelGroups__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
-
-def _doChangeGroup(self, principal_id, roles, groups=None, REQUEST=None, **kw):
-    """
-    Given a group's id, change its roles, domains, if respective
-    plugins for such exist. Domains are currently ignored.
-
-    See also _doChangeUser
-    """
-    gtool = getToolByName(self, 'portal_groups')
-    gtool.editGroup(principal_id, roles, groups, **kw)
-    return True
-
-PluggableAuthService._doChangeGroup = _doChangeGroup
-
-
-def _updateGroup(self, principal_id, roles=None, groups=None, **kw):
-    """
-    Given a group's id, change its roles, groups, if respective
-    plugins for such exist. Domains are ignored.
-
-    This is not an alias to _doChangeGroup because its params are different
-    (slightly).
-    """
-    return self._doChangeGroup(principal_id, roles, groups, **kw)
-
-PluggableAuthService._updateGroup = _updateGroup
-
-PluggableAuthService.userFolderEditGroup = \
-    postonly(PluggableAuthService._doChangeGroup)
-PluggableAuthService.userFolderEditGroup__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
-
-def getGroups(self):
-    gtool = getToolByName(self, 'portal_groups')
-    return gtool.listGroups()
-
-PluggableAuthService.getGroups = getGroups
-PluggableAuthService.getGroups__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
-
-def getGroupNames(self):
-    gtool = getToolByName(self, 'portal_groups')
-    return gtool.getGroupIds()
-
-PluggableAuthService.getGroupNames = getGroupNames
-PluggableAuthService.getGroupNames__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
-
-def getGroupIds(self):
-    gtool = getToolByName(self, 'portal_groups')
-    return gtool.getGroupIds()
-
-PluggableAuthService.getGroupIds = getGroupIds
-PluggableAuthService.getGroupIds__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
-
-def getGroup(self, group_id):
-    """Like getGroupById in groups tool, but doesn't wrap.
-    """
-    group = None
-    introspectors = self.plugins.listPlugins(IGroupIntrospection)
-
-    if not introspectors:
-        raise ValueError('No plugins allow for group management')
-    for iid, introspector in introspectors:
-        group = introspector.getGroupById(group_id)
-        if group is not None:
-            break
-    return group
-
-PluggableAuthService.getGroup = getGroup
-PluggableAuthService.getGroup__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
-
-def getGroupByName(self, name, default=None):
-    ret = self.getGroup(name)
-    if ret is None:
-        return default
-    return ret
-
-PluggableAuthService.getGroupByName = getGroupByName
-PluggableAuthService.getGroupByName__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
-
-def getGroupById(self, id, default=None):
-    gtool = getToolByName(self, "portal_groups")
-    ret = gtool.getGroupById(id)
-    if ret is None:
-        return default
-    else:
-        return ret
-
-PluggableAuthService.getGroupById = getGroupById
-PluggableAuthService.getGroupById__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
-
-def getLocalRolesForDisplay(self, object):
-    """This is used for plone's local roles display
-
-    This method returns a tuple (massagedUsername, roles, userType,
-    actualUserName).  This method is protected by the 'access content
-    information' permission. We may change that if it's too
-    permissive...
-
-    A GRUF method originally.
-    """
-    # Perform security check on destination object
-    if not getSecurityManager().checkPermission(manage_properties, object):
-        raise Unauthorized(name="getLocalRolesForDisplay")
-
-    return self._getLocalRolesForDisplay(object)
-
-PluggableAuthService.getLocalRolesForDisplay = getLocalRolesForDisplay
-
-
-def _getLocalRolesForDisplay(self, object):
-    result = []
-    # we don't have a PAS-side way to get this
-    local_roles = object.get_local_roles()
-    for one_user in local_roles:
-        username = userid = one_user[0]
-        roles = one_user[1]
-        userType = 'user'
-        if self.getGroup(userid):
-            userType = 'group'
-        else:
-            user = self.getUserById(userid) or self.getUser(username)
-            if user:
-                username = user.getUserName()
-                userid = user.getId()
-        result.append((username, roles, userType, userid))
-    return tuple(result)
-
-PluggableAuthService._getLocalRolesForDisplay = _getLocalRolesForDisplay
-
-
-def getUsers(self):
-    """
-    Return a list of all users from plugins that implement the user
-    introspection interface.
-
-    Could potentially be very long.
-    """
-    # We should have a method that's cheap about returning number of users.
-    retval = []
-    try:
-        introspectors = self.plugins.listPlugins(IUserIntrospection)
-    except KeyError:
-        return retval
-
-    for iid, introspector in introspectors:
-        retval += introspector.getUsers()
-
-    return retval
-
-PluggableAuthService.getUsers = getUsers
-PluggableAuthService.getUsers__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-PluggableAuthService.getPureUsers = getUsers   # this'll make listMembers work
-PluggableAuthService.getPureUsers__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
-
-def canListAllUsers(self):
-    plugins = self._getOb('plugins')
-
-    # Do we have multiple user plugins?
-    if len(plugins.listPlugins(IUserEnumerationPlugin)) \
-            != len(plugins.listPlugins(IUserIntrospection)):
-        return False
-    return True
-
-PluggableAuthService.canListAllUsers = canListAllUsers
-PluggableAuthService.canListAllUsers__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
-
-def canListAllGroups(self):
-    plugins = self._getOb('plugins')
-
-    # Do we have multiple user plugins?
-    if len(plugins.listPlugins(IGroupEnumerationPlugin)) \
-            != len(plugins.listPlugins(IGroupIntrospection)):
-        return False
-    return True
-
-PluggableAuthService.canListAllGroups = canListAllGroups
-PluggableAuthService.canListAllGroups__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
-
-def userSetPassword(self, userid, password):
-    """Emulate GRUF 3 call for password set, for use with PwRT."""
-    # used by _doChangeUser
-    plugins = self._getOb('plugins')
-    managers = plugins.listPlugins(IUserManagement)
-
-    if not (managers):
-        raise NotImplementedError("There is no plugin that can modify users")
-
-    modified = False
-    for mid, manager in managers:
-        try:
-            manager.doChangeUser(userid, password)
-        except RuntimeError:
-            # XXX: why silent ignore this Error?
-            pass
-        else:
-            modified = True
-
-    if not modified:
-        raise RuntimeError("No user management plugins were able "
-                           "to successfully modify the user")
-
-PluggableAuthService.userSetPassword = userSetPassword
-PluggableAuthService.userSetPassword__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
-
-def credentialsChanged(self, user, name, new_password):
-    """Notifies the authentication mechanism that this user has changed
-    passwords.  This can be used to update the authentication cookie.
-    Note that this call should *not* cause any change at all to user
-    databases.
-
-    For use by CMFCore.MembershipTool.credentialsChanged
-    """
-    request = self.REQUEST
-    response = request.RESPONSE
-    login = name
-
-    self.updateCredentials(request, response, login, new_password)
-
-PluggableAuthService.credentialsChanged = credentialsChanged
-PluggableAuthService.credentialsChanged__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
-
-# for ZopeVersionControl, we need to check 'plugins' for more than
-# existence, since it replaces objects (like 'plugins') with SimpleItems
-# and calls _delOb, which tries to use special methods of 'plugins'
-from OFS.Folder import Folder
-
-
-def _delOb(self, id):
-    #
-    #   Override ObjectManager's version to clean up any plugin
-    #   registrations for the deleted object
-    #
-    # XXX imo this is a evil one
-    #
-    plugins = self._getOb('plugins', None)
-
-    if getattr(plugins, 'removePluginById', None) is not None:
-        plugins.removePluginById(id)
-
-    Folder._delOb(self, id)
-
-PluggableAuthService._delOb = _delOb
-
-
-def addRole(self, role):
-    plugins = self._getOb('plugins')
-    roles = plugins.listPlugins(IRoleAssignerPlugin)
-
-    for plugin_id, plugin in roles:
-        try:
-            plugin.addRole(role)
-            return
-        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-            pass
-
-PluggableAuthService.addRole = addRole
-PluggableAuthService.addRole__roles__ = \
-    PermissionRole(ManageUsers, ('Manager',))
-
-
-def getAllLocalRoles(self, context):
-    # Perform security check on destination object
-    if not getSecurityManager().checkPermission(change_permissions, context):
-        raise Unauthorized(name="getAllLocalRoles")
-    return self._getAllLocalRoles(context)
-
-PluggableAuthService.getAllLocalRoles = getAllLocalRoles
-
-
-def _getAllLocalRoles(self, context):
-    plugins = self._getOb('plugins')
-    lrmanagers = plugins.listPlugins(ILocalRolesPlugin)
-
-    roles = {}
-    for lrid, lrmanager in lrmanagers:
-        newroles = lrmanager.getAllLocalRolesInContext(context)
-        for k, v in newroles.items():
-            if k not in roles:
-                roles[k] = set()
-            roles[k].update(v)
-
-    return roles
-
-PluggableAuthService._getAllLocalRoles = _getAllLocalRoles
diff --git a/Products/PlonePAS/patch.py b/Products/PlonePAS/patch.py
deleted file mode 100644
index 0f7361f..0000000
--- a/Products/PlonePAS/patch.py
+++ /dev/null
@@ -1,44 +0,0 @@
-import logging
-
-logger = logging.getLogger('PlonePAS')
-
-
-PATTERN = '__PlonePAS_%s__'
-
-
-def call(self, __name__, *args, **kw):
-    return getattr(self, PATTERN % __name__)(*args, **kw)
-
-
-WRAPPER = '__PlonePAS_is_wrapper_method__'
-ORIG_NAME = '__PlonePAS_original_method_name__'
-
-
-def isWrapperMethod(meth):
-    return getattr(meth, WRAPPER, False)
-
-
-def wrap_method(klass, name, method, pattern=PATTERN):
-    old_method = getattr(klass, name)
-    if isWrapperMethod(old_method):
-        logger.info('PlonePAS: *NOT* wrapping already wrapped method at %s.%s',
-            klass.__name__, name)
-        return
-    else:
-        logger.info('PlonePAS: Wrapping method at %s.%s', klass.__name__, name)
-    new_name = pattern % name
-    setattr(klass, new_name, old_method)
-    setattr(method, ORIG_NAME, new_name)
-    setattr(method, WRAPPER, True)
-    setattr(klass, name, method)
-
-
-def unwrap_method(klass, name):
-    old_method = getattr(klass, name)
-    if not isWrapperMethod(old_method):
-        raise ValueError('Trying to unwrap non-wrapped '
-                         'method at %s.%s' % (klass.__name__, name))
-    orig_name = getattr(old_method, ORIG_NAME)
-    new_method = getattr(klass, orig_name)
-    delattr(klass, orig_name)
-    setattr(klass, name, new_method)
diff --git a/Products/PlonePAS/permissions.py b/Products/PlonePAS/permissions.py
deleted file mode 100644
index 3ae3661..0000000
--- a/Products/PlonePAS/permissions.py
+++ /dev/null
@@ -1,16 +0,0 @@
-from Products.CMFCore.permissions import setDefaultRoles
-
-AddGroups = 'Add Groups'
-setDefaultRoles(AddGroups, ('Manager',))
-
-ManageGroups = 'Manage Groups'
-setDefaultRoles(ManageGroups, ('Manager',))
-
-ViewGroups = 'View Groups'
-setDefaultRoles(ViewGroups, ('Manager', 'Owner', 'Member'))
-
-DeleteGroups = 'Delete Groups'
-setDefaultRoles(DeleteGroups, ('Manager', ))
-
-SetGroupOwnership = 'Set Group Ownership'
-setDefaultRoles(SetGroupOwnership, ('Manager', 'Owner'))
diff --git a/Products/PlonePAS/plugins/__init__.py b/Products/PlonePAS/plugins/__init__.py
deleted file mode 100644
index 4287ca8..0000000
--- a/Products/PlonePAS/plugins/__init__.py
+++ /dev/null
@@ -1 +0,0 @@
-#
\ No newline at end of file
diff --git a/Products/PlonePAS/plugins/autogroup.py b/Products/PlonePAS/plugins/autogroup.py
deleted file mode 100644
index 2f3654e..0000000
--- a/Products/PlonePAS/plugins/autogroup.py
+++ /dev/null
@@ -1,148 +0,0 @@
-from zope.interface import implements
-
-from App.class_init import InitializeClass
-from Products.PluggableAuthService.PropertiedUser import PropertiedUser
-from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
-from Products.PluggableAuthService.interfaces.plugins \
-    import IGroupEnumerationPlugin
-from Products.PluggableAuthService.interfaces.plugins \
-    import IGroupsPlugin, IPropertiesPlugin
-from Products.PlonePAS.interfaces.group import IGroupIntrospection
-
-from Products.PageTemplates.PageTemplateFile import PageTemplateFile
-
-manage_addAutoGroupForm = PageTemplateFile("../zmi/AutoGroupForm", globals())
-
-
-def manage_addAutoGroup(self, id, title='', group='', description='',
-                        RESPONSE=None):
-    """Add an Auto Group plugin."""
-
-    plugin = AutoGroup(id, title, group, description)
-    self._setObject(id, plugin)
-
-    if RESPONSE is not None:
-        return RESPONSE.redirect(
-            "%s/manage_workspace?manage_tabs_message=AutoGroup+plugin+added"
-                % self.absolute_url())
-
-
-class VirtualGroup(PropertiedUser):
-    def __init__(self, id, title='', description=''):
-        super(VirtualGroup, self).__init__(id)
-        self.id = id
-        self.title = title
-        self.description = description
-
-    def getId(self):
-        return self.id
-
-    def getUserName(self):
-        return self.id
-
-    def getName(self):
-        return self.id
-
-    def getMemberIds(self, transitive=1):
-        return []
-
-    def getRolesInContext(self, context):
-        return []
-
-    def getRoles(self):
-        return []
-
-    def allowed(self, object, object_roles=None):
-        return 0
-
-    def getDomains(self):
-        return []
-
-    def isGroup(self):
-        return True
-
-
-class AutoGroup(BasePlugin):
-    meta_type = "Automatic Group Plugin"
-
-    implements(IGroupEnumerationPlugin, IGroupsPlugin, IGroupIntrospection,
-               IPropertiesPlugin)
-
-    _properties = (
-            {'id': 'title',
-             'label': 'Title',
-             'type': 'string',
-             'mode': 'w',
-            },
-            {'id': 'group',
-             'label': 'Group',
-             'type': 'string',
-             'mode': 'w',
-            },
-            {'id': 'description',
-             'label': 'Description',
-             'type': 'string',
-             'mode': 'w',
-            },)
-
-    def __init__(self, id, title='', group=None, description=''):
-        self._setId(id)
-        self.title = title
-        self.group = group
-        self.description = description
-
-    # IGroupEnumerationPlugin implementation
-    def enumerateGroups(self, id=None, exact_match=False, sort_by=None,
-                        max_results=None, **kw):
-        if kw:
-            return []
-
-        if id:
-            id = id.lower()
-            mygroup = self.group.lower()
-
-            if exact_match and id != mygroup:
-                return []
-
-            if not exact_match and id not in mygroup:
-                return []
-
-        return [{'id': self.group,
-                 'groupid': self.group,
-                 'title': self.title,
-                 'pluginid': self.getId()}]
-
-    # IGroupsPlugin implementation
-    def getGroupsForPrincipal(self, principal, request=None):
-        if principal.getUserName() == self.group:
-            return ()
-
-        return (self.group,)
-
-    # IGroupIntrospection implementation
-    def getGroupById(self, group_id):
-        if group_id != self.group:
-            return None
-
-        return VirtualGroup(self.group, title=self.title,
-                            description=self.description)
-
-    def getGroups(self):
-        return [self.getGroupById(id) for id in self.getGroupIds()]
-
-    def getGroupIds(self):
-        return [self.group]
-
-    def getGroupMembers(self, group_id):
-        return ()
-
-    # IPropertiesPlugin:
-    def getPropertiesForUser(self, user, request=None):
-        if user == self.group:
-            return {'title': self.title,
-                    'description': self.description}
-        else:
-            return {}
-
-
-InitializeClass(AutoGroup)
diff --git a/Products/PlonePAS/plugins/cookie_handler.py b/Products/PlonePAS/plugins/cookie_handler.py
deleted file mode 100644
index ee8639a..0000000
--- a/Products/PlonePAS/plugins/cookie_handler.py
+++ /dev/null
@@ -1,105 +0,0 @@
-""" Class: ExtendedCookieAuthHelper
-
-Simply extends the standard CookieAuthHelper provided via regular
-PluggableAuthService but overrides the updateCookie mechanism to
-provide similar functionality as CookieCrumbler does... by giving
-the portal the ability to provide a setAuthCookie method.
-"""
-
-from base64 import encodestring
-from urllib import quote
-
-from zope.interface import implements
-
-from AccessControl.SecurityManagement import getSecurityManager
-from Acquisition import aq_base
-from Acquisition import aq_parent
-from AccessControl.SecurityInfo import ClassSecurityInfo
-from App.class_init import InitializeClass
-from App.special_dtml import DTMLFile
-from Products.PluggableAuthService.plugins.CookieAuthHelper \
-    import CookieAuthHelper as BasePlugin
-from Products.PluggableAuthService.interfaces.authservice \
-        import IPluggableAuthService
-from Products.PluggableAuthService.interfaces.plugins import \
-        ILoginPasswordHostExtractionPlugin, IChallengePlugin,  \
-        ICredentialsUpdatePlugin, ICredentialsResetPlugin
-
-
-def manage_addExtendedCookieAuthHelper(self, id, title='',
-                                       RESPONSE=None, **kw):
-    """Create an instance of a extended cookie auth helper.
-    """
-
-    self = self.this()
-
-    o = ExtendedCookieAuthHelper(id, title, **kw)
-    self._setObject(o.getId(), o)
-    o = getattr(aq_base(self), id)
-
-    if RESPONSE is not None:
-        RESPONSE.redirect('manage_workspace')
-
-manage_addExtendedCookieAuthHelperForm = \
-    DTMLFile("../zmi/ExtendedCookieAuthHelperForm", globals())
-
-
-class ExtendedCookieAuthHelper(BasePlugin):
-    """Multi-plugin which adds ability to override the updating of cookie via
-    a setAuthCookie method/script.
-    """
-
-    meta_type = 'Extended Cookie Auth Helper'
-    security = ClassSecurityInfo()
-
-    implements(ILoginPasswordHostExtractionPlugin, IChallengePlugin,
-               ICredentialsUpdatePlugin, ICredentialsResetPlugin)
-
-    security.declarePrivate('updateCredentials')
-    def updateCredentials(self, request, response, login, new_password):
-        """Override standard updateCredentials method
-        """
-
-        setAuthCookie = getattr(self, 'setAuthCookie', None)
-        if setAuthCookie:
-            cookie_val = encodestring('%s:%s' % (login, new_password))
-            cookie_val = cookie_val.rstrip()
-            setAuthCookie(response, self.cookie_name, quote(cookie_val))
-        else:
-            BasePlugin.updateCredentials(self, request, response, login,
-                                         new_password)
-
-    security.declarePublic('login')
-    def login(self):
-        """Set a cookie and redirect to the url that we tried to
-        authenticate against originally.
-
-        Override standard login method to avoid calling
-        'return response.redirect(came_from)' as there is additional
-        processing to ignore known bad come_from templates at
-        login_next.cpy script.
-        """
-        request = self.REQUEST
-        response = request['RESPONSE']
-
-        password = request.get('__ac_password', '')
-
-        user = getSecurityManager().getUser()
-        login = user.getUserName()
-        user_pas = aq_parent(user)
-
-        if IPluggableAuthService.providedBy(user_pas):
-            # Delegate to the users own PAS if possible
-            user_pas.updateCredentials(request, response, login, password)
-        else:
-            # User does not originate from a PAS user folder, so lets try
-            # to do our own thing.
-            # XXX Perhaps we should do nothing here; test with pure User
-            # Folder!
-            pas_instance = self._getPAS()
-            if pas_instance is not None:
-                pas_instance.updateCredentials(request, response, login,
-                                               password)
-
-
-InitializeClass(ExtendedCookieAuthHelper)
diff --git a/Products/PlonePAS/plugins/crumbler.py b/Products/PlonePAS/plugins/crumbler.py
deleted file mode 100644
index 8173136..0000000
--- a/Products/PlonePAS/plugins/crumbler.py
+++ /dev/null
@@ -1,76 +0,0 @@
-""" Class: CookieCrumblingPlugin
-
-Acts as auth plugin, but injects cookie form credentials as HTTPBasicAuth.
-This allows form logins to fall through to parent user folders.
-
-"""
-from zope.interface import implements
-
-from Acquisition import aq_base
-from AccessControl.SecurityInfo import ClassSecurityInfo
-from App.class_init import InitializeClass
-from App.special_dtml import DTMLFile
-from OFS.Folder import Folder
-
-from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
-from Products.PluggableAuthService.interfaces.plugins import IExtractionPlugin
-
-from Products.CMFCore.CookieCrumbler import manage_addCC
-
-import logging
-logger = logging.getLogger('PlonePAS')
-
-CC_ID = 'cookie_auth'
-
-
-def manage_addCookieCrumblingPlugin(self, id, title='',
-                                    RESPONSE=None, **kw):
-    """
-    Create an instance of a cookie crumbling plugin.
-    """
-    self = self.this()
-
-    o = CookieCrumblingPlugin(id, title, **kw)
-    self._setObject(o.getId(), o)
-    o = getattr(aq_base(self), id)
-
-    manage_addCC(o, CC_ID)
-
-    if RESPONSE is not None:
-        RESPONSE.redirect('manage_workspace')
-
-manage_addCookieCrumblingPluginForm = \
-    DTMLFile("../zmi/CookieCrumblingPluginForm", globals())
-
-
-class CookieCrumblingPlugin(Folder, BasePlugin):
-    """Multi-plugin for injecting HTTP Basic Authentication
-    credentials from form credentials.
-    """
-    meta_type = 'Cookie Crumbling Plugin'
-
-    security = ClassSecurityInfo()
-
-    implements(IExtractionPlugin)
-
-    def __init__(self, id, title=None):
-        self._setId(id)
-        self.title = title
-
-    def _getCC(self):
-        return getattr(aq_base(self), CC_ID, None)
-
-    security.declarePrivate('extractCredentials')
-    def extractCredentials(self, request):
-        """ Extract basic auth credentials from 'request'.
-        """
-
-        try:
-            self._getCC().modifyRequest(request, request.RESPONSE)
-
-        except Exception, e:
-            logger.error("PlonePAS error: %s", e, exc_info=1)
-
-        return {}
-
-InitializeClass(CookieCrumblingPlugin)
diff --git a/Products/PlonePAS/plugins/group.py b/Products/PlonePAS/plugins/group.py
deleted file mode 100644
index 79d08de..0000000
--- a/Products/PlonePAS/plugins/group.py
+++ /dev/null
@@ -1,296 +0,0 @@
-"""
-ZODB Group Implementation with basic introspection and
-management (ie. rw) capabilities.
-
-"""
-
-import logging
-from BTrees.OOBTree import OOBTree, OOSet
-from App.special_dtml import DTMLFile
-from App.class_init import InitializeClass
-from AccessControl import ClassSecurityInfo
-
-from zope.interface import implements
-
-from Products.PluggableAuthService.PluggableAuthService \
-    import _SWALLOWABLE_PLUGIN_EXCEPTIONS
-from Products.PluggableAuthService.plugins.ZODBGroupManager \
-    import ZODBGroupManager
-from Products.PluggableAuthService.interfaces.plugins \
-    import IGroupEnumerationPlugin
-from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
-from Products.PluggableAuthService.interfaces.plugins import IRolesPlugin
-from Products.PluggableAuthService.utils import createViewName
-
-from Products.PlonePAS.interfaces.group \
-    import IGroupManagement, IGroupIntrospection
-from Products.PlonePAS.interfaces.capabilities import IGroupCapability
-from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
-from ufactory import PloneUser
-
-manage_addGroupManagerForm = DTMLFile("../zmi/GroupManagerForm", globals())
-logger = logging.getLogger('PlonePAS')
-
-
-def manage_addGroupManager(self, id, title='', RESPONSE=None):
-    """
-    Add a zodb group manager with management and introspection
-    capabilities to pas.
-    """
-    grum = GroupManager(id, title)
-
-    self._setObject(grum.getId(), grum)
-
-    if RESPONSE is not None:
-        return RESPONSE.redirect('manage_workspace')
-
-
-class GroupManager(ZODBGroupManager):
-
-    meta_type = "Group Manager"
-    security = ClassSecurityInfo()
-
-    implements(IGroupManagement, IGroupIntrospection, IGroupCapability,
-               IDeleteCapability)
-
-    def __init__(self, *args, **kw):
-        ZODBGroupManager.__init__(self, *args, **kw)
-        # reverse index of groups->principal
-        self._group_principal_map = OOBTree()
-
-    #################################
-    # overrides to ease group principal lookups for introspection api
-
-    def addGroup(self, group_id, *args, **kw):
-        ZODBGroupManager.addGroup(self, group_id, *args, **kw)
-        self._group_principal_map[group_id] = OOSet()
-        return True
-
-    def removeGroup(self, group_id):
-        ZODBGroupManager.removeGroup(self, group_id)
-        del self._group_principal_map[group_id]
-        return True
-
-    def addPrincipalToGroup(self, principal_id, group_id):
-        ZODBGroupManager.addPrincipalToGroup(self, principal_id, group_id)
-        self._group_principal_map[group_id].insert(principal_id)
-        return True
-
-    def removePrincipalFromGroup(self, principal_id, group_id):
-        already = ZODBGroupManager.removePrincipalFromGroup(self, principal_id,
-                                                            group_id)
-        if already:
-            self._group_principal_map[group_id].remove(principal_id)
-        return True
-
-    #################################
-    # overrides for api matching/massage
-
-    def updateGroup(self, group_id, title=None, description=None):
-        ZODBGroupManager.updateGroup(self, group_id, title=title,
-                                     description=description)
-        return True
-
-    #################################
-    # introspection interface
-
-    def getGroupById(self, group_id, default=None):
-        plugins = self._getPAS()._getOb('plugins')
-        title = None
-        if group_id not in self.getGroupIds():
-            return default
-
-        return self._findGroup(plugins, group_id, title)
-
-    def getGroups(self):
-        return map(self.getGroupById, self.getGroupIds())
-
-    def getGroupIds(self):
-        return self.listGroupIds()
-
-    def getGroupMembers(self, group_id):
-        return tuple(self._group_principal_map.get(group_id, ()))
-
-    #################################
-    # capabilties interface impls.
-
-    security.declarePublic('allowDeletePrincipal')
-    def allowDeletePrincipal(self, principal_id):
-        """True iff this plugin can delete a certain group.
-        This is true if this plugin manages the group.
-        """
-        if self._groups.get(principal_id) is not None:
-            return 1
-        return 0
-
-    def getGroupInfo(self, group_id):
-        """Over-ride parent to not explode when getting group info dict by
-        group id."""
-        return self._groups.get(group_id, None)
-
-    def allowGroupAdd(self, user_id, group_id):
-        """True iff this plugin will allow adding a certain user to a
-        certain group."""
-        present = self.getGroupInfo(group_id)
-        # if we have a group, we can add users to it
-        # slightly naive, but should be okay.
-        if present:
-            return 1
-
-        return 0
-
-    def allowGroupRemove(self, user_id, group_id):
-        """True iff this plugin will allow removing a certain user from a
-        certain group."""
-        present = self.getGroupInfo(group_id)
-        # if we don't have a group, we can't do anything
-        if not present:
-            return 0
-
-        group_members = self.getGroupMembers(group_id)
-        if user_id in group_members:
-            return 1
-        return 0
-
-    #################################
-    # group wrapping mechanics
-
-    security.declarePrivate('_createGroup')
-    def _createGroup(self, plugins, group_id, name):
-        """ Create group object. For users, this can be done with a
-        plugin, but I don't care to define one for that now. Just uses
-        PloneGroup.  But, the code's still here, just commented out.
-        This method based on PluggableAuthervice._createUser
-        """
-        return PloneGroup(group_id, name).__of__(self)
-
-    security.declarePrivate('_findGroup')
-    def _findGroup(self, plugins, group_id, title=None, request=None):
-        """ group_id -> decorated_group
-        This method based on PluggableAuthService._findGroup
-        """
-
-        view_name = '_findGroup-%s' % group_id
-        keywords = {'group_id': group_id, 'title': title}
-
-        group = self._createGroup(plugins, group_id, title)
-
-        propfinders = plugins.listPlugins(IPropertiesPlugin)
-        for propfinder_id, propfinder in propfinders:
-
-            data = propfinder.getPropertiesForUser(group, request)
-            if data:
-                group.addPropertysheet(propfinder_id, data)
-
-        groups = self._getPAS()._getGroupsForPrincipal(group, request,
-                                                       plugins=plugins)
-        group._addGroups(groups)
-
-        rolemakers = plugins.listPlugins(IRolesPlugin)
-
-        for rolemaker_id, rolemaker in rolemakers:
-            roles = rolemaker.getRolesForPrincipal(group, request)
-            if roles:
-                group._addRoles(roles)
-
-        group._addRoles(['Authenticated'])
-
-        return group.__of__(self)
-
-    security.declarePrivate('_verifyGroup')
-    def _verifyGroup(self, plugins, group_id=None, title=None):
-
-        """ group_id -> boolean
-        This method based on PluggableAuthService._verifyUser
-        """
-        criteria = {}
-
-        if group_id is not None:
-            criteria['id'] = group_id
-            criteria['exact_match'] = True
-
-        if title is not None:
-            criteria['title'] = title
-
-        if criteria:
-            view_name = createViewName('_verifyGroup', group_id)
-            enumerators = plugins.listPlugins(IGroupEnumerationPlugin)
-
-            for enumerator_id, enumerator in enumerators:
-                try:
-                    info = enumerator.enumerateGroups(**criteria)
-
-                    if info:
-                        return info[0]['id']
-
-                except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-                    logger.info(
-                       'PluggableAuthService: GroupEnumerationPlugin %s error',
-                       enumerator_id, exc_info=1)
-
-        return 0
-
-
-InitializeClass(GroupManager)
-
-
-class PloneGroup(PloneUser):
-    """Plone expects a user to come, with approximately the same
-    behavior as a user.
-    """
-
-    security = ClassSecurityInfo()
-    _isGroup = True
-
-    def getId(self, unprefixed=None):
-        """ -> user ID
-        Modified to accept silly GRUF param.
-        """
-        return self._id
-
-    security.declarePrivate("getMemberIds")
-    def getMemberIds(self, transitive=1):
-        """Return member ids of this group, including or not
-        transitive groups.
-        """
-        # acquired from the groups_source
-        plugins = self._getPAS().plugins
-        introspectors = plugins.listPlugins(IGroupIntrospection)
-        members = []
-        for iid, introspector in introspectors:
-            try:
-                members.extend(
-                    list(introspector.getGroupMembers(self.getId())))
-            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-                logger.info(
-                    'PluggableAuthService: getGroupMembers %s error',
-                    iid, exc_info=1)
-
-        return members
-
-
-    security.declarePublic('addMember')
-    def addMember(self, id):
-        """Add the existing member with the given id to the group
-        """
-        self.addPrincipalToGroup(id, self.getId())
-
-    security.declarePublic('removeMember')
-    def removeMember(self, id):
-        """Remove the member with the provided id from the group.
-        """
-        self.removePrincipalFromGroup(id, self.getId())
-
-    security.declarePublic('getRolesInContext')
-    def getRolesInContext(self, object):
-        """Since groups can't actually log in, do nothing.
-        """
-        return []
-
-    security.declarePublic('allowed')
-    def allowed(self, object, object_roles=None):
-        """Since groups can't actually log in, do nothing.
-        """
-        return 0
-
-InitializeClass(PloneGroup)
diff --git a/Products/PlonePAS/plugins/local_role.py b/Products/PlonePAS/plugins/local_role.py
deleted file mode 100644
index 10cac29..0000000
--- a/Products/PlonePAS/plugins/local_role.py
+++ /dev/null
@@ -1,190 +0,0 @@
-"""
-A Local Roles Plugin Implementation that respects Black Listing markers.
-
-ie. containers/objects which denote that they do not wish to acquire local
-roles from their containment structure.
-
-"""
-
-from AccessControl import ClassSecurityInfo
-from Acquisition import aq_inner, aq_parent
-from App.class_init import InitializeClass
-from App.special_dtml import DTMLFile
-
-from zope.interface import implements
-
-from Products.PluggableAuthService.plugins.LocalRolePlugin \
-    import LocalRolePlugin
-from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
-
-
-def manage_addLocalRolesManager(dispatcher, id, title=None, RESPONSE=None):
-    """
-    add a local roles manager
-    """
-    lrm = LocalRolesManager(id, title)
-    dispatcher._setObject(lrm.getId(), lrm)
-
-    if RESPONSE is not None:
-        RESPONSE.redirect('manage_workspace')
-
-manage_addLocalRolesManagerForm = \
-    DTMLFile('../zmi/LocalRolesManagerForm', globals())
-
-
-class LocalRolesManager(LocalRolePlugin):
-    """Class incorporating local role storage with
-    PlonePAS-specific local role permission checking.
-    """
-
-    meta_type = "Local Roles Manager"
-    security = ClassSecurityInfo()
-
-    implements(ILocalRolesPlugin)
-
-    def __init__(self, id, title=None):
-        self._id = self.id = id
-        self.title = title
-
-    #security.declarePrivate( 'getRolesInContext' )
-    def getRolesInContext(self, user, object):
-        user_id = user.getId()
-        group_ids = user.getGroups()
-
-        principal_ids = list(group_ids)
-        principal_ids.insert(0, user_id)
-
-        local = {}
-        object = aq_inner(object)
-
-        while 1:
-            local_roles = getattr(object, '__ac_local_roles__', None)
-
-            if local_roles and callable(local_roles):
-                local_roles = local_roles()
-
-            if local_roles:
-                dict = local_roles
-
-                for principal_id in principal_ids:
-                    for role in dict.get(principal_id, []):
-                        local[role] = 1
-
-            inner = aq_inner(object)
-            parent = aq_parent(inner)
-
-            if getattr(object, '__ac_local_roles_block__', None):
-                break
-
-            if parent is not None:
-                object = parent
-                continue
-
-            new = getattr(object, 'im_self', None)
-
-            if new is not None:
-                object = aq_inner(new)
-                continue
-
-            break
-
-        return local.keys()
-
-    #security.declarePrivate( 'checkLocalRolesAllowed' )
-    def checkLocalRolesAllowed(self, user, object, object_roles):
-        # Still have not found a match, so check local roles. We do
-        # this manually rather than call getRolesInContext so that
-        # we can incur only the overhead required to find a match.
-        inner_obj = aq_inner(object)
-        user_id = user.getId()
-        group_ids = user.getGroups()
-
-        principal_ids = list(group_ids)
-        principal_ids.insert(0, user_id)
-
-        while 1:
-
-            local_roles = getattr(inner_obj, '__ac_local_roles__', None)
-
-            if local_roles and callable(local_roles):
-                local_roles = local_roles()
-
-            if local_roles:
-                dict = local_roles
-
-                for principal_id in principal_ids:
-                    local_roles = dict.get(principal_id, [])
-
-                    # local_roles is empty most of the time, where as
-                    # object_roles is usually not.
-                    if not local_roles:
-                        continue
-
-                    for role in object_roles:
-                        if role in local_roles:
-                            if user._check_context(object):
-                                return 1
-                            return 0
-
-            inner = aq_inner(inner_obj)
-            parent = aq_parent(inner)
-
-            if getattr(inner_obj, '__ac_local_roles_block__', None):
-                break
-
-            if parent is not None:
-                inner_obj = parent
-                continue
-
-            new = getattr(inner_obj, 'im_self', None)
-
-            if new is not None:
-                inner_obj = aq_inner(new)
-                continue
-
-            break
-
-        return None
-
-    def getAllLocalRolesInContext(self, context):
-        roles = {}
-        object = aq_inner(context)
-
-        while True:
-
-            local_roles = getattr(object, '__ac_local_roles__', None)
-
-            if local_roles and callable(local_roles):
-                local_roles = local_roles()
-
-            if local_roles:
-
-                dict = local_roles
-
-                for principal, localroles in dict.items():
-                    if not principal in roles:
-                        roles[principal] = set()
-
-                    roles[principal].update(localroles)
-
-            inner = aq_inner(object)
-            parent = aq_parent(inner)
-
-            if getattr(object, '__ac_local_roles_block__', None):
-                break
-
-            if parent is not None:
-                object = parent
-                continue
-
-            new = getattr(object, 'im_self', None)
-
-            if new is not None:
-                object = aq_inner(new)
-                continue
-
-            break
-
-        return roles
-
-InitializeClass(LocalRolesManager)
diff --git a/Products/PlonePAS/plugins/passwordpolicy.py b/Products/PlonePAS/plugins/passwordpolicy.py
deleted file mode 100644
index 4d940c4..0000000
--- a/Products/PlonePAS/plugins/passwordpolicy.py
+++ /dev/null
@@ -1,71 +0,0 @@
-"""
-Password Validation plugin (IValidationPlugin)
-Mutable Property Provider
-"""
-import copy
-
-from zope.interface import implements
-from AccessControl import ClassSecurityInfo
-from App.class_init import InitializeClass
-from BTrees.OOBTree import OOBTree
-from ZODB.PersistentMapping import PersistentMapping
-
-from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
-from Products.PluggableAuthService.interfaces.plugins import IValidationPlugin
-from zope.i18nmessageid import MessageFactory
-
-_ = MessageFactory('plone')
-
-from Products.PageTemplates.PageTemplateFile import PageTemplateFile
-
-manage_addPasswordPolicyForm = PageTemplateFile("../zmi/PasswordPolicyForm", globals())
-
-
-def manage_addPasswordPolicyPlugin(self, id, title='',
-                                          RESPONSE=None, schema=None, **kw):
-    """
-    Create an instance of a password validation plugin.
-    """
-    o = PasswordPolicyPlugin(id, title)
-    self._setObject(o.getId(), o)
-
-    if RESPONSE is not None:
-        return RESPONSE.redirect("%s/manage_workspace?manage_tabs_message=DefaultPasswordPlugin+plugin+added" %
-                self.absolute_url())
-
-class PasswordPolicyPlugin(BasePlugin):
-    """Simple Password Policy to ensure password is 5 chars long.
-    """
-
-    meta_type = 'Default Plone Password Policy'
-
-    implements(IValidationPlugin)
-
-    security = ClassSecurityInfo()
-
-    def __init__(self, id, title=''):
-        """Create a default plone password policy to ensure 5 char passwords
-        """
-        self.id = id
-        self.title = title
-
-    security.declarePrivate('validateUserInfo')
-    def validateUserInfo(self, user, set_id, set_info ):
-        """ See IValidationPlugin. Used to validate password property
-        """
-
-        if not set_info:
-            return []
-        password = set_info.get('password', None)
-        if password is None:
-            return []
-        elif password == '':
-            return [{'id':'password','error':_(u'Minimum 5 characters.')}]
-        elif len(password) < 5:
-            return [{'id':'password','error':
-                _(u'Your password must contain at least 5 characters.')}]
-        else:
-            return []
-
-InitializeClass(PasswordPolicyPlugin)
-
diff --git a/Products/PlonePAS/plugins/property.py b/Products/PlonePAS/plugins/property.py
deleted file mode 100644
index 0bd9963..0000000
--- a/Products/PlonePAS/plugins/property.py
+++ /dev/null
@@ -1,288 +0,0 @@
-"""
-Mutable Property Provider
-"""
-import copy
-
-from zope.interface import implements
-from AccessControl import ClassSecurityInfo
-from App.class_init import InitializeClass
-from App.special_dtml import DTMLFile
-from BTrees.OOBTree import OOBTree
-from ZODB.PersistentMapping import PersistentMapping
-from Products.CMFCore.utils import getToolByName
-
-from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
-from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
-from Products.PluggableAuthService.interfaces.plugins \
-    import IUserEnumerationPlugin
-from Products.PluggableAuthService.UserPropertySheet import _guessSchema
-from Products.PlonePAS.sheet import MutablePropertySheet, validateValue
-from Products.PlonePAS.interfaces.plugins import IMutablePropertiesPlugin
-from Products.PlonePAS.utils import safe_unicode
-from zope.i18nmessageid import MessageFactory
-
-_ = MessageFactory('plone')
-
-
-def manage_addZODBMutablePropertyProvider(self, id, title='',
-                                          RESPONSE=None, schema=None, **kw):
-    """
-    Create an instance of a mutable property manager.
-    """
-    o = ZODBMutablePropertyProvider(id, title, schema, **kw)
-    self._setObject(o.getId(), o)
-
-    if RESPONSE is not None:
-        RESPONSE.redirect('manage_workspace')
-
-manage_addZODBMutablePropertyProviderForm = DTMLFile(
-    "../zmi/MutablePropertyProviderForm", globals())
-
-
-def isStringType(data):
-    return isinstance(data, str) or isinstance(data, unicode)
-
-
-class ZODBMutablePropertyProvider(BasePlugin):
-    """Storage for mutable properties in the ZODB for users/groups.
-
-    API sounds like it's only for users, but groups work as well.
-    """
-
-    meta_type = 'ZODB Mutable Property Provider'
-
-    implements(IPropertiesPlugin, IUserEnumerationPlugin,
-               IMutablePropertiesPlugin)
-
-    security = ClassSecurityInfo()
-
-    def __init__(self, id, title='', schema=None, **kw):
-        """Create in-ZODB mutable property provider.
-
-        Provide a schema either as a list of (name,type,value) tuples
-        in the 'schema' parameter or as a series of keyword parameters
-        'name=value'. Types will be guessed in this case.
-
-        The 'value' is meant as the default value, and will be used
-        unless the user provides data.
-
-        If no schema is provided by constructor, the properties of the
-        portal_memberdata object will be used.
-
-        Types available: string, text, boolean, int, long, float, lines, date
-        """
-        self.id = id
-        self.title = title
-        self._storage = OOBTree()
-
-        # calculate schema and default values
-        defaultvalues = {}
-        if not schema and not kw:
-            schema = ()
-        elif not schema and kw:
-            schema = _guessSchema(kw)
-            defaultvalues = kw
-        else:
-            valuetuples = [(name, value) for name, type, value in schema]
-            schema = [(name, type) for name, type, value in schema]
-            for name, value in valuetuples:
-                defaultvalues[name] = value
-        self._schema = tuple(schema)
-        self._defaultvalues = defaultvalues
-
-    def _getSchema(self, isgroup=None):
-        # this could probably stand to be cached
-        datatool = isgroup and "portal_groupdata" or "portal_memberdata"
-
-        schema = self._schema
-        if not schema:
-            # if no schema is provided, use portal_memberdata properties
-            schema = ()
-            mdtool = getToolByName(self, datatool, None)
-            # Don't fail badly if tool is not available.
-            if mdtool is not None:
-                mdschema = mdtool.propertyMap()
-                schema = [(elt['id'], elt['type']) for elt in mdschema]
-        return schema
-
-    def _getDefaultValues(self, isgroup=None):
-        """Returns a dictionary mapping of property names to default values.
-        Defaults to portal_*data tool if necessary.
-        """
-        datatool = isgroup and "portal_groupdata" or "portal_memberdata"
-
-        defaultvalues = self._defaultvalues
-        if not self._schema:
-            # if no schema is provided, use portal_*data properties
-            defaultvalues = {}
-            mdtool = getToolByName(self, datatool, None)
-            # Don't fail badly if tool is not available.
-            if mdtool is not None:
-                # we rely on propertyMap and propertyItems mapping
-                mdvalues = mdtool.propertyItems()
-                for name, value in mdvalues:
-                    # For selection types the default value is the name of a
-                    # method which returns the possible values. There is no way
-                    # to set a default value for those types.
-                    ptype = mdtool.getPropertyType(name)
-                    if ptype == "selection":
-                        defaultvalues[name] = ""
-                    elif ptype == "multiple selection":
-                        defaultvalues[name] = []
-                    else:
-                        defaultvalues[name] = value
-
-            # ALERT! if someone gives their *_data tool a title, and want a
-            #        title as a property of the user/group (and groups do by
-            #        default) we don't want them all to have this title, since
-            #        a title is used in the UI if it exists
-            if defaultvalues.get("title"):
-                defaultvalues["title"] = ""
-        return defaultvalues
-
-    security.declarePrivate('getPropertiesForUser')
-    def getPropertiesForUser(self, user, request=None):
-        """Get property values for a user or group.
-        Returns a dictionary of values or a PropertySheet.
-
-        This implementation will always return a MutablePropertySheet.
-
-        NOTE: Must always return something, or else the property sheet
-        won't get created and this will screw up portal_memberdata.
-        """
-        isGroup = getattr(user, 'isGroup', lambda: None)()
-
-        data = self._storage.get(user.getId())
-        defaults = self._getDefaultValues(isGroup)
-
-        # provide default values where missing
-        if not data:
-            data = {}
-        for key, val in defaults.items():
-            if not key in data:
-                data[key] = val
-
-        return MutablePropertySheet(self.id,
-                                    schema=self._getSchema(isGroup), **data)
-
-    security.declarePrivate('setPropertiesForUser')
-    def setPropertiesForUser(self, user, propertysheet):
-        """Set the properties of a user or group based on the contents of a
-        property sheet.
-        """
-        isGroup = getattr(user, 'isGroup', lambda: None)()
-
-        properties = dict(propertysheet.propertyItems())
-
-        for name, property_type in self._getSchema(isGroup) or ():
-            if (name in properties and not
-                validateValue(property_type, properties[name])):
-                raise ValueError('Invalid value: %s does not conform '
-                                   'to %s' % (name, property_type))
-
-        allowed_prop_keys = [pn for pn, pt in self._getSchema(isGroup) or ()]
-        if allowed_prop_keys:
-            prop_names = set(properties.keys()) - set(allowed_prop_keys)
-            if prop_names:
-                raise ValueError('Unknown Properties: %r' % prop_names)
-
-        userid = user.getId()
-        userprops = self._storage.get(userid)
-        properties.update({'isGroup': isGroup})
-        if userprops is not None:
-            userprops.update(properties)
-            # notify persistence machinery of change
-            self._storage[userid] = self._storage[userid]
-        else:
-            self._storage.insert(user.getId(), properties)
-
-    security.declarePrivate('deleteUser')
-    def deleteUser(self, user_id):
-        """Delete all user properties
-        """
-        # Do nothing if an unknown user_id is given
-        try:
-            del self._storage[user_id]
-        except KeyError:
-            pass
-
-    security.declarePrivate('testMemberData')
-    def testMemberData(self, memberdata, criteria, exact_match=False):
-        """Test if a memberdata matches the search criteria.
-        """
-        for (key, value) in criteria.items():
-            testvalue = memberdata.get(key, None)
-            if testvalue is None:
-                return False
-
-            if isStringType(testvalue):
-                testvalue = safe_unicode(testvalue.lower())
-            if isStringType(value):
-                value = safe_unicode(value.lower())
-
-            if exact_match:
-                if value != testvalue:
-                    return False
-            else:
-                try:
-                    if value not in testvalue:
-                        return False
-                except TypeError:
-                    # Fall back to exact match if we can check for
-                    # sub-component
-                    if value != testvalue:
-                        return False
-
-        return True
-
-    security.declarePrivate('enumerateUsers')
-    def enumerateUsers(self, id=None, login=None,
-                       exact_match=False, **kw):
-        """ See IUserEnumerationPlugin.
-        """
-        plugin_id = self.getId()
-
-        # This plugin can't search for a user by id or login, because there is
-        # no such keys in the storage (data dict in the comprehensive list)
-        # If kw is empty or not, we continue the search.
-        if id is not None or login is not None:
-            return ()
-
-        criteria = copy.copy(kw)
-
-        users = [(user, data) for (user, data) in self._storage.items()
-                    if self.testMemberData(data, criteria, exact_match)
-                        and not data.get('isGroup', False)]
-
-        user_info = [{'id': self.prefix + user_id,
-                      'login': user_id,
-                      'title': data.get('fullname', user_id),
-                      'description': data.get('fullname', user_id),
-                      'email': data.get('email', ''),
-                      'pluginid': plugin_id} for (user_id, data) in users]
-
-        return tuple(user_info)
-
-    def updateUser(self, user_id, login_name):
-        """ Update the login name of the user with id user_id.
-
-        This is a new part of the IUserEnumerationPlugin interface, but
-        not interesting for us.
-        """
-        pass
-
-
-    def updateEveryLoginName(self, quit_on_first_error=True):
-        """Update login names of all users to their canonical value.
-
-        This is a new part of the IUserEnumerationPlugin interface, but
-        not interesting for us.
-        """
-        pass
-
-
-InitializeClass(ZODBMutablePropertyProvider)
-
-
-class PersistentProperties(PersistentMapping):
-    pass
diff --git a/Products/PlonePAS/plugins/role.py b/Products/PlonePAS/plugins/role.py
deleted file mode 100644
index 65142ca..0000000
--- a/Products/PlonePAS/plugins/role.py
+++ /dev/null
@@ -1,161 +0,0 @@
-"""
-group aware role manager, returns roles assigned to group a principal
-is a member of, in addition to the explicit roles assigned directly
-to the principal.
-
-"""
-
-from AccessControl import ClassSecurityInfo
-from AccessControl.requestmethod import postonly
-from Acquisition import aq_parent, aq_inner, aq_get
-from App.class_init import InitializeClass
-from App.special_dtml import DTMLFile
-
-from zope.interface import implements
-
-from Products.PluggableAuthService.plugins.ZODBRoleManager \
-     import ZODBRoleManager
-
-from Products.PlonePAS.utils import getGroupsForPrincipal
-from Products.PlonePAS.interfaces.capabilities import IAssignRoleCapability
-from Products.PluggableAuthService.permissions import ManageUsers
-
-
-def manage_addGroupAwareRoleManager(self, id, title='', RESPONSE=None):
-    """
-    this is a doc string
-    """
-    garm = GroupAwareRoleManager(id, title)
-    self._setObject(garm.getId(), garm)
-
-    if RESPONSE is not None:
-        RESPONSE.redirect('manage_workspace')
-
-manage_addGroupAwareRoleManagerForm = DTMLFile(
-    '../zmi/GroupAwareRoleManagerForm', globals())
-
-
-class GroupAwareRoleManager(ZODBRoleManager):
-
-    meta_type = "Group Aware Role Manager"
-    security = ClassSecurityInfo()
-    implements(IAssignRoleCapability)
-
-    def updateRolesList(self):
-        role_holder = aq_parent(aq_inner(self._getPAS()))
-        for role in getattr(role_holder, '__ac_roles__', ()):
-            if role not in ('Anonymous', 'Authenticated') and \
-                    role not in self._roles:
-                try:
-                    self.addRole(role)
-                except KeyError:
-                    pass
-
-    # don't blow up if manager already exists; mostly for ZopeVersionControl
-    def manage_afterAdd(self, item, container):
-        try:
-            self.addRole('Manager')
-        except KeyError:
-            pass
-
-        if item is self:
-            self.updateRolesList()
-
-    security.declareProtected(ManageUsers, 'assignRoleToPrincipal')
-    def assignRoleToPrincipal(self, role_id, principal_id, REQUEST=None):
-        try:
-            return ZODBRoleManager.assignRoleToPrincipal(
-                                        self, role_id, principal_id)
-        except KeyError:
-            # Lazily update our roles list and try again
-            self.updateRolesList()
-            return ZODBRoleManager.assignRoleToPrincipal(
-                                        self, role_id, principal_id)
-
-    security.declareProtected(ManageUsers, 'assignRolesToPrincipal')
-    def assignRolesToPrincipal(self, roles, principal_id, REQUEST=None):
-        """ Assign a specific set of roles, and only those roles, to a
-        principal.
-
-        o no return value
-
-        o Raise KeyError if a role_id is unknown.
-        """
-        for role_id in roles:
-            if role_id not in ('Authenticated', 'Anonymous', 'Owner'):
-                try:
-                    # raise KeyError if unknown!
-                    role_info = self._roles[role_id]
-                except KeyError:
-                    # Lazily update our roles list and try again
-                    self.updateRolesList()
-                    if role_id in self._roles:
-                        # check if this role is managed by this plugin, and
-                        # set it
-                        role_info = self._roles[role_id]
-
-        self._principal_roles[principal_id] = tuple(roles)
-
-    assignRolesToPrincipal = postonly(assignRolesToPrincipal)
-
-    security.declarePrivate('getRolesForPrincipal')
-    def getRolesForPrincipal(self, principal, request=None):
-        """ See IRolesPlugin.
-        """
-        roles = set([])
-        principal_ids = set([])
-        # Some services need to determine the roles obtained from groups
-        # while excluding the directly assigned roles.  In this case
-        # '__ignore_direct_roles__' = True should be pushed in the request.
-        request = aq_get(self, 'REQUEST', None)
-        if request is None or \
-            not request.get('__ignore_direct_roles__', False):
-            principal_ids.add(principal.getId())
-
-        # Some services may need the real roles of an user but **not**
-        # the ones he got through his groups. In this case, the
-        # '__ignore_group_roles__'= True should be previously pushed
-        # in the request.
-        plugins = self._getPAS()['plugins']
-        if request is None or \
-            not request.get('__ignore_group_roles__', False):
-            principal_ids.update(getGroupsForPrincipal(principal, plugins,
-                                                       request))
-        for pid in principal_ids:
-            roles.update(self._principal_roles.get(pid, ()))
-        return tuple(roles)
-
-    ## implement IAssignRoleCapability
-
-    def allowRoleAssign(self, user_id, role_id):
-        """True iff this plugin will allow assigning a certain user a
-        certain role.
-
-        Note that at least currently this only checks if the role_id
-        exists.  If it exists, this method returns True.  Nothing is
-        done with the user_id parameter.  This might be wrong.  See
-        http://dev.plone.org/plone/ticket/7762
-        """
-        present = self.getRoleInfo(role_id)
-        if present:
-            # if we have a role, we can assign it
-            # slightly naive, but should be okay.
-            return 1
-
-        return 0
-
-    def listRoleIds(self):
-        self.updateRolesList()
-        return ZODBRoleManager.listRoleIds(self)
-
-    def listRoleInfo(self):
-        self.updateRolesList()
-        return ZODBRoleManager.listRoleInfo(self)
-
-    def getRoleInfo(self, role_id):
-        if role_id not in self._roles:
-            self.updateRolesList()
-        return ZODBRoleManager.getRoleInfo(self, role_id)
-
-
-InitializeClass(GroupAwareRoleManager)
diff --git a/Products/PlonePAS/plugins/ufactory.py b/Products/PlonePAS/plugins/ufactory.py
deleted file mode 100644
index 2a27bdf..0000000
--- a/Products/PlonePAS/plugins/ufactory.py
+++ /dev/null
@@ -1,240 +0,0 @@
-from zope.interface import implements
-
-from AccessControl import ClassSecurityInfo
-from AccessControl.PermissionRole import _what_not_even_god_should_do
-from App.class_init import InitializeClass
-from App.special_dtml import DTMLFile
-
-from Products.PluggableAuthService.PropertiedUser import PropertiedUser
-from Products.PluggableAuthService.UserPropertySheet import UserPropertySheet
-from Products.PluggableAuthService.interfaces.plugins import IUserFactoryPlugin
-from Products.PluggableAuthService.interfaces.propertysheets \
-    import IPropertySheet
-from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
-from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
-
-from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
-from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
-try:
-    from collections import OrderedDict
-except ImportError:
-    from ordereddict import OrderedDict
-
-manage_addPloneUserFactoryForm = DTMLFile('../zmi/PloneUserFactoryForm',
-                                          globals())
-
-_marker = object()
-
-
-def manage_addPloneUserFactory(self, id, title='', RESPONSE=None):
-    """
-    Add a plone user factory
-    """
-
-    puf = PloneUserFactory(id, title)
-    self._setObject(puf.getId(), puf)
-
-    if RESPONSE is not None:
-        return RESPONSE.redirect('manage_workspace')
-
-
-class PloneUserFactory(BasePlugin):
-
-    security = ClassSecurityInfo()
-    meta_type = 'Plone User Factory'
-    implements(IUserFactoryPlugin)
-
-    def __init__(self, id, title=''):
-        self.id = id
-        self.title = title or self.meta_type
-
-    security.declarePrivate('createUser')
-    def createUser(self, user_id, name):
-        return PloneUser(user_id, name)
-
-
-InitializeClass(PloneUserFactory)
-
-
-class PloneUser(PropertiedUser):
-
-    security = ClassSecurityInfo()
-
-    #################################
-    # GRUF API
-    _isGroup = False
-
-    def __init__(self, id, login=None):
-        super(PloneUser, self).__init__(id, login)
-        self._propertysheets = OrderedDict()
-
-    def _getPAS(self):
-        # XXX This is not very optimal *at all*
-        return self.acl_users
-
-    def _getPlugins(self):
-        # XXX This is not very optimal *at all*
-        return self._getPAS().plugins
-
-    security.declarePublic('isGroup')
-    def isGroup(self):
-        """Return 1 if this user is a group abstraction"""
-        return self._isGroup
-
-    security.declarePublic('getName')
-    def getName(self):
-        """Get user's or group's name.
-        This is the id. PAS doesn't do prefixes and such like GRUF.
-        """
-        return self.getId()
-
-    security.declarePublic('getName')
-    def getUserId(self):
-        """Get user's or group's name.
-        This is the id. PAS doesn't do prefixes and such like GRUF.
-        """
-        return self.getId()
-
-    security.declarePublic('getGroupNames')
-    def getGroupNames(self):
-        """Return ids of this user's groups. GRUF compat."""
-        return self.getGroups()
-
-    security.declarePublic('getGroupIds')
-    getGroupIds = getGroupNames
-
-    #################################
-    # acquisition aware
-
-    security.declarePublic('getPropertysheet')
-    def getPropertysheet(self, id):
-        """ -> propertysheet (wrapped if supported)
-        """
-        sheet = self._propertysheets[id]
-        try:
-            return sheet.__of__(self)
-        except AttributeError:
-            return sheet
-
-    security.declarePrivate('addPropertysheet')
-    def addPropertysheet(self, id, data):
-        """ -> add a prop sheet, given data which is either
-        a property sheet or a raw mapping.
-        """
-        if IPropertySheet.providedBy(data):
-            sheet = data
-        else:
-            sheet = UserPropertySheet(id, **data)
-
-        if self._propertysheets.get(id) is not None:
-            raise KeyError('Duplicate property sheet: %s' % id)
-
-        self._propertysheets[id] = sheet
-
-    def _getPropertyPlugins(self):
-        return self._getPAS().plugins.listPlugins(IPropertiesPlugin)
-
-    security.declarePrivate('getOrderedPropertySheets')
-    def getOrderedPropertySheets(self):
-        return self._propertysheets.values()
-
-    #################################
-    # local roles plugin type delegation
-
-    def _getLocalRolesPlugins(self):
-        return self._getPAS().plugins.listPlugins(ILocalRolesPlugin)
-
-    def getRolesInContext(self, object):
-        lrmanagers = self._getLocalRolesPlugins()
-        roles = set([])
-        for lrid, lrmanager in lrmanagers:
-            roles.update(lrmanager.getRolesInContext(self, object))
-        roles.update(self.getRoles())
-        return list(roles)
-
-    def allowed(self, object, object_roles=None):
-        if object_roles is _what_not_even_god_should_do:
-            return 0
-
-        # Short-circuit the common case of anonymous access.
-        if object_roles is None or 'Anonymous' in object_roles:
-            return 1
-
-        # Provide short-cut access if object is protected by 'Authenticated'
-        # role and user is not nobody
-        if 'Authenticated' in object_roles and (
-            self.getUserName() != 'Anonymous User'):
-            return 1
-
-        # Check for ancient role data up front, convert if found.
-        # This should almost never happen, and should probably be
-        # deprecated at some point.
-        if 'Shared' in object_roles:
-            object_roles = self._shared_roles(object)
-            if object_roles is None or 'Anonymous' in object_roles:
-                return 1
-
-        # Check for a role match with the normal roles given to
-        # the user, then with local roles only if necessary. We
-        # want to avoid as much overhead as possible.
-        user_roles = self.getRoles()
-        for role in object_roles:
-            if role in user_roles:
-                if self._check_context(object):
-                    return 1
-                return None
-
-        # check for local roles
-        lrmanagers = self._getLocalRolesPlugins()
-
-        for lrid, lrm in lrmanagers:
-            allowed = lrm.checkLocalRolesAllowed(self, object, object_roles)
-            # return values
-            # 0, 1, None
-            # - 1 success
-            # - 0 object context violation
-            # - None - failure
-            if allowed is None:
-                continue
-            return allowed
-        return None
-
-    def setProperties(self, properties=None, **kw):
-        """ Set properties on a given user.
-
-        Accepts either keyword arguments or a mapping for the ``properties``
-        argument. The ``properties`` argument will take precedence over
-        keyword arguments if both are provided; no merging will occur.
-        """
-        if properties is None:
-            properties = kw
-
-        for sheet in self.getOrderedPropertySheets():
-            if not IMutablePropertySheet.providedBy(sheet):
-                continue
-
-            update = {}
-            for (key, value) in properties.items():
-                if sheet.hasProperty(key):
-                    update[key] = value
-                    del properties[key]
-
-            if update:
-                sheet.setProperties(self, update)
-
-    def getProperty(self, id, default=_marker):
-        for sheet in self.getOrderedPropertySheets():
-            if sheet.hasProperty(id):
-                value = sheet.getProperty(id)
-                if isinstance(value, unicode):
-                    # XXX Temporarily work around the fact that
-                    # property sheets blindly store and return
-                    # unicode. This is sub-optimal and should be
-                    # dealed with at the property sheets level by
-                    # using Zope's converters.
-                    return value.encode('utf-8')
-                return value
-
-        return default
-
-InitializeClass(PloneUser)
diff --git a/Products/PlonePAS/plugins/user.py b/Products/PlonePAS/plugins/user.py
deleted file mode 100644
index bfc65b4..0000000
--- a/Products/PlonePAS/plugins/user.py
+++ /dev/null
@@ -1,131 +0,0 @@
-"""
-ZODB based user manager with introspection and management interfaces.
-"""
-
-from zope.interface import implements
-
-from AccessControl import ClassSecurityInfo, AuthEncoding
-from AccessControl.Permissions import manage_users as ManageUsers
-from App.class_init import InitializeClass
-from App.special_dtml import DTMLFile
-from Products.PluggableAuthService.utils import createViewName
-
-from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
-from Products.PlonePAS.interfaces.capabilities import IPasswordSetCapability
-from Products.PlonePAS.interfaces.plugins import IUserManagement
-from Products.PlonePAS.interfaces.plugins import IUserIntrospection
-
-from Products.PluggableAuthService.plugins.ZODBUserManager import \
-    ZODBUserManager as BasePlugin
-
-manage_addUserManagerForm = DTMLFile('../zmi/UserManagerForm',
-                                          globals())
-
-
-def manage_addUserManager(dispatcher, id, title=None, REQUEST=None):
-    """ Add a UserManager to a Pluggable Auth Service. """
-
-    pum = UserManager(id, title)
-    dispatcher._setObject(pum.getId(), pum)
-
-    if REQUEST is not None:
-        REQUEST['RESPONSE'].redirect(
-            '%s/manage_workspace'
-            '?manage_tabs_message='
-            'UserManager+added.'
-            % dispatcher.absolute_url())
-
-
-class UserManager(BasePlugin):
-    """PAS plugin for managing users. (adds write API)
-    """
-
-    meta_type = 'User Manager'
-    security = ClassSecurityInfo()
-    implements(IUserManagement, IUserIntrospection, IDeleteCapability,
-               IPasswordSetCapability)
-
-    security.declareProtected(ManageUsers, 'addUser')
-    def addUser(self, user_id, login_name, password):
-        """Original ZODBUserManager.addUser, modified to check if
-        incoming password is already encypted.
-
-        This support clean migration from default user source.
-        Should go into PAS.
-        """
-        if self._user_passwords.get(user_id) is not None:
-            raise KeyError('Duplicate user ID: %s' % user_id)
-
-        if self._login_to_userid.get(login_name) is not None:
-            raise KeyError('Duplicate login name: %s' % login_name)
-
-        if not AuthEncoding.is_encrypted(password):
-            password = AuthEncoding.pw_encrypt(password)
-        self._user_passwords[user_id] = password
-        self._login_to_userid[login_name] = user_id
-        self._userid_to_login[user_id] = login_name
-
-        # enumerateUsers return value has changed
-        view_name = createViewName('enumerateUsers')
-        self.ZCacheable_invalidate(view_name=view_name)
-
-    ## User Management interface
-
-    security.declarePrivate('doDeleteUser')
-    def doDeleteUser(self, userid):
-        """Given a user id, delete that user
-        """
-        return self.removeUser(userid)
-
-    security.declarePrivate('doChangeUser')
-    def doChangeUser(self, principal_id, password):
-        """Change a user's password
-        """
-        if self._user_passwords.get(principal_id) is None:
-            raise RuntimeError("User does not exist: %s" % principal_id)
-        self._user_passwords[principal_id] = AuthEncoding.pw_encrypt(password)
-
-    # implement interfaces IDeleteCapability, IPasswordSetCapability
-
-    security.declarePublic('allowDeletePrincipal')
-    def allowDeletePrincipal(self, principal_id):
-        """True iff this plugin can delete a certain user/group.
-        This is true if this plugin manages the user.
-        """
-        if self._user_passwords.get(principal_id) is not None:
-            return 1
-        return 0
-
-    security.declarePublic('allowPasswordSet')
-    def allowPasswordSet(self, principal_id):
-        """True iff this plugin can set the password a certain user.
-        This is true if this plugin manages the user.
-        """
-        return self.allowDeletePrincipal(principal_id)
-
-    ## User Introspection interface
-
-    security.declareProtected(ManageUsers, 'getUserIds')
-    def getUserIds(self):
-        """
-        Return a list of user ids
-        """
-        return self.listUserIds()
-
-    security.declareProtected(ManageUsers, 'getUserNames')
-    def getUserNames(self):
-        """
-        Return a list of usernames
-        """
-        return [x['login_name'] for x in self.listUserInfo()]
-
-    security.declareProtected(ManageUsers, 'getUsers')
-    def getUsers(self):
-        """
-        Return a list of users
-        """
-        uf = self.acl_users
-        return [uf.getUserById(x) for x in self.getUserIds()]
-
-
-InitializeClass(UserManager)
diff --git a/Products/PlonePAS/profiles.zcml b/Products/PlonePAS/profiles.zcml
deleted file mode 100644
index 8410395..0000000
--- a/Products/PlonePAS/profiles.zcml
+++ /dev/null
@@ -1,14 +0,0 @@
-<configure
-    xmlns="http://namespaces.zope.org/zope"
-    xmlns:genericsetup="http://namespaces.zope.org/genericsetup"
-    i18n_domain="plonepas">
-
-  <genericsetup:registerProfile
-      name="PlonePAS"
-      title="PlonePAS"
-      directory="profiles/default"
-      description="Extension profile for default PlonePAS setup."
-      provides="Products.GenericSetup.interfaces.EXTENSION"
-      />
-
-</configure>
diff --git a/Products/PlonePAS/profiles/default/metadata.xml b/Products/PlonePAS/profiles/default/metadata.xml
deleted file mode 100644
index dab4dc0..0000000
--- a/Products/PlonePAS/profiles/default/metadata.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0"?>
-<metadata>
-  <version>4</version>
-</metadata>
diff --git a/Products/PlonePAS/profiles/default/plone-pas.txt b/Products/PlonePAS/profiles/default/plone-pas.txt
deleted file mode 100644
index 9b080f9..0000000
--- a/Products/PlonePAS/profiles/default/plone-pas.txt
+++ /dev/null
@@ -1 +0,0 @@
-The plone-pas step is run if this file is present in the profile
diff --git a/Products/PlonePAS/setuphandlers.py b/Products/PlonePAS/setuphandlers.py
deleted file mode 100644
index 2d1bf37..0000000
--- a/Products/PlonePAS/setuphandlers.py
+++ /dev/null
@@ -1,108 +0,0 @@
-import pkg_resources
-
-from Acquisition import aq_parent
-from Products.CMFCore.utils import getToolByName
-
-from Products.PlonePAS.Extensions.Install import challenge_chooser_setup
-from Products.PlonePAS.Extensions.Install import migrate_root_uf
-from Products.PlonePAS.Extensions.Install import registerPluginTypes
-from Products.PlonePAS.Extensions.Install import setupPlugins
-
-
-def setLoginFormInCookieAuth(context):
-    """Makes sure the cookie auth redirects to 'require_login' instead
-       of 'login_form'."""
-    uf = getattr(context, 'acl_users', None)
-    if uf is None or getattr(uf.aq_base, '_getOb', None) is None:
-        # we have no user folder or it's not a PAS folder, do nothing
-        return
-    cookie_auth = uf._getOb('credentials_cookie_auth', None)
-    if cookie_auth is None:
-        # there's no cookie auth object, do nothing
-        return
-    current_login_form = cookie_auth.getProperty('login_path')
-    if current_login_form != 'login_form':
-        # it's customized already, do nothing
-        return
-    cookie_auth.manage_changeProperties(login_path='require_login')
-
-
-def addRolesToPlugIn(p):
-    """
-    XXX This is horrible.. need to switch PlonePAS to a GenericSetup
-    based install so this doesn't need to happen.
-
-    Have to manually register the roles from the 'rolemap' step
-    with the roles plug-in.
-    """
-    uf = getToolByName(p, 'acl_users')
-    rmanager = uf.portal_role_manager
-    roles = ('Reviewer', 'Member')
-    existing = rmanager.listRoleIds()
-    for role in roles:
-        if role not in existing:
-            rmanager.addRole(role)
-
-
-def setupGroups(site):
-    """
-    Create Plone's default set of groups.
-    """
-    uf = getToolByName(site, 'acl_users')
-    gtool = getToolByName(site, 'portal_groups')
-    if not uf.searchGroups(id='Administrators'):
-        gtool.addGroup('Administrators', title='Administrators',
-                       roles=['Manager'])
-
-    # Add Site Administrators group on Plone 4.1+ only.
-    try:
-        pkg_resources.get_distribution('Products.CMFPlone>=4.1a1')
-    except (pkg_resources.VersionConflict, pkg_resources.DistributionNotFound):
-        pass
-    else:
-        if not uf.searchGroups(id='Site Administrators'):
-            gtool.addGroup('Site Administrators', title='Site Administrators',
-                           roles=['Site Administrator'])
-
-    if not uf.searchGroups(id='Reviewers'):
-        gtool.addGroup('Reviewers', title='Reviewers', roles=['Reviewer'])
-    # if not uf.searchGroups(id='AuthenticatedUsers'):
-    #     gtool.addGroup('Authenticated Users',
-    #                    title='Authenticated Users (Virtual Group)')
-
-
-def installPAS(portal):
-    # Add user folder
-    portal.manage_addProduct['PluggableAuthService'].addPluggableAuthService()
-
-    # Configure Challenge Chooser plugin if available
-    challenge_chooser_setup(portal)
-
-    # A bunch of general configuration settings
-    registerPluginTypes(portal.acl_users)
-    setupPlugins(portal)
-
-    # XXX Why are we doing this?
-    # According to Sidnei, "either cookie or basic auth for a user in the root
-    # folder doesn't work
-    # if it's not a PAS UF when you sign in to Plone. IIRC."
-    # See: http://twitter.com/#!/sidneidasilva/status/14030732112429056
-    # And here's the original commit:
-    # http://dev.plone.org/collective/changeset/10720/PlonePAS/trunk/Extensions/Install.py
-    if aq_parent(portal):
-        migrate_root_uf(portal)
-
-
-def setupPlonePAS(context):
-    """
-    Setup PlonePAS step.
-    """
-    # Only run step if a flag file is present (e.g. not an extension profile)
-    if context.readDataFile('plone-pas.txt') is None:
-        return
-    site = context.getSite()
-    if 'acl_users' not in site:
-        installPAS(site)
-        addRolesToPlugIn(site)
-        setupGroups(site)
-        setLoginFormInCookieAuth(site)
diff --git a/Products/PlonePAS/sheet.py b/Products/PlonePAS/sheet.py
deleted file mode 100644
index 77d4e17..0000000
--- a/Products/PlonePAS/sheet.py
+++ /dev/null
@@ -1,118 +0,0 @@
-"""
-Add Mutable Property Sheets and Schema Mutable Property Sheets to PAS
-
-also a property schema type registry which is extensible.
-
-"""
-
-from types import StringTypes, IntType
-from types import LongType, FloatType, InstanceType
-
-from zope.component import getUtility
-from zope.interface import implements
-
-from DateTime.DateTime import DateTime
-from Products.CMFCore.interfaces import ISiteRoot
-
-from Products.PluggableAuthService.UserPropertySheet import _SequenceTypes
-from Products.PluggableAuthService.UserPropertySheet import UserPropertySheet
-from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
-
-
-class PropertyValueError(ValueError):
-    pass
-
-
-class PropertySchemaTypeMap(object):
-
-    def __init__(self):
-        self.tmap = {}
-        self.tmap_order = []
-
-    def addType(self, type_name, identifier, order=None):
-        self.tmap[type_name] = identifier
-        if order is not None and isinstance(order, int):
-            self.tmap_order.insert(order, type_name)
-        else:
-            self.tmap_order.append(type_name)
-
-    def getTypeFor(self, value):
-        ptypes = [(ptype, self.tmap[ptype]) for ptype in self.tmap_order]
-        for ptype, inspector in ptypes:
-            if inspector(value):
-                return ptype
-        raise TypeError('Invalid property type: %s' % type(value))
-
-    def validate(self, property_type, value):
-        inspector = self.tmap[property_type]
-        return inspector(value)
-
-PropertySchema = PropertySchemaTypeMap()
-PropertySchema.addType('string', lambda x: x is None or type(x) in StringTypes)
-PropertySchema.addType('text', lambda x: x is None or type(x) in StringTypes)
-PropertySchema.addType('boolean', lambda x: 1)  # anything can be boolean
-PropertySchema.addType('int', lambda x:  x is None or type(x) is IntType)
-PropertySchema.addType('long', lambda x:  x is None or type(x) is LongType)
-PropertySchema.addType('float', lambda x:  x is None or type(x) is FloatType)
-PropertySchema.addType('lines',
-                       lambda x:  x is None or type(x) in _SequenceTypes)
-PropertySchema.addType('selection',
-                       lambda x:  x is None or type(x) in StringTypes)
-PropertySchema.addType('multiple selection',
-                       lambda x:  x is None or type(x) in _SequenceTypes)
-PropertySchema.addType('date',
-                       lambda x: 1 or x is None \
-                                 or type(x) is InstanceType \
-                                 and isinstance(x, DateTime))
-validateValue = PropertySchema.validate
-
-
-class MutablePropertySheet(UserPropertySheet):
-
-    implements(IMutablePropertySheet)
-
-    def validateProperty(self, id, value):
-        if not id in self._properties:
-            raise PropertyValueError('No such property found on this schema')
-
-        proptype = self.getPropertyType(id)
-        if not validateValue(proptype, value):
-            raise PropertyValueError("Invalid value (%s) for "
-                                     "property '%s' of type %s"
-                                        % (value, id, proptype))
-
-    def setProperty(self, user, id, value):
-        self.validateProperty(id, value)
-
-        self._properties[id] = value
-        self._properties = self._properties
-
-        # cascade to plugin
-        provider = self._getPropertyProviderForUser(user)
-        provider.setPropertiesForUser(user, self)
-
-    def setProperties(self, user, mapping):
-        prop_keys = self._properties.keys()
-        prop_update = mapping.copy()
-
-        for key, value in tuple(prop_update.items()):
-            if key not in prop_keys:
-                prop_update.pop(key)
-                continue
-            self.validateProperty(key, value)
-
-        self._properties.update(prop_update)
-
-        # cascade to plugin
-        provider = self._getPropertyProviderForUser(user)
-        provider.setPropertiesForUser(user, self)
-
-    def _getPropertyProviderForUser(self, user):
-        # XXX This assumes that the acl_users that we want is in the portal
-        # root. This may not always be the case.
-        portal = getUtility(ISiteRoot)
-        return portal.acl_users._getOb(self._id)
-
-
-class SchemaMutablePropertySheet(MutablePropertySheet):
-    pass
diff --git a/Products/PlonePAS/storage.py b/Products/PlonePAS/storage.py
deleted file mode 100644
index 652a56b..0000000
--- a/Products/PlonePAS/storage.py
+++ /dev/null
@@ -1,37 +0,0 @@
-"""
-an archetypes storage that delegates to a pas property provider.
-
-main use.. cmfmember integration w/ properties providers
-
-"""
-
-from zope.interface import implements
-
-from AccessControl import ClassSecurityInfo
-from Products.Archetypes.public import IStorage
-from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
-
-
-class PASStorage(object):
-
-    security = ClassSecurityInfo()
-    implements(IStorage)
-
-    def get(self, name, instance, **kwargs):
-        user = instance.getUser()
-        sheets = user.getOrderedSheets()
-        for sheet in sheets:
-            if sheet.hasProperty(name):
-                return sheet.getProperty(name)
-        raise AttributeError(name)
-
-    def set(self, name, instance, value, **kwargs):
-        user = instance.getUser()
-        sheets = user.getOrderedSheets()
-        for sheet in sheets:
-            if sheet.hasProperty(name):
-                if IMutablePropertySheet.providedBy(sheet):
-                    sheet.setProperty(name, value)
-                else:
-                    raise RuntimeError("mutable property provider shadowed by"
-                                       "read only provider")
diff --git a/Products/PlonePAS/tests/__init__.py b/Products/PlonePAS/tests/__init__.py
deleted file mode 100644
index 8b13789..0000000
--- a/Products/PlonePAS/tests/__init__.py
+++ /dev/null
@@ -1 +0,0 @@
-
diff --git a/Products/PlonePAS/tests/base.py b/Products/PlonePAS/tests/base.py
deleted file mode 100644
index 924ef4e..0000000
--- a/Products/PlonePAS/tests/base.py
+++ /dev/null
@@ -1,2 +0,0 @@
-from plone.app.testing.bbb import PloneTestCase as TestCase
-from plone.app.testing.bbb import PloneTestCase as FunctionalTestCase
diff --git a/Products/PlonePAS/tests/cookie_auth.rst b/Products/PlonePAS/tests/cookie_auth.rst
deleted file mode 100644
index cb249b5..0000000
--- a/Products/PlonePAS/tests/cookie_auth.rst
+++ /dev/null
@@ -1,98 +0,0 @@
-Test for Cookie Auth
-====================
-
-  >>> from zope.interface import implementedBy
-  >>> from plone.app.testing import TEST_USER_NAME
-  >>> from plone.app.testing import TEST_USER_PASSWORD
-
-User in Plone Site
-------------------
-
-Plone Site has PAS installed
-
-  >>> portal = layer['portal']
-  >>> print portal.acl_users.meta_type
-  Pluggable Auth Service
-
-User exists in the user folder inside the Plone Site.
-
-  >>> uf = portal.acl_users
-  >>> print uf.meta_type
-  Pluggable Auth Service
-
-  >>> user_name, user_password, user_role = ('foo', 'bar', 'Manager')
-  >>> uf.userFolderAddUser(user_name, user_password, [user_role], [])
-
-  >>> uf.getUserById(user_name)
-  <PloneUser 'foo'>
-
-Login to Plone Site using Basic Auth works.
-
-  >>> from plone.testing.z2 import Browser
-  >>> browser = Browser(layer['app'])
-  >>> browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
-  >>> browser.open('%s/manage' % portal.absolute_url())
-  >>> print browser.headers
-  Status: 200 Ok...
-
-Make sure cookie plugin is installed and activated.
-
-  >>> uf.objectIds('Extended Cookie Auth Helper')
-  ['credentials_cookie_auth']
-
-  >>> plugins = uf.plugins
-  >>> cookie = uf['credentials_cookie_auth']
-
-  >>> ifaces = tuple(implementedBy(cookie.__class__).flattened())
-
-  >>> actives = []
-  >>> for iface in ifaces:
-  ...    try:
-  ...       actives.append((plugins.listPlugins(iface), iface))
-  ...    except KeyError:
-  ...       pass
-
-  >>> for active, iface in actives:
-  ...     print iface,
-  ...     for id, plugin in active:
-  ...         if id == 'credentials_cookie_auth':
-  ...            print True
-  <...IExtraction...> True
-  <...IChallenge...> True
-  <...ICredentialsUpdate...> <...ICredentialsReset...>
-
-User in parent folder
----------------------
-
-User Exists on the folder containing the Plone Site, which should be a
-Pluggable Auth Service too.
-
-  >>> uf = layer['app'].acl_users
-  >>> print uf.meta_type
-  Pluggable Auth Service
-
-  >>> user_name, user_password, user_role = ('baz', 'bar', 'Manager')
-  >>> uf.userFolderAddUser(user_name, user_password, [user_role], [])
-
-  >>> uf.getUserById(user_name)
-  <PropertiedUser 'baz'>
-
-  >>> import transaction
-  >>> transaction.commit()
-
-Login directly to containing folder using Basic Auth works.
-
-  >>> browser = Browser(layer['app'])
-  >>> browser.addHeader('Authorization', 'Basic %s:%s' % (user_name, user_password,))
-  >>> browser.open('%s/manage' % layer['app'].absolute_url())
-  >>> print browser.headers
-  Status: 200 Ok...
-
-Login to Plone Site using Basic Auth works.
-
-  >>> browser = Browser(layer['app'])
-  >>> browser.addHeader('Authorization', 'Basic %s:%s' % (user_name, user_password,))
-  >>> browser.open('%s/manage' % portal.absolute_url())
-  >>> print browser.headers
-  Status: 200 Ok...
-
diff --git a/Products/PlonePAS/tests/dummy.py b/Products/PlonePAS/tests/dummy.py
deleted file mode 100644
index 4b10a05..0000000
--- a/Products/PlonePAS/tests/dummy.py
+++ /dev/null
@@ -1,58 +0,0 @@
-from OFS.SimpleItem import SimpleItem
-from ZPublisher.HTTPRequest import FileUpload
-
-TEXT = 'file data'
-
-
-class FieldStorage(object):
-    def __init__(self, file, filename='testfile', headers=None):
-        self.file = file
-        if headers is None:
-            headers = {}
-        self.headers = headers
-        self.filename = filename
-
-
-class File(FileUpload):
-    '''Dummy upload object
-       Used to fake uploaded files.
-    '''
-
-    __allow_access_to_unprotected_subobjects__ = 1
-    filename = 'dummy.txt'
-    data = TEXT
-    headers = {}
-
-    def __init__(self, filename=None, data=None, headers=None):
-        if filename is not None:
-            self.filename = filename
-        if data is not None:
-            self.data = data
-        if headers is not None:
-            self.headers = headers
-
-    def seek(self, *args):
-        pass
-
-    def tell(self, *args):
-        return 1
-
-    def read(self, *args):
-        return self.data
-
-
-class Error(Exception):
-    '''Dummy exception'''
-
-
-class Raiser(SimpleItem):
-    '''Raises the stored exception when called'''
-
-    exception = Error
-
-    def __init__(self, exception=None):
-        if exception is not None:
-            self.exception = exception
-
-    def __call__(self, *args, **kw):
-        raise self.exception
diff --git a/Products/PlonePAS/tests/images/test.gif b/Products/PlonePAS/tests/images/test.gif
deleted file mode 100644
index b1ac85b..0000000
Binary files a/Products/PlonePAS/tests/images/test.gif and /dev/null differ
diff --git a/Products/PlonePAS/tests/images/test.jpg b/Products/PlonePAS/tests/images/test.jpg
deleted file mode 100644
index d444aff..0000000
Binary files a/Products/PlonePAS/tests/images/test.jpg and /dev/null differ
diff --git a/Products/PlonePAS/tests/images/test.png b/Products/PlonePAS/tests/images/test.png
deleted file mode 100644
index 078487d..0000000
Binary files a/Products/PlonePAS/tests/images/test.png and /dev/null differ
diff --git a/Products/PlonePAS/tests/test_basic_ops.py b/Products/PlonePAS/tests/test_basic_ops.py
deleted file mode 100644
index 865e3c7..0000000
--- a/Products/PlonePAS/tests/test_basic_ops.py
+++ /dev/null
@@ -1,153 +0,0 @@
-import unittest
-from zope.component import adapter
-from zope.component import getGlobalSiteManager
-
-from Products.PluggableAuthService.interfaces.events \
-    import IPrincipalDeletedEvent
-from Products.PluggableAuthService.PluggableAuthService \
-    import _SWALLOWABLE_PLUGIN_EXCEPTIONS
-from Products.PluggableAuthService.interfaces.authservice \
-     import IPluggableAuthService
-from Products.PluggableAuthService.interfaces.plugins \
-     import IRolesPlugin
-
-from Products.PlonePAS.tests import base
-
-
-class BasicOpsTestCase(base.TestCase):
-
-    def afterSetUp(self):
-        self.loginAsPortalOwner()
-        self.acl_users = self.portal.acl_users
-
-    def compareRoles(self, target, user, roles):
-        """
-        compareRoles(self, target, user, roles) => do not raise if
-        user has exactly the specified roles.
-
-        If target is None, test user roles (no local roles)
-        """
-        u = self.acl_users.getUser(user)
-        if not u:
-            raise RuntimeError("compareRoles: Invalid user: '%s'" % user)
-        non_roles = ('Authenticated', 'Anonymous', '')
-        if target is None:
-            user_roles = list(u.getRoles())
-        else:
-            user_roles = list(u.getRolesInContext(target))
-        actual_roles = filter(lambda x: x not in non_roles, user_roles)
-        actual_roles.sort()
-        wished_roles = list(roles)
-        wished_roles.sort()
-        if actual_roles == wished_roles:
-            return 1
-        raise RuntimeError("User %s: Whished roles: %s BUT current "
-                           "roles: %s" % (user, wished_roles, actual_roles))
-
-    def createUser(self, login="created_user", password="secret",
-                   roles=[], groups=[], domains=()):
-        self.acl_users.userFolderAddUser(
-            login, password, roles=roles, groups=groups, domains=domains,)
-
-    def test_installed(self):
-        self.assertTrue(IPluggableAuthService.providedBy(self.acl_users))
-
-    def test_add(self):
-        self.createUser()
-        self.assertTrue(self.acl_users.getUser("created_user"))
-
-    def test_edit(self):
-        # this will fail unless the PAS role plugin is told it manages
-        # the new role.
-        self.createUser()
-        self.compareRoles(None, "created_user", [])
-        self.acl_users.userFolderEditUser(
-            "created_user",  # name
-            "secret2",  # password
-            roles=["Member"],
-            groups=["g1"],
-            domains=(),)
-        self.compareRoles(None, "created_user", ['Member'])
-
-    def test_edit_userDefinedRole(self):
-        roleplugins = self.acl_users.plugins.listPlugins(IRolesPlugin)
-        for id, plugin in roleplugins:
-            try:
-                plugin.addRole('r1')
-            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-                pass
-            else:
-                break
-
-        self.createUser()
-        self.compareRoles(None, "created_user", [])
-        self.acl_users.userFolderEditUser(
-            "created_user",  # name
-            "secret2",  # password
-            roles=["r1"],
-            groups=["g1"],
-            domains=(),)
-        self.compareRoles(None, "created_user", ['r1'])
-
-    def test_del(self):
-        self.createUser()
-        self.assertTrue(self.acl_users.getUser("created_user"))
-        self.acl_users.userFolderDelUsers(['created_user'])
-        self.assertFalse(self.acl_users.getUser("created_user"))
-
-    def test_principal_del_event(self):
-        eventsFired = []
-
-        @adapter(IPrincipalDeletedEvent)
-        def gotDeletion(event):
-            eventsFired.append(event)
-
-        gsm = getGlobalSiteManager()
-        gsm.registerHandler(gotDeletion)
-        self.createUser()
-        self.acl_users.userFolderDelUsers(['created_user'])
-        self.assertEqual(len(eventsFired), 1)
-        self.assertEqual(eventsFired[0].principal, 'created_user')
-        gsm.unregisterHandler(gotDeletion)
-
-    def test_search(self):
-        self.createUser("created_user1")
-        self.createUser("created_user2")
-        mt = self.portal.portal_membership
-        retlist = mt.searchForMembers(REQUEST=None, login="created_user1")
-        usernames = [user.getUserName() for user in retlist]
-        self.assertEqual(len(usernames), 1)
-        self.assertTrue("created_user1" in usernames,
-                        "'created_user1' not in %s" % usernames)
-
-    def test_setpw(self):
-        # there is more than one place where one can set the password.
-        # insane. anyway we have to check the patch in pas.py userSetPassword
-        # here its checked in the general setup using ZODBUserManager.
-        self.createUser()
-        uf = self.acl_users
-        new_secret = 'new_secret'
-        uf.userSetPassword('created_user', new_secret)
-
-        # possible to authenticate with new password?
-        from Products.PluggableAuthService.interfaces.plugins \
-            import IAuthenticationPlugin
-        authenticators = uf.plugins.listPlugins(IAuthenticationPlugin)
-        credentials = {'login': 'created_user', 'password': new_secret}
-        result = None
-        for aid, authenticator in authenticators:
-            result = authenticator.authenticateCredentials(credentials)
-            if result is not None:
-                break
-        self.assertTrue(result)
-
-    def test_setProperties(self):
-        self.createUser()
-        user = self.acl_users.getUser('created_user')
-        user.setProperties(fullname='Test User', email='test@example.org')
-        self.assertEqual(user.getProperty('fullname'), 'Test User')
-        self.assertEqual(user.getProperty('email'), 'test@example.org')
-
-        user.setProperties(properties={'fullname': 'Test User2', 'email': 'test2@example.org'})
-        self.assertEqual(user.getProperty('fullname'), 'Test User2')
-        self.assertEqual(user.getProperty('email'), 'test2@example.org')
diff --git a/Products/PlonePAS/tests/test_doctests.py b/Products/PlonePAS/tests/test_doctests.py
deleted file mode 100644
index df6ed7f..0000000
--- a/Products/PlonePAS/tests/test_doctests.py
+++ /dev/null
@@ -1,14 +0,0 @@
-from plone.app.testing.bbb import PTC_FUNCTIONAL_TESTING
-from plone.testing import layered
-import doctest
-import unittest
-
-
-def test_suite():
-    suite = unittest.TestSuite()
-    suite.addTest(layered(
-        doctest.DocFileSuite('cookie_auth.rst', package='Products.PlonePAS.tests',
-                             optionflags=doctest.ELLIPSIS),
-        layer=PTC_FUNCTIONAL_TESTING))
-    suite.addTest(doctest.DocTestSuite('Products.PlonePAS.utils', optionflags=doctest.ELLIPSIS)),
-    return suite
diff --git a/Products/PlonePAS/tests/test_groupdatatool.py b/Products/PlonePAS/tests/test_groupdatatool.py
deleted file mode 100644
index b3ce414..0000000
--- a/Products/PlonePAS/tests/test_groupdatatool.py
+++ /dev/null
@@ -1,182 +0,0 @@
-from AccessControl import Permissions
-from AccessControl import Unauthorized
-
-from Products.CMFCore.tests.base.testcase import WarningInterceptor
-from plone.app.testing import TEST_USER_ID
-from plone.app.testing import TEST_USER_NAME
-
-from Products.PlonePAS.tests import base
-
-
-def sortTuple(t):
-    l = list(t)
-    l.sort()
-    return tuple(l)
-
-
-class TestGroupDataTool(base.TestCase):
-
-    def afterSetUp(self):
-        self.acl_users = self.portal.acl_users
-        self.groups = self.portal.portal_groups
-        self.groupdata = self.portal.portal_groupdata
-        self.groups.addGroup('foo')
-        # MUST reset _v_ attributes!
-        self.groupdata._v_temps = None
-        if 'auto_group' in self.acl_users:
-            self.acl_users.manage_delObjects(['auto_group'])
-
-    def testWrapGroup(self):
-        g = self.acl_users.getGroup('foo')
-        self.assertEqual(g.__class__.__name__, 'PloneGroup')
-        g = self.groupdata.wrapGroup(g)
-        self.assertEqual(g.__class__.__name__, 'GroupData')
-        self.assertEqual(g.aq_parent.__class__.__name__, 'PloneGroup')
-        self.assertEqual(g.aq_parent.aq_parent.__class__.__name__,
-                         'GroupManager')
-
-
-class TestGroupData(base.TestCase, WarningInterceptor):
-
-    def afterSetUp(self):
-        self.membership = self.portal.portal_membership
-        self.memberdata = self.portal.portal_memberdata
-        self.acl_users = self.portal.acl_users
-        self.groups = self.portal.portal_groups
-        self.groupdata = self.portal.portal_groupdata
-        self.groups.addGroup('foo')
-        if 'auto_group' in self.acl_users:
-            self.acl_users.manage_delObjects(['auto_group'])
-        # MUST reset _v_ attributes!
-        self.memberdata._v_temps = None
-        self.groupdata._v_temps = None
-        self._trap_warning_output()
-
-    def testGetGroup(self):
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(g.__class__.__name__, 'GroupData')
-        g = g.getGroup()
-        self.assertEqual(g.__class__.__name__, 'PloneGroup')
-
-    def testGetTool(self):
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(g.getTool().getId(), 'portal_groupdata')
-
-    def testGetGroupMembers(self):
-        g = self.groups.getGroupById('foo')
-        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
-        self.assertEqual(g.getGroupMembers()[0].getId(), TEST_USER_ID)
-
-    def testGroupMembersAreWrapped(self):
-        g = self.groups.getGroupById('foo')
-        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
-        ms = g.getGroupMembers()
-        self.assertEqual(ms[0].__class__.__name__, 'MemberData')
-        self.assertEqual(ms[0].aq_parent.__class__.__name__, 'PloneUser')
-        self.assertEqual(ms[0].aq_parent.aq_parent.__class__.__name__,
-                         'PluggableAuthService')
-
-    def testAddMember(self):
-        self.setPermissions([Permissions.manage_users])
-        g = self.groups.getGroupById('foo')
-        g.addMember(TEST_USER_ID)
-        self.assertEqual(g.getGroupMembers()[0].getId(), TEST_USER_ID)
-
-    def testRemoveMember(self):
-        self.setPermissions([Permissions.manage_users])
-        g = self.groups.getGroupById('foo')
-        g.addMember(TEST_USER_ID)
-        g.removeMember(TEST_USER_ID)
-        self.assertEqual(len(g.getGroupMembers()), 0)
-
-    def testSetGroupProperties(self):
-        g = self.groups.getGroupById('foo')
-        g.setGroupProperties({'email': 'foo@bar.com'})
-        gd = self.groups.getGroupById('foo')
-        self.assertEqual(gd.getProperty('email'), 'foo@bar.com')
-
-    def testSetMemberProperties(self):
-        # For reference
-        m = self.membership.getMemberById(TEST_USER_ID)
-        m.setMemberProperties({'email': 'foo@bar.com'})
-        md = self.membership.getMemberById(TEST_USER_ID)
-        self.assertEqual(md.getProperty('email'), 'foo@bar.com')
-
-    def testGetProperty(self):
-        g = self.groups.getGroupById('foo')
-        g.setGroupProperties({'email': 'foo@bar.com'})
-        self.assertEqual(g.getProperty('email'), 'foo@bar.com')
-        self.assertEqual(g.getProperty('id'), 'foo')
-
-    def testGetGroupName(self):
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(g.getGroupName(), 'foo')
-
-    def testGetGroupId(self):
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(g.getGroupId(), 'foo')
-
-    def testGetRoles(self):
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(tuple(g.getRoles()), ('Authenticated',))
-        self.groups.editGroup(g.getId(), roles=['Member'])
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(sortTuple(tuple(g.getRoles())),
-                         ('Authenticated', 'Member'))
-
-    def testGetRolesInContext(self):
-        g = self.groups.getGroupById('foo')
-        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
-        user = self.acl_users.getUser(TEST_USER_NAME)
-        self.assertEqual(user.getRolesInContext(self.folder).sort(),
-                        ['Member', 'Authenticated', 'Owner'].sort())
-        self.folder.manage_setLocalRoles(g.getId(), ['NewRole'])
-        self.assertEqual(user.getRolesInContext(self.folder).sort(),
-                        ['Member', 'Authenticated', 'Owner', 'NewRole'].sort())
-
-    def testGetDomains(self):
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(g.getDomains(), ())
-
-    def testHasRole(self):
-        g = self.groups.getGroupById('foo')
-        self.groups.editGroup(g.getId(), roles=['Member'])
-        g = self.groups.getGroupById('foo')
-        self.assertTrue(g.has_role('Member'))
-
-    def beforeTearDown(self):
-        self._free_warning_output()
-
-
-class TestMethodProtection(base.TestCase):
-
-    def afterSetUp(self):
-        self.groups = self.portal.portal_groups
-        self.groups.addGroup('foo')
-        self.groupdata = self.groups.getGroupById('foo')
-
-    def testAnonAddMember(self):
-        self.logout()
-        self.assertRaises(Unauthorized, self.groupdata.addMember, TEST_USER_ID)
-
-    def testAnonRemoveMember(self):
-        self.logout()
-        self.assertRaises(Unauthorized, self.groupdata.removeMember,
-                          TEST_USER_ID)
-
-    def testMemberAddMember(self):
-        self.assertRaises(Unauthorized, self.groupdata.addMember, TEST_USER_ID)
-
-    def testMemberRemoveMember(self):
-        self.assertRaises(Unauthorized, self.groupdata.removeMember,
-                          TEST_USER_ID)
-
-    def testManagerAddMember(self):
-        self.setPermissions([Permissions.manage_users])
-        self.groupdata.addMember(TEST_USER_ID)
-
-    def testManagerRemoveMember(self):
-        self.setPermissions([Permissions.manage_users])
-        self.groupdata.addMember(TEST_USER_ID)
-        self.groupdata.removeMember(TEST_USER_ID)
-
diff --git a/Products/PlonePAS/tests/test_groupstool.py b/Products/PlonePAS/tests/test_groupstool.py
deleted file mode 100644
index d0b4f18..0000000
--- a/Products/PlonePAS/tests/test_groupstool.py
+++ /dev/null
@@ -1,254 +0,0 @@
-import unittest
-
-from Acquisition import aq_base
-from Acquisition import aq_parent
-from AccessControl import Permissions
-from AccessControl import Unauthorized
-
-from Products.CMFCore.tests.base.testcase import WarningInterceptor
-from Products.CMFCore.utils import getToolByName
-from plone.app.testing import TEST_USER_ID
-from plone.app.testing import TEST_USER_NAME
-
-from Products.PlonePAS.tools.groupdata import GroupData
-from Products.PlonePAS.plugins.group import PloneGroup
-from Products.PlonePAS.tests import base
-
-
-def sortTuple(t):
-    l = list(t)
-    l.sort()
-    return tuple(l)
-
-
-class GroupsToolTest(base.TestCase):
-
-    def afterSetUp(self):
-        self.gt = gt = getToolByName(self.portal, 'portal_groups')
-        self.gd = gd = getToolByName(self.portal, 'portal_groupdata')
-
-        self.group_id = 'group1'
-        # Create a new Group
-        self.loginAsPortalOwner()
-        gt.addGroup(self.group_id, ['Reviewer'], [],
-                    {'email': 'group1@host.com',
-                     'title': 'Group #1'})
-
-    def test_get_group(self):
-        # Use PAS (monkeypatched) API method to get a group by id.
-        group = self.portal.acl_users.getGroup(self.group_id)
-        self.assertFalse(group is None)
-
-        # Should be wrapped into the GroupManagement, which is wrapped
-        # into the PAS.
-        got = aq_base(aq_parent(aq_parent(group)))
-        expected = aq_base(self.portal.acl_users)
-        self.assertEqual(got, expected)
-
-        self.assertTrue(isinstance(group, PloneGroup))
-
-    def test_get_group_by_id(self):
-        # Use tool way of getting group by id. This returns a
-        # GroupData object wrapped by the group
-        group = self.gt.getGroupById(self.group_id)
-        self.assertFalse(group is None)
-        self.assertTrue(isinstance(group, GroupData))
-        self.assertTrue(isinstance(aq_parent(group), PloneGroup))
-
-    def test_edit_group(self):
-        # Use the tool way to edit a group.
-        properties = {
-            'email': 'group1@host2.com',
-            'title': 'Group #1 new title'
-        }
-        self.gt.editGroup(self.group_id, roles=['Manager'],
-            **properties)
-
-        # test edition of roles and properties
-        group = self.gt.getGroupById(self.group_id)
-        self.assertTrue(group.has_role('Manager'))
-        self.assertEqual(group.getProperty('email'), properties['email'])
-        self.assertEqual(group.getProperty('title'), properties['title'])
-
-        # test for empty list of roles
-        self.gt.editGroup(self.group_id, roles=[])
-        self.assertTrue(group.has_role('Authenticated'))
-
-        # test edition of group groups
-        self.gt.editGroup(self.group_id, groups=['Reviewers'],
-            **properties)
-        group = self.gt.getGroupById(self.group_id)
-        self.assertTrue('Reviewers' in group.getGroups())
-
-
-class TestMethodProtection(base.TestCase):
-    # GroupData has wrong security declarations
-
-    def afterSetUp(self):
-        self.groups = self.portal.portal_groups
-        self.groups.addGroup('foo')
-        self.groupdata = self.groups.getGroupById('foo')
-
-    def testAnonAddMember(self):
-        self.logout()
-        self.assertRaises(Unauthorized, self.groupdata.addMember, TEST_USER_ID)
-
-    def testAnonRemoveMember(self):
-        self.logout()
-        self.assertRaises(Unauthorized, self.groupdata.removeMember,
-                          TEST_USER_ID)
-
-    def testMemberAddMember(self):
-        self.assertRaises(Unauthorized, self.groupdata.addMember, TEST_USER_ID)
-
-    def testMemberRemoveMember(self):
-        self.assertRaises(Unauthorized, self.groupdata.removeMember,
-                          TEST_USER_ID)
-
-    def testManagerAddMember(self):
-        self.setPermissions([Permissions.manage_users])
-        self.groupdata.addMember(TEST_USER_ID)
-
-    def testManagerRemoveMember(self):
-        self.setPermissions([Permissions.manage_users])
-        self.groupdata.addMember(TEST_USER_ID)
-        self.groupdata.removeMember(TEST_USER_ID)
-
-
-class TestGroupsTool(base.TestCase, WarningInterceptor):
-
-    def afterSetUp(self):
-        self.membership = self.portal.portal_membership
-        self.acl_users = self.portal.acl_users
-        self.groups = self.portal.portal_groups
-        self._trap_warning_output()
-
-        if 'auto_group' in self.acl_users:
-            self.acl_users.manage_delObjects(['auto_group'])
-
-        # Nuke Administators and Reviewers groups added in 2.1a2 migrations
-        # (and any other migrated-in groups) to avoid test confusion
-        self.groups.removeGroups(self.groups.listGroupIds())
-
-    def testAddGroup(self):
-        self.groups.addGroup('foo', [], [])
-        self.assertEqual(self.groups.listGroupIds(), ['foo'])
-
-    def testGetGroupById(self):
-        self.groups.addGroup('foo', [], [])
-        g = self.groups.getGroupById('foo')
-        self.assertNotEqual(g, None)
-
-    def testGetBadGroupById(self):
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(g, None)
-
-    def testGroupByIdIsWrapped(self):
-        self.groups.addGroup('foo', [], [])
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(g.__class__.__name__, 'GroupData')
-        self.assertEqual(g.aq_parent.__class__.__name__, 'PloneGroup')
-        self.assertEqual(g.aq_parent.aq_parent.__class__.__name__,
-                         'GroupManager')
-
-    def testEditGroup(self):
-        self.groups.addGroup('foo', )
-        self.groups.editGroup('foo', roles=['Reviewer'])
-        g = self.groups.getGroupById('foo')
-        self.assertEqual(sortTuple(g.getRoles()),
-                         ('Authenticated', 'Reviewer'))
-
-    def testEditBadGroup(self):
-        # Error type depends on the user folder...
-        try:
-            self.groups.editGroup('foo', [], [])
-        except (KeyError, ValueError):
-            pass        # Ok, this is the wanted behaviour
-        else:
-            self.fail("Should have raised KeyError or ValueError")
-
-    def testRemoveGroups(self):
-        self.groups.addGroup('foo', [], [])
-        self.groups.removeGroups(['foo'])
-        self.assertEqual(len(self.groups.listGroupIds()), 0)
-
-    def testListGroupIds(self):
-        self.groups.addGroup('foo', [], [])
-        self.groups.addGroup('bar', [], [])
-        grps = self.groups.listGroupIds()
-        grps.sort()
-        self.assertEqual(grps, ['bar', 'foo'])
-
-    def testGetGroupsByUserId(self):
-        self.groups.addGroup('foo', [], [])
-        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
-        gs = self.groups.getGroupsByUserId(TEST_USER_ID)
-        self.assertEqual(gs[0].getId(), 'foo')
-
-    def testGroupsByUserIdAreWrapped(self):
-        self.groups.addGroup('foo', [], [])
-        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
-        gs = self.groups.getGroupsByUserId(TEST_USER_ID)
-        self.assertEqual(gs[0].__class__.__name__, 'GroupData')
-        self.assertEqual(gs[0].aq_parent.__class__.__name__, 'PloneGroup')
-        self.assertEqual(gs[0].aq_parent.aq_parent.__class__.__name__,
-                         'GroupManager')
-
-    def testListGroups(self):
-        self.groups.addGroup('foo', [], [])
-        self.groups.addGroup('bar', [], [])
-        gs = self.groups.listGroups()
-        self.assertEqual(gs[0].getId(), 'bar')
-        self.assertEqual(gs[1].getId(), 'foo')
-
-    def testListedGroupsAreWrapped(self):
-        self.groups.addGroup('foo', [], [])
-        gs = self.groups.listGroups()
-        self.assertEqual(gs[0].__class__.__name__, 'GroupData')
-        self.assertEqual(gs[0].aq_parent.__class__.__name__, 'PloneGroup')
-        self.assertEqual(gs[0].aq_parent.aq_parent.__class__.__name__,
-                         'GroupManager')
-
-    def testSetGroupOwnership(self):
-        self.groups.addGroup('foo', [], [])
-        self.folder.invokeFactory('Document', 'doc')
-        doc = self.folder.doc
-        g = self.groups.getGroupById('foo')
-        self.groups.setGroupOwnership(g, doc)
-        self.assertEqual(doc.getOwnerTuple()[1], 'foo')
-        self.assertEqual(doc.get_local_roles_for_userid('foo'), ('Owner',))
-        self.assertEqual(doc.get_local_roles_for_userid(TEST_USER_ID),
-                         ('Owner',))
-
-    def testWrapGroup(self):
-        self.groups.addGroup('foo', [], [])
-        g = self.acl_users.getGroup('foo')
-        self.assertEqual(g.__class__.__name__, 'PloneGroup')
-        g = self.groups.wrapGroup(g)
-        self.assertEqual(g.__class__.__name__, 'GroupData')
-        self.assertEqual(g.aq_parent.__class__.__name__, 'PloneGroup')
-        self.assertEqual(g.aq_parent.aq_parent.__class__.__name__,
-                         'GroupManager')
-
-    def testGetGroupInfo(self):
-        self.groups.addGroup('foo', title='Foo', description='Bar',
-                             email='foo@foo.com')
-        info = self.groups.getGroupInfo('foo')
-        self.assertEqual(info.get('title'), 'Foo')
-        self.assertEqual(info.get('description'), 'Bar')
-        self.assertEqual(info.get('email'), None)  # No email!
-
-    def testGetGroupInfoAsAnonymous(self):
-        self.groups.addGroup('foo', title='Foo', description='Bar')
-        self.logout()
-        info = self.groups.restrictedTraverse('getGroupInfo')('foo')
-        self.assertEqual(info.get('title'), 'Foo')
-        self.assertEqual(info.get('description'), 'Bar')
-
-    def testGetBadGroupInfo(self):
-        info = self.groups.getGroupInfo('foo')
-        self.assertEqual(info, None)
-
-    def beforeTearDown(self):
-        self._free_warning_output()
-
diff --git a/Products/PlonePAS/tests/test_memberdatatool.py b/Products/PlonePAS/tests/test_memberdatatool.py
deleted file mode 100644
index 6b3c4f0..0000000
--- a/Products/PlonePAS/tests/test_memberdatatool.py
+++ /dev/null
@@ -1,72 +0,0 @@
-from DateTime import DateTime
-from OFS.Image import Image
-
-from plone.app.testing import TEST_USER_ID as default_user
-
-from Products.PlonePAS.tests import base
-from Products.PlonePAS.tests import dummy
-
-
-class TestMemberDataTool(base.TestCase):
-
-    def afterSetUp(self):
-        self.memberdata = self.portal.portal_memberdata
-        self.membership = self.portal.portal_membership
-        self.membership.memberareaCreationFlag = 0
-        # Don't let default_user disturb results
-        self.portal.acl_users._doDelUsers([default_user])
-        # Add some members
-        self.addMember('fred', 'Fred Flintstone', 'fred@bedrock.com',
-                       ['Member', 'Reviewer'], '2002-01-01')
-        self.addMember('barney', 'Barney Rubble', 'barney@bedrock.com',
-                       ['Member'], '2002-01-01')
-        self.addMember('brubble', 'Bambam Rubble', 'bambam@bambam.net',
-                       ['Member'], '2003-12-31')
-        # MUST reset this
-        self.memberdata._v_temps = None
-
-    def addMember(self, username, fullname, email, roles, last_login_time):
-        self.membership.addMember(username, 'secret', roles, [])
-        member = self.membership.getMemberById(username)
-        member.setMemberProperties({
-            'fullname': fullname,
-            'email': email,
-            'last_login_time': DateTime(last_login_time), })
-
-    def testSetPortrait(self):
-        self.memberdata._setPortrait(
-            Image(id=default_user, file=dummy.File(), title=''),
-            default_user)
-        self.assertEqual(self.memberdata._getPortrait(default_user).getId(),
-                         default_user)
-        self.assertEqual(self.memberdata._getPortrait(default_user).meta_type,
-                         'Image')
-
-    def testDeletePortrait(self):
-        self.memberdata._setPortrait(
-            Image(id=default_user, file=dummy.File(), title=''),
-            default_user)
-        self.memberdata._deletePortrait(default_user)
-        self.assertEqual(self.memberdata._getPortrait(default_user), None)
-
-    def testPruneMemberDataContents(self):
-        # Only test what is not already tested elswhere
-        self.memberdata._setPortrait(
-            Image(id=default_user, file=dummy.File(), title=''),
-            default_user)
-        self.memberdata._setPortrait(
-            Image(id=default_user, file=dummy.File(), title=''),
-            'dummy')
-        self.memberdata.pruneMemberDataContents()
-        self.assertEqual(len(self.memberdata.portraits), 1)
-
-    def testFulltextMemberSearch(self):
-        # Search for a user by id, name, email, ...
-        search = self.memberdata.searchFulltextForMembers
-        self.assertEqual(len(search('')), 3)
-        self.assertEqual(len(search('rubble')), 2)
-        self.assertEqual(len(search('stone')), 1)
-        self.assertEqual(len(search('bambam.net')), 1)
-        self.assertEqual(len(search('bedrock.com')), 2)
-        self.assertEqual(len(search('brubble')), 1)
-
diff --git a/Products/PlonePAS/tests/test_membershiptool.py b/Products/PlonePAS/tests/test_membershiptool.py
deleted file mode 100644
index f3553b8..0000000
--- a/Products/PlonePAS/tests/test_membershiptool.py
+++ /dev/null
@@ -1,948 +0,0 @@
-# coding=utf-8
-import os
-import unittest
-from cStringIO import StringIO
-
-from AccessControl.User import nobody
-from AccessControl import getSecurityManager
-from AccessControl import Unauthorized
-from Acquisition import aq_base
-from Acquisition import aq_parent
-from DateTime import DateTime
-from OFS.Image import Image
-from zExceptions import BadRequest
-from zope.component import getUtility
-
-from Products.CMFCore.utils import getToolByName
-from Products.CMFCore.tests.base.testcase import WarningInterceptor
-
-from plone.app.testing import TEST_USER_ID
-from plone.app.testing import TEST_USER_NAME
-from plone.app.testing import TEST_USER_PASSWORD
-from plone.app.testing import SITE_OWNER_NAME
-from plone.app.testing import PLONE_SITE_ID
-
-from Products.CMFCore.interfaces import IPropertiesTool
-from Products.PlonePAS.interfaces.membership import IMembershipTool
-from Products.PlonePAS.browser.member import PASMemberView
-from Products.PlonePAS.plugins.ufactory import PloneUser
-from Products.PlonePAS.tests import base
-from Products.PlonePAS.tests import dummy
-from Products.PlonePAS.tools.memberdata import MemberData
-from Products.PlonePAS.tools.membership import MembershipTool
-from Products.PlonePAS.utils import getGroupsForPrincipal
-
-
-class MembershipToolTest(base.TestCase):
-
-    def afterSetUp(self):
-        self.mt = mt = getToolByName(self.portal, 'portal_membership')
-        self.md = md = getToolByName(self.portal, 'portal_memberdata')
-
-        self.member_id = 'member1'
-        # Create a new Member
-        mt.addMember(self.member_id, 'pw', ['Member'], [],
-                     {'email': 'member1@host.com',
-                      'title': 'Member #1'})
-
-    def test_get_member(self):
-        member = self.portal.acl_users.getUserById(self.member_id)
-        self.assertFalse(member is None)
-
-        # Should be wrapped into the PAS.
-        got = aq_base(aq_parent(member))
-        expected = aq_base(self.portal.acl_users)
-        self.assertEqual(got, expected)
-
-        self.assertTrue(isinstance(member, PloneUser))
-
-    def test_get_member_by_id(self):
-        # Use tool way of getting member by id. This returns a
-        # MemberData object wrapped by the member
-        member = self.mt.getMemberById(self.member_id)
-        self.assertFalse(member is None)
-        self.assertTrue(isinstance(member, MemberData))
-        self.assertTrue(isinstance(aq_parent(member), PloneUser))
-
-    def test_id_clean(self):
-        from Products.PlonePAS.utils import cleanId, decleanId
-        a = [
-             "asdfasdf",
-             "asdf-asdf",
-             "asdf--asdf",
-             "asdf---asdf",
-             "asdf----asdf",
-             "asdf-----asdf",
-             "asdf%asdf",
-             "asdf%%asdf",
-             "asdf%%%asdf",
-             "asdf%%%%asdf",
-             "asdf%%%%%asdf",
-             "asdf-%asdf",
-             "asdf%-asdf",
-             "asdf-%-asdf",
-             "asdf%-%asdf",
-             "asdf--%asdf",
-             "asdf%--asdf",
-             "asdf--%-asdf",
-             "asdf-%--asdf",
-             "asdf--%--asdf",
-             "asdf%-%asdf",
-             "asdf%--%asdf",
-             "asdf%---%asdf",
-             "-asdf",
-             "--asdf",
-             "---asdf",
-             "----asdf",
-             "-----asdf",
-             "asdf-",
-             "asdf--",
-             "asdf---",
-             "asdf----",
-             "asdf-----",
-             "%asdf",
-             "%%asdf",
-             "%%%asdf",
-             "%%%%asdf",
-             "%%%%%asdf",
-             "asdf%",
-             "asdf%%",
-             "asdf%%%",
-             "asdf%%%%",
-             "asdf%%%%%",
-             "asdf\x00asdf",
-        ]
-        b = [cleanId(id) for id in a]
-        c = [decleanId(id) for id in b]
-        ac = zip(a, c)
-        for aa, cc in ac:
-            self.assertTrue(aa == cc)
-
-
-class MemberAreaTest(base.TestCase):
-
-    def afterSetUp(self):
-        self.mt = mt = getToolByName(self.portal, 'portal_membership')
-        self.md = md = getToolByName(self.portal, 'portal_memberdata')
-        # Enable member-area creation
-        self.mt.memberareaCreationFlag = 1
-        # Those are all valid chars in Zope.
-        self.mid = "Member #1 - Houston, TX. ($100)"
-        self.pas = self.portal.acl_users
-        self.loginAsPortalOwner()
-
-    def test_funky_member_ids_1(self):
-        mid = self.mid
-        minfo = (mid, 'pw', ['Member'], [])
-
-        # Create a new User
-        self.pas._doAddUser(*minfo)
-        self.mt.createMemberArea, (mid)
-
-    def test_funky_member_ids_2(self):
-        # Forward-slash is not allowed
-        mid = self.mid + '/'
-        minfo = (mid, 'pw', ['Member'], [])
-
-        # Create a new User
-        self.pas._doAddUser(*minfo)
-        self.mt.createMemberArea(mid)
-
-    def test_memberareaCreationFlag_respected(self):
-        self.pas._doAddUser('foo', 'pw', ['Member'], [])
-        self.pas._doAddUser('bar', 'pw', ['Member'], [])
-
-        self.assertFalse('foo' in self.portal.Members)
-        self.assertFalse('bar' in self.portal.Members)
-
-        self.mt.createMemberarea('foo')
-        self.assertTrue('foo' in self.portal.Members)
-
-        self.mt.memberareaCreationFlag = 0
-        self.mt.createMemberArea('bar')
-        self.assertFalse('bar' in self.portal.Members)
-
-
-class TestMembershipTool(base.TestCase, WarningInterceptor):
-
-    def afterSetUp(self):
-        self.membership = self.portal.portal_membership
-        self.groups = self.portal.portal_groups
-        self._trap_warning_output()
-
-    def test_interface(self):
-        from zope.interface.verify import verifyClass
-        verifyClass(IMembershipTool, MembershipTool)
-
-    def addMember(self, username, fullname, email, roles, last_login_time):
-        self.membership.addMember(username, 'secret', roles, [])
-        member = self.membership.getMemberById(username)
-        member.setMemberProperties({
-            'fullname': fullname, 'email': email,
-            'last_login_time': DateTime(last_login_time), })
-
-    def makeRealImage(self):
-        import Products.PlonePAS as ppas
-        pas_path = os.path.dirname(ppas.__file__)
-        path = os.path.join(pas_path, 'tool.gif')
-        image = open(path, 'rb')
-        image_upload = dummy.FileUpload(dummy.FieldStorage(image))
-        return image_upload
-
-    def testNoMorePersonalFolder(self):
-        # .personal folders are history
-        personal = getattr(self.folder, self.membership.personal_id, None)
-        self.assertEqual(personal, None)
-        self.assertEqual(self.membership.getPersonalFolder(TEST_USER_ID), None)
-
-    def testGetPersonalFolderIfNoHome(self):
-        # Should return None as the user has no home folder
-        members = self.membership.getMembersFolder()
-        members._delObject(TEST_USER_ID)
-        self.assertEqual(self.membership.getPersonalFolder(TEST_USER_ID), None)
-
-    def testGetPersonalPortrait(self):
-        # Should return the default portrait
-        self.assertEqual(
-            self.membership.getPersonalPortrait(TEST_USER_ID).getId(),
-            'defaultUser.png')
-
-    def testChangeOwnMemberPortrait(self):
-        # Should change the portrait image
-        # first we need a valid image
-        image = self.makeRealImage()
-        self.membership.changeMemberPortrait(image, TEST_USER_ID)
-        self.assertEqual(
-            self.membership.getPersonalPortrait(TEST_USER_ID).getId(),
-            TEST_USER_ID)
-        self.assertEqual(
-            self.membership.getPersonalPortrait(TEST_USER_ID).meta_type,
-            'Image')
-
-    def testChangeOwnMemberPortraitWithEmailUsers(self):
-        member_id = 'member2@host.com'
-        self.membership.addMember(member_id, 'pw', ['Member'], [],
-                     {'email': 'member2@host.com',
-                      'title': 'Member #2'})
-
-        self.login(member_id)
-        image = self.makeRealImage()
-        safe_member_id = self.membership._getSafeMemberId(member_id)
-
-        self.membership.changeMemberPortrait(image, member_id)
-        self.assertEqual(
-            self.membership.getPersonalPortrait(member_id).getId(),
-            safe_member_id)
-        self.assertEqual(
-            self.membership.getPersonalPortrait(member_id).meta_type,
-            'Image')
-
-    def testCannotChangeOtherMemberPortrait(self):
-        # A normal member should not be able to change the portrait of
-        # another member.
-        image = self.makeRealImage()
-        self.membership.addMember('joe', 'secret', ['Member'], [])
-        self.assertRaises(Unauthorized, self.membership.changeMemberPortrait,
-                          image, 'joe')
-
-    def testChangeMemberPortraitAsManager(self):
-        # Managers should be able to change the portrait of another
-        # member.
-        image = self.makeRealImage()
-        self.membership.addMember('joe', 'secret', ['Member'], [])
-        self.setRoles(['Manager'])
-        # This should not raise Unauthorized:
-        self.membership.changeMemberPortrait(image, 'joe')
-        self.assertEqual(self.membership.getPersonalPortrait('joe').getId(),
-                         'joe')
-        self.assertEqual(self.membership.getPersonalPortrait('joe').meta_type,
-                         'Image')
-
-    def testDeleteOwnPersonalPortrait(self):
-        # Should delete the portrait image
-        image = self.makeRealImage()
-        self.membership.changeMemberPortrait(image, TEST_USER_ID)
-        self.assertEqual(
-            self.membership.getPersonalPortrait(TEST_USER_ID).getId(),
-            TEST_USER_ID)
-        self.membership.deletePersonalPortrait(TEST_USER_ID)
-        self.assertEqual(
-            self.membership.getPersonalPortrait(TEST_USER_ID).getId(),
-            'defaultUser.png')
-
-    def testCannotDeleteOtherPersonalPortrait(self):
-        # A normal member should not be able to delete the portrait of
-        # another member.
-        image = self.makeRealImage()
-        self.membership.addMember('joe', 'secret', ['Member'], [])
-        self.setRoles(['Manager'])
-        self.membership.changeMemberPortrait(image, 'joe')
-        self.setRoles(['Member'])
-        self.assertRaises(Unauthorized, self.membership.deletePersonalPortrait,
-                          'joe')
-
-    def testDeleteOtherPersonalPortraitAsManager(self):
-        # Managers should be able to change the portrait of another
-        # member.
-        image = self.makeRealImage()
-        self.membership.addMember('joe', 'secret', ['Member'], [])
-        self.setRoles(['Manager'])
-        self.membership.changeMemberPortrait(image, 'joe')
-        self.membership.deletePersonalPortrait('joe')
-        self.assertEqual(self.membership.getPersonalPortrait('joe').getId(),
-                        'defaultUser.png')
-
-    def testGetPersonalPortraitWithoutPassingId(self):
-        # Should return the logged in users portrait if no id is given
-        image = self.makeRealImage()
-        self.membership.changeMemberPortrait(image, TEST_USER_ID)
-        self.assertEqual(self.membership.getPersonalPortrait().getId(),
-                         TEST_USER_ID)
-        self.assertEqual(self.membership.getPersonalPortrait().meta_type,
-                         'Image')
-
-    def testPortraitForNonStandardUserId(self):
-        # Some characters in a user id can give problems for getting
-        # or saving a portrait, especially '-', '+', '@'.
-        image = self.makeRealImage()
-        user_id = 'bob-jones+test@example.org'
-        safe_id = self.membership._getSafeMemberId(user_id)
-        self.assertEqual(safe_id, 'bob--jones-2Btest-40example.org')
-        self.membership.addMember(user_id, 'secret', ['Member'], [])
-        self.login(user_id)
-
-        # Should return the default portrait
-        self.assertEqual(
-            self.membership.getPersonalPortrait(user_id).getId(),
-            'defaultUser.png')
-
-        # Change your own portrait.
-        self.membership.changeMemberPortrait(image, user_id)
-        self.assertEqual(self.membership.getPersonalPortrait().getId(),
-                         safe_id)
-        self.assertEqual(self.membership.getPersonalPortrait().meta_type,
-                         'Image')
-
-        # Other users should be able to see your portrait.
-        self.login(TEST_USER_NAME)
-        self.assertEqual(
-            self.membership.getPersonalPortrait(user_id).getId(),
-            safe_id)
-        self.assertEqual(
-            self.membership.getPersonalPortrait(user_id).meta_type,
-            'Image')
-
-        # You can delete your own portrait.
-        self.login(user_id)
-        self.membership.deletePersonalPortrait(user_id)
-        self.assertEqual(
-            self.membership.getPersonalPortrait(user_id).getId(),
-            'defaultUser.png')
-
-        # Managers should be able to change the portrait of another
-        # member and delete it.
-        manager_image = self.makeRealImage()
-        self.loginAsPortalOwner()
-        # This should not raise Unauthorized:
-        self.membership.changeMemberPortrait(manager_image, user_id)
-        self.assertEqual(self.membership.getPersonalPortrait(user_id).getId(),
-                         safe_id)
-        self.membership.deletePersonalPortrait(user_id)
-        self.assertEqual(self.membership.getPersonalPortrait(user_id).getId(),
-                        'defaultUser.png')
-
-    def testListMembers(self):
-        # Should return the members list
-        members = self.membership.listMembers()
-        self.assertEqual(len(members), 1)
-        self.assertEqual(members[0].getId(), TEST_USER_ID)
-
-    def testListMembersSkipsGroups(self):
-        # Should only return real members, not groups
-        uf = self.portal.acl_users
-        self.groups.addGroup('Foo')
-        self.groups.addGroup('Bar')
-        self.assertEqual(len(uf.getUserNames()), 1)
-        members = self.membership.listMembers()
-        self.assertEqual(len(members), 1)
-        self.assertEqual(members[0].getId(), TEST_USER_ID)
-
-    def testListMemberIds(self):
-        # Should return the members ids list
-        memberids = self.membership.listMemberIds()
-        self.assertEqual(len(memberids), 1)
-        self.assertEqual(memberids[0], TEST_USER_ID)
-
-    def testListMemberIdsSkipsGroups(self):
-        # Should only return real members, not groups
-        uf = self.portal.acl_users
-        self.groups.addGroup('Foo')
-        self.groups.addGroup('Bar')
-        self.assertEqual(len(uf.getUserNames()), 1)
-        memberids = self.membership.listMemberIds()
-        self.assertEqual(len(memberids), 1)
-        self.assertEqual(memberids[0], TEST_USER_ID)
-
-    def testCurrentPassword(self):
-        # Password checking should work
-        self.assertTrue(self.membership.testCurrentPassword('secret'))
-        self.assertFalse(self.membership.testCurrentPassword('geheim'))
-
-    def testSetPassword(self):
-        # Password should be changed
-        self.membership.setPassword('geheim')
-        self.assertTrue(self.membership.testCurrentPassword('geheim'))
-
-    def testSetPasswordIfAnonymous(self):
-        # Anonymous should not be able to change password
-        self.logout()
-        try:
-            self.membership.setPassword('geheim')
-        except BadRequest:
-            import sys
-            e, v, tb = sys.exc_info()
-            del tb
-            if str(v) == 'Not logged in.':
-                pass
-            else:
-                raise
-
-    def testSetPasswordAndKeepGroups(self):
-        # Password should be changed and user must not change group membership
-        group2 = 'g2'
-        groups = self.groups
-        groups.addGroup(group2, None, [], [])
-        group = groups.getGroupById(group2)
-        self.loginAsPortalOwner()
-        group.addMember(TEST_USER_ID)
-        self.login(TEST_USER_NAME)  # Back to normal
-        ugroups = self.portal.acl_users.getUserById(TEST_USER_ID).getGroups()
-        self.membership.setPassword('geheim')
-        self.assertTrue(
-            self.portal.acl_users.getUserById(TEST_USER_ID).getGroups()
-                == ugroups)
-
-    def testGetMemberById(self):
-        # This should work for portal users,
-        self.assertNotEqual(self.membership.getMemberById(TEST_USER_ID), None)
-        self.assertEqual(self.membership.getMemberById('foo'), None)
-        self.assertNotEqual(self.membership.getMemberById(SITE_OWNER_NAME), None)
-
-    def testGetMemberByIdIsWrapped(self):
-        member = self.membership.getMemberById(TEST_USER_ID)
-        self.assertNotEqual(member, None)
-        self.assertEqual(member.__class__.__name__, 'MemberData')
-        self.assertEqual(member.aq_parent.__class__.__name__, 'PloneUser')
-
-    def testGetAuthenticatedMember(self):
-        member = self.membership.getAuthenticatedMember()
-        self.assertEqual(member.getUserName(), TEST_USER_NAME)
-
-    def testGetAuthenticatedMemberIsWrapped(self):
-        member = self.membership.getAuthenticatedMember()
-        self.assertEqual(member.getUserName(), TEST_USER_NAME)
-        self.assertEqual(member.__class__.__name__, 'MemberData')
-        self.assertEqual(member.aq_parent.__class__.__name__, 'PloneUser')
-
-    def testGetAuthenticatedMemberIfAnonymous(self):
-        self.logout()
-        member = self.membership.getAuthenticatedMember()
-        self.assertEqual(member.getUserName(), 'Anonymous User')
-
-    def testAnonymousMemberIsNotWrapped(self):
-        # Also see http://dev.plone.org/plone/ticket/1851
-        self.logout()
-        member = self.membership.getAuthenticatedMember()
-        self.assertNotEqual(member.__class__.__name__, 'MemberData')
-        self.assertEqual(member.__class__.__name__, 'SpecialUser')
-
-    def testIsAnonymousUser(self):
-        self.assertFalse(self.membership.isAnonymousUser())
-        self.logout()
-        self.assertTrue(self.membership.isAnonymousUser())
-
-    def testWrapUserWrapsBareUser(self):
-        user = self.portal.acl_users.getUserById(TEST_USER_ID)
-        # TODO: GRUF users are wrapped
-        self.assertTrue(hasattr(user, 'aq_base'))
-        user = aq_base(user)
-        user = self.membership.wrapUser(user)
-        self.assertEqual(user.__class__.__name__, 'MemberData')
-        self.assertEqual(user.aq_parent.__class__.__name__, 'PloneUser')
-        self.assertEqual(user.aq_parent.aq_parent.__class__.__name__,
-                         'PluggableAuthService')
-
-    def testWrapUserWrapsWrappedUser(self):
-        user = self.portal.acl_users.getUserById(TEST_USER_ID)
-        # TODO: GRUF users are wrapped
-        self.assertTrue(hasattr(user, 'aq_base'))
-        user = self.membership.wrapUser(user)
-        self.assertEqual(user.__class__.__name__, 'MemberData')
-        self.assertEqual(user.aq_parent.__class__.__name__, 'PloneUser')
-        self.assertEqual(user.aq_parent.aq_parent.__class__.__name__,
-                         'PluggableAuthService')
-
-    def testWrapUserDoesntWrapMemberData(self):
-        user = self.portal.acl_users.getUserById(TEST_USER_ID)
-        user.getMemberId = lambda x: 1
-        user = self.membership.wrapUser(user)
-        self.assertEqual(user.__class__.__name__, 'PloneUser')
-
-    def testWrapUserDoesntWrapAnonymous(self):
-        user = self.membership.wrapUser(nobody)
-        self.assertEqual(user.__class__.__name__, 'SpecialUser')
-
-    def testWrapUserWrapsAnonymous(self):
-        self.assertFalse(hasattr(nobody, 'aq_base'))
-        user = self.membership.wrapUser(nobody, wrap_anon=1)
-        self.assertEqual(user.__class__.__name__, 'MemberData')
-        self.assertEqual(user.aq_parent.__class__.__name__, 'SpecialUser')
-        self.assertEqual(user.aq_parent.aq_parent.__class__.__name__,
-                         'PluggableAuthService')
-
-    def testGetCandidateLocalRoles(self):
-        self.assertEqual(self.membership.getCandidateLocalRoles(self.folder),
-                         ('Owner',))
-        self.setRoles(['Member', 'Reviewer'])
-        self.assertEqual(self.membership.getCandidateLocalRoles(self.folder),
-                         ('Owner', 'Reviewer'))
-
-    def testSetLocalRoles(self):
-        self.assertTrue(
-            'Owner' in self.folder.get_local_roles_for_userid(TEST_USER_ID))
-        self.setRoles(['Member', 'Reviewer'])
-        self.membership.setLocalRoles(self.folder, [TEST_USER_ID, 'user2'],
-                                      'Reviewer')
-        self.assertEqual(self.folder.get_local_roles_for_userid(TEST_USER_ID),
-                         ('Owner', 'Reviewer'))
-        self.assertEqual(self.folder.get_local_roles_for_userid('user2'),
-                         ('Reviewer',))
-
-    def testDeleteLocalRoles(self):
-        self.setRoles(['Member', 'Reviewer'])
-        self.membership.setLocalRoles(self.folder, ['user2'], 'Reviewer')
-        self.assertEqual(self.folder.get_local_roles_for_userid('user2'),
-                         ('Reviewer',))
-        self.membership.deleteLocalRoles(self.folder, ['user2'])
-        self.assertEqual(self.folder.get_local_roles_for_userid('user2'), ())
-
-    def testGetHomeFolder(self):
-        self.assertNotEqual(self.membership.getHomeFolder(), None)
-        self.assertEqual(self.membership.getHomeFolder('user2'), None)
-
-    def testGetHomeUrl(self):
-        self.assertNotEqual(self.membership.getHomeUrl(), None)
-        self.assertEqual(self.membership.getHomeUrl('user2'), None)
-
-    def testGetAuthenticatedMemberInfo(self):
-        member = self.membership.getAuthenticatedMember()
-        member.setMemberProperties({'fullname': 'Test user'})
-        info = self.membership.getMemberInfo()
-        self.assertEqual(info['fullname'], 'Test user')
-
-    def testGetMemberInfo(self):
-        self.membership.addMember('user2', 'secret', ['Member'], [],
-                                  properties={'fullname': 'Second user'})
-        info = self.membership.getMemberInfo('user2')
-        self.assertEqual(info['fullname'], 'Second user')
-
-    def testGetCandidateLocalRolesIncludesLocalRolesOnObjectForManager(self):
-        self.folder._addRole('my_test_role')
-        self.folder.manage_setLocalRoles(TEST_USER_ID,
-                                         ('Manager', 'Owner'))
-        roles = self.membership.getCandidateLocalRoles(self.folder)
-        self.assertTrue('my_test_role' in roles,
-                        'my_test_role not in: %s' % str(roles))
-
-    def testGetCandidateLocalRolesIncludesLocalRolesOnObjectForAssignees(self):
-        self.folder._addRole('my_test_role')
-        self.folder.manage_setLocalRoles(TEST_USER_ID,
-                                         ('my_test_role', 'Owner'))
-        roles = self.membership.getCandidateLocalRoles(self.folder)
-        self.assertTrue('Owner' in roles)
-        self.assertTrue('my_test_role' in roles)
-        self.assertEqual(len(roles), 2)
-
-    def testGetCandidateLocalRolesForManager(self):
-        self.folder._addRole('my_test_role')
-        self.folder.manage_setLocalRoles(TEST_USER_ID, ('Manager', 'Owner'))
-        roles = self.membership.getCandidateLocalRoles(self.folder)
-        self.assertTrue('Manager' in roles)
-        self.assertTrue('Owner' in roles)
-        self.assertTrue('Reviewer' in roles)
-
-    def testGetCandidateLocalRolesForOwner(self):
-        self.folder._addRole('my_test_role')
-        roles = self.membership.getCandidateLocalRoles(self.folder)
-        self.assertTrue('Owner' in roles)
-        self.assertEqual(len(roles), 1)
-
-    def testGetCandidateLocalRolesForAssigned(self):
-        self.folder._addRole('my_test_role')
-        self.folder.manage_setLocalRoles(TEST_USER_ID, ('Reviewer', 'Owner'))
-        roles = self.membership.getCandidateLocalRoles(self.folder)
-        self.assertTrue('Owner' in roles)
-        self.assertTrue('Reviewer' in roles)
-        self.assertEqual(len(roles), 2)
-
-    def test_bug4333_delete_user_remove_memberdata(self):
-        # delete user should delete portal_memberdata
-        memberdata = self.portal.portal_memberdata
-        self.setRoles(['Manager'])
-        self.addMember('barney', 'Barney Rubble', 'barney@bedrock.com',
-                       ['Member'], '2002-01-01')
-        barney = self.membership.getMemberById('barney')
-        self.assertEqual(barney.getProperty('email'), 'barney@bedrock.com')
-        del barney
-
-        self.membership.deleteMembers(['barney'])
-        md = memberdata._members
-        self.assertFalse('barney' in md)
-
-        # There is an _v_ variable that is killed at the end of each request
-        # which stores a temporary version of the member object, this is
-        # a problem in this test.  In fact, this test does not really
-        # demonstrate the bug, which is actually caused by the script not
-        # using the tool.
-        memberdata._v_temps = None
-
-        self.membership.addMember('barney', 'secret', ['Member'], [])
-        barney = self.membership.getMemberById('barney')
-        self.assertNotEqual(barney.getProperty('fullname'), 'Barney Rubble')
-        self.assertNotEqual(barney.getProperty('email'), 'barney@bedrock.com')
-
-    def testBogusMemberPortrait(self):
-        # Should change the portrait image
-        bad_file = dummy.File(data='<div>This is a lie!!!</div>',
-                              headers={'content_type': 'image/jpeg'})
-        self.assertRaises(IOError, self.membership.changeMemberPortrait,
-                          bad_file, TEST_USER_ID)
-
-    def testGetBadMembers(self):
-        # Should list members with bad images
-        # We should not have any bad images out of the box
-        self.assertEqual(self.membership.getBadMembers(), [])
-        # Let's add one
-        bad_file = Image(id=TEST_USER_ID, title='',
-                               file=StringIO('<div>This is a lie!!!</div>'))
-        # Manually set a bad image using private methods
-        self.portal.portal_memberdata._setPortrait(bad_file, TEST_USER_ID)
-        self.assertEqual(self.membership.getBadMembers(), [TEST_USER_ID])
-        # Try an empty image
-        empty_file = Image(id=TEST_USER_ID, title='', file=StringIO(''))
-        self.portal.portal_memberdata._setPortrait(empty_file, TEST_USER_ID)
-        self.assertEqual(self.membership.getBadMembers(), [])
-        # And a good image
-        self.membership.changeMemberPortrait(self.makeRealImage(),
-                                             TEST_USER_ID)
-        self.assertEqual(self.membership.getBadMembers(), [])
-
-    def beforeTearDown(self):
-        self._free_warning_output()
-
-
-class TestCreateMemberarea(base.TestCase):
-
-    def afterSetUp(self):
-        self.membership = self.portal.portal_membership
-        self.membership.addMember('user2', 'secret', ['Member'], [])
-
-    def testCreateMemberarea(self):
-        # Should create a memberarea for user2
-        if self.membership.memberareaCreationFlag == True:
-            members = self.membership.getMembersFolder()
-            self.membership.createMemberarea('user2')
-            memberfolder = self.membership.getHomeFolder('user2')
-            self.assertTrue(memberfolder,
-                            'createMemberarea failed to create memberarea')
-            # member area creation should be on by default
-            self.assertTrue(self.membership.getMemberareaCreationFlag())
-
-    def testCreatMemberareaUsesCurrentUser(self):
-        if self.membership.memberareaCreationFlag == True:
-            # Should create a memberarea for user2
-            self.login('user2')
-            self.membership.createMemberarea()
-            memberfolder = self.membership.getHomeFolder('user2')
-            self.assertTrue(
-                memberfolder,
-                'createMemberarea failed to create memberarea for current '
-                    'user')
-        else:
-            pass
-
-    def testNoMemberareaIfNoMembersFolder(self):
-        # Should not create a memberarea if the Members folder is missing
-        self.portal._delObject('Members')
-        self.membership.createMemberarea('user2')
-        memberfolder = self.membership.getHomeFolder('user2')
-        self.assertFalse(memberfolder,
-                    'createMemberarea unexpectedly created a memberarea')
-
-    def testNoMemberareaIfMemberareaExists(self):
-        # Should not attempt to create a memberarea if a memberarea already
-        # exists
-        self.membership.createMemberarea('user2')
-        # The second call should do nothing (not cause an error)
-        self.membership.createMemberarea('user2')
-
-    def testNotifyScriptIsCalled(self):
-        # The notify script should be called
-        if self.membership.memberareaCreationFlag == True:
-            self.portal.notifyMemberAreaCreated = dummy.Raiser(dummy.Error)
-            self.assertRaises(dummy.Error, self.membership.createMemberarea,
-                              'user2')
-
-    def testCreateMemberareaAlternateName(self):
-        # Alternate method name 'createMemberaArea' should work
-        if self.membership.memberareaCreationFlag == True:
-            members = self.membership.getMembersFolder()
-            self.membership.createMemberArea('user2')
-            memberfolder = self.membership.getHomeFolder('user2')
-            self.assertTrue(memberfolder,
-                            'createMemberArea failed to create memberarea')
-
-    def testCreateMemberareaAlternateType(self):
-        # Should be able to create another type instead of a normal Folder
-        if self.membership.memberareaCreationFlag == True:
-            self.membership.setMemberAreaType('Document')
-            self.membership.createMemberarea('user2')
-            memberfolder = self.membership.getHomeFolder('user2')
-            self.assertEqual(memberfolder.getPortalTypeName(), 'Document')
-
-    def testCreateMemberareaWhenDisabled(self):
-        # Should not create a member area
-        self.membership.setMemberareaCreationFlag = False
-        self.assertFalse(self.membership.getMemberareaCreationFlag())
-        self.membership.createMemberarea('user2')
-        memberfolder = self.membership.getHomeFolder('user2')
-        self.assertFalse(memberfolder,
-                    'createMemberarea created memberarea despite flag')
-
-
-class TestMemberareaSetup(base.TestCase):
-
-    def afterSetUp(self):
-        self.membership = self.portal.portal_membership
-        self.membership.addMember('user2', 'secret', ['Member'], [])
-        self.membership.createMemberarea('user2')
-        self.home = self.membership.getHomeFolder('user2')
-
-    def testMemberareaIsFolder(self):
-        if self.membership.memberareaCreationFlag == True:
-            # Memberarea should be a folder
-            self.assertEqual(self.home.meta_type, 'ATFolder')
-            self.assertEqual(self.home.portal_type, 'Folder')
-
-    def testMemberareaIsOwnedByMember(self):
-        if self.membership.memberareaCreationFlag == True:
-            # Memberarea should be owned by member
-            try:
-                owner_info = self.home.getOwnerTuple()
-            except AttributeError:
-                owner_info = self.home.getOwner(info=1)
-            self.assertEqual(owner_info[0], [PLONE_SITE_ID, 'acl_users'])
-            self.assertEqual(owner_info[1], 'user2')
-            self.assertEqual(len(self.home.get_local_roles()), 1)
-            self.assertEqual(self.home.get_local_roles_for_userid('user2'),
-                             ('Owner',))
-
-    def testMemberareaIsCataloged(self):
-        if self.membership.memberareaCreationFlag == True:
-            # Memberarea should be cataloged
-            catalog = self.portal.portal_catalog
-            self.assertTrue(catalog(id='user2', Type='Folder', Title="user2"),
-                            "Could not find user2's home folder in the "
-                            "catalog")
-
-    def testHomePageNotExists(self):
-        if self.membership.memberareaCreationFlag == True:
-            # Should not have an index_html document anymore
-            self.assertFalse('index_html' in self.home)
-
-
-class TestSearchForMembers(base.TestCase, WarningInterceptor):
-
-    def afterSetUp(self):
-        self.memberdata = self.portal.portal_memberdata
-        self.membership = self.portal.portal_membership
-        # Don't let default_user disturb results
-        self.portal.acl_users._doDelUsers([TEST_USER_ID])
-        # Add some members
-        self.addMember('fred', 'Fred Flintstone',
-                       'fred@bedrock.com', ['Member', 'Reviewer'],
-                       '2002-01-01')
-        self.addMember('barney', 'Barney Rubble',
-                       'barney@bedrock.com', ['Member'],
-                       '2002-01-01')
-        self.addMember('brubble', 'Bambam Rubble',
-                       'bambam@bambam.net', ['Member'],
-                       '2003-12-31')
-        # MUST reset this
-        self.memberdata._v_temps = None
-        self._trap_warning_output()
-
-    def addMember(self, username, fullname, email, roles, last_login_time):
-        self.membership.addMember(username, 'secret', roles, [])
-        member = self.membership.getMemberById(username)
-        member.setMemberProperties({
-            'fullname': fullname,
-            'email': email,
-            'last_login_time': DateTime(last_login_time), })
-
-    def testSearchById(self):
-        # Should search id and fullname
-        search = self.membership.searchForMembers
-        self.assertEqual(len(search(name='brubble')), 0)
-        self.assertEqual(len(search(name='barney')), 1)
-        self.assertEqual(len(search(name='rubble')), 2)
-
-    def testSearchByName(self):
-        # Should search id and fullname
-        search = self.membership.searchForMembers
-        self.assertEqual(len(search(name='rubble')), 2)
-        self.assertEqual(len(search(name='stone')), 1)
-
-    def testSearchByEmail(self):
-        search = self.membership.searchForMembers
-        self.assertEqual(len(search(email='bedrock')), 2)
-        self.assertEqual(len(search(email='bambam')), 1)
-
-    def testSearchByRoles(self):
-        search = self.membership.searchForMembers
-        self.assertEqual(len(search(roles=['Member'])), 3)
-        self.assertEqual(len(search(roles=['Reviewer'])), 1)
-
-    def testSearchByNameAndEmail(self):
-        search = self.membership.searchForMembers
-        self.assertEqual(len(search(name='rubble', email='bedrock')), 1)
-        self.assertEqual(len(search(name='bambam', email='bedrock')), 0)
-
-    def testSearchByNameAndRoles(self):
-        search = self.membership.searchForMembers
-        self.assertEqual(len(search(name='fred', roles=['Reviewer'])), 1)
-        self.assertEqual(len(search(name='fred', roles=['Manager'])), 0)
-
-    def testSearchByEmailAndRoles(self):
-        search = self.membership.searchForMembers
-        self.assertEqual(len(search(email='fred', roles=['Reviewer'])), 1)
-        self.assertEqual(len(search(email='fred', roles=['Manager'])), 0)
-
-    def testSearchByRequestObj(self):
-        search = self.membership.searchForMembers
-        self.addMember(u'jürgen', u'Jürgen Internationalist',
-                       'juergen@example.com', ['Member'],
-                       '2014-02-03')
-
-        self.assertEqual(len(search(
-            REQUEST=dict(name=u'jürgen'))), 1)
-
-        ptool = getUtility(IPropertiesTool)
-        ptool._setProperty('default_charset', 'iso8859-1')
-        self.assertEqual(len(search(
-            REQUEST=dict(name=u'jürgen'.encode('iso8859-1')))), 1)
-
-    def beforeTearDown(self):
-        self._free_warning_output()
-
-
-class TestDefaultUserAndPasswordNotChanged(base.TestCase):
-    # A test for a silly transaction/persistency bug in PlonePAS
-
-    def afterSetUp(self):
-        self.membership = self.portal.portal_membership
-
-    def testDefaultUserAndPasswordUnchanged(self):
-        member = self.membership.getAuthenticatedMember()
-        self.assertEqual(member.getUserName(), TEST_USER_NAME)
-        self.assertTrue(self.membership.testCurrentPassword(TEST_USER_PASSWORD))
-        self.assertFalse(self.membership.testCurrentPassword('geheim'))
-
-
-class TestMethodProtection(base.TestCase):
-    # MembershipTool is missing security declarations
-    # http://dev.plone.org/plone/ticket/5432
-
-    _unprotected = (
-        'changeMemberPortrait',
-        'deletePersonalPortrait',
-        'testCurrentPassword',
-        'searchForMembers',
-    )
-
-    def afterSetUp(self):
-        self.membership = self.portal.portal_membership
-
-    def assertUnprotected(self, object, method):
-        self.logout()
-        object.restrictedTraverse(method)
-
-    def assertProtected(self, object, method):
-        self.logout()
-        self.assertRaises(Unauthorized, object.restrictedTraverse, method)
-
-    for method in _unprotected:
-        exec "def testUnprotected_%s(self):" \
-             "    self.assertProtected(self.membership, '%s')" \
-                % (method, method)
-
-        exec "def testMemberAccessible_%s(self):" \
-             "    self.membership.restrictedTraverse('%s')" % (method, method)
-
-
-class TestMemberInfoView(base.TestCase):
-
-    def afterSetUp(self):
-        self.membership = self.portal.portal_membership
-        self.view = PASMemberView(self.portal, self.portal.REQUEST)
-
-    def testMemberInfoViewForAuthenticated(self):
-        member = self.membership.getAuthenticatedMember()
-        member.setMemberProperties({'fullname': 'Test user'})
-        info = self.view.info()
-        self.assertEqual(info['username'], 'test-user')
-        self.assertEqual(info['fullname'], 'Test user')
-        self.assertEqual(info['name_or_id'], 'Test user')
-
-    def testGetMemberInfoViewForMember(self):
-        self.membership.addMember('user2', 'secret', ['Member'], [],
-                                  properties={'fullname': 'Second user'})
-        info = self.view.info('user2')
-        self.assertEqual(info['username'], 'user2')
-        self.assertEqual(info['fullname'], 'Second user')
-        self.assertEqual(info['name_or_id'], 'Second user')
-
-    def testGetMemberInfoViewForNonMember(self):
-        # When content is owned by a user who has meanwhile been
-        # removed, we do not want to throw an exception when asking
-        # for his member info.
-        self.assertFalse(self.membership.getMemberById('charon'))
-        info = self.view.info('charon')
-        self.assertEqual(info['username'], 'charon')
-        self.assertEqual(info['fullname'], '')
-        self.assertEqual(info['name_or_id'], 'charon')
-
-    def testGetMemberInfoViewForAnonymous(self):
-        self.logout()
-        self.assertTrue(self.membership.isAnonymousUser())
-        info = self.view.info()
-        self.assertEqual(info['username'], 'Anonymous User')
-        self.assertEqual(info['fullname'], None)
-        self.assertEqual(info['name_or_id'], 'Anonymous User')
-
-    def testSetGroupsWithUserNameIdDifference(self):
-        pas = self.portal['acl_users']
-        self.portal.portal_groups.addGroup('Editors', [], [])
-        self.setGroups(['Editors'], name=TEST_USER_ID)
-        self.login(TEST_USER_NAME)
-        user = getSecurityManager().getUser()
-        self.assertTrue('Editors' in getGroupsForPrincipal(user, pas['plugins']))
-        self.login()
-
-    def testSetGroupsWithSameUserNameAndId(self):
-        pas = self.portal['acl_users']
-        self.portal.portal_groups.addGroup('Editors', [], [])
-        self.setGroups(['Editors'])
-        user = getSecurityManager().getUser()
-        self.assertTrue('Editors' in getGroupsForPrincipal(user, pas['plugins']))
-
diff --git a/Products/PlonePAS/tests/test_properties.py b/Products/PlonePAS/tests/test_properties.py
deleted file mode 100644
index ec26262..0000000
--- a/Products/PlonePAS/tests/test_properties.py
+++ /dev/null
@@ -1,279 +0,0 @@
-import unittest
-
-from Products.CMFCore.utils import getToolByName
-from Products.PluggableAuthService.interfaces.plugins \
-    import IUserEnumerationPlugin
-
-from Products.PlonePAS.plugins.property import ZODBMutablePropertyProvider
-from Products.PlonePAS.tests import base
-
-
-class PropertiesTest(base.TestCase):
-
-    def test_user_properties(self):
-        mt = getToolByName(self.portal, 'portal_membership')
-        md = getToolByName(self.portal, 'portal_memberdata')
-
-        # Create a new Member
-        mt.addMember('user1', 'u1', ['Member'], [],
-                     {'email': 'user1@host.com',
-                      'fullname': 'User #1'})
-        member = mt.getMemberById('user1')
-        self.assertFalse(member is None)
-
-        # Assert user doesn't have the property yet
-        self.assertFalse(member.hasProperty('age'))
-
-        # Add new property
-        md.manage_addProperty('age', 20, 'int')
-
-        # Assert user has the property now
-        self.assertTrue(member.hasProperty('age'))
-
-        # Get the property, should have the default value
-        got = member.getProperty('age', None)
-        expected = 20
-        self.assertEqual(got, expected)
-
-        # get a handle on the member
-        member = mt.getMemberById('user1')
-
-        # Set some member properties. Needs to be logged in as the user.
-        self.login('user1')
-        member.setMemberProperties({'age': 30, 'fullname': 'User #1 Is Cool',
-                                    'email': 'user1@anotherhost.qa'})
-
-        # Check the properties have been set
-        got = member.getProperty('age', None)
-        expected = 30
-        self.assertEqual(got, expected)
-
-        got = member.getProperty('fullname', None)
-        expected = 'User #1 Is Cool'
-        self.assertEqual(got, expected)
-
-        got = member.getProperty('email', None)
-        expected = 'user1@anotherhost.qa'
-        self.assertEqual(got, expected)
-
-        # Delete the property
-        md.manage_delProperties(ids=('age',))
-
-        # re-get the member to reflect the new memberdata schema
-        member = mt.getMemberById('user1')
-
-        # Assert property is gone
-        self.assertFalse(member.hasProperty('age'))
-
-        # Get the property, should return default (None)
-        got = member.getProperty('age', None)
-        expected = None
-        self.assertEqual(got, expected)
-
-        # Other properties should still be there.
-        got = member.getProperty('fullname', None)
-        expected = 'User #1 Is Cool'
-        self.assertEqual(got, expected)
-
-        got = member.getProperty('email', None)
-        expected = 'user1@anotherhost.qa'
-        self.assertEqual(got, expected)
-
-    def test_group_properties(self):
-        gt = getToolByName(self.portal, 'portal_groups')
-        gd = getToolByName(self.portal, 'portal_groupdata')
-
-        self.loginAsPortalOwner()
-
-        # Create a new Group
-        gt.addGroup('group1', ['Reviewer'], [],
-                     {'email': 'group1@host.com',
-                      'title': 'Group #1'})
-        group = gt.getGroupById('group1')
-        self.assertFalse(group is None)
-
-        # Assert group doesn't have the property yet
-        self.assertFalse(group.hasProperty('karma'))
-
-        # Add new property
-        gd.manage_addProperty('karma', 20, 'int')
-
-        # get group again to re-create with new groupdata schema
-        group = gt.getGroupById('group1')
-
-        # Assert group has the property now
-        self.assertTrue(group.hasProperty('karma'))
-
-        # Get the property, should have the default value
-        got = group.getProperty('karma', None)
-        expected = 20
-
-        self.assertEqual(got, expected)
-
-        # Set some group properties
-        group.setGroupProperties({'karma': 30, 'title': 'Group #1 Is Cool',
-                                  'email': 'group1@anotherhost.qa'})
-
-        # Check the properties have been set
-        got = group.getProperty('karma', None)
-        expected = 30
-        self.assertEqual(got, expected)
-
-        got = group.getProperty('title', None)
-        expected = 'Group #1 Is Cool'
-        self.assertEqual(got, expected)
-
-        got = group.getProperty('email', None)
-        expected = 'group1@anotherhost.qa'
-        self.assertEqual(got, expected)
-
-        # Delete the property
-        gd.manage_delProperties(ids=('karma',))
-
-        # get group again to re-create with new groupdata schema
-        group = gt.getGroupById('group1')
-
-        # Assert property is gone
-        self.assertFalse(group.hasProperty('karma'))
-
-        # Get the property, should return default (None)
-        got = group.getProperty('karma', None)
-        expected = None
-        self.assertEqual(got, expected)
-
-        # Other properties should still be there.
-        got = group.getProperty('title', None)
-        expected = 'Group #1 Is Cool'
-        self.assertEqual(got, expected)
-
-        got = group.getProperty('email', None)
-        expected = 'group1@anotherhost.qa'
-        self.assertEqual(got, expected)
-
-    def test_schema_for_mutable_property_provider(self):
-        """Add a schema to a ZODBMutablePropertyProvider.
-        """
-
-        # Schema is list of tuples with name, type (string), value.
-        # From the types it seems only 'lines' is handled differently.
-        address_schema = [
-            ('addresses', 'lines', ['Here', 'There']),
-            ('city', 'str', 'Somewhere'),
-            ('telephone', 'int', 1234567),
-            ]
-
-        # This used to give a ValueError, so we just check that it
-        # does not.
-        provider = ZODBMutablePropertyProvider(
-            'address_plugin', "Address Plugin", schema=address_schema)
-
-        # When this test passes, we are happy already, but let's add a
-        # few more basic tests.
-
-        # Create a new Member
-        mt = getToolByName(self.portal, 'portal_membership')
-        mt.addMember('user1', 'u1', ['Member'], [],
-                     {'email': 'user1@host.com',
-                      'fullname': 'User #1'})
-        member = mt.getMemberById('user1')
-        sheet = provider.getPropertiesForUser(member)
-        self.assertEqual(
-            sheet.propertyIds(), ['addresses', 'city', 'telephone'])
-        self.assertEqual(sheet.propertyInfo('city'),
-                         {'type': 'str', 'id': 'city', 'mode': ''})
-        self.assertEqual(sheet.getProperty('addresses'), ('Here', 'There'))
-
-
-class PropertySearchTest(base.TestCase):
-
-    def afterSetUp(self):
-        self.mt = getToolByName(self.portal, 'portal_membership')
-        self.md = getToolByName(self.portal, 'portal_memberdata')
-        self.gt = getToolByName(self.portal, 'portal_groups')
-
-        # Create a new Member
-        self.mt.addMember('member1', 'pw', ['Member'], [],
-                     {'email': 'member1@host.com',
-                      'title': 'Member #1'})
-        member = self.mt.getMemberById('member1')
-        self.assertFalse(member is None)
-
-        self.mt.addMember('member2', 'pw', ['Member'], [],
-                     {'email': 'user2@otherhost.com',
-                      'fullname': 'User #2'})
-        member = self.mt.getMemberById('member2')
-        self.assertFalse(member is None)
-
-        # Add a Group to make sure searchUsers isn't returning them in results.
-        self.gt.addGroup('group1', title="Group 1")
-        group = self.gt.getGroupById('group1')
-        self.assertFalse(group is None)
-
-        self.pas = getToolByName(self.portal, "acl_users")
-        for plugin in self.pas.plugins \
-                          .getAllPlugins('IUserEnumerationPlugin')['active']:
-            if plugin != 'mutable_properties':
-                self.pas.plugins.deactivatePlugin(IUserEnumerationPlugin,
-                                                  plugin)
-
-    def testPluginActivated(self):
-        plugins = self.pas.plugins \
-                      .getAllPlugins('IUserEnumerationPlugin')['active']
-        self.assertEqual(plugins, ('mutable_properties',))
-
-    def testEmptySearch(self):
-        results = self.pas.searchUsers()
-        self.assertEqual(len(results), 2)
-
-    def testInexactStringSearch(self):
-        results = self.pas.searchUsers(email="something@somewhere.tld")
-        self.assertEqual(results, ())
-
-        results = self.pas.searchUsers(email="member1@host.com",
-                                       exact_match=False)
-        results = [info['userid'] for info in results]
-        self.assertEqual(results, ['member1'])
-
-        results = self.pas.searchUsers(email="@host.com", exact_match=False)
-        results = [info['userid'] for info in results]
-        self.assertEqual(results, ['member1'])
-
-        results = self.pas.searchUsers(email="member1@host.com",
-                                       exact_match=True)
-        results = [info['userid'] for info in results]
-        self.assertEqual(results, ['member1'])
-
-        results = self.pas.searchUsers(email="@host.com", exact_match=True)
-        results = [info['userid'] for info in results]
-        self.assertEqual(results, [])
-
-    def testBooleanSearch(self):
-        results = self.pas.searchUsers(visible_ids=True)
-        results = [info['userid'] for info in results]
-        self.assertEqual(results, [])
-
-        results = self.pas.searchUsers(visible_ids=False)
-        results = [info['userid'] for info in results]
-        self.assertEqual(results, ['member1', 'member2'])
-
-    def testGroupsNotReturnedByEnumerateUsers(self):
-        """Check to make sure that groups aren't returned by a enumerateUsers
-           call.
-           See http://dev.plone.org/plone/ticket/9435"""
-        results = self.pas.searchUsers()
-        resultIds = [a['id'] for a in results]
-        self.assertFalse('group1' in resultIds)
-
-    def testSearchEmptyId(self):
-        self.assertEqual(self.pas.mutable_properties.enumerateUsers(id=''), ())
-        self.assertEqual(
-                self.pas.mutable_properties.enumerateUsers(login=''), ())
-
-    def testCantSearchByIdOrLogin(self):
-        # we can't search by id
-        results = self.pas.searchUsers(id='member1')
-        self.assertEqual(results, ())
-        # or login
-        results = self.pas.searchUsers(login='member1')
-        self.assertEqual(results, ())
-
diff --git a/Products/PlonePAS/tests/test_role_plugin.py b/Products/PlonePAS/tests/test_role_plugin.py
deleted file mode 100644
index 3c76941..0000000
--- a/Products/PlonePAS/tests/test_role_plugin.py
+++ /dev/null
@@ -1,87 +0,0 @@
-# -*- coding: utf-8 -*-
-# $Id$
-"""Tests for Products.PlonePAS.plugins.role.GroupAwareRoleManager"""
-
-import unittest
-
-from Products.PluginRegistry.PluginRegistry import PluginRegistry
-from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
-from Products.PluggableAuthService.plugins.tests.helpers import (
-    FauxPAS, DummyUser, makeRequestAndResponse)
-from Products.PluggableAuthService.PluggableAuthService \
-    import _PLUGIN_TYPE_INFO
-from Products.PluggableAuthService.interfaces.plugins import IGroupsPlugin
-from Products.PlonePAS.tests import base
-from zope.interface import implements
-
-
-class FauxGroupsPlugin(BasePlugin):
-    implements(IGroupsPlugin)
-
-    def getGroupsForPrincipal(self, principal, request=None):
-        return principal._groups
-
-
-class GroupAwareRoleManagerTests(base.TestCase):
-    """Roles manager that takes care of goup of principal"""
-
-    def _getTargetClass(self):
-
-        from Products.PlonePAS.plugins.role import GroupAwareRoleManager
-        return GroupAwareRoleManager
-
-    def _makeOne(self, id='test', *args, **kw):
-
-        plugin = self._getTargetClass()(id=id, *args, **kw)
-        # We need to bind a fake request to this plugin
-        request, dummy_response = makeRequestAndResponse()
-        setattr(plugin, 'REQUEST', request)
-        return plugin
-
-    def test_roles_for_control_panel(self):
-        """There's a special case, the users control panel for which
-        we should never grant to users the roles they have got through
-        the groups they belong.
-        In that intent, the control panels view pushes
-        '__ignore_group_roles__' = True
-        in the request.
-        """
-        root = FauxPAS()
-
-        # Add a minimal PluginRegistry with a mock IGroupsPlugin, because the
-        # roles plugin depends on it:
-        root._setObject('plugins', PluginRegistry(_PLUGIN_TYPE_INFO))
-        root._setObject('groups', FauxGroupsPlugin())
-        root['plugins'].activatePlugin(IGroupsPlugin, 'groups')
-
-        garm = self._makeOne('garm').__of__(root)
-
-        # 2 roles
-        garm.addRole('foo_role')
-        garm.addRole('bar_role')
-
-        # Group 'somegroup' has 'bar_role'
-        garm.assignRoleToPrincipal('bar_role', 'somegroup')
-
-        # 'johndoe' has 'foo_role'
-        johndoe = DummyUser('johndoe', ('somegroup',))
-        garm.assignRoleToPrincipal('foo_role', 'johndoe')
-
-        # 'johndoe' should have 'foo_role' and 'bar_roles'
-        got = garm.getRolesForPrincipal(johndoe)
-        expected = ['foo_role', 'bar_role']
-        self.assertEqual(set(got), set(expected))
-
-        # For the users control panel, johndoe has only the 'foo_role'
-        garm.REQUEST.set('__ignore_group_roles__', True)
-        got = garm.getRolesForPrincipal(johndoe)
-        self.assertEqual(got, ('foo_role',))
-
-        # Confirm we can get only the inherited roles
-        garm.REQUEST.set('__ignore_group_roles__', False)
-        garm.REQUEST.set('__ignore_direct_roles__', True)
-        got = garm.getRolesForPrincipal(johndoe)
-        self.assertEqual(got, ('bar_role',))
-
-        return
-
diff --git a/Products/PlonePAS/tests/test_views.py b/Products/PlonePAS/tests/test_views.py
deleted file mode 100644
index 6347c5b..0000000
--- a/Products/PlonePAS/tests/test_views.py
+++ /dev/null
@@ -1,21 +0,0 @@
-# -*- encoding: utf-8 -*-
-
-from Products.PlonePAS.tests import base
-
-
-class TestPASSearchView(base.TestCase):
-
-    def test_sort(self):
-        pas_search = self.portal.restrictedTraverse('@@pas_search')
-        values = [{'title': u'Sociologie'}, {'title': u'Économie'},
-                  {'title': u'anthropologie'}]
-        sorted_values = pas_search.sort(values, 'title')
-        # do not modify original
-        self.assertEqual(values,
-                         [{'title': u'Sociologie'}, {'title': u'Économie'},
-                          {'title': u'anthropologie'}])
-        # sorted here
-        self.assertEqual(sorted_values,
-                         [{'title': u'anthropologie'}, {'title': u'Économie'},
-                          {'title': u'Sociologie'}])
-
diff --git a/Products/PlonePAS/tool.gif b/Products/PlonePAS/tool.gif
deleted file mode 100644
index 2d866bb..0000000
Binary files a/Products/PlonePAS/tool.gif and /dev/null differ
diff --git a/Products/PlonePAS/tools/__init__.py b/Products/PlonePAS/tools/__init__.py
deleted file mode 100644
index 4287ca8..0000000
--- a/Products/PlonePAS/tools/__init__.py
+++ /dev/null
@@ -1 +0,0 @@
-#
\ No newline at end of file
diff --git a/Products/PlonePAS/tools/groupdata.py b/Products/PlonePAS/tools/groupdata.py
deleted file mode 100644
index 74c3110..0000000
--- a/Products/PlonePAS/tools/groupdata.py
+++ /dev/null
@@ -1,524 +0,0 @@
-from zope.interface import implements
-
-from Acquisition import aq_base
-from Acquisition import aq_inner
-from Acquisition import aq_parent
-from AccessControl import ClassSecurityInfo
-from AccessControl import Unauthorized
-from AccessControl import Permissions
-from AccessControl import getSecurityManager
-from AccessControl.requestmethod import postonly
-from BTrees.OOBTree import OOBTree
-from App.class_init import InitializeClass
-from OFS.SimpleItem import SimpleItem
-from OFS.PropertyManager import PropertyManager
-from ZPublisher.Converters import type_converters
-
-from Products.CMFCore.utils import getToolByName
-from Products.CMFCore.utils import registerToolInterface
-from Products.CMFCore.utils import UniqueObject
-from Products.PluggableAuthService.interfaces.authservice \
-        import IPluggableAuthService
-from Products.PluggableAuthService.PluggableAuthService \
-        import _SWALLOWABLE_PLUGIN_EXCEPTIONS
-
-from Products.PlonePAS.interfaces.group import IGroupManagement
-from Products.PlonePAS.interfaces.group import IGroupDataTool
-from Products.PlonePAS.interfaces.group import IGroupData
-from Products.PlonePAS.interfaces.capabilities import IManageCapabilities
-from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
-from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
-from Products.PlonePAS.tools.memberdata import MemberData
-from Products.PlonePAS.utils import CleanupTemp
-
-import logging
-
-logger = logging.getLogger('PlonePAS')
-_marker = object()
-
-
-class GroupDataTool(UniqueObject, SimpleItem, PropertyManager):
-    """This tool wraps group objects, allowing transparent access to
-    properties.
-    """
-
-    id = 'portal_groupdata'
-    meta_type = "PlonePAS GroupData Tool"
-    toolicon = 'tool.gif'
-    implements(IGroupDataTool)
-
-    _v_temps = None
-    _properties = ({'id': 'title', 'type': 'string', 'mode': 'wd'},)
-    security = ClassSecurityInfo()
-
-    def __init__(self):
-        self._members = OOBTree()
-        # Create the default properties.
-        self._setProperty('description', '', 'text')
-        self._setProperty('email', '', 'string')
-
-    def wrapGroup(self, g):
-        """Returns an object implementing the GroupData interface."""
-
-        id = g.getId()
-        members = self._members
-        if not id in members:
-            # Get a temporary member that might be
-            # registered later via registerMemberData().
-            temps = self._v_temps
-            if temps is not None and id in temps:
-                portal_group = temps[id]
-            else:
-                base = aq_base(self)
-                portal_group = GroupData(base, id)
-                if temps is None:
-                    self._v_temps = {id: portal_group}
-                    if hasattr(self, 'REQUEST'):
-                        self.REQUEST._hold(CleanupTemp(self))
-                else:
-                    temps[id] = portal_group
-        else:
-            portal_group = members[id]
-        # Return a wrapper with self as containment and
-        # the user as context.
-        return portal_group.__of__(self).__of__(g)
-
-    security.declarePrivate('registerGroupData')
-    def registerGroupData(self, g, id):
-        '''
-        Adds the given member data to the _members dict.
-        This is done as late as possible to avoid side effect
-        transactions and to reduce the necessary number of
-        entries.
-        '''
-        self._members[id] = aq_base(g)
-
-
-InitializeClass(GroupDataTool)
-registerToolInterface('portal_groupdata', IGroupDataTool)
-
-
-class GroupData(SimpleItem):
-
-    implements(IGroupData, IManageCapabilities)
-
-    security = ClassSecurityInfo()
-
-    id = None
-    _tool = None
-
-    def __init__(self, tool, id):
-        self.id = id
-        # Make a temporary reference to the tool.
-        # The reference will be removed by notifyModified().
-        self._tool = tool
-
-    def _getGRUF(self,):
-        return self.acl_users
-
-    security.declarePrivate('notifyModified')
-    def notifyModified(self):
-        # Links self to parent for full persistence.
-        tool = getattr(self, '_tool', None)
-        if tool is not None:
-            del self._tool
-            tool.registerGroupData(self, self.getId())
-
-    security.declarePublic('getGroup')
-    def getGroup(self):
-        """ Returns the actual group implementation. Varies by group
-        implementation (GRUF/Nux/et al). In GRUF this is a user object."""
-        # The user object is our context, but it's possible for
-        # restricted code to strip context while retaining
-        # containment.  Therefore we need a simple security check.
-        parent = aq_parent(self)
-        bcontext = aq_base(parent)
-        bcontainer = aq_base(aq_parent(aq_inner(self)))
-        if bcontext is bcontainer or not hasattr(bcontext, 'getUserName'):
-            raise 'GroupDataError', "Can't find group data"
-        # Return the user object, which is our context.
-        return parent
-
-    def getTool(self):
-        return aq_parent(aq_inner(self))
-
-    security.declarePublic("getGroupMemberIds")
-    def getGroupMemberIds(self):
-        """
-        Return a list of group member ids
-        """
-        return map(lambda x: x.getMemberId(), self.getGroupMembers())
-
-    security.declarePublic("getAllGroupMemberIds")
-    def getAllGroupMemberIds(self):
-        """
-        Return a list of group member ids
-        """
-        return map(lambda x: x.getMemberId(), self.getAllGroupMembers())
-
-    security.declarePublic('getGroupMembers')
-    def getGroupMembers(self):
-        """
-        Returns a list of the portal_memberdata-ish members of the group.
-        This doesn't include TRANSITIVE groups/users.
-        """
-        md = self.portal_memberdata
-        gtool = self.portal_groups
-        ret = []
-        for u_name in gtool.getGroupMembers(self.getId()):
-            usr = self._getGRUF().getUserById(u_name)
-            # getUserById from
-            #   Products.PluggableAuthService.PluggableAuthService
-            # The returned object is not wrapped, we wrapped it below
-            if not usr:
-                usr = self._getGRUF().getGroupById(u_name)
-                # getGroupById from Products.PlonePAS.pas
-                # The returned object is already wrapped
-                if not usr:
-                    logger.debug("Group has a non-existing principal %s"
-                                    % u_name)
-                    continue
-                ret.append(usr)
-            else:
-                ret.append(md.wrapUser(usr))
-        return ret
-
-    security.declarePublic('getAllGroupMembers')
-    def getAllGroupMembers(self):
-        """
-        Returns a list of the portal_memberdata-ish members of the group.
-        This will include transitive groups / users
-        """
-        md = self.portal_memberdata
-        ret = []
-        for u_name in self.getGroup().getMemberIds():
-            usr = self._getGRUF().getUserById(u_name)
-            if not usr:
-                usr = self._getGRUF().getGroupById(u_name)
-                if not usr:
-                    logger.debug("Group has a non-existing principal %s"
-                                    % u_name)
-                    continue
-                ret.append(usr)
-            else:
-                ret.append(md.wrapUser(usr))
-        return ret
-
-    def _getGroup(self):
-        """Get the underlying group object in a PAS-acceptable way.
-        (I don't even know why there's the two different ways for GRUF. Speed?)
-        """
-        return self.getGroup()
-
-    security.declarePrivate("canAdministrateGroup")
-    def canAdministrateGroup(self):
-        """
-        Return true if the #current# user can administrate this group
-        """
-        user = getSecurityManager().getUser()
-        tool = self.getTool()
-        portal = getToolByName(tool, 'portal_url').getPortalObject()
-
-        # Has manager users pemission?
-        if user.has_permission(Permissions.manage_users, portal):
-            return True
-
-        # Is explicitly mentioned as a group administrator?
-        managers = self.getProperty('delegated_group_member_managers', ())
-        if user.getId() in managers:
-            return True
-
-        # Belongs to a group which is explicitly mentionned as a group
-        # administrator
-        meth = getattr(user, "getAllGroupNames", None)
-        if meth:
-            groups = meth()
-        else:
-            groups = ()
-        for v in groups:
-            if v in managers:
-                return True
-
-        # No right to edit this: we complain.
-        return False
-
-    security.declarePublic('addMember')
-    @postonly
-    def addMember(self, id, REQUEST=None):
-        """ Add the existing member with the given id to the group"""
-        if not self.canAdministrateGroup():
-            raise Unauthorized("You cannot add a member to the group.")
-
-        plugins = self._getPlugins()
-        managers = plugins.listPlugins(IGroupManagement)
-        for mid, manager in managers:
-            try:
-                if manager.addPrincipalToGroup(id, self.getId()):
-                    break
-            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-                pass
-
-    security.declarePublic('removeMember')
-    @postonly
-    def removeMember(self, id, REQUEST=None):
-        """Remove the member with the provided id from the group.
-        """
-        if not self.canAdministrateGroup():
-            raise Unauthorized("You cannot remove a member from the group.")
-
-        plugins = self._getPlugins()
-        managers = plugins.listPlugins(IGroupManagement)
-        for mid, manager in managers:
-            try:
-                if manager.removePrincipalFromGroup(id, self.getId()):
-                    break
-            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-                pass
-
-    security.declareProtected(Permissions.manage_users, 'setProperties')
-    def setProperties(self, properties=None, **kw):
-        """Allows the manager group to set his/her own properties.
-        Accepts either keyword arguments or a mapping for the "properties"
-        argument.
-        """
-        if properties is None:
-            properties = kw
-        return self.setGroupProperties(properties)
-
-    security.declareProtected(Permissions.manage_users, 'setGroupProperties')
-    def setGroupProperties(self, mapping):
-        """PAS-specific method to set the properties of a group.
-        """
-        sheets = None
-
-        if not IPluggableAuthService.providedBy(self.acl_users):
-            # Defer to base impl in absence of PAS, a PAS group, or
-            # property sheets
-            return self._gruf_setGroupProperties(mapping)
-        else:
-            # It's a PAS! Whee!
-            group = self.getGroup()
-            sheets = getattr(group, 'getOrderedPropertySheets', lambda: [])()
-
-            # We won't always have PlonePAS groups, due to acquisition,
-            # nor are guaranteed property sheets
-            if not sheets:
-                # Defer to base impl if we have a PAS but no property
-                # sheets.
-                return self._gruf_setGroupProperties(mapping)
-
-        # If we got this far, we have a PAS and some property sheets.
-        # XXX track values set to defer to default impl
-        # property routing?
-        modified = False
-        for k, v in mapping.items():
-            for sheet in sheets:
-                if not sheet.hasProperty(k):
-                    continue
-                if IMutablePropertySheet.providedBy(sheet):
-                    sheet.setProperty(group, k, v)
-                    modified = True
-                else:
-                    raise RuntimeError("Mutable property provider "
-                                       "shadowed by read only provider")
-        if modified:
-            self.notifyModified()
-
-    def _gruf_setGroupProperties(self, mapping):
-        '''Sets the properties of the member.
-        '''
-        # Sets the properties given in the MemberDataTool.
-        tool = self.getTool()
-        for id in tool.propertyIds():
-            if id in mapping:
-                if not id in self.__class__.__dict__:
-                    value = mapping[id]
-                    if type(value) == type(''):
-                        proptype = tool.getPropertyType(id) or 'string'
-                        if proptype in type_converters:
-                            value = type_converters[proptype](value)
-                    setattr(self, id, value)
-
-        # Hopefully we can later make notifyModified() implicit.
-        self.notifyModified()
-
-    security.declarePublic('getProperties')
-    def getProperties(self):
-        """ Return the properties of this group. Properties are as usual
-            in Zope.
-        """
-        tool = self.getTool()
-        ret = {}
-        for pty in tool.propertyIds():
-            try:
-                ret[pty] = self.getProperty(pty)
-            except ValueError:
-                # We ignore missing ptys
-                continue
-        return ret
-
-    security.declarePublic('getProperty')
-    def getProperty(self, id, default=None):
-        """PAS-specific method to fetch a group's properties. Looks
-        through the ordered property sheets.
-        """
-        group = self.getGroup()
-        sheets = getattr(group, 'getOrderedPropertySheets', lambda: [])()
-
-        # If we made this far, we found a PAS and some property sheets.
-        for sheet in sheets:
-            if sheet.hasProperty(id):
-                # Return the first one that has the property.
-                return sheet.getProperty(id)
-        # we won't always have PlonePAS groups, due to acquisition,
-        # nor are guaranteed property sheets
-        # Couldn't find the property in the property sheets. Try to
-        # delegate back to the base implementation.
-
-        tool = self.getTool()
-        base = aq_base(self)
-
-        # Then, check the user object, the tool, and attrs of myself for a
-        # value:
-        user_value = getattr(aq_base(self.getGroup()), id, _marker)
-        tool_value = tool.getProperty(id, _marker)
-        value = getattr(base, id, _marker)
-
-        # Take the first of the above that is filled out:
-        for v in [user_value, tool_value, value]:
-            if v is not _marker:
-                return v
-
-        return default
-
-    def __str__(self):
-        return self.getGroupId()
-
-    security.declarePublic("isGroup")
-    def isGroup(self):
-        """
-        isGroup(self,) => Return true if this is a group.
-        Will always return true for groups.
-        As MemberData objects do not support this method, it is quite useless
-        by now.
-        So one can use groupstool.isGroup(g) instead to get this information.
-        """
-        return 1
-
-    ### Group object interface ###
-
-    security.declarePublic('getGroupName')
-    def getGroupName(self):
-        return self.getName()
-
-    security.declarePublic('getGroupId')
-    def getGroupId(self):
-        """Get the ID of the group. The ID can be used, at least from
-        Python, to get the user from the user's UserDatabase.
-        Within Plone, all group ids are UNPREFIXED."""
-        return self.getGroup().getId()
-
-    def getGroupTitleOrName(self):
-        """Get the Title property of the group. If there is none
-        then return the name """
-        title = self.getProperty('title', None)
-        return title or self.getGroupName()
-
-    security.declarePublic("getMemberId")
-    def getMemberId(self):
-        """This exists only for a basic user/group API compatibility
-        """
-        return self.getGroupId()
-
-    security.declarePublic('getRoles')
-    def getRoles(self):
-        """Return the list of roles assigned to a user."""
-        return self.getGroup().getRoles()
-
-    security.declarePublic('getRolesInContext')
-    def getRolesInContext(self, object):
-        """Return the list of roles assigned to the user,  including local
-        roles assigned in context of the passed in object."""
-        return self.getGroup().getRolesInContext(object)
-
-    security.declarePublic('getDomains')
-    def getDomains(self):
-        """Return the list of domain restrictions for a user"""
-        return self.getGroup().getDomains()
-
-    security.declarePublic('has_role')
-    def has_role(self, roles, object=None):
-        """Check to see if a user has a given role or roles."""
-        return self.getGroup().has_role(roles, object)
-
-    ## GRUF 3.2 methods...
-
-    def getUserName(self):
-        return self.getName()
-    getUserNameWithoutGroupPrefix = getUserName
-
-    ## IManageCapabilities methods
-    def canDelete(self):
-        """True iff user can be removed from the Plone UI.
-        """
-        # IGroupManagement provides removeGroup
-        plugins = self._getPlugins()
-        managers = plugins.listPlugins(IGroupManagement)
-        if managers:
-            for mid, manager in managers:
-                if (IDeleteCapability.providedBy(manager) and
-                        manager.allowDeletePrincipal(self.getId())):
-                    return True
-        return False
-
-    def canPasswordSet(self):
-        """Always false for groups, which have no password.
-        """
-        return False
-
-    def passwordInClear(self):
-        """True iff password can be retrieved in the clear (not hashed.)
-
-        False for PAS. It provides no API for getting passwords,
-        though it would be possible to add one in the future.
-        """
-        return False
-
-    def _groupdataHasProperty(self, prop_name):
-        gdata = getToolByName(self, 'portal_groupdata', None)
-        if gdata:
-            return gdata.hasProperty(prop_name)
-        return 0
-
-    def canWriteProperty(self, prop_name):
-        """True iff the group property named in 'prop_name'
-        can be changed.
-        """
-        # this looks almost exactly like in memberdata. refactor?
-        if not IPluggableAuthService.providedBy(self.acl_users):
-            # not PAS; Groupdata is writable
-            return self._groupdataHasProperty(prop_name)
-        else:
-            # it's PAS
-            group = self.getGroup()
-            sheets = getattr(group, 'getOrderedPropertySheets', lambda: [])()
-            for sheet in sheets:
-                if not sheet.hasProperty(prop_name):
-                    continue
-                if IMutablePropertySheet.providedBy(sheet):
-                    return 1
-                else:
-                    break  # shadowed by read-only
-        return 0
-
-    canAddToGroup = MemberData.canAddToGroup.im_func
-    canRemoveFromGroup = MemberData.canRemoveFromGroup.im_func
-    canAssignRole = MemberData.canAssignRole.im_func
-
-    ## plugin getters
-
-    security.declarePrivate('_getPlugins')
-    def _getPlugins(self):
-        return self.acl_users.plugins
-
-InitializeClass(GroupData)
diff --git a/Products/PlonePAS/tools/groups.py b/Products/PlonePAS/tools/groups.py
deleted file mode 100644
index c560e93..0000000
--- a/Products/PlonePAS/tools/groups.py
+++ /dev/null
@@ -1,442 +0,0 @@
-import logging
-
-from zope.interface import implements
-
-from Acquisition import aq_base
-from AccessControl import ClassSecurityInfo
-from AccessControl.requestmethod import postonly
-from AccessControl.User import nobody
-from App.class_init import InitializeClass
-from OFS.SimpleItem import SimpleItem
-from ZODB.POSException import ConflictError
-
-from Products.CMFCore.utils import getToolByName
-from Products.CMFCore.utils import registerToolInterface
-from Products.CMFCore.utils import UniqueObject
-
-from Products.PluggableAuthService.interfaces.plugins \
-    import IRoleAssignerPlugin
-from Products.PluggableAuthService.PluggableAuthService \
-    import _SWALLOWABLE_PLUGIN_EXCEPTIONS
-
-from Products.PlonePAS.interfaces import group as igroup
-from Products.PlonePAS.permissions import AddGroups
-from Products.PlonePAS.permissions import ManageGroups
-from Products.PlonePAS.permissions import DeleteGroups
-from Products.PlonePAS.permissions import ViewGroups
-from Products.PlonePAS.permissions import SetGroupOwnership
-from Products.PlonePAS.utils import getGroupsForPrincipal
-
-
-logger = logging.getLogger('PluggableAuthService')
-
-
-class NotSupported(Exception):
-    pass
-
-
-class GroupsTool(UniqueObject, SimpleItem):
-    """ This tool accesses group data through a acl_users object.
-
-    It can be replaced with something that groups member data in a
-    different way.
-    """
-
-    implements(igroup.IGroupTool)
-
-    id = 'portal_groups'
-    meta_type = 'PlonePAS Groups Tool'
-    security = ClassSecurityInfo()
-    toolicon = 'tool.gif'
-
-    ##
-    # basic group mgmt
-    ##
-
-    security.declareProtected(AddGroups, 'addGroup')
-    @postonly
-    def addGroup(self, id, roles=[], groups=[], properties=None,
-                 REQUEST=None, *args, **kw):
-        """Create a group, with the supplied id, roles, and domains.
-
-        Underlying user folder must support adding users via the usual
-        Zope API.
-        """
-        group = None
-        success = 0
-        managers = self._getGroupManagers()
-        if roles is None:
-            roles = []
-        if groups is None:
-            groups = []
-
-        # Check to see if a user with the id already exists fail if it does
-        results = self.acl_users.searchPrincipals(id=id, exact_match=True)
-        if results:
-            return 0
-
-        if not managers:
-            raise NotSupported('No plugins allow for group management')
-        for mid, manager in managers:
-            success = manager.addGroup(id, title=kw.get('title', id),
-                                       description=kw.get('description', ''))
-            if success:
-                self.setRolesForGroup(id, roles)
-                for g in groups:
-                    manager.addPrincipalToGroup(g, id)
-                break
-
-        if success:
-            group = self.getGroupById(id)
-            group.setGroupProperties(properties or kw)
-
-        return success
-
-    security.declareProtected(ManageGroups, 'editGroup')
-    @postonly
-    def editGroup(self, id, roles=None, groups=None, REQUEST=None,
-                  *args, **kw):
-        """Edit the given group with the supplied roles.
-
-        Passwords for groups seem to be irrelevant.
-        PlonePAS doesn't deal with domains either.
-
-        If group is not present, returns without exception.
-        """
-        g = self.getGroupById(id)
-        if not g:
-            raise KeyError('Trying to edit a non-existing group: %s' % id)
-
-        # Update title/description properties of original group
-        gTools = self._getGroupTools()
-        if not gTools:
-            raise NotSupported('No plugins allow for both group management '
-                               'and introspection')
-
-        for tid, tool in gTools:
-            if id in tool.getGroupIds():
-                tool.updateGroup(id, title=kw.get('title'),
-                                     description=kw.get('description'))
-                break
-
-        if roles is not None:
-            self.setRolesForGroup(id, roles)
-
-        g.setGroupProperties(kw)
-        if groups:
-            # remove absent groups
-            groupset = set(groups)
-            p_groups = set(self.getGroupsForPrincipal(g))
-            rmgroups = p_groups - groupset
-            for gid in rmgroups:
-                if gid != 'AuthenticatedUsers':
-                    self.removePrincipalFromGroup(g, gid)
-
-            # add groups
-            try:
-                groupmanagers = self.acl_users.plugins.listPlugins(
-                                    igroup.IGroupManagement)
-            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-                logger.exception('Plugin listing error')
-                groupmanagers = ()
-
-            for group in groups:
-                for gm_id, gm in groupmanagers:
-                    try:
-                        if gm.addPrincipalToGroup(id, group):
-                            break
-                    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
-                        logger.exception('AuthenticationPlugin %s error'
-                                            % gm_id)
-
-    security.declareProtected(DeleteGroups, 'removeGroup')
-    @postonly
-    def removeGroup(self, group_id, REQUEST=None):
-        """Remove a single group.
-        """
-        retval = False
-        managers = self._getGroupManagers()
-        if not managers:
-            raise NotSupported('No plugins allow for group management')
-
-        for mid, manager in managers:
-            if manager.removeGroup(group_id):
-                retval = True
-
-        return retval
-
-    security.declareProtected(DeleteGroups, 'removeGroups')
-    @postonly
-    def removeGroups(self, ids, REQUEST=None):
-        """Remove the group in the provided list (if possible).
-        """
-        for gid in ids:
-            self.removeGroup(gid)
-
-    security.declareProtected(ManageGroups, 'setRolesForGroup')
-    @postonly
-    def setRolesForGroup(self, group_id, roles=(), REQUEST=None):
-        rmanagers = self._getPlugins().listPlugins(IRoleAssignerPlugin)
-        if not (rmanagers):
-            raise NotImplementedError('There is no plugin that can '
-                                      'assign roles to groups')
-        for rid, rmanager in rmanagers:
-            rmanager.assignRolesToPrincipal(roles, group_id)
-
-    ##
-    # basic principal mgmt
-    ##
-
-    security.declareProtected(ManageGroups, 'addPrincipalToGroup')
-    @postonly
-    def addPrincipalToGroup(self, principal_id, group_id, REQUEST=None):
-        managers = self._getGroupManagers()
-        if not managers:
-            raise NotSupported('No plugins allow for group management')
-        for mid, manager in managers:
-            if manager.addPrincipalToGroup(principal_id, group_id):
-                return True
-        return False
-
-    security.declareProtected(ManageGroups, 'removePrincipalFromGroup')
-    @postonly
-    def removePrincipalFromGroup(self, principal_id, group_id, REQUEST=None):
-        managers = self._getGroupManagers()
-        if not managers:
-            raise NotSupported('No plugins allow for group management')
-        for mid, manager in managers:
-            if manager.removePrincipalFromGroup(principal_id, group_id):
-                return True
-        return False
-
-
-    ##
-    # group getters
-    ##
-
-    security.declareProtected(ViewGroups, 'getGroupById')
-    def getGroupById(self, group_id):
-        group = self.acl_users.getGroup(group_id)
-        if group is not None:
-            group = self.wrapGroup(group)
-        return group
-
-    security.declareProtected(ManageGroups, 'searchGroups')
-    def searchGroups(self, *args, **kw):
-        return self.acl_users.searchGroups(*args, **kw)
-
-    def searchForGroups(self, REQUEST={}, **kw):
-        """Search for groups by keyword.
-        The following properties can be searched:
-        - name
-        #- email
-        #- title
-
-        Only id/title search is implemented for groups. Is the rest of
-        this junk used anywhere?
-
-        This is an 'AND' request.
-
-        When it takes 'name' as keyword (or in REQUEST) and searches on
-        Full name and id.
-
-        Simple name searches are "fast".
-        """
-        acl_users = self.acl_users
-        if REQUEST:
-            dict = REQUEST
-        else:
-            dict = kw
-
-        name = dict.get('name', None)
-        title_or_name = dict.get('title_or_name', None)
-        if name:
-            name = name.strip().lower()
-        if name is not None:
-            name = None
-        if title_or_name is not None:
-            name = title_or_name
-
-        md_groups = []
-        uf_groups = []
-
-        if name is not None:
-            # This will allow us to retrieve groups by their id only
-            uf_groups = acl_users.searchGroups(id=name)
-
-            # PAS allows search to return dupes. We must winnow...
-            uf_groups_new = []
-            for group in uf_groups:
-                if group not in uf_groups_new:
-                    uf_groups_new.append(group)
-            uf_groups = uf_groups_new
-
-        groups = []
-        if md_groups or uf_groups:
-            getGroupById = self.getGroupById
-
-            for groupid in md_groups:
-                groups.append(getGroupById(groupid))
-            for group in uf_groups:
-                groupid = group['groupid']
-                if groupid in md_groups:
-                    continue             # Kill dupes
-                groups.append(getGroupById(groupid))
-
-        return groups
-
-    security.declareProtected(ViewGroups, 'listGroups')
-    def listGroups(self):
-        # potentially not all groups may be found by this interface
-        # if the underlying group source doesn't support introspection
-        groups = []
-        introspectors = self._getGroupIntrospectors()
-        for iid, introspector in introspectors:
-            groups.extend(introspector.getGroups())
-        return [self.wrapGroup(elt) for elt in groups]
-
-    security.declareProtected(ViewGroups, 'getGroupIds')
-    def getGroupIds(self):
-        groups = []
-        introspectors = self._getGroupIntrospectors()
-        for iid, introspector in introspectors:
-            groups.extend(introspector.getGroupIds())
-        return groups
-
-    listGroupIds = getGroupIds
-
-    security.declareProtected(ViewGroups, 'getGroupMembers')
-    def getGroupMembers(self, group_id):
-        members = set()
-        introspectors = self._getGroupIntrospectors()
-        for iid, introspector in introspectors:
-            members.update(introspector.getGroupMembers(group_id))
-        return list(members)
-
-    security.declareProtected(ViewGroups, 'getGroupsForPrincipal')
-    def getGroupsForPrincipal(self, principal):
-        return getGroupsForPrincipal(principal, self._getPlugins())
-
-    ##
-    # plugin getters
-    ##
-
-    security.declarePrivate('_getPlugins')
-    def _getPlugins(self):
-        return self.acl_users.plugins
-
-    security.declarePrivate('_getGroupManagers')
-    def _getGroupManagers(self):
-        return self._getPlugins().listPlugins(
-            igroup.IGroupManagement
-            )
-
-    security.declarePrivate('_getGroupIntrospectors')
-    def _getGroupIntrospectors(self):
-        return self._getPlugins().listPlugins(
-            igroup.IGroupIntrospection
-            )
-
-    security.declarePrivate('_getGroupTools')
-    def _getGroupTools(self):
-        managers = self._getPlugins().listPlugins(
-                        igroup.IGroupManagement)
-        return [(id, manager) for (id, manager) in managers
-                             if igroup.IGroupIntrospection.providedBy(manager)]
-
-    ##
-    # BBB
-    ##
-
-    security.declarePublic('getGroupInfo')
-    def getGroupInfo(self, groupId):
-        """
-        Return default group info of any group
-        """
-        group = self.getGroupById(groupId)
-
-        if group is None:
-            return None
-
-        groupinfo = {'title': group.getProperty('title'),
-                     'description': group.getProperty('description')}
-
-        return groupinfo
-
-    security.declareProtected(ViewGroups, 'getGroupsByUserId')
-    def getGroupsByUserId(self, userid):
-        """Return a list of the groups the user corresponding to 'userid'
-        belongs to."""
-        user = self.acl_users.getUserById(userid)
-        if user:
-            groups = user.getGroups() or []
-        else:
-            groups = []
-        return [self.getGroupById(elt) for elt in groups]
-
-    security.declareProtected(ViewGroups, 'listGroupNames')
-    def listGroupNames(self):
-        """Return a list of the available groups' ids as entered
-        (without group prefixes)."""
-        return self.acl_users.getGroupNames()
-
-    security.declarePublic("isGroup")
-    def isGroup(self, u):
-        """Test if a user/group object is a group or not.
-        You must pass an object you get earlier with wrapUser() or wrapGroup()
-        """
-        base = aq_base(u)
-        if hasattr(base, "isGroup") and base.isGroup():
-            return 1
-        return 0
-
-    security.declareProtected(SetGroupOwnership, 'setGroupOwnership')
-    @postonly
-    def setGroupOwnership(self, group, object, REQUEST=None):
-        """Make the object  'object' owned by group 'group'
-        (a portal_groupdata-ish object).
-
-        For GRUF this is easy. Others may have to re-implement."""
-        user = group.getGroup()
-        if user is None:
-            raise ValueError("Invalid group: '%s'." % (group, ))
-        object.changeOwnership(user)
-        object.manage_setLocalRoles(user.getId(), ['Owner'])
-
-    security.declarePrivate('wrapGroup')
-    def wrapGroup(self, g, wrap_anon=0):
-        ''' Sets up the correct acquisition wrappers for a group
-        object and provides an opportunity for a portal_memberdata
-        tool to retrieve and store member data independently of
-        the user object.
-        '''
-        b = getattr(g, 'aq_base', None)
-        if b is None:
-            # u isn't wrapped at all.  Wrap it in self.acl_users.
-            b = g
-            g = g.__of__(self.acl_users)
-        if (b is nobody and not wrap_anon) or hasattr(b, 'getMemberId'):
-            # This user is either not recognized by acl_users or it is
-            # already registered with something that implements the
-            # member data tool at least partially.
-            return g
-
-        parent = self.aq_inner.aq_parent
-        base = getattr(parent, 'aq_base', None)
-        if hasattr(base, 'portal_groupdata'):
-            # Get portal_groupdata to do the wrapping.
-            gd = getToolByName(parent, 'portal_groupdata')
-            try:
-                #log("wrapping group %s" % g)
-                portal_group = gd.wrapGroup(g)
-                return portal_group
-            except ConflictError:
-                raise
-            except:
-                logger.exception('Error during wrapGroup')
-        # Failed.
-        return g
-
-
-InitializeClass(GroupsTool)
-registerToolInterface('portal_groups', igroup.IGroupTool)
diff --git a/Products/PlonePAS/tools/memberdata.py b/Products/PlonePAS/tools/memberdata.py
deleted file mode 100644
index 812b693..0000000
--- a/Products/PlonePAS/tools/memberdata.py
+++ /dev/null
@@ -1,451 +0,0 @@
-from App.class_init import InitializeClass
-from Acquisition import aq_base
-from AccessControl import ClassSecurityInfo
-
-from zope.interface import implements
-
-from Products.BTreeFolder2.BTreeFolder2 import BTreeFolder2
-from Products.CMFCore.permissions import ManagePortal
-from Products.CMFCore.utils import getToolByName
-from Products.CMFCore.MemberDataTool import MemberData as BaseMemberData
-from Products.CMFCore.MemberDataTool import MemberDataTool as BaseTool
-
-from Products.PluggableAuthService.interfaces.authservice \
-    import IPluggableAuthService
-from Products.PluggableAuthService.interfaces.plugins \
-    import IPropertiesPlugin, IRoleAssignerPlugin
-
-from Products.PlonePAS.interfaces.plugins import IUserManagement
-from Products.PlonePAS.interfaces.group import IGroupManagement
-from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
-from Products.PlonePAS.interfaces.capabilities \
-    import IDeleteCapability, IPasswordSetCapability
-from Products.PlonePAS.interfaces.capabilities \
-    import IGroupCapability, IAssignRoleCapability
-from Products.PlonePAS.interfaces.capabilities import IManageCapabilities
-from AccessControl.requestmethod import postonly
-
-_marker = object()
-
-
-class MemberDataTool(BaseTool):
-    """PAS-specific implementation of memberdata tool.
-    """
-
-    meta_type = "PlonePAS MemberData Tool"
-    security = ClassSecurityInfo()
-    toolicon = 'tool.gif'
-
-    def __init__(self):
-        BaseTool.__init__(self)
-        self.portraits = BTreeFolder2(id='portraits')
-
-    def _getPortrait(self, member_id):
-        "return member_id's portrait if you can "
-        return self.portraits.get(member_id, None)
-
-    def _setPortrait(self, portrait, member_id):
-        " store portrait which must be a raw image in _portrais "
-        if member_id in self.portraits:
-            self.portraits._delObject(member_id)
-        self.portraits._setObject(id=member_id, object=portrait)
-
-    def _deletePortrait(self, member_id):
-        " remove member_id's portrait "
-        if member_id in self.portraits:
-            self.portraits._delObject(member_id)
-
-    security.declarePrivate('pruneMemberDataContents')
-    def pruneMemberDataContents(self):
-        '''
-        Compare the user IDs stored in the member data
-        tool with the list in the actual underlying acl_users
-        and delete anything not in acl_users
-        '''
-        BaseTool.pruneMemberDataContents(self)
-        membertool = getToolByName(self, 'portal_membership')
-        portraits = self.portraits
-        user_list = membertool.listMemberIds()
-
-        for tuple in portraits.items():
-            member_id = tuple[0]
-            if member_id not in user_list:
-                self.portraits._delObject(member_id)
-
-    security.declareProtected(ManagePortal, 'purgeMemberDataContents')
-    def purgeMemberDataContents(self):
-        '''
-        Delete ALL MemberData information. This is required for us as we change
-        the MemberData class.
-        '''
-        members = self._members
-
-        for tuple in members.items():
-            member_name = tuple[0]
-            del members[member_name]
-
-        return "Done."
-
-    security.declarePrivate("updateMemberDataContents")
-    def updateMemberDataContents(self,):
-        """Update former MemberData objects to new MemberData objects
-        """
-        count = 0
-        members = self._members
-        properties = self.propertyIds()
-
-        # Scan members for old MemberData
-        for member_name, member_obj in members.items():
-            values = {}
-            if getattr(member_obj, "_is_new_kind", None):
-                continue        # Do not have to upgrade that object
-
-            # Have to upgrade. Create the values mapping.
-            for pty_name in properties:
-                user_value = getattr(member_obj, pty_name, _marker)
-                if user_value is not _marker:
-                    values[pty_name] = user_value
-
-            # Wrap a new user object of the RIGHT class
-            u = self.acl_users.getUserById(member_name, None)
-            if not u:
-                continue                # User is not in main acl_users anymore
-            self.wrapUser(u)
-
-            # Set its properties
-            mbr = self._members.get(member_name, None)
-            if not mbr:
-                raise RuntimeError("Error while upgrading user '%s'."
-                                        % (member_name, ))
-            mbr.setProperties(values, force_local=1)
-            count += 1
-
-        return count
-
-    security.declarePrivate('searchMemberDataContents')
-    def searchMemberDataContents(self, search_param, search_term):
-        """
-        Search members.
-        This is the same as CMFCore except that it doesn't check term case.
-        """
-        res = []
-
-        search_term = search_term.strip().lower()
-
-        if search_param == 'username':
-            search_param = 'id'
-
-        mtool = getToolByName(self, 'portal_membership')
-
-        for member_id in self._members.keys():
-            user_wrapper = mtool.getMemberById(member_id)
-
-            if user_wrapper is not None:
-                memberProperty = user_wrapper.getProperty
-                searched = memberProperty(search_param, None)
-
-                if searched is not None:
-                    if searched.strip().lower().find(search_term) != -1:
-
-                        res.append({'username': memberProperty('id'),
-                                    'email': memberProperty('email', '')})
-        return res
-
-    security.declarePublic('searchFulltextForMembers')
-    def searchFulltextForMembers(self, s):
-        """search for members which do have string 's' in name, email or full
-        name (if defined)
-
-        this is mainly used for the localrole form
-        """
-        s = s.strip().lower()
-        mu = getToolByName(self, 'portal_membership')
-
-        res = []
-        for member in mu.listMembers():
-            u = member.getUser()
-            if u.getUserName().lower().find(s) != -1 \
-                or member.getProperty('fullname').lower().find(s) != -1 \
-                or member.getProperty('email').lower().find(s) != -1:
-                    res.append(member)
-        return res
-
-    #### check to see if we can add users. Need to be careful here
-    #### so we do not write on read
-    def canAddMemberData(self):
-        try:
-            if self.REQUEST.REQUEST_METHOD != 'POST':
-                return False
-            if getattr(self, '_p_jar', None) and \
-                    len(self._p_jar._registered_objects) > 0:
-                # XXX do not write on read
-                return True
-        except AttributeError:
-            pass
-        return False
-
-    #### an exact copy from the base, so that we pick up the new MemberData.
-    #### wrapUser should have a MemberData factory method to over-ride (or even
-    #### set at run-time!) so that we don't have to do this.
-    def wrapUser(self, u):
-        '''
-        If possible, returns the Member object that corresponds
-        to the given User object.
-        We override this to ensure OUR MemberData class is used
-        '''
-        id = u.getId()
-        members = self._members
-        if not id in members:
-            base = aq_base(self)
-            md = MemberData(base, id)
-            if self.canAddMemberData():
-                # XXX do not write on read
-                members[id] = md
-            return md.__of__(self).__of__(u)
-        else:
-            # Return a wrapper with self as containment and
-            # the user as context.
-            return members[id].__of__(self).__of__(u)
-
-    @postonly
-    def deleteMemberData(self, member_id, REQUEST=None):
-        """ Delete member data of specified member.
-        """
-        if IPluggableAuthService.providedBy(self.acl_users):
-            # It's a PAS! Whee!
-            # XXX: can we safely assume that user name == member_id
-            plugins = self._getPlugins()
-            prop_managers = plugins.listPlugins(IPropertiesPlugin)
-            for mid, prop_manager in prop_managers:
-                # Not all PropertiesPlugins support user deletion
-                try:
-                    prop_manager.deleteUser(member_id)
-                except AttributeError:
-                    pass
-
-        # we won't always have PlonePAS users, due to acquisition,
-        # nor are guaranteed property sheets
-        members = self._members
-        if member_id in members:
-            del members[member_id]
-            return 1
-        else:
-            return 0
-
-    ## plugin getter
-    def _getPlugins(self):
-        return self.acl_users.plugins
-
-InitializeClass(MemberDataTool)
-
-
-class MemberData(BaseMemberData):
-
-    security = ClassSecurityInfo()
-    implements(IManageCapabilities)
-
-    ## setProperties uses setMemberProperties. no need to override.
-
-    def setMemberProperties(self, mapping, force_local=0):
-        """PAS-specific method to set the properties of a
-        member. Ignores 'force_local', which is not reliably present.
-        """
-        sheets = None
-
-        # We could pay attention to force_local here...
-        if not IPluggableAuthService.providedBy(self.acl_users):
-            # Defer to base impl in absence of PAS, a PAS user, or
-            # property sheets
-            return BaseMemberData.setMemberProperties(self, mapping)
-        else:
-            # It's a PAS! Whee!
-            user = self.getUser()
-            sheets = getattr(user, 'getOrderedPropertySheets', lambda: None)()
-
-            # We won't always have PlonePAS users, due to acquisition,
-            # nor are guaranteed property sheets
-            if not sheets:
-                # Defer to base impl if we have a PAS but no property
-                # sheets.
-                return BaseMemberData.setMemberProperties(self, mapping)
-
-        # If we got this far, we have a PAS and some property sheets.
-        # XXX track values set to defer to default impl
-        # property routing?
-        modified = False
-        for k, v in mapping.items():
-            if v == None:
-                continue
-            for sheet in sheets:
-                if not sheet.hasProperty(k):
-                    continue
-                if IMutablePropertySheet.providedBy(sheet):
-                    sheet.setProperty(user, k, v)
-                    modified = True
-                else:
-                    break
-                    #raise RuntimeError, ("Mutable property provider "
-                    #                     "shadowed by read only provider")
-        if modified:
-            self.notifyModified()
-
-    def getProperty(self, id, default=_marker):
-        """PAS-specific method to fetch a user's properties. Looks
-        through the ordered property sheets.
-        """
-        sheets = None
-        if not IPluggableAuthService.providedBy(self.acl_users):
-            return BaseMemberData.getProperty(self, id)
-        else:
-            # It's a PAS! Whee!
-            user = self.getUser()
-            sheets = getattr(user, 'getOrderedPropertySheets', lambda: None)()
-
-            # we won't always have PlonePAS users, due to acquisition,
-            # nor are guaranteed property sheets
-            if not sheets:
-                return BaseMemberData.getProperty(self, id, default)
-
-        # If we made this far, we found a PAS and some property sheets.
-        for sheet in sheets:
-            if sheet.hasProperty(id):
-                # Return the first one that has the property.
-                value = sheet.getProperty(id)
-                if isinstance(value, unicode):
-                    # XXX Temporarily work around the fact that
-                    # property sheets blindly store and return
-                    # unicode. This is sub-optimal and should be
-                    # dealed with at the property sheets level by
-                    # using Zope's converters.
-                    return value.encode('utf-8')
-                return value
-
-        # Couldn't find the property in the property sheets. Try to
-        # delegate back to the base implementation.
-        return BaseMemberData.getProperty(self, id, default)
-
-    def getPassword(self):
-        """Returns None. Present to avoid NotImplementedError."""
-        return None
-
-    ## IManageCapabilities methods
-
-    def canDelete(self):
-        """True iff user can be removed from the Plone UI."""
-        # IUserManagement provides doDeleteUser
-        plugins = self._getPlugins()
-        managers = plugins.listPlugins(IUserManagement)
-        for mid, manager in managers:
-            if (IDeleteCapability.providedBy(manager) and
-                    manager.allowDeletePrincipal(self.getId())):
-                return True
-        return False
-
-    def canPasswordSet(self):
-        """True iff user can change password."""
-        # IUserManagement provides doChangeUser
-        plugins = self._getPlugins()
-        managers = plugins.listPlugins(IUserManagement)
-        for mid, manager in managers:
-            if (IPasswordSetCapability.providedBy(manager) and
-                    manager.allowPasswordSet(self.getId())):
-                return True
-        return False
-
-    def passwordInClear(self):
-        """True iff password can be retrieved in the clear (not hashed.)
-
-        False for PAS. It provides no API for getting passwords,
-        though it would be possible to add one in the future.
-        """
-        return 0
-
-    def _memberdataHasProperty(self, prop_name):
-        mdata = getToolByName(self, 'portal_memberdata', None)
-        if mdata:
-            return mdata.hasProperty(prop_name)
-        return 0
-
-    def canWriteProperty(self, prop_name):
-        """True iff the member/group property named in 'prop_name'
-        can be changed.
-        """
-        if not IPluggableAuthService.providedBy(self.acl_users):
-            # not PAS; Memberdata is writable
-            return self._memberdataHasProperty(prop_name)
-        else:
-            # it's PAS
-            user = self.getUser()
-            sheets = getattr(user, 'getOrderedPropertySheets', lambda: None)()
-            if not sheets:
-                return self._memberdataHasProperty(prop_name)
-
-            for sheet in sheets:
-                if not sheet.hasProperty(prop_name):
-                    continue
-                if IMutablePropertySheet.providedBy(sheet):
-                    # BBB for plugins implementing an older version of
-                    # IMutablePropertySheet
-                    if hasattr(sheet, 'canWriteProperty'):
-                        return sheet.canWriteProperty(user, prop_name)
-                    return True
-                else:
-                    break  # shadowed by read-only
-        return False
-
-    def canAddToGroup(self, group_id):
-        """True iff member can be added to group."""
-        # IGroupManagement provides IGroupCapability
-        plugins = self._getPlugins()
-        managers = plugins.listPlugins(IGroupManagement)
-        for mid, manager in managers:
-            if (IGroupCapability.providedBy(manager) and
-                    manager.allowGroupAdd(self.getId(), group_id)):
-                return True
-        return False
-
-    def canRemoveFromGroup(self, group_id):
-        """True iff member can be removed from group."""
-        # IGroupManagement provides IGroupCapability
-        plugins = self._getPlugins()
-        managers = plugins.listPlugins(IGroupManagement)
-        for mid, manager in managers:
-            if (IGroupCapability.providedBy(manager) and
-                    manager.allowGroupRemove(self.getId(), group_id)):
-                return True
-        return False
-
-    def canAssignRole(self, role_id):
-        """True iff member can be assigned role. Role id is string."""
-        # IRoleAssignerPlugin provides IAssignRoleCapability
-        plugins = self._getPlugins()
-        managers = plugins.listPlugins(IRoleAssignerPlugin)
-        for mid, manager in managers:
-            if (IAssignRoleCapability.providedBy(manager) and
-                    manager.allowRoleAssign(self.getId(), role_id)):
-                return True
-        return False
-
-    security.declarePrivate('setSecurityProfile')
-    def setSecurityProfile(self, password=None, roles=None, domains=None):
-        """Set the user's basic security profile"""
-        u = self.getUser()
-
-        # The Zope User API is stupid, it should check for None.
-        if roles is None:
-            roles = list(u.getRoles())
-            if 'Authenticated' in roles:
-                roles.remove('Authenticated')
-        if domains is None:
-            domains = u.getDomains()
-
-        u.userFolderEditUser(u.getUserId(), password, roles, domains)
-
-    ## plugin getters
-
-    security.declarePrivate('_getPlugins')
-    def _getPlugins(self):
-        return self.acl_users.plugins
-
-
-InitializeClass(MemberData)
diff --git a/Products/PlonePAS/tools/membership.py b/Products/PlonePAS/tools/membership.py
deleted file mode 100644
index 7d9459a..0000000
--- a/Products/PlonePAS/tools/membership.py
+++ /dev/null
@@ -1,745 +0,0 @@
-import logging
-from cStringIO import StringIO
-
-import transaction
-from zope import event
-from zope.interface import implements
-
-from DateTime import DateTime
-from App.class_init import InitializeClass
-from App.special_dtml import DTMLFile
-from OFS.Image import Image
-
-from AccessControl import ClassSecurityInfo
-from AccessControl import getSecurityManager
-from AccessControl import Unauthorized
-from AccessControl.SecurityManagement import noSecurityManager
-from AccessControl.requestmethod import postonly
-from Acquisition import aq_get
-from Acquisition import aq_inner
-from Acquisition import aq_parent
-from zExceptions import BadRequest
-from ZODB.POSException import ConflictError
-
-from Products.CMFDefault.utils import decode
-from Products.CMFCore.permissions import ManagePortal
-from Products.CMFCore.permissions import ManageUsers
-from Products.CMFCore.permissions import SetOwnProperties
-from Products.CMFCore.permissions import SetOwnPassword
-from Products.CMFCore.permissions import View
-from Products.CMFCore.permissions import ListPortalMembers
-from Products.CMFCore.utils import _checkPermission
-from Products.CMFCore.utils import getToolByName
-from Products.CMFCore.MembershipTool import MembershipTool as BaseTool
-
-from Products.PlonePAS.events import UserLoggedInEvent
-from Products.PlonePAS.events import UserInitialLoginInEvent
-from Products.PlonePAS.events import UserLoggedOutEvent
-from Products.PlonePAS.interfaces import membership
-from Products.PlonePAS.utils import cleanId
-from Products.PlonePAS.utils import scale_image
-
-default_portrait = 'defaultUser.png'
-logger = logging.getLogger('PlonePAS')
-
-
-class MembershipTool(BaseTool):
-    """PAS-based customization of MembershipTool.
-    """
-
-    implements(membership.IMembershipTool)
-
-    meta_type = "PlonePAS Membership Tool"
-    toolicon = 'tool.gif'
-    personal_id = '.personal'
-    portrait_id = 'MyPortrait'
-    default_portrait = 'defaultUser.gif'
-    memberarea_type = 'Folder'
-    membersfolder_id = 'Members'
-    memberareaCreationFlag = False
-    security = ClassSecurityInfo()
-
-    user_search_keywords = ('login', 'fullname', 'email', 'exact_match',
-                            'sort_by', 'max_results')
-
-    _properties = (getattr(BaseTool, '_properties', ()) +
-                   ({'id': 'user_search_keywords',
-                     'type': 'lines',
-                     'mode': 'rw',
-                     },))
-
-    manage_options = (BaseTool.manage_options
-                        + ({'label': 'Portraits',
-                            'action': 'manage_portrait_fix'},))
-
-    # TODO I'm not quite sure why getPortalRoles is declared 'Managed'
-    #    in CMFCore.MembershipTool - but in Plone we are not so anal ;-)
-    security.declareProtected(View, 'getPortalRoles')
-
-    security.declareProtected(ManagePortal, 'manage_mapRoles')
-    manage_mapRoles = DTMLFile('../zmi/membershipRolemapping', globals())
-
-    security.declareProtected(ManagePortal, 'manage_portrait_fix')
-    manage_portrait_fix = DTMLFile('../zmi/portrait_fix', globals())
-
-    security.declareProtected(ManagePortal, 'manage_setMemberAreaType')
-    def manage_setMemberAreaType(self, type_name, REQUEST=None):
-        """ ZMI method to set the home folder type by its type name.
-        """
-        self.setMemberAreaType(type_name)
-        if REQUEST is not None:
-            REQUEST['RESPONSE'].redirect(self.absolute_url()
-                    + '/manage_mapRoles'
-                    + '?manage_tabs_message=Member+area+type+changed.')
-
-    security.declareProtected(ManagePortal, 'manage_setMembersFolderById')
-    def manage_setMembersFolderById(self, id, REQUEST=None):
-        """ ZMI method to set the members folder object by its id.
-        """
-        self.setMembersFolderById(id)
-        if REQUEST is not None:
-            REQUEST['RESPONSE'].redirect(self.absolute_url()
-                    + '/manage_mapRoles'
-                    + '?manage_tabs_message=Members+folder+id+changed.')
-
-    security.declareProtected(ManagePortal, 'setMemberAreaType')
-    def setMemberAreaType(self, type_name):
-        """ Sets the portal type to use for new home folders.
-        """
-        # No check for folderish since someone somewhere may actually want
-        # members to have objects instead of folders as home "directory".
-        self.memberarea_type = str(type_name).strip()
-
-    security.declareProtected(ManagePortal, 'setMembersFolderById')
-    def setMembersFolderById(self, id=''):
-        """ Set the members folder object by its id.
-        """
-        self.membersfolder_id = id.strip()
-
-    security.declarePublic('getMembersFolder')
-    def getMembersFolder(self):
-        """ Get the members folder object.
-        """
-        parent = aq_parent( aq_inner(self) )
-        members = getattr(parent, self.membersfolder_id, None)
-        return members
-
-    security.declarePrivate('addMember')
-    def addMember(self, id, password, roles, domains, properties=None):
-        """Adds a new member to the user folder.
-
-        Security checks will have already been performed.  Called by
-        portal_registration.  This one specific to PAS. PAS ignores
-        domains. Adding members with login_name also not yet
-        supported.
-        """
-        acl_users = self.acl_users
-        acl_users._doAddUser(id, password, roles, domains)
-
-        if properties is not None:
-            member = self.getMemberById(id)
-            member.setMemberProperties(properties)
-
-    security.declareProtected(ListPortalMembers, 'searchForMembers')
-    def searchForMembers(self, REQUEST=None, **kw):
-        """Hacked up version of Plone searchForMembers.
-
-        The following properties can be provided:
-        - name
-        - email
-        - last_login_time
-        - before_specified_time
-        - roles (any role will cause a match)
-        - groupname
-
-        This is an 'AND' request.
-
-        Simple name searches are "fast".
-        """
-        logger.debug('searchForMembers: started.')
-
-        acl_users = getToolByName(self, "acl_users")
-        md = getToolByName(self, "portal_memberdata")
-        groups_tool = getToolByName(self, "portal_groups")
-
-        if REQUEST is not None:
-            searchmap = REQUEST
-            for key, value in searchmap.items():
-                if isinstance(value, basestring):
-                    searchmap[key] = decode(value, self)
-        else:
-            searchmap = kw
-
-        # While the parameter is called name it is actually used to search a
-        # users name, which is stored in the fullname property. We need to fix
-        # that here so the right name is used when calling into PAS plugins.
-        if 'name' in searchmap:
-            searchmap['fullname'] = searchmap['name']
-            del searchmap['name']
-
-        user_search = dict([x for x in searchmap.items()
-                               if x[0] in self.user_search_keywords and x[1]])
-
-        fullname = searchmap.get('fullname', None)
-        email = searchmap.get('email', None)
-        roles = searchmap.get('roles', None)
-        last_login_time = searchmap.get('last_login_time', None)
-        before_specified_time = searchmap.get('before_specified_time', None)
-        groupname = searchmap.get('groupname', '').strip()
-
-        if fullname:
-            fullname = fullname.strip().lower()
-        if not fullname:
-            fullname = None
-        if email:
-            email = email.strip().lower()
-        if not email:
-            email = None
-
-        uf_users = []
-
-        logger.debug(
-            'searchForMembers: searching PAS '
-            'with arguments %r.' % user_search)
-        for user in acl_users.searchUsers(**user_search):
-            uid = user['userid']
-            uf_users.append(uid)
-
-        if not uf_users:
-            return []
-
-        wrap = self.wrapUser
-        getUserById = acl_users.getUserById
-
-        def dedupe(seq):
-            # Thanks http://www.peterbe.com/plog/uniqifiers-benchmark
-            seen = set()
-            seen_add = seen.add
-            # nice trick! set.add() does always return None
-            return [ x for x in seq if x not in seen and not seen_add(x)]
-
-        uf_users = dedupe(uf_users)
-        members = [getUserById(userid) for userid in uf_users]
-        members = [member for member in members if member is not None]
-
-        if (not email and
-            not fullname and
-            not roles and
-            not groupname and
-            not last_login_time):
-            logger.debug(
-                'searchForMembers: searching users '
-                'with no extra filter, immediate return.')
-            return members
-
-        # Now perform individual checks on each user
-        res = []
-        portal = getToolByName(self, 'portal_url').getPortalObject()
-
-        for member in members:
-            if groupname and groupname not in member.getGroupIds():
-                continue
-
-            if roles:
-                user_roles = member.getRoles()
-                found = 0
-                for r in roles:
-                    if r in user_roles:
-                        found = 1
-                        break
-                if not found:
-                    continue
-
-            if last_login_time:
-                last_login = member.getProperty('last_login_time', '')
-
-                if isinstance(last_login, basestring):
-                    # value is a string when member hasn't yet logged in
-                    last_login = DateTime(last_login or '2000/01/01')
-
-                if before_specified_time:
-                    if last_login >= last_login_time:
-                        continue
-                elif last_login < last_login_time:
-                    continue
-
-            res.append(member)
-
-        logger.debug('searchForMembers: finished.')
-        return res
-
-    #############
-    ## sanitize home folders (we may get URL-illegal ids)
-
-    security.declarePublic('createMemberarea')
-    def createMemberarea(self, member_id=None, minimal=None):
-        """
-        Create a member area for 'member_id' or the authenticated
-        user, but don't assume that member_id is url-safe.
-        """
-        if not self.getMemberareaCreationFlag():
-            return None
-        catalog = getToolByName(self, 'portal_catalog')
-        membership = getToolByName(self, 'portal_membership')
-        members = self.getMembersFolder()
-
-        if not member_id:
-            # member_id is optional (see CMFCore.interfaces.portal_membership:
-            #     Create a member area for 'member_id' or authenticated user.)
-            member = membership.getAuthenticatedMember()
-            member_id = member.getId()
-
-        if hasattr(members, 'aq_explicit'):
-            members = members.aq_explicit
-
-        if members is None:
-            # no members area
-            logger.debug('createMemberarea: members area does not exist.')
-            return
-
-        safe_member_id = cleanId(member_id)
-        if hasattr(members, safe_member_id):
-            # has already this member
-            logger.debug(
-                'createMemberarea: member area '
-                'for %r already exists.' % safe_member_id)
-            return
-
-        if not safe_member_id:
-            # Could be one of two things:
-            # - A Emergency User
-            # - cleanId made a empty string out of member_id
-            logger.debug(
-                'createMemberarea: empty member id '
-                '(%r, %r), skipping member area creation.' % (
-                member_id, safe_member_id))
-            return
-
-        # Create member area without security checks
-        typesTool = getToolByName(members, 'portal_types')
-        fti = typesTool.getTypeInfo(self.memberarea_type)
-        member_folder = fti._constructInstance(members, safe_member_id)
-
-        # Get the user object from acl_users
-        acl_users = getToolByName(self, "acl_users")
-        user = acl_users.getUserById(member_id)
-        if user is not None:
-            user = user.__of__(acl_users)
-        else:
-            user = getSecurityManager().getUser()
-            # check that we do not do something wrong
-            if user.getId() != member_id:
-                raise NotImplementedError(
-                        'cannot get user for member area creation')
-
-        member_object = self.getMemberById(member_id)
-
-        ## Modify member folder
-        member_folder = self.getHomeFolder(member_id)
-        # Grant Ownership and Owner role to Member
-        member_folder.changeOwnership(user)
-        member_folder.__ac_local_roles__ = None
-        member_folder.manage_setLocalRoles(member_id, ['Owner'])
-        # We use ATCT now use the mutators
-        fullname = member_object.getProperty('fullname')
-        member_folder.setTitle(fullname or member_id)
-        member_folder.reindexObject()
-
-        ## Hook to allow doing other things after memberarea creation.
-        notify_script = getattr(member_folder, 'notifyMemberAreaCreated', None)
-        if notify_script is not None:
-            notify_script()
-
-     # deal with ridiculous API change in CMF
-    security.declarePublic('createMemberArea')
-    createMemberArea = createMemberarea
-
-    security.declarePublic('getMemberInfo')
-    def getMemberInfo(self, memberId=None):
-        # Return 'harmless' Memberinfo of any member, such as Full name,
-        # Location, etc
-        if not memberId:
-            member = self.getAuthenticatedMember()
-        else:
-            member = self.getMemberById(memberId)
-
-        if member is None:
-            return None
-
-        memberinfo = {'fullname'    : member.getProperty('fullname'),
-                      'description' : member.getProperty('description'),
-                      'location'    : member.getProperty('location'),
-                      'language'    : member.getProperty('language'),
-                      'home_page'   : member.getProperty('home_page'),
-                      'username'    : member.getUserName(),
-                      'has_email'   : bool(member.getProperty('email')),
-                     }
-
-        return memberinfo
-
-    def _getSafeMemberId(self, id=None):
-        """Return a safe version of a member id.
-
-        If no id is given return the id for the currently authenticated user.
-        """
-
-        if id is None:
-            member = self.getAuthenticatedMember()
-            if not hasattr(member, 'getMemberId'):
-                return None
-            id = member.getMemberId()
-
-        return cleanId(id)
-
-    security.declarePublic('getHomeFolder')
-    def getHomeFolder(self, id=None, verifyPermission=0):
-        """ Return a member's home folder object, or None.
-
-        Specially instrumented for URL-quoted-member-id folder
-        names.
-        """
-        safe_id = self._getSafeMemberId(id)
-        if safe_id is None:
-            member = self.getAuthenticatedMember()
-            if not hasattr(member, 'getMemberId'):
-                return None
-            safe_id = member.getMemberId()
-        members = self.getMembersFolder()
-        if members:
-            try:
-                folder = members._getOb(safe_id)
-                if verifyPermission and not _checkPermission(View, folder):
-                    # Don't return the folder if the user can't get to it.
-                    return None
-                return folder
-            # KeyError added to deal with btree member folders
-            except (AttributeError, KeyError, TypeError):
-                pass
-        return None
-
-    def getHomeUrl(self, id=None, verifyPermission=0):
-        """ Return the URL to a member's home folder, or None.
-        """
-        home = self.getHomeFolder(id, verifyPermission)
-        if home is not None:
-            return home.absolute_url()
-        else:
-            return None
-
-    security.declarePublic('getPersonalFolder')
-    def getPersonalFolder(self, member_id=None):
-        """
-        returns the Personal Item folder for a member
-        if no Personal Folder exists will return None
-        """
-        home = self.getHomeFolder(member_id)
-        personal = None
-        if home:
-            personal = getattr(home, self.personal_id, None)
-        return personal
-
-    security.declarePublic('getPersonalPortrait')
-    def getPersonalPortrait(self, id=None, verifyPermission=0):
-        """Return a members personal portait.
-
-        Modified from CMFPlone version to URL-quote the member id.
-        """
-        if not id:
-            id = self.getAuthenticatedMember().getId()
-        safe_id = self._getSafeMemberId(id)
-        membertool = getToolByName(self, 'portal_memberdata')
-        portrait = membertool._getPortrait(safe_id)
-        if isinstance(portrait, str):
-            portrait = None
-        if portrait is not None:
-            if verifyPermission and not _checkPermission('View', portrait):
-                # Don't return the portrait if the user can't get to it
-                portrait = None
-        if portrait is None:
-            portal = getToolByName(self, 'portal_url').getPortalObject()
-            portrait = getattr(portal, default_portrait, None)
-
-        return portrait
-
-    security.declareProtected(SetOwnProperties, 'deletePersonalPortrait')
-    def deletePersonalPortrait(self, id=None):
-        """deletes the Portait of a member.
-        """
-        authenticated_id = self.getAuthenticatedMember().getId()
-        if not id:
-            id = authenticated_id
-        safe_id = self._getSafeMemberId(id)
-        if id != authenticated_id and not _checkPermission(
-                ManageUsers, self):
-            raise Unauthorized
-
-        membertool = getToolByName(self, 'portal_memberdata')
-        return membertool._deletePortrait(safe_id)
-
-    security.declareProtected(SetOwnProperties, 'changeMemberPortrait')
-    def changeMemberPortrait(self, portrait, id=None):
-        """update the portait of a member.
-
-        We URL-quote the member id if needed.
-
-        Note that this method might be called by an anonymous user who
-        is getting registered.  This method will then be called from
-        plone.app.users and this is fine.  When called from restricted
-        python code or with a curl command by a hacker, the
-        declareProtected line will kick in and prevent use of this
-        method.
-        """
-        authenticated_id = self.getAuthenticatedMember().getId()
-        if not id:
-            id = authenticated_id
-        safe_id = self._getSafeMemberId(id)
-        if authenticated_id and id != authenticated_id:
-            # Only Managers can change portraits of others.
-            if not _checkPermission(ManageUsers, self):
-                raise Unauthorized
-        if portrait and portrait.filename:
-            scaled, mimetype = scale_image(portrait)
-            portrait = Image(id=safe_id, file=scaled, title='')
-            membertool = getToolByName(self, 'portal_memberdata')
-            membertool._setPortrait(portrait, safe_id)
-
-    security.declareProtected(ManageUsers, 'listMembers')
-    def listMembers(self):
-        '''Gets the list of all members.
-        THIS METHOD MIGHT BE VERY EXPENSIVE ON LARGE USER FOLDERS AND MUST
-        BE USED WITH CARE! We plan to restrict its use in the future (ie.
-        force large requests to use searchForMembers instead of listMembers,
-        so that it will not be possible anymore to have a method returning
-        several hundred of users :)
-        '''
-        return BaseTool.listMembers(self)
-
-    security.declareProtected(ManageUsers, 'listMemberIds')
-    def listMemberIds(self):
-        '''Lists the ids of all members.  This may eventually be
-        replaced with a set of methods for querying pieces of the
-        list rather than the entire list at once.
-        '''
-        return self.acl_users.getUserIds()
-
-    security.declareProtected(SetOwnPassword, 'testCurrentPassword')
-    def testCurrentPassword(self, password):
-        """ test to see if password is current """
-        REQUEST = getattr(self, 'REQUEST', {})
-        member = self.getAuthenticatedMember()
-        acl_users = self._findUsersAclHome(member.getUserId())
-        if not acl_users:
-            return 0
-        return acl_users.authenticate(member.getUserName(), password, REQUEST)
-
-    def _findUsersAclHome(self, userid):
-        portal = getToolByName(self, 'portal_url').getPortalObject()
-        acl_users = portal.acl_users
-        parent = acl_users
-        while parent:
-            if acl_users.aq_explicit.getUserById(userid, None) is not None:
-                break
-            parent = aq_parent(aq_inner(parent)).aq_parent
-            acl_users = getattr(parent, 'acl_users')
-        if parent:
-            return acl_users
-        else:
-            return None
-
-    security.declareProtected(SetOwnPassword, 'setPassword')
-    def setPassword(self, password, domains=None, REQUEST=None):
-        '''Allows the authenticated member to set his/her own password.
-        '''
-        registration = getToolByName(self, 'portal_registration', None)
-        if not self.isAnonymousUser():
-            member = self.getAuthenticatedMember()
-            #self.acl_users
-            acl_users = self._findUsersAclHome(member.getUserId())
-            if not acl_users:
-                # should not possibly ever happen
-                raise BadRequest('did not find current user in any '
-                                 'user folder')
-            if registration:
-                failMessage = registration.testPasswordValidity(password)
-                if failMessage is not None:
-                    raise BadRequest(failMessage)
-
-            if domains is None:
-                domains = []
-            user = acl_users.getUserById(member.getUserId(), None)
-            # we must change the users password trough grufs changepassword
-            # to keep her  group settings
-            if hasattr(user, 'changePassword'):
-                user.changePassword(password)
-            else:
-                acl_users._doChangeUser(member.getUserId(), password,
-                                        member.getRoles(), domains)
-            if REQUEST is None:
-                REQUEST = aq_get(self, 'REQUEST', None)
-            self.credentialsChanged(password, REQUEST=REQUEST)
-        else:
-            raise BadRequest('Not logged in.')
-    setPassword = postonly(setPassword)
-
-    security.declareProtected(View, 'getCandidateLocalRoles')
-    def getCandidateLocalRoles(self, obj):
-        """ What local roles can I assign?
-            Override the CMFCore version so that we can see the local roles on
-            an object, and so that local managers can assign all roles locally.
-        """
-        member = self.getAuthenticatedMember()
-        # Use getRolesInContext as someone may be a local manager
-        if 'Manager' in member.getRolesInContext(obj):
-            # Use valid_roles as we may want roles defined only on a subobject
-            local_roles = [r for r in obj.valid_roles() if r not in
-                            ('Anonymous', 'Authenticated', 'Shared')]
-        else:
-            local_roles = [role for role in member.getRolesInContext(obj)
-                                if role not in ('Member', 'Authenticated')]
-        local_roles.sort()
-        return tuple(local_roles)
-
-    security.declareProtected(View, 'loginUser')
-    def loginUser(self, REQUEST=None):
-        """ Handle a login for the current user.
-
-        This method takes care of all the standard work that needs to be
-        done when a user logs in:
-        - clear the copy/cut/paste clipboard
-        - PAS credentials update
-        - sending a logged-in event
-        - storing the login time
-        - create the member area if it does not exist
-        """
-        user = getSecurityManager().getUser()
-        if user is None:
-            return
-
-        if self.setLoginTimes():
-            event.notify(UserInitialLoginInEvent(user))
-        else:
-            event.notify(UserLoggedInEvent(user))
-
-        if REQUEST is None:
-            REQUEST = getattr(self, 'REQUEST', None)
-        if REQUEST is None:
-            return
-
-        # Expire the clipboard
-        if REQUEST.get('__cp', None) is not None:
-            REQUEST.RESPONSE.expireCookie('__cp', path='/')
-
-        self.createMemberArea()
-
-        try:
-            pas = getToolByName(self, 'acl_users')
-            pas.credentials_cookie_auth.login()
-        except AttributeError:
-            # The cookie plugin may not be present
-            pass
-
-    security.declareProtected(View, 'logoutUser')
-    def logoutUser(self, REQUEST=None):
-        """Process a user logout.
-
-        This takes care of all the standard logout work:
-        - ask the user folder to logout
-        - expire a skin selection cookie
-        - invalidate a Zope session if there is one
-        """
-        # Invalidate existing sessions, but only if they exist.
-        sdm = getToolByName(self, 'session_data_manager', None)
-        if sdm is not None:
-                session = sdm.getSessionData(create=0)
-                if session is not None:
-                            session.invalidate()
-
-        if REQUEST is None:
-            REQUEST = getattr(self, 'REQUEST', None)
-        if REQUEST is not None:
-            pas = getToolByName(self, 'acl_users')
-            try:
-                pas.logout(REQUEST)
-            except:
-                # XXX Bare except copied from logout.cpy. This should be
-                # changed in the next Plone release.
-                pass
-
-            # Expire the skin cookie if it is not configured to persist
-            st = getToolByName(self, "portal_skins")
-            skinvar = st.getRequestVarname()
-            if skinvar in REQUEST and not st.getCookiePersistence():
-                    portal = getToolByName(self, "portal_url") \
-                                .getPortalObject()
-                    path = '/' + portal.absolute_url(1)
-                    # XXX check if this path is sane
-                    REQUEST.RESPONSE.expireCookie(skinvar, path=path)
-
-        user = getSecurityManager().getUser()
-        if user is not None:
-            event.notify(UserLoggedOutEvent(user))
-
-    security.declareProtected(View, 'immediateLogout')
-    def immediateLogout(self):
-        """ Log the current user out immediately.  Used by logout.py so that
-            we do not have to do a redirect to show the logged out status. """
-        noSecurityManager()
-
-    security.declarePublic('setLoginTimes')
-    def setLoginTimes(self):
-        """ Called by logged_in to set the login time properties
-            even if members lack the "Set own properties" permission.
-
-            The return value indicates if this is the first logged
-            login time.
-        """
-        res = False
-        if not self.isAnonymousUser():
-            member = self.getAuthenticatedMember()
-            default = DateTime('2000/01/01')
-            login_time = member.getProperty('login_time', default)
-            if login_time == default:
-                res = True
-                login_time = DateTime()
-            member.setProperties(login_time=self.ZopeTime(),
-                                 last_login_time=login_time)
-        return res
-
-    security.declareProtected(ManagePortal, 'getBadMembers')
-    def getBadMembers(self):
-        """Will search for members with bad images in the portal_memberdata
-        delete their portraits and return their member ids"""
-        memberdata = getToolByName(self, 'portal_memberdata')
-        portraits = getattr(memberdata, 'portraits', None)
-        if portraits is None:
-            return []
-        bad_member_ids = []
-        TXN_THRESHOLD = 50
-        counter = 1
-        for member_id in tuple(portraits.keys()):
-            portrait = portraits[member_id]
-            portrait_data = str(portrait.data)
-            if portrait_data == '':
-                continue
-            try:
-                import PIL
-            except ImportError:
-                raise RuntimeError('No Python Imaging Libraries (PIL) found. '
-                    'Unable to validate profile image.')
-            try:
-                img = PIL.Image.open(StringIO(portrait_data))
-            except ConflictError:
-                pass
-            except:
-                # Anything else we have a bad bad image and we destroy it
-                # and ask questions later.
-                portraits._delObject(member_id)
-                bad_member_ids.append(member_id)
-            if not counter % TXN_THRESHOLD:
-                transaction.savepoint(optimistic=True)
-            counter = counter + 1
-
-        return bad_member_ids
-
-
-InitializeClass(MembershipTool)
diff --git a/Products/PlonePAS/tools/plonetool.py b/Products/PlonePAS/tools/plonetool.py
deleted file mode 100644
index 8e3bd6a..0000000
--- a/Products/PlonePAS/tools/plonetool.py
+++ /dev/null
@@ -1,3 +0,0 @@
-# This is a backwards compatibility alias. It can be removed once Plone
-# doesn't support upgrading from Plone 2.5 anymore.
-from Products.CMFPlone.PloneTool import PloneTool
diff --git a/Products/PlonePAS/utils.py b/Products/PlonePAS/utils.py
deleted file mode 100644
index 57c6799..0000000
--- a/Products/PlonePAS/utils.py
+++ /dev/null
@@ -1,205 +0,0 @@
-from cStringIO import StringIO
-from urllib import quote as url_quote
-from urllib import unquote as url_unquote
-
-from Products.PlonePAS.config import IMAGE_SCALE_PARAMS
-from Products.PluggableAuthService.interfaces.plugins import IGroupsPlugin
-
-
-def unique(iterable):
-    d = {}
-    for i in iterable:
-        d[i] = None
-    return d.keys()
-
-
-# XXX this can probably be removed
-def getCharset(context):
-    """Returns the site default charset, or utf-8.
-    """
-    return 'utf-8'
-
-
-def cleanId(id):
-    """'url_quote' turns strange chars into '%xx', which is not a valid char
-    for ObjectManager. Here we encode '%' into '-' (and '-' into '--' as
-    escaping).
-    De-clean is possible; see 'decleanId'.
-    Assumes that id can start with non-alpha(numeric), which is true.
-    """
-    __traceback_info__ = (id,)
-    if id:
-        # note: we provide the 'safe' param to get '/' encoded
-        return url_quote(id, '').replace('-', '--').replace('%', '-')
-    return ''
-
-
-def decleanId(id):
-    """Reverse cleanId."""
-    if id:
-        id = id.replace('--', '\x00').replace('-', '%').replace('\x00', '-')
-        return url_unquote(id)
-    return ''
-
-
-def scale_image(image_file, max_size=None, default_format=None):
-    """Scales an image down to at most max_size preserving aspect ratio
-    from an input file
-
-        >>> from Products.PlonePAS import config
-        >>> import os
-        >>> from StringIO import StringIO
-        >>> from Products.PlonePAS.utils import scale_image
-        >>> from PIL import Image
-
-    Let's make a couple test images and see how it works (all are
-    100x100), the gif is palletted mode::
-
-        >>> pas_path = os.path.dirname(config.__file__)
-        >>> pjoin = os.path.join
-        >>> path = pjoin(pas_path, 'tests', 'images')
-        >>> orig_jpg = open(pjoin(path, 'test.jpg'), 'rb')
-        >>> orig_png = open(pjoin(path, 'test.png'), 'rb')
-        >>> orig_gif = open(pjoin(path, 'test.gif'), 'rb')
-
-    We'll also make some evil non-images, including one which
-    masquerades as a jpeg (which would trick OFS.Image)::
-
-        >>> invalid = StringIO('<div>Evil!!!</div>')
-        >>> sneaky = StringIO('\377\330<div>Evil!!!</div>')
-
-    OK, let's get to it, first check that our bad images fail:
-
-        >>> scale_image(invalid, (50, 50))
-        Traceback (most recent call last):
-        ...
-        IOError: cannot identify image file...
-        >>> scale_image(sneaky, (50, 50))
-        Traceback (most recent call last):
-        ...
-        IOError: cannot identify image file...
-
-    Now that that's out of the way we check on our real images to make
-    sure the format and mode are preserved, that they are scaled, and that they
-    return the correct mimetype::
-
-        >>> new_jpg, mimetype = scale_image(orig_jpg, (50, 50))
-        >>> img = Image.open(new_jpg)
-        >>> img.size
-        (50, 50)
-        >>> img.format
-        'JPEG'
-        >>> mimetype
-        'image/jpeg'
-
-        >>> new_png, mimetype = scale_image(orig_png, (50, 50))
-        >>> img = Image.open(new_png)
-        >>> img.size
-        (50, 50)
-        >>> img.format
-        'PNG'
-        >>> mimetype
-        'image/png'
-
-        >>> new_gif, mimetype = scale_image(orig_gif, (50, 50))
-        >>> img = Image.open(new_gif)
-        >>> img.size
-        (50, 50)
-        >>> img.format
-        'GIF'
-        >>> img.mode
-        'P'
-        >>> mimetype
-        'image/gif'
-
-    We should also preserve the aspect ratio by scaling to the given
-    width only unless told not to (we need to reset out files before
-    trying again though::
-
-        >>> orig_jpg.seek(0)
-        >>> new_jpg, mimetype = scale_image(orig_jpg, (70, 100))
-        >>> img = Image.open(new_jpg)
-        >>> img.size
-        (70, 70)
-
-        >>> orig_jpg.seek(0)
-        >>> new_jpg, mimetype = scale_image(orig_jpg, (70, 50))
-        >>> img = Image.open(new_jpg)
-        >>> img.size
-        (50, 50)
-
-    """
-    from PIL import Image
-
-    if max_size is None:
-        max_size = IMAGE_SCALE_PARAMS['scale']
-    if default_format is None:
-        default_format = IMAGE_SCALE_PARAMS['default_format']
-    # Make sure we have ints
-    size = (int(max_size[0]), int(max_size[1]))
-    # Load up the image, don't try to catch errors, we want to fail miserably
-    # on invalid images
-    image = Image.open(image_file)
-    # When might image.format not be true?
-    format = image.format
-    mimetype = 'image/%s' % format.lower()
-    cur_size = image.size
-    # from Archetypes ImageField
-    # consider image mode when scaling
-    # source images can be mode '1','L,','P','RGB(A)'
-    # convert to greyscale or RGBA before scaling
-    # preserve palletted mode (but not pallette)
-    # for palletted-only image formats, e.g. GIF
-    # PNG compression is OK for RGBA thumbnails
-    original_mode = image.mode
-    if original_mode == '1':
-        image = image.convert('L')
-    elif original_mode == 'P':
-        image = image.convert('RGBA')
-    # Rescale in place with an method that will not alter the aspect ratio
-    # and will only shrink the image not enlarge it.
-    image.thumbnail(size, resample=IMAGE_SCALE_PARAMS['algorithm'])
-    # preserve palletted mode for GIF and PNG
-    if original_mode == 'P' and format in ('GIF', 'PNG'):
-        image = image.convert('P')
-    # Save
-    new_file = StringIO()
-    image.save(new_file, format, quality=IMAGE_SCALE_PARAMS['quality'])
-    new_file.seek(0)
-    # Return the file data and the new mimetype
-    return new_file, mimetype
-
-
-def getGroupsForPrincipal(principal, plugins, request=None):
-    groups = set()
-    for iid, plugin in plugins.listPlugins(IGroupsPlugin):
-        groups.update(plugin.getGroupsForPrincipal(principal, request))
-    return list(groups)
-
-
-def safe_unicode(value, encoding='utf-8'):
-    """Converts a value to unicode, even it is already a unicode string.
-    """
-    if isinstance(value, unicode):
-        return value
-    elif isinstance(value, basestring):
-        try:
-            value = unicode(value, encoding)
-        except UnicodeDecodeError:
-            value = value.decode('utf-8', 'replace')
-    return value
-
-
-# Imported from Products.CMFCore.MemberdataTool as it has now been removed.
-class CleanupTemp:
-    """Used to cleanup _v_temps at the end of the request."""
-
-    def __init__(self, tool):
-        self._tool = tool
-
-    def __del__(self):
-        try:
-            del self._tool._v_temps
-        except (AttributeError, KeyError):
-            # The object has already been deactivated.
-            pass
diff --git a/Products/PlonePAS/zmi/AutoGroupForm.zpt b/Products/PlonePAS/zmi/AutoGroupForm.zpt
deleted file mode 100644
index 187abc6..0000000
--- a/Products/PlonePAS/zmi/AutoGroupForm.zpt
+++ /dev/null
@@ -1,66 +0,0 @@
-<h1 tal:replace="structure here/manage_page_header">Header</h1>
-
-<h2 tal:define="form_title string:Add Auto Group plugin"
-    tal:replace="structure here/manage_form_title">Form Title</h2>
-
-<p class="form-help">
-The Auto Group plugin automatically puts all authenticated users in a virtual
-group.
-</p>
-
-<form action="manage_addAutoGroup" method="post">
-<table cellspacing="0" cellpadding="2" border="0">
-  <tr>
-    <td align="left" valign="top">
-    <div class="form-label">
-    Id
-    </div>
-    </td>
-    <td align="left" valign="top">
-    <input type="text" name="id" size="40" />
-    </td>
-  </tr>
-  <tr>
-    <td align="left" valign="top">
-    <div class="form-optional">
-    Title
-    </div>
-    </td>
-    <td align="left" valign="top">
-    <input type="text" name="title" size="40" />
-    </td>
-  </tr>
-  <tr>
-    <td align="left" valign="top">
-    <div class="form-label">
-    Group id
-    </div>
-    </td>
-    <td align="left" valign="top">
-    <input type="text" name="group" size="40" />
-    </td>
-  </tr>
-  <tr>
-    <td align="left" valign="top">
-    <div class="form-label">
-    Description
-    </div>
-    </td>
-    <td align="left" valign="top">
-    <input type="text" name="description" size="40" />
-    </td>
-  </tr>
-  <tr>
-    <td align="left" valign="top">
-    </td>
-    <td align="left" valign="top">
-    <div class="form-element">
-    <input class="form-element" type="submit" name="submit" 
-     value=" Add " /> 
-    </div>
-    </td>
-  </tr>
-</table>
-</form>
-
-<h1 tal:replace="structure here/manage_page_footer">Footer</h1>
diff --git a/Products/PlonePAS/zmi/CookieCrumblingPluginForm.dtml b/Products/PlonePAS/zmi/CookieCrumblingPluginForm.dtml
deleted file mode 100644
index 56facac..0000000
--- a/Products/PlonePAS/zmi/CookieCrumblingPluginForm.dtml
+++ /dev/null
@@ -1,39 +0,0 @@
-<dtml-var manage_page_header>
-
-<h2> Add A CookieCrumblingPlugin For PAS</h2>
-
-<p class="form-help">
- This user factory allows form-based logins to be authenticated against regular user folders
- in parent folders. Otherwise, users from, say, the root's <code>acl_users</code> won't be able
- to log in via a form
-</p>
-
-<p>
- It does this by injecting form-provided credentials into the REQUEST as CookieCrumbler does.
-</p>
-
-<form action="manage_addCookieCrumblingPlugin" method="POST">
-
-<table>
-<tr>
-   <td class="form-label"> Id </td>
-   <td> <input type="text" name="id" /> </td>
-</tr>
-<tr>
-   <td class="form-label"> Title </td>
-   <td> <input type="text" name="title" /> </td>
-</tr>
-<tr>
-   <td colspan="2"> 
-    <div class="form-element">
-     <input type="submit" value="submit"/>
-     </div>
-   </td>
-</tr>
-
-</table>
-
-</form>
-
-</body>
-</html>
diff --git a/Products/PlonePAS/zmi/ExtendedCookieAuthHelperForm.dtml b/Products/PlonePAS/zmi/ExtendedCookieAuthHelperForm.dtml
deleted file mode 100644
index 285c6d3..0000000
--- a/Products/PlonePAS/zmi/ExtendedCookieAuthHelperForm.dtml
+++ /dev/null
@@ -1,30 +0,0 @@
-<dtml-var manage_page_header>
-
-<h2> Add An ExtendedCookieAuthHelper For PAS</h2>
-
-
-<form action="manage_addExtendedCookieAuthHelper" method="POST">
-
-<table>
-<tr>
-   <td class="form-label"> Id </td>
-   <td> <input type="text" name="id" /> </td>
-</tr>
-<tr>
-   <td class="form-label"> Title </td>
-   <td> <input type="text" name="title" /> </td>
-</tr>
-<tr>
-   <td colspan="2"> 
-    <div class="form-element">
-     <input type="submit" value="submit"/>
-     </div>
-   </td>
-</tr>
-
-</table>
-
-</form>
-
-</body>
-</html>
diff --git a/Products/PlonePAS/zmi/GroupAwareRoleManagerForm.dtml b/Products/PlonePAS/zmi/GroupAwareRoleManagerForm.dtml
deleted file mode 100644
index cf2c5f2..0000000
--- a/Products/PlonePAS/zmi/GroupAwareRoleManagerForm.dtml
+++ /dev/null
@@ -1,35 +0,0 @@
-<dtml-var manage_page_header>
-
-<h2> Add A Group Aware Role Manager For PAS </h2>
-
-<p class="form-help">
-  install a group aware role manager. returns roles assigned to group 
-  a principal is a member of, in addition to the explicit roles
-  assigned directly to the principal.
-</p>
-
-<form action="manage_addGroupAwareRoleManager" method="POST">
-
-<table>
-
-<tr>
-   <td class="form-label"> Id </td>
-   <td> <input type="text" name="id" /> </td>
-</tr>
-<tr>
-   <td class="form-label"> Title </td>
-   <td> <input type="text" name="title" /> </td>
-</tr>
-<tr>
-   <td colspan="2"> 
-   <div class="form-element">
-    <input type="submit" value="add group aware role manager"/>
-   </div>
-   </td>
-</tr>
-</table>   
-
-</form>
-
-</body>
-</html>
diff --git a/Products/PlonePAS/zmi/GroupManagerForm.dtml b/Products/PlonePAS/zmi/GroupManagerForm.dtml
deleted file mode 100644
index fcb2974..0000000
--- a/Products/PlonePAS/zmi/GroupManagerForm.dtml
+++ /dev/null
@@ -1,35 +0,0 @@
-<dtml-var manage_page_header>
-
-<h2> Add A Group Manager For PAS </h2>
-
-<p class="form-help">
- This group manager allows for zodb based storage of groups, as well
- exposing a management interface for adding, deleting, modifying, and
- introspecting groups. 
-</p>
-
-<form action="manage_addGroupManager" method="POST">
-
-<table>
-<tr>
-   <td class="form-label"> Id </td>
-   <td> <input type="text" name="id" /> </td>
-</tr>
-<tr>
-   <td class="form-label"> Title </td>
-   <td> <input type="text" name="title" /> </td>
-</tr>
-<tr>
-   <td colspan="2"> 
-    <div class="form-element">
-     <input type="submit" value="submit"/>
-     </div>
-   </td>
-</tr>
-
-</table>
-
-</form>
-
-</body>
-</html>
diff --git a/Products/PlonePAS/zmi/LocalRolesManagerForm.dtml b/Products/PlonePAS/zmi/LocalRolesManagerForm.dtml
deleted file mode 100644
index 1a136b6..0000000
--- a/Products/PlonePAS/zmi/LocalRolesManagerForm.dtml
+++ /dev/null
@@ -1,34 +0,0 @@
-<dtml-var manage_page_header>
-
-<h2> Add A Local Roles Manager For PAS </h2>
-
-<p class="form-help">
- This local roles manager checks for both user and the user's groups
- local roles as well allowing for local roles blocking on containers.
-</p>
-
-<form action="manage_addLocalRolesManager" method="POST">
-
-<table>
-<tr>
-   <td class="form-label"> Id </td>
-   <td> <input type="text" name="id" /> </td>
-</tr>
-<tr>
-   <td class="form-label"> Title </td>
-   <td> <input type="text" name="title" /> </td>
-</tr>
-<tr>
-   <td colspan="2"> 
-    <div class="form-element">
-     <input type="submit" value="submit"/>
-     </div>
-   </td>
-</tr>
-
-</table>
-
-</form>
-
-</body>
-</html>
diff --git a/Products/PlonePAS/zmi/MutablePropertyProviderForm.dtml b/Products/PlonePAS/zmi/MutablePropertyProviderForm.dtml
deleted file mode 100644
index 53731fa..0000000
--- a/Products/PlonePAS/zmi/MutablePropertyProviderForm.dtml
+++ /dev/null
@@ -1,34 +0,0 @@
-<dtml-var manage_page_header>
-
-<h2> Add A Mutable Property Provider For PAS </h2>
-
-<p class="form-help">
-  install a ZODB-based mutable property provider. provides property sheets like
-  a regular property manager, but allows writing as well.
-</p>
-
-<form action="manage_addZODBMutablePropertyProvider" method="POST">
-
-<table>
-
-<tr>
-   <td class="form-label"> Id </td>
-   <td> <input type="text" name="id" /> </td>
-</tr>
-<tr>
-   <td class="form-label"> Title </td>
-   <td> <input type="text" name="title" /> </td>
-</tr>
-<tr>
-   <td colspan="2"> 
-   <div class="form-element">
-    <input type="submit" value="add mutable property provider"/>
-   </div>
-   </td>
-</tr>
-</table>   
-
-</form>
-
-</body>
-</html>
diff --git a/Products/PlonePAS/zmi/PasswordPolicyForm.zpt b/Products/PlonePAS/zmi/PasswordPolicyForm.zpt
deleted file mode 100644
index 43a2726..0000000
--- a/Products/PlonePAS/zmi/PasswordPolicyForm.zpt
+++ /dev/null
@@ -1,45 +0,0 @@
-<h1 tal:replace="structure here/manage_page_header">Header</h1>
-
-<h2 tal:define="form_title string:Add Default Plone Password Policy plugin"
-    tal:replace="structure here/manage_form_title">Form Title</h2>
-
-<p class="form-help">
-The Default Plone Password Policy validates passwords to be at least 5 chars long
-</p>
-
-<form action="manage_addPasswordPolicyPlugin" method="post">
-<table cellspacing="0" cellpadding="2" border="0">
-  <tr>
-    <td align="left" valign="top">
-    <div class="form-label">
-    Id
-    </div>
-    </td>
-    <td align="left" valign="top">
-    <input type="text" name="id" size="40" />
-    </td>
-  </tr>
-  <tr>
-    <td align="left" valign="top">
-    <div class="form-optional">
-    Title
-    </div>
-    </td>
-    <td align="left" valign="top">
-    <input type="text" name="title" size="40" />
-    </td>
-  </tr>
-  <tr>
-    <td align="left" valign="top">
-    </td>
-    <td align="left" valign="top">
-    <div class="form-element">
-    <input class="form-element" type="submit" name="submit"
-     value=" Add " />
-    </div>
-    </td>
-  </tr>
-</table>
-</form>
-
-<h1 tal:replace="structure here/manage_page_footer">Footer</h1>
diff --git a/Products/PlonePAS/zmi/PloneUserFactoryForm.dtml b/Products/PlonePAS/zmi/PloneUserFactoryForm.dtml
deleted file mode 100644
index a4b8a08..0000000
--- a/Products/PlonePAS/zmi/PloneUserFactoryForm.dtml
+++ /dev/null
@@ -1,35 +0,0 @@
-<dtml-var manage_page_header>
-
-<h2> Add A PloneUser Factory For PAS </h2>
-
-<p class="form-help">
- This user factory allows for creation of plone compatible users from
- PAS, specifically it performs name/id demangling and allows for local
- roles black listing.
-</p>
-
-<form action="manage_addPloneUserFactory" method="POST">
-
-<table>
-<tr>
-   <td class="form-label"> Id </td>
-   <td> <input type="text" name="id" /> </td>
-</tr>
-<tr>
-   <td class="form-label"> Title </td>
-   <td> <input type="text" name="title" /> </td>
-</tr>
-<tr>
-   <td colspan="2"> 
-    <div class="form-element">
-     <input type="submit" value="submit"/>
-     </div>
-   </td>
-</tr>
-
-</table>
-
-</form>
-
-</body>
-</html>
diff --git a/Products/PlonePAS/zmi/UserManagerForm.dtml b/Products/PlonePAS/zmi/UserManagerForm.dtml
deleted file mode 100644
index 1601847..0000000
--- a/Products/PlonePAS/zmi/UserManagerForm.dtml
+++ /dev/null
@@ -1,35 +0,0 @@
-<dtml-var manage_page_header>
-
-<h2> Add A User Manager For PAS </h2>
-
-<p class="form-help">
- This user manager allows for zodb based storage of users, as well
- exposing a management interface for adding, deleting, and modifying
- users. 
-</p>
-
-<form action="manage_addUserManager" method="POST">
-
-<table>
-<tr>
-   <td class="form-label"> Id </td>
-   <td> <input type="text" name="id" /> </td>
-</tr>
-<tr>
-   <td class="form-label"> Title </td>
-   <td> <input type="text" name="title" /> </td>
-</tr>
-<tr>
-   <td colspan="2"> 
-    <div class="form-element">
-     <input type="submit" value="submit"/>
-     </div>
-   </td>
-</tr>
-
-</table>
-
-</form>
-
-</body>
-</html>
diff --git a/Products/PlonePAS/zmi/membershipRolemapping.dtml b/Products/PlonePAS/zmi/membershipRolemapping.dtml
deleted file mode 100644
index 1b535af..0000000
--- a/Products/PlonePAS/zmi/membershipRolemapping.dtml
+++ /dev/null
@@ -1,136 +0,0 @@
-<dtml-let form_title="'Membership Tool Role Mappings'">
-<dtml-if manage_page_header>
- <dtml-var manage_page_header>
-<dtml-else>
- <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.or
- <html lang="en">
- <head>
- <title>&dtml-form_title;</title>
- </head>
- <body bgcolor="#FFFFFF" link="#000099" vlink="#555555">
- <h3>&dtml-form_title;</h3>
-</dtml-if>
-</dtml-let>
-
-<dtml-var name="manage_tabs">
-
-<h2>Membership role mappings</h2>
-
-<p>Use this screen if you are using a userfolder other than the built-in folder
-existing role names to roles understood by the CMF.</p>
-
-<dtml-in expr="getPortalRoles()">
-  <dtml-if name="sequence-start">
-    <table border="1" cellpadding="3">
-      <tr>
-        <td class="form-label"><b>Portal Role</b></td>
-        <td class="form-label"><b>User Folder-defined Role</b></td>
-        <td>&nbsp;</td>
-      </tr>
-  </dtml-if>
-
-  <tr>
-    <form method="post" action="setRoleMapping">
-
-    <td class="form-label"><dtml-var name="sequence-item"><input type="hidden"
-        name="portal_role" value="&dtml-sequence-item;"></td>
-    <td class="form-element"><input type="text" size="30" name="userfolder_role"
-              value="<dtml-var expr="getMappedRole(_['sequence-item'])">"></td>
-    <td><input type="submit" value="Set Mapping"></td>
-    </form>
-  </tr>
-
-  <dtml-if name="sequence-end">
-    </table>
-  </dtml-if>
-</dtml-in>
-
-<p><hr></p>
-
-<h2>Control creation of member areas</h2>
-
-<p>This feature controls whether users
-will have their own folder created upon first login or not.</p>
-
-<form method="post" action="setMemberareaCreationFlag">
-
-<dtml-if expr="getMemberareaCreationFlag() == 1">
-  <p><b>Member areas are created upon first login.</b>
-  <input type="submit" value=" Turn folder creation off ">
-<dtml-else>
-  <p><b>No member areas are created.</b>
-  <input type="submit" value=" Turn folder creation on ">
-</dtml-if>
-
-</form>
-
-<p><hr></p>
-
-<h2>Set member area type</h2>
-
-<p>Select the (folderish) type to use when creating new
-member areas. You have all the freedom you want but be aware that
-non-folderish types may cause problems.</p>
-
-<form action="manage_setMemberAreaType" method="post">
-<table cellspacing="2">
-<tr>
-  <td align="left" valign="top">
-    <div class="form-label">Member area type</div>
-  </td>
-  <td align="left" valign="top">
-    <select name="type_name">
-      <dtml-let types="[x.getId() for x in portal_types.listTypeInfo()]"
-                dummy="types.sort()">
-        <dtml-in types>
-          <dtml-let id="_['sequence-item']">
-            <option
-              <dtml-if expr="id == memberarea_type">
-                selected="selected"
-              </dtml-if>
-              name="<dtml-var id>"><dtml-var id></option>
-          </dtml-let>
-        </dtml-in>
-      </dtml-let>
-    </select>
-  </td>
-</tr>
-<tr>
-  <td>
-  </td>
-  <td align="left" valign="top">
-    <input class="form-element" type="submit" value=" Change ">
-  </td>
-</tr>
-</table>
-</form>
-
-<p><hr></p>
-
-<h2>Set members folder</h2>
-
-<p>The members folder has to be in the same container as the membership tool.</p>
-
-<form action="manage_setMembersFolderById" method="post">
-<table cellspacing="2">
-<tr>
-  <td align="left" valign="top">
-    <div class="form-label">Members folder id</div>
-  </td>
-  <td align="left" valign="top">
-    <input class="form-element" type="text" name="id"
-        value="&dtml-membersfolder_id;">
-  </td>
-</tr>
-<tr>
-  <td>
-  </td>
-  <td align="left" valign="top">
-    <input class="form-element" type="submit" value=" Change ">
-  </td>
-</tr>
-</table>
-</form>
-
-</body>
-</html>
diff --git a/Products/PlonePAS/zmi/portrait_fix.dtml b/Products/PlonePAS/zmi/portrait_fix.dtml
deleted file mode 100644
index 6109e31..0000000
--- a/Products/PlonePAS/zmi/portrait_fix.dtml
+++ /dev/null
@@ -1,55 +0,0 @@
-<dtml-var manage_page_header>
-<dtml-var manage_tabs>
-
-<p>This is a simple tool for purging members who have uploaded non-image files
-as their member portraits in an attempted cross site scripting attack.  The
-issue which allowed such portraits to be uploaded has been resolved, and this
-tool will remove any existing bad portraits and give you the option of removing
-the members to whom those portraits belonged.
-</p>
-
-<hr />
-<dtml-if search_for_bad_members>
-  <dtml-let ids="getBadMembers()">
-    <dtml-if ids>
-      <p>Found <dtml-var "len(ids)"> bad member portraits and removed them.
-         You may optionally delete these members as well using the form below.
-      </p>
-      <form name="purge_bad_members"
-            method="POST"
-            action="manage_portrait_fix">
-        <ul>
-          <dtml-in ids>
-            <li><dtml-var sequence-item></li>
-            <input type="hidden"
-                   name="member_ids:list"
-                   value="&dtml-sequence-item;"/>
-          </dtml-in>
-        </ul>
-        <input type="checkbox"
-               name="delete_memberareas:bool"
-               checked="true">Delete member areas
-        <br />
-        <input type="submit"
-               name="purge_bad_members"
-               value="Remove These Members" />
-      </form>
-    <dtml-else>
-      <p>No bad members found</p>
-    </dtml-if>
-  </dtml-let>
-<dtml-elif purge_bad_members>
-  
-  <dtml-let deleted="deleteMembers(member_ids, REQUEST.get('delete_memberareas', False), REQUEST=REQUEST)">
-    <dtml-call "portal_memberdata.pruneMemberDataContents()">
-    <p>Deleted <dtml-var "len(deleted)"> bad members</p>
-  </dtml-let>
-<dtml-else>
-  <form name="get_bad_members"
-        method="POST"
-        action="manage_portrait_fix">
-
-    <input type="submit" name="search_for_bad_members"
-           value="Remove Bad Portraits" />
-  </form>
-</dtml-if>
diff --git a/Products/__init__.py b/Products/__init__.py
deleted file mode 100644
index f48ad10..0000000
--- a/Products/__init__.py
+++ /dev/null
@@ -1,6 +0,0 @@
-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages
-try:
-    __import__('pkg_resources').declare_namespace(__name__)
-except ImportError:
-    from pkgutil import extend_path
-    __path__ = extend_path(__path__, __name__)
diff --git a/README.rst b/README.rst
new file mode 100644
index 0000000..0f7ff23
--- /dev/null
+++ b/README.rst
@@ -0,0 +1,80 @@
+Overview
+========
+
+This product extends `PluggableAuthService <https://github.com/zopefoundation/Products.PluggableAuthService>'_ (PAS) for use in Plone.
+
+It adds
+
+- group support
+- auto group assignment
+- support for mutable properties
+- cookie based login
+- local role support
+- password policy support
+- enhanced user objects
+- enhanced cmf tools (groups, members)
+- simple passwordpolicy
+- new event for users initial log in
+
+PlonePAS also adds the API of the old GroupUserFolder (GRUF) to PAS.
+GRUF was used in Plone 2.5.x and earlier as the default user folder.
+
+Lots of this changes are done with monkey patches to PAS itself.
+This is not ideal, but was done in past this way, even if we now would do it better.
+
+PlonePAS does not depend on Plone itself, just on Zope2, PAS and CMF and some low level libraries.
+
+FAQ
+---
+
+Why doesn't the title of my group, that I set in the ZMI, show up?
+    The title for a group comes from the properties plugin.
+    The info in the groups plugin isn't used, except for the name.
+
+    The value of the ``title``property on the ``portal_groupdata`` or ``portal_memberdata tools`` themselves (as opposed to the group or member data records within them) will not be used as a default for the title of the group or member.
+    This is to prevent UI confusion if a title is set without realizing the implications.
+    To remove this special case, see ``plugins.property._getDefaultValues``.
+
+Why are my schema changes ignored?
+    If PAS caching is enabled (see the ``Cache`` tab) and the cache manager does not have a *cleanup* method (RAMCacheManager has one), then changes to the memberdata schema will not effect users already cached.
+    In this case, restart the server or clear the cache (if possible) for the changes to take effect.
+
+    Similarly, changes to the memberdata schema will not propagate to member objects already in use.
+    If you have a memberdata object and change the memberdata properties you must re-construct the member by saying ``portal_membership.getMemberById`` again.
+    See ``tests.test_properties.test_user_properties`` for example.
+
+Why can't I logout?
+    By default, logout from users signed in under HTTP Basic Auth cannot log out.
+    If you enable the ``Credentials Reset`` plugin for the HTTP Basic plugin, the logout for cookies will no longer work.
+    However, this is not a problem if you're not using cookies.
+
+Authorship
+----------
+
+Initial creation: The PAS CIGNEX Sprint Team [ Anders, Bob, Ben,
+Chad, Gautham, Joel, Kapil, Michel, Micheal ]
+
+Post-sprint work: J Cameron Cooper, Leo, Sidnei, Mark at `Enfold
+Systems <http://enfoldsystems.com>`_
+
+Basic setAuthCookie support (to mimick CookieCrumbler):
+Rocky Burt at `ServerZen Software <http://www.serverzen.com>`_
+
+Synced login process with Plone:
+Dorneles Tremea at `PloneSolutions <http://plonesolutions.com>`_
+
+Bugfixes, various development and merging with Plone:
+Wichert Akkerman at Simplon
+
+Bugfixes, improvements to membership and property lookups:
+Eric Steele and Erik Rose
+
+Review, cleanup, modernize code, adressing Plone 5:
+Jens Klein, BlueDynamics Alliance - `Klein & Partner KG <http://kleinundpartner.at>`_
+
+Source Code
+-----------
+
+Contributors please read the document `Process for Plone core's development <http://docs.plone.org/develop/plone-coredev/index.html>`_
+
+Sources are at the `Plone code repository hosted at Github <https://github.com/plone/Products.PlonePAS>`_.
diff --git a/README.txt b/README.txt
deleted file mode 100644
index 925cae2..0000000
--- a/README.txt
+++ /dev/null
@@ -1,74 +0,0 @@
-Overview
-========
-
-This product adapts the
-"PluggableAuthService":http://svn.zope.org/PluggableAuthService/
-for use by Plone.
-
-Notes
------
-
-Why doesn't the title of my group, that I set in the ZODB, show up?
-The title for a group comes from the properties plugin. The info
-in the groups plugin isn't used, except for the name.
-
-The value of the 'title' property on the portal_groupdata or
-portal_memberdata tools themselves (as opposed to the group or
-member data records within them) will not be used as a default for
-the title of the group or member. This is to prevent UI confusion if
-a title is set without realizing the implications. To remove this
-special case, see 'plugins.property._getDefaultValues'.
-
-If PAS caching is enabled (see the "Cache" tab) and the cache
-manager does not have a 'cleanup' method (RAMCacheManager has one),
-then changes to the memberdata schema will not effect users already
-cached. In this case, restart the server or clear the cache (if
-possible) for the changes to take effect.
-
-Similarly, changes to the memberdata schema will not propagate to
-member objects already in use. If you have a memberdata object and
-change the memberdata properties you must re-construct the member by
-saying portal_membership.getMemberById again.  See
-'tests.test_properties.test_user_properties' for example.
-
-By default, logout from users signed in under HTTP Basic Auth cannot
-log out.  If you enable the "Credentials Reset" plugin for the HTTP
-Basic plugin, the logout for cookies will no longer work. However,
-this is not a problem if you're not using cookies.
-
-Implementation
---------------
-
-In some places, PlonePAS acts as an adaptor to make PAS provide
-enough of GRUF's interface to satisfy Plone. All the monkey patches
-in pas.py, for instance, extend PAS with expected methods.
-
-PlonePAS also modifies Plone to work with PAS by providing
-partially-new implementations of several tools.  In the tools/
-directory you can see new tools for groups and members, as well as
-the utils tool.
-
-It also provides extra capabilities for PAS needed by plone, such as
-mutable property sheets, local role calculation, creation of group
-objects, and more.
-
-Authorship
-----------
-
-Initial creation: The PAS CIGNEX Sprint Team [ Anders, Bob, Ben,
-Chad, Gautham, Joel, Kapil, Michel, Micheal ]
-
-Post-sprint work: J Cameron Cooper, Leo, Sidnei, Mark at "Enfold
-Systems":http://enfoldsystems.com
-
-Basic setAuthCookie support (to mimick CookieCrumbler):
-Rocky Burt at "ServerZen Software":http://www.serverzen.com
-
-Synced login process with Plone:
-Dorneles Tremea at "PloneSolutions":http://plonesolutions.com
-
-Bugfixes, various development and merging with Plone:
-Wichert Akkerman at Simplon
-
-Bugfixes, improvements to membership and property lookups:
-Eric Steele and Erik Rose
diff --git a/bootstrap.py b/bootstrap.py
deleted file mode 100644
index 1b28969..0000000
--- a/bootstrap.py
+++ /dev/null
@@ -1,170 +0,0 @@
-##############################################################################
-#
-# Copyright (c) 2006 Zope Foundation and Contributors.
-# All Rights Reserved.
-#
-# This software is subject to the provisions of the Zope Public License,
-# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
-# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
-# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
-# FOR A PARTICULAR PURPOSE.
-#
-##############################################################################
-"""Bootstrap a buildout-based project
-
-Simply run this script in a directory containing a buildout.cfg.
-The script accepts buildout command-line options, so you can
-use the -c option to specify an alternate configuration file.
-"""
-
-import os
-import shutil
-import sys
-import tempfile
-
-from optparse import OptionParser
-
-tmpeggs = tempfile.mkdtemp()
-
-usage = '''\
-[DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]
-
-Bootstraps a buildout-based project.
-
-Simply run this script in a directory containing a buildout.cfg, using the
-Python that you want bin/buildout to use.
-
-Note that by using --find-links to point to local resources, you can keep 
-this script from going over the network.
-'''
-
-parser = OptionParser(usage=usage)
-parser.add_option("-v", "--version", help="use a specific zc.buildout version")
-
-parser.add_option("-t", "--accept-buildout-test-releases",
-                  dest='accept_buildout_test_releases',
-                  action="store_true", default=False,
-                  help=("Normally, if you do not specify a --version, the "
-                        "bootstrap script and buildout gets the newest "
-                        "*final* versions of zc.buildout and its recipes and "
-                        "extensions for you.  If you use this flag, "
-                        "bootstrap and buildout will get the newest releases "
-                        "even if they are alphas or betas."))
-parser.add_option("-c", "--config-file",
-                  help=("Specify the path to the buildout configuration "
-                        "file to be used."))
-parser.add_option("-f", "--find-links",
-                  help=("Specify a URL to search for buildout releases"))
-
-
-options, args = parser.parse_args()
-
-######################################################################
-# load/install setuptools
-
-to_reload = False
-try:
-    import pkg_resources
-    import setuptools
-except ImportError:
-    ez = {}
-
-    try:
-        from urllib.request import urlopen
-    except ImportError:
-        from urllib2 import urlopen
-
-    # XXX use a more permanent ez_setup.py URL when available.
-    exec(urlopen('https://bitbucket.org/pypa/setuptools/raw/0.7.2/ez_setup.py'
-                ).read(), ez)
-    setup_args = dict(to_dir=tmpeggs, download_delay=0)
-    ez['use_setuptools'](**setup_args)
-
-    if to_reload:
-        reload(pkg_resources)
-    import pkg_resources
-    # This does not (always?) update the default working set.  We will
-    # do it.
-    for path in sys.path:
-        if path not in pkg_resources.working_set.entries:
-            pkg_resources.working_set.add_entry(path)
-
-######################################################################
-# Install buildout
-
-ws = pkg_resources.working_set
-
-cmd = [sys.executable, '-c',
-       'from setuptools.command.easy_install import main; main()',
-       '-mZqNxd', tmpeggs]
-
-find_links = os.environ.get(
-    'bootstrap-testing-find-links',
-    options.find_links or
-    ('http://downloads.buildout.org/'
-     if options.accept_buildout_test_releases else None)
-    )
-if find_links:
-    cmd.extend(['-f', find_links])
-
-setuptools_path = ws.find(
-    pkg_resources.Requirement.parse('setuptools')).location
-
-requirement = 'zc.buildout'
-version = options.version
-if version is None and not options.accept_buildout_test_releases:
-    # Figure out the most recent final version of zc.buildout.
-    import setuptools.package_index
-    _final_parts = '*final-', '*final'
-
-    def _final_version(parsed_version):
-        for part in parsed_version:
-            if (part[:1] == '*') and (part not in _final_parts):
-                return False
-        return True
-    index = setuptools.package_index.PackageIndex(
-        search_path=[setuptools_path])
-    if find_links:
-        index.add_find_links((find_links,))
-    req = pkg_resources.Requirement.parse(requirement)
-    if index.obtain(req) is not None:
-        best = []
-        bestv = None
-        for dist in index[req.project_name]:
-            distv = dist.parsed_version
-            if _final_version(distv):
-                if bestv is None or distv > bestv:
-                    best = [dist]
-                    bestv = distv
-                elif distv == bestv:
-                    best.append(dist)
-        if best:
-            best.sort()
-            version = best[-1].version
-if version:
-    requirement = '=='.join((requirement, version))
-cmd.append(requirement)
-
-import subprocess
-if subprocess.call(cmd, env=dict(os.environ, PYTHONPATH=setuptools_path)) != 0:
-    raise Exception(
-        "Failed to execute command:\n%s",
-        repr(cmd)[1:-1])
-
-######################################################################
-# Import and run buildout
-
-ws.add_entry(tmpeggs)
-ws.require(requirement)
-import zc.buildout.buildout
-
-if not [a for a in args if '=' not in a]:
-    args.append('bootstrap')
-
-# if -c was provided, we push it back into args for buildout' main function
-if options.config_file is not None:
-    args[0:0] = ['-c', options.config_file]
-
-zc.buildout.buildout.main(args)
-shutil.rmtree(tmpeggs)
diff --git a/buildout.cfg b/buildout.cfg
index f839b65..93e9d85 100644
--- a/buildout.cfg
+++ b/buildout.cfg
@@ -1,4 +1,9 @@
 [buildout]
+# run with:
+#     virtualenv .
+#     pip install zc.buildout
+#     ./bin/buildout
+
 extends =
     https://raw.github.com/collective/buildout.plonetest/master/test-4.x.cfg
 parts +=
@@ -6,6 +11,8 @@ parts +=
 package-name = Products.PlonePAS
 package-extras = [test]
 
+develop = .
+
 [coverage]
 recipe = zc.recipe.testrunner
 eggs = ${test:eggs}
diff --git a/setup.py b/setup.py
index 01a9a83..e220ae6 100644
--- a/setup.py
+++ b/setup.py
@@ -1,51 +1,47 @@
-from setuptools import setup, find_packages
+# -*- coding: utf-8 -*-
+from setuptools import setup
+from setuptools import find_packages
 
-version = '5.0.1.dev0'
+version = '6.0.dev0'
 
-install_requires=[
-        'setuptools',
-        'plone.memoize',
-        'plone.session',
-        'plone.i18n',
-        'Products.CMFCore',
-        'Products.CMFDefault',
-        'Products.GenericSetup',
-        'Products.PluggableAuthService',
-        'Zope2 > 2.12.4',
-      ]
-
-try:
-    from collections import OrderedDict
-except ImportError:
-    install_requires.append('ordereddict')
+longdescription = open("README.rst").read()
+longdescription += '\n'
+longdescription += open("CHANGES.rst").read()
 
-setup(name='Products.PlonePAS',
-      version=version,
-      description="PlonePAS adapts the PluggableAuthService for use by Plone.",
-      long_description=open("README.txt").read() + "\n" + \
-                       open("CHANGES.txt").read(),
-      classifiers=[
+setup(
+    name='Products.PlonePAS',
+    version=version,
+    description="PlonePAS modifies the PluggableAuthService for use by Plone.",
+    long_description=longdescription,
+    classifiers=[
         "Framework :: Plone",
         "Framework :: Zope2",
-      ],
-      keywords='Zope CMF Plone PAS authentication',
-      author='Kapil Thangavelu, Wichert Akkerman',
-      author_email='plone-developers@lists.sourceforge.net',
-      url='http://pypi.python.org/pypi/Products.PlonePAS',
-      license='ZPL',
-      packages=find_packages(exclude=['ez_setup']),
-      namespace_packages=['Products'],
-      include_package_data=True,
-      zip_safe=False,
-      extras_require=dict(
+    ],
+    keywords='Zope CMF Plone PAS authentication',
+    author='Kapil Thangavelu, Wichert Akkerman',
+    author_email='plone-developers@lists.sourceforge.net',
+    url='http://pypi.python.org/pypi/Products.PlonePAS',
+    license='ZPL',
+    packages=find_packages('src'),
+    package_dir={'': 'src'},
+    namespace_packages=['Products'],
+    include_package_data=True,
+    zip_safe=False,
+    install_requires=[
+        'Products.CMFCore',
+        'Products.GenericSetup',
+        'Products.PluggableAuthService',
+        'Zope2 >=2.13.22',
+        'plone.i18n',
+        'plone.memoize',
+        'plone.session',
+        'setuptools',
+        'zope.deprecation',
+    ],
+    extras_require=dict(
         test=[
             'plone.app.testing',
             'plone.testing',
-            'Products.Archetypes',
         ],
-        atstorage=[
-            'Products.Archetypes',
-        ]
-      ),
-      install_requires=install_requires,
+    ),
 )
diff --git a/src/Products/PlonePAS/Extensions/Install.py b/src/Products/PlonePAS/Extensions/Install.py
new file mode 100644
index 0000000..3f02911
--- /dev/null
+++ b/src/Products/PlonePAS/Extensions/Install.py
@@ -0,0 +1,18 @@
+# -*- coding: utf-8 -*-
+# BBB
+
+# imported at least by borg.localrole.utils
+from Products.PlonePAS.setuphandlers import activatePluginInterfaces  # noqa
+
+# used by plone.app.upgrade/plone/app/upgrade/v43/final.py
+from Products.PlonePAS.setuphandlers import setupPasswordPolicyPlugin  # noqa
+
+# seems this is not needed anywhere outside setuphandlers
+# from Products.PlonePAS.setuphandlers import setupRoles
+# from Products.PlonePAS.setuphandlers import registerPluginType
+# from Products.PlonePAS.setuphandlers import registerPluginTypes
+# from Products.PlonePAS.setuphandlers import setupAuthPlugins
+# from Products.PlonePAS.setuphandlers import updateProperties
+# from Products.PlonePAS.setuphandlers import updateProp
+# from Products.PlonePAS.setuphandlers import addPAS
+# from Products.PlonePAS.setuphandlers import challenge_chooser_setup
diff --git a/src/Products/PlonePAS/Extensions/__init__.py b/src/Products/PlonePAS/Extensions/__init__.py
new file mode 100644
index 0000000..40a96af
--- /dev/null
+++ b/src/Products/PlonePAS/Extensions/__init__.py
@@ -0,0 +1 @@
+# -*- coding: utf-8 -*-
diff --git a/src/Products/PlonePAS/__init__.py b/src/Products/PlonePAS/__init__.py
new file mode 100644
index 0000000..46ebe11
--- /dev/null
+++ b/src/Products/PlonePAS/__init__.py
@@ -0,0 +1,146 @@
+# -*- coding: utf-8 -*-
+from AccessControl.Permissions import add_user_folders
+from Products.CMFCore.utils import ToolInit
+from Products.PlonePAS.pas import patch_pas
+from Products.PlonePAS.plugins import autogroup
+from Products.PlonePAS.plugins import cookie_handler
+from Products.PlonePAS.plugins import crumbler
+from Products.PlonePAS.plugins import group
+from Products.PlonePAS.plugins import local_role
+from Products.PlonePAS.plugins import passwordpolicy
+from Products.PlonePAS.plugins import property
+from Products.PlonePAS.plugins import role
+from Products.PlonePAS.plugins import ufactory
+from Products.PlonePAS.plugins import user
+from Products.PlonePAS.tools.groupdata import GroupDataTool
+from Products.PlonePAS.tools.groups import GroupsTool
+from Products.PlonePAS.tools.memberdata import MemberDataTool
+from Products.PlonePAS.tools.membership import MembershipTool
+from Products.PluggableAuthService import registerMultiPlugin
+
+####################################
+# monkey patch pas, the evil happens
+patch_pas()
+
+#################################
+# new groups tool
+
+#################################
+# register plugins with pas
+try:
+    registerMultiPlugin(user.UserManager.meta_type)
+    registerMultiPlugin(group.GroupManager.meta_type)
+    registerMultiPlugin(role.GroupAwareRoleManager.meta_type)
+    registerMultiPlugin(local_role.LocalRolesManager.meta_type)
+    registerMultiPlugin(ufactory.PloneUserFactory.meta_type)
+    registerMultiPlugin(property.ZODBMutablePropertyProvider.meta_type)
+    registerMultiPlugin(crumbler.CookieCrumblingPlugin.meta_type)
+    registerMultiPlugin(cookie_handler.ExtendedCookieAuthHelper.meta_type)
+    registerMultiPlugin(autogroup.AutoGroup.meta_type)
+    registerMultiPlugin(passwordpolicy.PasswordPolicyPlugin.meta_type)
+except RuntimeError:
+    # make refresh users happy
+    pass
+
+
+def initialize(context):
+
+    tools = (GroupsTool, GroupDataTool, MembershipTool, MemberDataTool)
+
+    ToolInit(
+        'PlonePAS Tool',
+        tools=tools,
+        icon='tool.gif',
+    ).initialize(context)
+
+    context.registerClass(
+        role.GroupAwareRoleManager,
+        permission=add_user_folders,
+        constructors=(
+            role.manage_addGroupAwareRoleManagerForm,
+            role.manage_addGroupAwareRoleManager),
+        visibility=None
+    )
+
+    context.registerClass(
+        user.UserManager,
+        permission=add_user_folders,
+        constructors=(
+            user.manage_addUserManagerForm,
+            user.manage_addUserManager),
+        visibility=None
+    )
+
+    context.registerClass(
+        group.GroupManager,
+        permission=add_user_folders,
+        constructors=(
+            group.manage_addGroupManagerForm,
+            group.manage_addGroupManager
+        ),
+        visibility=None
+    )
+
+    context.registerClass(
+        ufactory.PloneUserFactory,
+        permission=add_user_folders,
+        constructors=(
+            ufactory.manage_addPloneUserFactoryForm,
+            ufactory.manage_addPloneUserFactory),
+        visibility=None
+    )
+
+    context.registerClass(
+        local_role.LocalRolesManager,
+        permission=add_user_folders,
+        constructors=(
+            local_role.manage_addLocalRolesManagerForm,
+            local_role.manage_addLocalRolesManager),
+        visibility=None
+    )
+
+    context.registerClass(
+        property.ZODBMutablePropertyProvider,
+        permission=add_user_folders,
+        constructors=(
+            property.manage_addZODBMutablePropertyProviderForm,
+            property.manage_addZODBMutablePropertyProvider),
+        visibility=None
+    )
+
+    context.registerClass(
+        crumbler.CookieCrumblingPlugin,
+        permission=add_user_folders,
+        constructors=(
+            crumbler.manage_addCookieCrumblingPluginForm,
+            crumbler.manage_addCookieCrumblingPlugin),
+        visibility=None
+    )
+
+    context.registerClass(
+        cookie_handler.ExtendedCookieAuthHelper,
+        permission=add_user_folders,
+        constructors=(
+            cookie_handler.manage_addExtendedCookieAuthHelperForm,
+            cookie_handler.manage_addExtendedCookieAuthHelper),
+        visibility=None
+    )
+
+    context.registerClass(
+        autogroup.AutoGroup,
+        permission=add_user_folders,
+        constructors=(
+            autogroup.manage_addAutoGroupForm,
+            autogroup.manage_addAutoGroup),
+        visibility=None
+    )
+
+    context.registerClass(
+        passwordpolicy.PasswordPolicyPlugin,
+        permission=add_user_folders,
+        constructors=(
+            passwordpolicy.manage_addPasswordPolicyForm,
+            passwordpolicy.manage_addPasswordPolicyPlugin
+        ),
+        visibility=None
+    )
diff --git a/src/Products/PlonePAS/browser/__init__.py b/src/Products/PlonePAS/browser/__init__.py
new file mode 100644
index 0000000..40a96af
--- /dev/null
+++ b/src/Products/PlonePAS/browser/__init__.py
@@ -0,0 +1 @@
+# -*- coding: utf-8 -*-
diff --git a/src/Products/PlonePAS/browser/configure.zcml b/src/Products/PlonePAS/browser/configure.zcml
new file mode 100644
index 0000000..f8e6749
--- /dev/null
+++ b/src/Products/PlonePAS/browser/configure.zcml
@@ -0,0 +1,36 @@
+<configure
+    i18n_domain="Five"
+    xmlns="http://namespaces.zope.org/zope"
+    xmlns:browser="http://namespaces.zope.org/browser"
+    xmlns:five="http://namespaces.zope.org/five">
+
+  <permission
+      id="PAS.SearchPrincipals"
+      title="Search for principals"
+  />
+
+  <browser:page
+      allowed_interface="Products.PlonePAS.interfaces.browser.IPASInfoView"
+      class=".info.PASInfoView"
+      for="*"
+      name="pas_info"
+      permission="zope2.View"
+  />
+
+  <browser:page
+      allowed_interface="Products.PlonePAS.interfaces.browser.IPASMemberView"
+      class=".member.PASMemberView"
+      for="*"
+      name="pas_member"
+      permission="zope2.View"
+  />
+
+  <browser:page
+      allowed_interface="Products.PlonePAS.interfaces.browser.IPASSearchView"
+      class=".search.PASSearchView"
+      for="*"
+      name="pas_search"
+      permission="zope2.View"
+  />
+
+</configure>
diff --git a/src/Products/PlonePAS/browser/info.py b/src/Products/PlonePAS/browser/info.py
new file mode 100644
index 0000000..01a0342
--- /dev/null
+++ b/src/Products/PlonePAS/browser/info.py
@@ -0,0 +1,41 @@
+# -*- coding: utf-8 -*-
+from Acquisition import aq_inner
+from Products.CMFCore.utils import getToolByName
+from Products.Five import BrowserView
+from Products.PlonePAS.interfaces.browser import IPASInfoView
+from Products.PluggableAuthService.interfaces.plugins import IExtractionPlugin
+from Products.PluggableAuthService.interfaces.plugins \
+    import ILoginPasswordExtractionPlugin
+from plone.memoize.instance import memoize
+from zope.interface import implementer
+
+
+@implementer(IPASInfoView)
+class PASInfoView(BrowserView):
+
+    def checkExtractorForInterface(self, interface):
+        acl = getToolByName(aq_inner(self.context), "acl_users")
+        plugins = acl.plugins.listPlugins(IExtractionPlugin)
+
+        for plugin in plugins:
+            if interface.providedBy(plugin[1]):
+                return True
+
+        return False
+
+    @memoize
+    def hasLoginPasswordExtractor(self):
+        return self.checkExtractorForInterface(ILoginPasswordExtractionPlugin)
+
+    @memoize
+    def hasOpenIDExtractor(self):
+        try:
+            from plone.openid.interfaces import IOpenIdExtractionPlugin
+        except ImportError:
+            return False
+
+        return self.checkExtractorForInterface(IOpenIdExtractionPlugin)
+
+    def hasOpenIDdExtractor(self):
+        # BBB Keeping method name with typo for backwards compatibility.
+        return self.hasOpenIDExtractor()
diff --git a/src/Products/PlonePAS/browser/member.py b/src/Products/PlonePAS/browser/member.py
new file mode 100644
index 0000000..b0fcfa6
--- /dev/null
+++ b/src/Products/PlonePAS/browser/member.py
@@ -0,0 +1,29 @@
+# -*- coding: utf-8 -*-
+from Products.CMFCore.utils import getToolByName
+from Products.PlonePAS.interfaces.browser import IPASMemberView
+from plone.memoize.instance import memoize
+from zope.interface import implementer
+from zope.publisher.browser import BrowserView
+
+
+@implementer(IPASMemberView)
+class PASMemberView(BrowserView):
+
+    @memoize
+    def info(self, userid=None):
+        pm = getToolByName(self.context, 'portal_membership')
+        result = pm.getMemberInfo(memberId=userid)
+        if result is None:
+            # No such member: removed?  We return something useful anyway.
+            return {
+                'username': userid,
+                'description': '',
+                'language': '',
+                'home_page': '',
+                'name_or_id': userid,
+                'location': '',
+                'fullname': ''
+            }
+        result['name_or_id'] = result.get('fullname') or \
+            result.get('username') or userid
+        return result
diff --git a/src/Products/PlonePAS/browser/search.py b/src/Products/PlonePAS/browser/search.py
new file mode 100644
index 0000000..b2d0b00
--- /dev/null
+++ b/src/Products/PlonePAS/browser/search.py
@@ -0,0 +1,76 @@
+# -*- coding: utf-8 -*-
+from Products.CMFCore.utils import getToolByName
+from Products.Five import BrowserView
+from Products.PlonePAS.interfaces.browser import IPASSearchView
+from plone.i18n.normalizer.interfaces import IIDNormalizer
+from zope.component import queryUtility
+from zope.interface import implementer
+
+
+@implementer(IPASSearchView)
+class PASSearchView(BrowserView):
+
+    @staticmethod
+    def extractCriteriaFromRequest(request):
+        criteria = request.form.copy()
+
+        for key in ["form.submitted", "submit", 'b_start', 'b_size']:
+            if key in criteria:
+                del criteria[key]
+
+        for (key, value) in criteria.items():
+            if not value:
+                del criteria[key]
+
+        return criteria
+
+    @staticmethod
+    def merge(results, key):
+        output = {}
+        for entry in results:
+            id = entry[key]
+            if id not in output:
+                output[id] = entry.copy()
+            else:
+                buf = entry.copy()
+                buf.update(output[id])
+                output[id] = buf
+
+        return output.values()
+
+    def sort(self, results, sort_key):
+        idnormalizer = queryUtility(IIDNormalizer)
+
+        def key_func(a):
+            return idnormalizer.normalize(a.get(sort_key, a))
+        return sorted(results, key=key_func)
+
+    def searchUsers(self, sort_by=None, **criteria):
+        self.pas = getToolByName(self.context, "acl_users")
+        results = self.merge(self.pas.searchUsers(**criteria), "userid")
+        if sort_by is not None:
+            results = self.sort(results, sort_by)
+        return results
+
+    def searchUsersByRequest(self, request, sort_by=None):
+        criteria = self.extractCriteriaFromRequest(request)
+        return self.searchUsers(sort_by=sort_by, **criteria)
+
+    def searchGroups(self, sort_by=None, **criteria):
+        self.pas = getToolByName(self.context, "acl_users")
+        results = self.merge(self.pas.searchGroups(**criteria), "groupid")
+        if sort_by is not None:
+            results = self.sort(results, sort_by)
+        return results
+
+    def searchGroupsByRequest(self, request):
+        criteria = self.extractCriteriaFromRequest(request)
+        return self.searchGroups(**criteria)
+
+    def getPhysicalPath(self):
+        # We call various PAS methods which can be ZCached. The ZCache
+        # infrastructure relies on getPhysicalPath on the context being
+        # available, which this view does not have, it not being a
+        # persistent object. So we fake things and return the physical path
+        # for our context.
+        return self.context.getPhysicalPath()
diff --git a/src/Products/PlonePAS/config.py b/src/Products/PlonePAS/config.py
new file mode 100644
index 0000000..99ae0bc
--- /dev/null
+++ b/src/Products/PlonePAS/config.py
@@ -0,0 +1,28 @@
+# -*- coding: utf-8 -*-
+PROJECTNAME = 'PlonePAS'
+GLOBALS = globals()
+
+DEFAULT_CHALLENGE_PROTOCOL = ['http']
+DEFAULT_PROTO_MAPPING = {
+    'WebDAV': DEFAULT_CHALLENGE_PROTOCOL,
+    'FTP': DEFAULT_CHALLENGE_PROTOCOL,
+    'XML-RPC': DEFAULT_CHALLENGE_PROTOCOL
+}
+
+# Settings for member image resize quality
+HAS_PIL = True
+try:
+    from PIL import Image
+    PIL_SCALING_ALGO = Image.ANTIALIAS
+except ImportError:
+    PIL_SCALING_ALGO = None
+    HAS_PIL = False
+
+PIL_QUALITY = 88
+MEMBER_IMAGE_SCALE = (75, 100)
+IMAGE_SCALE_PARAMS = {
+    'scale': MEMBER_IMAGE_SCALE,
+    'quality': PIL_QUALITY,
+    'algorithm': PIL_SCALING_ALGO,
+    'default_format': 'PNG'
+}
diff --git a/src/Products/PlonePAS/configure.zcml b/src/Products/PlonePAS/configure.zcml
new file mode 100644
index 0000000..f326d9e
--- /dev/null
+++ b/src/Products/PlonePAS/configure.zcml
@@ -0,0 +1,26 @@
+<configure
+    i18n_domain="plone"
+    xmlns="http://namespaces.zope.org/zope"
+    xmlns:five="http://namespaces.zope.org/five"
+    xmlns:genericsetup="http://namespaces.zope.org/genericsetup"
+    xmlns:i18n="http://namespaces.zope.org/i18n">
+
+  <include package=".browser" />
+  <include file="profiles.zcml" />
+  <include file="exportimport.zcml" />
+
+  <genericsetup:importStep
+      description="Configure PlonePas"
+      handler="Products.PlonePAS.setuphandlers.setupPlonePAS"
+      name="plonepas"
+      title="PlonePAS setup">
+    <depends name="componentregistry" />
+    <depends name="controlpanel" />
+    <depends name="memberdata-properties" />
+    <depends name="rolemap" />
+  </genericsetup:importStep>
+
+  <five:deprecatedManageAddDelete class=".plugins.cookie_handler.ExtendedCookieAuthHelper" />
+  <five:deprecatedManageAddDelete class=".plugins.role.GroupAwareRoleManager" />
+
+</configure>
diff --git a/src/Products/PlonePAS/events.py b/src/Products/PlonePAS/events.py
new file mode 100644
index 0000000..79c2433
--- /dev/null
+++ b/src/Products/PlonePAS/events.py
@@ -0,0 +1,30 @@
+# -*- coding: utf-8 -*-
+from Products.PlonePAS.interfaces.events import IUserInitialLoginInEvent
+from Products.PluggableAuthService.events import PASEvent
+from Products.PluggableAuthService.interfaces.events import IUserLoggedInEvent
+from Products.PluggableAuthService.interfaces.events import IUserLoggedOutEvent
+from zope.interface import implementer
+
+
+@implementer(IUserLoggedInEvent)
+class UserLoggedInEvent(PASEvent):
+    """Plone Implementation of the logged in event
+
+    PAS Event
+    """
+
+
+@implementer(IUserInitialLoginInEvent)
+class UserInitialLoginInEvent(UserLoggedInEvent):
+    """Implementation of the initial logged in event
+
+    Plone only event!
+    """
+
+
+@implementer(IUserLoggedOutEvent)
+class UserLoggedOutEvent(PASEvent):
+    """Plone Implementation of the logged out event
+
+    PAS Event
+    """
diff --git a/src/Products/PlonePAS/exportimport.zcml b/src/Products/PlonePAS/exportimport.zcml
new file mode 100644
index 0000000..ae6fa67
--- /dev/null
+++ b/src/Products/PlonePAS/exportimport.zcml
@@ -0,0 +1,26 @@
+<configure xmlns="http://namespaces.zope.org/zope">
+
+  <adapter
+      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
+      for="Products.PluggableAuthService.interfaces.plugins.IUserFactoryPlugin"
+      provides="Products.GenericSetup.interfaces.IFilesystemExporter"
+  />
+  <adapter
+      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
+      for="Products.PluggableAuthService.interfaces.plugins.IUserFactoryPlugin"
+      provides="Products.GenericSetup.interfaces.IFilesystemImporter"
+  />
+
+  <!-- XXX This should point to an own export/import class! TitleOnly is far not enough -->
+  <adapter
+      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
+      for="Products.PlonePAS.interfaces.plugins.IMutablePropertiesPlugin"
+      provides="Products.GenericSetup.interfaces.IFilesystemExporter"
+  />
+  <adapter
+      factory="Products.PluggableAuthService.plugins.exportimport.TitleOnlyExportImport"
+      for="Products.PlonePAS.interfaces.plugins.IMutablePropertiesPlugin"
+      provides="Products.GenericSetup.interfaces.IFilesystemImporter"
+  />
+
+</configure>
diff --git a/src/Products/PlonePAS/interfaces/__init__.py b/src/Products/PlonePAS/interfaces/__init__.py
new file mode 100644
index 0000000..40a96af
--- /dev/null
+++ b/src/Products/PlonePAS/interfaces/__init__.py
@@ -0,0 +1 @@
+# -*- coding: utf-8 -*-
diff --git a/src/Products/PlonePAS/interfaces/browser.py b/src/Products/PlonePAS/interfaces/browser.py
new file mode 100644
index 0000000..6f2b5cb
--- /dev/null
+++ b/src/Products/PlonePAS/interfaces/browser.py
@@ -0,0 +1,89 @@
+# -*- coding: utf-8 -*-
+from zope.interface import Interface
+
+
+class IPASInfoView(Interface):
+
+    def hasLoginPasswordExtractor():
+        """Check if a login & password extraction plugin is active.
+
+        Check if there is a plugin with an enabled
+        ILoginPasswordExtractionPlugin interface. This can be used to
+        conditionally show username & password logins.
+        """
+
+    def hasOpenIDExtractor():
+        """Check if an OpenID extraction plugin is active.
+        """
+
+    def hasOpenIDdExtractor():
+        """Check if an OpenID extraction plugin is active.
+
+        BBB Keeping method name with typo for backwards compatibility.
+        """
+
+
+class IPASMemberView(Interface):
+
+    def info(userid=None):
+        """Return 'harmless' member info of any user, such as full name,
+        location, etc.
+        """
+
+
+class IPASSearchView(Interface):
+
+    def searchUsers(sort_by=None, any_field=None, **criteria):
+        """Search for users matching a set of criteria.
+
+        The criteria are a dictionary mapping user properties to values and
+        have the semantics declared by IPluggableAuthService.searchUsers().
+        Duplicate results returned by PAS are filtered so only the first
+        result remains in the result set. The results can be sorted on
+        sort_bys (case insensitive).
+
+        In addition, a single search string can be sought in multiple
+        fields at a time by passing any_field='your-string'. The fields
+        that will be searched are not explicitly enumerated but will be the
+        user-facing ones a user would expect to search, such as login name
+        and full name. (Perhaps any_field should/could be moved into PAS
+        proper. This could be done without breaking code that depends on
+        this interface.)
+
+        If you specify both any_field and other criteria that include a
+        field that any_field would typically search (such as login name),
+        the other criteria will be enforced at the expense of any_field.
+        """
+
+    def searchUsersByRequest(request, sort_by=None):
+        """Search for users matching a set of criteria found in a request.
+
+        This method will look remove any obvious values from the request
+        which are not search criteria. It will also remove any fields
+        which have an empty string value.
+        Duplicate results returned by PAS are filtered so only the first
+        result remains in the result set. The results can be sorted on
+        sort_by (case insensitive).
+        """
+
+    def searchGroups(**criteria):
+        """Search for groups matching a set of criteria.
+
+        The criteria are a dictionary mapping group properties
+        to values and have the semantics declared by
+        IPluggableAuthService.searchGroups().
+        """
+
+    def searchGroupsByRequest(request):
+        """Search for groups matching a set of criteria found in a request.
+
+        This method will look remove any obvious values from the request
+        which are not search criteria. It will also remove any fields
+        which have an empty string value.
+        """
+
+    def merge(results, key):
+        """merge two search results based on key as the unique criterion"""
+
+    def sort(results, key):
+        """sort results on a key"""
diff --git a/src/Products/PlonePAS/interfaces/capabilities.py b/src/Products/PlonePAS/interfaces/capabilities.py
new file mode 100644
index 0000000..92b1286
--- /dev/null
+++ b/src/Products/PlonePAS/interfaces/capabilities.py
@@ -0,0 +1,78 @@
+# -*- coding: utf-8 -*-
+# Define certain interfaces that a plugin must meet if it is to allow
+# certain operations to be done by the Plone UI.
+from Products.PluggableAuthService.interfaces.plugins import Interface
+
+
+class IDeleteCapability(Interface):
+    """Interface for plugin to say if it allows for deletion of a user.
+    Expected to be found on IUserManagement plugins.
+    For Plone UI.
+    """
+
+    def allowDeletePrincipal(id):
+        """True iff this plugin can delete a certain user/group."""
+
+
+class IPasswordSetCapability(Interface):
+    """Interface for plugin to say if it allows for setting the password of a
+    user.
+    Expected to be found on IUserManagement plugins.
+    For Plone UI.
+    """
+
+    def allowPasswordSet(id):
+        """True iff this plugin can set the password of a certain user."""
+
+
+class IGroupCapability(Interface):
+    """Interface for plugin to say if it allows for deletion of a user.
+    For Plone UI.
+    """
+
+    def allowGroupAdd(principal_id, group_id):
+        """True iff this plugin will allow adding a certain principal to a
+        certain group."""
+
+    def allowGroupRemove(principal_id, group_id):
+        """True iff this plugin will allow removing a certain principal from a
+        certain group."""
+
+
+class IAssignRoleCapability(Interface):
+    """Interface for plugin to say if it allows for deletion of a user.
+    For Plone UI.
+    """
+
+    def allowRoleAssign(id, role):
+        """True iff this plugin will allow assigning a certain principal a
+        certain role."""
+
+
+class IManageCapabilities(Interface):
+    """Interface for MemberData/GroupData to provide information as to whether
+    or not the member can be deleted, reset password, modify a property.
+    """
+
+    def canDelete():
+        """True iff user can be removed from the Plone UI."""
+
+    def canPasswordSet():
+        """True iff user can change password."""
+
+    def passwordInClear():
+        """True iff password can be retrieved in the clear (not hashed.)"""
+
+    def canWriteProperty(prop_name):
+        """True iff the member/group property named in 'prop_name'
+        can be changed.
+        """
+
+    def canAddToGroup(group_id):
+        """True iff member can be added to group."""
+
+    def canRemoveFromGroup(group_id):
+        """True iff member can be removed from group."""
+
+    def canAssignRole(role):
+        """True iff member can be assigned role."""
diff --git a/src/Products/PlonePAS/interfaces/events.py b/src/Products/PlonePAS/interfaces/events.py
new file mode 100644
index 0000000..500ca8d
--- /dev/null
+++ b/src/Products/PlonePAS/interfaces/events.py
@@ -0,0 +1,7 @@
+# -*- coding: utf-8 -*-
+from Products.PluggableAuthService.interfaces.events import IUserLoggedInEvent
+
+
+class IUserInitialLoginInEvent(IUserLoggedInEvent):
+    """A user logs in for the first time in the portal.
+    """
diff --git a/src/Products/PlonePAS/interfaces/group.py b/src/Products/PlonePAS/interfaces/group.py
new file mode 100644
index 0000000..53ea92c
--- /dev/null
+++ b/src/Products/PlonePAS/interfaces/group.py
@@ -0,0 +1,140 @@
+# -*- coding: utf-8 -*-
+from Products.PluggableAuthService.interfaces import plugins
+from zope.interface import Interface
+
+
+class IGroupManagement(Interface):
+
+    def addGroup(id, **kw):
+        """
+        Create a group with the supplied id, roles, and groups.
+        return True if the operation suceeded
+        """
+
+    def addPrincipalToGroup(principal_id, group_id):
+        """
+        Add a given principal to the group.
+        return True on success
+        """
+
+    def updateGroup(id, **kw):
+        """
+        Edit the given group. plugin specific
+        return True on success
+        """
+
+    def setRolesForGroup(group_id, roles=()):
+        """
+        set roles for group
+        return True on success
+        """
+
+    def removeGroup(group_id):
+        """
+        Remove the given group
+        return True on success
+        """
+
+    def removePrincipalFromGroup(principal_id, group_id):
+        """
+        remove the given principal from the group
+        return True on success
+        """
+
+
+class IGroupIntrospection(Interface):
+
+    def getGroupById(group_id):
+        """
+        Returns the portal_groupdata-ish object for a group
+        corresponding to this id.
+        """
+
+    #################################
+    # these interface methods are suspect for scalability.
+    #################################
+
+    def getGroups():
+        """
+        Returns an iteration of the available groups
+        """
+
+    def getGroupIds():
+        """
+        Returns a list of the available groups
+        """
+
+    def getGroupMembers(group_id):
+        """
+        return the members of the given group
+        """
+
+
+class IGroupDataTool(Interface):
+
+    def wrapGroup(group):
+        """
+        decorate a group with property management capabilities if needed
+        """
+
+
+class IGroupTool(IGroupIntrospection,
+                 IGroupManagement,
+                 plugins.IGroupsPlugin):
+
+    """
+    Defines an interface for managing and introspecting and
+    groups and group membership.
+    """
+
+
+class IGroupData(Interface):
+    """ An abstract interface for accessing properties on a group object"""
+
+    def setProperties(properties=None, **kw):
+        """Allows setting of group properties en masse.
+        Properties can be given either as a dict or a keyword parameters
+        list"""
+
+    def getProperty(id):
+        """ Return the value of the property specified by 'id' """
+
+    def getProperties():
+        """ Return the properties of this group. Properties are as usual in
+        Zope."""
+
+    def getGroupId():
+        """ Return the string id of this group, WITHOUT group prefix."""
+
+    def getMemberId():
+        """This exists only for a basic user/group API compatibility
+        """
+
+    def getGroupName():
+        """ Return the name of the group."""
+
+    def getGroupMembers():
+        """ Return a list of the portal_memberdata-ish members of the group."""
+
+    def getAllGroupMembers():
+        """ Return a list of the portal_memberdata-ish members of the group
+        including transitive ones (ie. users or groups of a group in that
+        group)."""
+
+    def getGroupMemberIds():
+        """ Return a list of the user ids of the group."""
+
+    def getAllGroupMemberIds():
+        """ Return a list of the user ids of the group.
+        including transitive ones (ie. users or groups of a group in that
+        group)."""
+
+    def addMember(id):
+        """ Add the existing member with the given id to the group"""
+
+    def removeMember(id):
+        """ Remove the member with the provided id from the group """
+
+    def getGroup():
+        """ Returns the actual group implementation. Varies by group
+        implementation (GRUF/Nux/et al)."""
diff --git a/src/Products/PlonePAS/interfaces/membership.py b/src/Products/PlonePAS/interfaces/membership.py
new file mode 100644
index 0000000..1f8a757
--- /dev/null
+++ b/src/Products/PlonePAS/interfaces/membership.py
@@ -0,0 +1,12 @@
+# -*- coding: utf-8 -*-
+from Products.CMFCore import interfaces
+
+
+class IMembershipTool(interfaces.IMembershipTool):
+
+    def getMemberInfo(memberId=None):
+        """Return 'harmless' Memberinfo of any member, such as full name,
+        location, etc
+        """
+
+__all__ = (IMembershipTool, )
diff --git a/src/Products/PlonePAS/interfaces/plugins.py b/src/Products/PlonePAS/interfaces/plugins.py
new file mode 100644
index 0000000..a1f78a3
--- /dev/null
+++ b/src/Products/PlonePAS/interfaces/plugins.py
@@ -0,0 +1,127 @@
+# -*- coding: utf-8 -*-
+from Products.PluggableAuthService.interfaces import plugins
+from Products.PluggableAuthService.interfaces.plugins import Interface
+
+
+class IUserIntrospection(Interface):
+    """
+    Introspect users in a user source, api users need to be careful as
+    all sources may or not support this interface.
+
+    Realistically this can only be done by authentication sources, or
+    plugins which have intimate knowledge of such.
+    """
+
+    def getUserIds():
+        """
+        Return a list of user ids
+        """
+
+    def getUserNames():
+        """
+        Return a list of usernames
+        """
+
+    def getUsers():
+        """
+        Return a list of users
+        """
+
+
+class ILocalRolesPlugin(Interface):
+    """
+    Plugin for determining a user's local roles and object access
+    based on local roles.
+    """
+
+    def getRolesInContext(user, object):
+        """
+        Return the list of roles assigned to the user.
+
+        o Include local roles assigned in context of the passed-in object.
+
+        o Include *both* local roles assigned directly to us *and* those
+          assigned to our groups.
+
+        o Ripped off from AccessControl.User.BasicUser, which provides
+          no other extension mechanism. :(
+        """
+
+    def checkLocalRolesAllowed(user, object, object_roles):
+        """
+        Check whether the user has access to object based
+        on local roles. access is determined by a user's local roles
+        including one of the object roles.
+        """
+
+    def getAllLocalRolesInContext(object):
+        """
+        Return active all local roles in a context.
+
+        The roles are returned in a dictionary mapping a principal (a
+        user or a group) to the set of roles assigned to it.
+        """
+
+
+class IUserManagement(plugins.IUserAdderPlugin):
+    """
+    Manage users
+    """
+
+    def doChangeUser(user_id, password, **kw):
+        """
+        Change a user's password (differs from role) roles are set in
+        the pas engine api for the same but are set via a role
+        manager)
+        """
+
+    def doDeleteUser(login):
+        """
+        Remove a user record from a User Manager, with the given login
+        and password
+
+        o Return a Boolean indicating whether a user was removed or
+          not
+        """
+
+
+class IMutablePropertiesPlugin(Interface):
+    """
+    Return a property set for a user. Property set can either an
+    object conforming to the IMutable property sheet interface or a
+    dictionary (in which case the properties are not persistently
+    mutable).
+    """
+
+    def getPropertiesForUser(user, request=None):
+        """
+        User -> IMutablePropertySheet || {}
+
+        o User will implement IPropertiedUser.
+
+        o Plugin may scribble on the user, if needed (but must still
+          return a mapping, even if empty).
+
+        o May assign properties based on values in the REQUEST object, if
+          present
+        """
+
+    def setPropertiesForUser(user, propertysheet):
+        """
+        Set modified properties on the user persistently.
+
+        Raise a ValueError if the property or property value is invalid
+        """
+
+    def deleteUser(user_id):
+        """
+        Remove properties stored for a user
+        """
+
+
+class ISchemaMutablePropertiesPlugin(Interface):
+
+    def addProperty(property_type, property_name, default=None):
+        """
+        Add a new property to a property provider.
+        """
diff --git a/src/Products/PlonePAS/interfaces/propertysheets.py b/src/Products/PlonePAS/interfaces/propertysheets.py
new file mode 100644
index 0000000..8ff7ab3
--- /dev/null
+++ b/src/Products/PlonePAS/interfaces/propertysheets.py
@@ -0,0 +1,22 @@
+# -*- coding: utf-8 -*-
+from Products.PluggableAuthService.interfaces.propertysheets \
+    import IPropertySheet
+
+
+class IMutablePropertySheet(IPropertySheet):
+
+    def canWriteProperty(object, id):
+        """ Check if a property can be modified.
+        """
+
+    def setProperty(object, id, value):
+        """
+        """
+
+    def setProperties(object, mapping):
+        """
+        """
+
+
+class ISchemaMutablePropertySheet(IMutablePropertySheet):
+    pass
diff --git a/src/Products/PlonePAS/ldapmp.py b/src/Products/PlonePAS/ldapmp.py
new file mode 100644
index 0000000..c5511b3
--- /dev/null
+++ b/src/Products/PlonePAS/ldapmp.py
@@ -0,0 +1,72 @@
+# -*- coding: utf-8 -*-
+from Products.PlonePAS.patch import call
+from Products.PlonePAS.patch import wrap_method
+from Products.PlonePAS.plugins.group import PloneGroup
+
+GROUP_PROPERTY_MAP = {
+    # target property: (possible key, ...)
+    'title': ('name',
+              'displayName',
+              'cn',),
+    'description': ('description', ),
+    'email': ('mail', ),
+}
+
+KNOWN_ATTRS = []
+for attrs in GROUP_PROPERTY_MAP.values():
+    for attr in attrs:
+        KNOWN_ATTRS.append(attr)
+KNOWN_ATTRS = set(KNOWN_ATTRS)
+
+
+def getPropertiesForUser(self, user, request=None):
+    """Fullfill PropertiesPlugin requirements
+    """
+
+    if not isinstance(user, PloneGroup):
+        # It's not a PloneGroup, continue as usual
+        return call(self, 'getPropertiesForUser', user=user, request=request)
+
+    # We've got a PloneGroup.
+    # Search for groups instead of users
+    groups = self.enumerateGroups(id=user.getId(), exact_match=True)
+    # XXX Should we assert there's only one group?
+    properties = {}
+    for group in groups:
+        for pname, attrs in GROUP_PROPERTY_MAP.items():
+            for attr in attrs:
+                value = group.get(attr)
+                if value:
+                    # Break on first found
+                    properties[pname] = value
+                    break
+
+    return properties
+
+
+def getGroupsForPrincipal(self, user, request=None, attr=None):
+    """ Fulfill GroupsPlugin requirements, but don't return any groups for
+    groups """
+
+    if not isinstance(user, PloneGroup):
+        # It's not a PloneGroup, continue as usual
+        return call(self, 'getGroupsForPrincipal', user,
+                    request=request, attr=attr)
+
+    return ()
+
+
+def patch_ldapmp():
+    from Products.LDAPMultiPlugins.LDAPPluginBase import LDAPPluginBase
+    wrap_method(
+        LDAPPluginBase,
+        'getPropertiesForUser',
+        getPropertiesForUser
+    )
+
+    from Products.LDAPMultiPlugins.LDAPMultiPlugin import LDAPMultiPlugin
+    wrap_method(
+        LDAPMultiPlugin,
+        'getGroupsForPrincipal',
+        getGroupsForPrincipal
+    )
diff --git a/src/Products/PlonePAS/pas.py b/src/Products/PlonePAS/pas.py
new file mode 100644
index 0000000..1c34a9c
--- /dev/null
+++ b/src/Products/PlonePAS/pas.py
@@ -0,0 +1,739 @@
+# -*- coding: utf-8 -*-
+# pas alterations and monkies
+from AccessControl import Unauthorized
+from AccessControl import getSecurityManager
+from AccessControl.PermissionRole import PermissionRole
+from AccessControl.Permissions import change_permissions
+from AccessControl.Permissions import manage_properties
+from AccessControl.Permissions import manage_users as ManageUsers
+from AccessControl.requestmethod import postonly
+from OFS.Folder import Folder
+from Products.CMFCore.utils import getToolByName
+from Products.CMFCore.utils import registerToolInterface
+from Products.PlonePAS.interfaces.group import IGroupIntrospection
+from Products.PlonePAS.interfaces.group import IGroupManagement
+from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
+from Products.PlonePAS.interfaces.plugins import IUserIntrospection
+from Products.PlonePAS.interfaces.plugins import IUserManagement
+from Products.PlonePAS.patch import ORIG_NAME
+from Products.PlonePAS.patch import wrap_method
+from Products.PluggableAuthService.PluggableAuthService import \
+    PluggableAuthService
+from Products.PluggableAuthService.PluggableAuthService import \
+    _SWALLOWABLE_PLUGIN_EXCEPTIONS
+from Products.PluggableAuthService.events import PrincipalDeleted
+from Products.PluggableAuthService.interfaces.authservice import \
+    IPluggableAuthService
+from Products.PluggableAuthService.interfaces.plugins import \
+    IAuthenticationPlugin
+from Products.PluggableAuthService.interfaces.plugins import \
+    IGroupEnumerationPlugin
+from Products.PluggableAuthService.interfaces.plugins import \
+    IRoleAssignerPlugin
+from Products.PluggableAuthService.interfaces.plugins import \
+    IUserEnumerationPlugin
+from zope.event import notify
+import logging
+
+logger = logging.getLogger('PlonePAS')
+
+registerToolInterface('acl_users', IPluggableAuthService)
+
+
+#################################
+# helper functions
+
+def _userSetGroups(pas, user_id, groupnames):
+    """method was used at GRUF level, but is used inside this monkies at several
+    places too.
+
+    We no longer provide it on PAS to clean up patches
+
+    """
+    plugins = pas.plugins
+    gtool = getToolByName(pas, "portal_groups")
+
+    member = pas.getUserById(user_id)
+    groupnameset = set(groupnames)
+
+    # remove absent groups
+    groups = set(gtool.getGroupsForPrincipal(member))
+    rmgroups = groups - groupnameset
+    for gid in rmgroups:
+        try:
+            gtool.removePrincipalFromGroup(user_id, gid)
+        except KeyError:
+            # We could hit a group which does not allow user removal, such as
+            # created by our AutoGroup plugin.
+            pass
+
+    # add groups
+    try:
+        groupmanagers = plugins.listPlugins(IGroupManagement)
+    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+        logger.info(
+            'PluggableAuthService: Plugin listing error',
+            exc_info=1
+        )
+        groupmanagers = ()
+
+    for group in groupnames:
+        for gm_id, gm in groupmanagers:
+            try:
+                if gm.addPrincipalToGroup(user_id, group):
+                    break
+            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+                logger.info(
+                    'PluggableAuthService: GroupManagement %s error',
+                    gm_id,
+                    exc_info=1
+                )
+
+#################################
+# pas folder monkies - standard zope user folder api or GRUF
+
+
+def _doAddUser(self, login, password, roles, domains, groups=None, **kw):
+    """Masking of PAS._doAddUser to add groups param."""
+    _old_doAddUser = getattr(self, getattr(_doAddUser, ORIG_NAME))
+    retval = _old_doAddUser(login, password, roles, domains)
+    if groups is not None:
+        _userSetGroups(self, login, groups)
+    return retval
+
+
+def _doDelUsers(self, names, REQUEST=None):
+    """
+    Delete users given by a list of user ids.
+    Has no return value, like the original (GRUF).
+    """
+    for name in names:
+        self._doDelUser(name)
+
+
+def _doDelUser(self, id):
+    """
+    Given a user id, hand off to a deleter plugin if available.
+    """
+    plugins = self._getOb('plugins')
+    userdeleters = plugins.listPlugins(IUserManagement)
+
+    if not userdeleters:
+        raise NotImplementedError(
+            "There is no plugin that can delete users."
+        )
+
+    for userdeleter_id, userdeleter in userdeleters:
+        try:
+            userdeleter.doDeleteUser(id)
+        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+            pass
+        else:
+            notify(PrincipalDeleted(id))
+
+
+def _doChangeUser(self, principal_id, password, roles, domains=(), groups=None,
+                  REQUEST=None, **kw):
+    """
+    Given a principal id, change its password, roles, domains, if
+    respective plugins for such exist.
+
+    XXX domains are currently ignored.
+    """
+    # Might be called with 'None' as password from the Plone UI, in
+    # prefs_users_overview when resetPassword is not set.
+    if password is not None:
+        self.userSetPassword(principal_id, password)
+
+    plugins = self._getOb('plugins')
+    rmanagers = plugins.listPlugins(IRoleAssignerPlugin)
+
+    if not (rmanagers):
+        raise NotImplementedError("There is no plugin that can modify roles")
+
+    for rid, rmanager in rmanagers:
+        rmanager.assignRolesToPrincipal(roles, principal_id)
+
+    if groups is not None:
+        _userSetGroups(self, principal_id, groups)
+
+    return True
+
+
+def userFolderAddUser(self, login, password, roles, domains,
+                      groups=None, REQUEST=None, **kw):
+    self._doAddUser(login, password, roles, domains, **kw)
+    if groups is not None:
+        _userSetGroups(self, login, groups)
+
+
+def _doAddGroup(self, id, roles, groups=None, **kw):
+    gtool = getToolByName(self, 'portal_groups')
+    return gtool.addGroup(id, roles, groups, **kw)
+
+
+# for prefs_group_manage compatibility. really should be using tool.
+def _doDelGroups(self, names, REQUEST=None):
+    gtool = getToolByName(self, 'portal_groups')
+    for group_id in names:
+        gtool.removeGroup(group_id)
+
+
+def _doChangeGroup(self, principal_id, roles, groups=None, REQUEST=None, **kw):
+    """
+    Given a group's id, change its roles, domains, if respective
+    plugins for such exist. Domains are currently ignored.
+
+    See also _doChangeUser
+    """
+    gtool = getToolByName(self, 'portal_groups')
+    gtool.editGroup(principal_id, roles, groups, **kw)
+    return True
+
+
+def _updateGroup(self, principal_id, roles=None, groups=None, **kw):
+    """
+    Given a group's id, change its roles, groups, if respective
+    plugins for such exist. Domains are ignored.
+
+    This is not an alias to _doChangeGroup because its params are different
+    (slightly).
+    """
+    return self._doChangeGroup(principal_id, roles, groups, **kw)
+
+
+def getGroups(self):
+    gtool = getToolByName(self, 'portal_groups')
+    return gtool.listGroups()
+
+
+def getGroupNames(self):
+    gtool = getToolByName(self, 'portal_groups')
+    return gtool.getGroupIds()
+
+
+def getGroupIds(self):
+    gtool = getToolByName(self, 'portal_groups')
+    return gtool.getGroupIds()
+
+
+def getGroup(self, group_id):
+    """Like getGroupById in groups tool, but doesn't wrap.
+    """
+    group = None
+    introspectors = self.plugins.listPlugins(IGroupIntrospection)
+
+    if not introspectors:
+        raise ValueError('No plugins allow for group management')
+    for iid, introspector in introspectors:
+        group = introspector.getGroupById(group_id)
+        if group is not None:
+            break
+    return group
+
+
+def getGroupByName(self, name, default=None):
+    ret = self.getGroup(name)
+    if ret is None:
+        return default
+    return ret
+
+
+def getGroupById(self, id, default=None):
+    gtool = getToolByName(self, "portal_groups")
+    ret = gtool.getGroupById(id)
+    if ret is None:
+        return default
+    else:
+        return ret
+
+
+def getLocalRolesForDisplay(self, object):
+    """This is used for plone's local roles display
+
+    This method returns a tuple (massagedUsername, roles, userType,
+    actualUserName).  This method is protected by the 'access content
+    information' permission. We may change that if it's too
+    permissive...
+
+    A GRUF method originally.
+    """
+    # Perform security check on destination object
+    if not getSecurityManager().checkPermission(manage_properties, object):
+        raise Unauthorized(name="getLocalRolesForDisplay")
+
+    return self._getLocalRolesForDisplay(object)
+
+
+def _getLocalRolesForDisplay(self, object):
+    result = []
+    # we don't have a PAS-side way to get this
+    local_roles = object.get_local_roles()
+    for one_user in local_roles:
+        username = userid = one_user[0]
+        roles = one_user[1]
+        userType = 'user'
+        if self.getGroup(userid):
+            userType = 'group'
+        else:
+            user = self.getUserById(userid) or self.getUser(username)
+            if user:
+                username = user.getUserName()
+                userid = user.getId()
+        result.append((username, roles, userType, userid))
+    return tuple(result)
+
+
+def getUsers(self):
+    """
+    Return a list of all users from plugins that implement the user
+    introspection interface.
+
+    Could potentially be very long.
+    """
+    # We should have a method that's cheap about returning number of users.
+    retval = []
+    try:
+        introspectors = self.plugins.listPlugins(IUserIntrospection)
+    except KeyError:
+        return retval
+
+    for iid, introspector in introspectors:
+        retval += introspector.getUsers()
+
+    return retval
+
+
+def canListAllUsers(self):
+    plugins = self._getOb('plugins')
+    # Do we have multiple user plugins?
+    num_enumeration_plugins = plugins.listPlugins(IUserEnumerationPlugin)
+    num_introspection_plugins = plugins.listPlugins(IUserEnumerationPlugin)
+    return num_enumeration_plugins == num_introspection_plugins
+
+
+def canListAllGroups(self):
+    plugins = self._getOb('plugins')
+    # Do we have multiple group plugins?
+    num_enumeration_plugins = plugins.listPlugins(IGroupEnumerationPlugin)
+    num_introspection_plugins = plugins.listPlugins(IGroupEnumerationPlugin)
+    return num_enumeration_plugins == num_introspection_plugins
+
+
+def userSetPassword(self, userid, password):
+    """Emulate GRUF 3 call for password set, for use with PwRT."""
+    # used by _doChangeUser
+    plugins = self._getOb('plugins')
+    managers = plugins.listPlugins(IUserManagement)
+
+    if not managers:
+        raise NotImplementedError("There is no plugin that can modify users")
+
+    modified = False
+    for mid, manager in managers:
+        try:
+            manager.doChangeUser(userid, password)
+        except RuntimeError:
+            # XXX: why silent ignore this Error?
+            pass
+        else:
+            modified = True
+
+    if not modified:
+        raise RuntimeError("No user management plugins were able "
+                           "to successfully modify the user")
+
+
+def credentialsChanged(self, user, name, new_password):
+    """Notifies the authentication mechanism that this user has changed
+    passwords.  This can be used to update the authentication cookie.
+    Note that this call should *not* cause any change at all to user
+    databases.
+
+    For use by CMFCore.MembershipTool.credentialsChanged
+    """
+    request = self.REQUEST
+    response = request.RESPONSE
+    login = name
+
+    self.updateCredentials(request, response, login, new_password)
+
+
+# for ZopeVersionControl, we need to check 'plugins' for more than
+# existence, since it replaces objects (like 'plugins') with SimpleItems
+# and calls _delOb, which tries to use special methods of 'plugins'
+def _delOb(self, id):
+    #
+    #   Override ObjectManager's version to clean up any plugin
+    #   registrations for the deleted object
+    #
+    # XXX imo this is a evil one
+    #
+    plugins = self._getOb('plugins', None)
+
+    if getattr(plugins, 'removePluginById', None) is not None:
+        plugins.removePluginById(id)
+
+    Folder._delOb(self, id)
+
+
+def addRole(self, role):
+    plugins = self._getOb('plugins')
+    roles = plugins.listPlugins(IRoleAssignerPlugin)
+
+    for plugin_id, plugin in roles:
+        try:
+            plugin.addRole(role)
+            break
+        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+            pass
+
+
+def getAllLocalRoles(self, context):
+    # Perform security check on destination object
+    if not getSecurityManager().checkPermission(change_permissions, context):
+        raise Unauthorized(name="getAllLocalRoles")
+    return self._getAllLocalRoles(context)
+
+
+def _getAllLocalRoles(self, context):
+    plugins = self._getOb('plugins')
+    lrmanagers = plugins.listPlugins(ILocalRolesPlugin)
+
+    roles = {}
+    for lrid, lrmanager in lrmanagers:
+        newroles = lrmanager.getAllLocalRolesInContext(context)
+        for k, v in newroles.items():
+            if k not in roles:
+                roles[k] = set()
+            roles[k].update(v)
+
+    return roles
+
+
+def authenticate(self, name, password, request):
+    """See AccessControl.User.BasicUserFolder.authenticate
+
+    Products.PluggableAuthService.PluggableAuthService does not provide this
+    method, BasicUserFolder documents it as "Private UserFolder object
+    interface". GRUF does provide the method, so not marked as private.
+
+    should be deprecated in future!
+    """
+
+    plugins = self.plugins
+
+    try:
+        authenticators = plugins.listPlugins(IAuthenticationPlugin)
+    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
+        authenticators = ()
+
+    credentials = {'login': name,
+                   'password': password}
+
+    user_id = None
+
+    for authenticator_id, auth in authenticators:
+        try:
+            uid_and_name = auth.authenticateCredentials(credentials)
+            if uid_and_name is not None:
+                user_id, name = uid_and_name
+                break
+        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+            logger.info(
+                'PluggableAuthService: AuthenticationPlugin %s error',
+                authenticator_id,
+                exc_info=1
+            )
+            continue
+
+    if not user_id:
+        return
+
+    return self._findUser(plugins, user_id, name, request)
+
+
+def getUserIds(self):
+    """method was used at GRUF and is here for bbb. Not good for many users!
+    DEPRECATED
+    """
+    plugins = self.plugins
+
+    try:
+        introspectors = plugins.listPlugins(IUserIntrospection)
+    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
+        introspectors = ()
+
+    results = []
+    for introspector_id, introspector in introspectors:
+        try:
+            results.extend(introspector.getUserIds())
+        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+            logger.info(
+                'PluggableAuthService: UserIntrospection %s error',
+                introspector_id,
+                exc_info=1
+            )
+
+    return results
+
+
+def getUserNames(self):
+    """method was used at GRUF and is here for bbb. Not good for many users!
+    DEPRECATED
+    """
+    plugins = self.plugins
+
+    try:
+        introspectors = plugins.listPlugins(IUserIntrospection)
+    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+        logger.info('PluggableAuthService: Plugin listing error', exc_info=1)
+        introspectors = ()
+
+    results = []
+    for introspector_id, introspector in introspectors:
+        try:
+            results.extend(introspector.getUserNames())
+        except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+            logger.info(
+                'PluggableAuthService: UserIntroSpection plugin %s error',
+                introspector_id, exc_info=1)
+
+    return results
+
+
+def patch_pas():
+    # sort alphabetically by patched/added method name
+    wrap_method(
+        PluggableAuthService,
+        '_delOb',
+        _delOb
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_getAllLocalRoles',
+        _getAllLocalRoles,
+        add=True,
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doAddGroup',
+        _doAddGroup,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doAddUser',
+        _doAddUser
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doChangeGroup',
+        _doChangeGroup,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doChangeUser',
+        _doChangeUser,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doDelGroups',
+        _doDelGroups,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doDelUser',
+        _doDelUser,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_doDelUsers',
+        _doDelUsers,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_getLocalRolesForDisplay',
+        _getLocalRolesForDisplay,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        '_updateGroup',
+        _updateGroup,
+        add=True
+    )
+    wrap_method(
+        PluggableAuthService,
+        'addRole',
+        addRole,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'authenticate',
+        authenticate,
+        add=True,
+        roles=(),
+    )
+    wrap_method(
+        PluggableAuthService,
+        'canListAllGroups',
+        canListAllGroups,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'canListAllUsers',
+        canListAllUsers,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'credentialsChanged',
+        credentialsChanged,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getAllLocalRoles',
+        getAllLocalRoles,
+        add=True,
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getGroup',
+        getGroup,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getGroupById',
+        getGroupById,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getGroupByName',
+        getGroupByName,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getGroupIds',
+        getGroupIds,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getGroupNames',
+        getGroupNames,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getGroups',
+        getGroups,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getLocalRolesForDisplay',
+        getLocalRolesForDisplay,
+        add=True,
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getUserIds',
+        getUserIds,
+        add=True,
+        deprecated="Inefficient GRUF wrapper, use IUserIntrospection instead."
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getUserNames',
+        getUserNames,
+        add=True,
+        deprecated="Inefficient GRUF wrapper, use IUserIntrospection instead."
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getUsers',
+        getUsers,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'getPureUsers',
+        getUsers,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userFolderAddUser',
+        postonly(userFolderAddUser),
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userFolderDelUsers',
+        postonly(_doDelUsers),
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userFolderEditGroup',
+        postonly(_doChangeGroup),
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userFolderEditUser',
+        postonly(_doChangeUser),
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userFolderDelGroups',
+        postonly(_doDelGroups),
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userSetGroups',
+        _userSetGroups,
+        add=True,
+        deprecated="Method from GRUF was removed."
+    )
+    wrap_method(
+        PluggableAuthService,
+        'userSetPassword',
+        userSetPassword,
+        add=True,
+        roles=PermissionRole(ManageUsers, ('Manager',))
+    )
diff --git a/src/Products/PlonePAS/patch.py b/src/Products/PlonePAS/patch.py
new file mode 100644
index 0000000..fce6d38
--- /dev/null
+++ b/src/Products/PlonePAS/patch.py
@@ -0,0 +1,74 @@
+# -*- coding: utf-8 -*-
+from zope.deprecation import deprecation
+import logging
+
+logger = logging.getLogger('PlonePAS')
+
+PATTERN = '__PlonePAS_%s__'
+
+
+def call(self, __name__, *args, **kw):
+    return getattr(self, PATTERN % __name__)(*args, **kw)
+
+
+WRAPPER = '__PlonePAS_is_wrapper_method__'
+ADDED = '__PlonePAS_is_added_method__'
+ORIG_NAME = '__PlonePAS_original_method_name__'
+
+_marker = dict()
+
+
+def isWrapperMethod(meth):
+    return getattr(meth, WRAPPER, False)
+
+
+def wrap_method(klass, name, method,
+                pattern=PATTERN, add=False, roles=None, deprecated=False):
+    """takes a method and set it to a class. Annotates with hints what happened.
+    """
+    new_name = pattern % name
+    if not add:
+        old_method = getattr(klass, name)
+        if isWrapperMethod(old_method):
+            logger.info(
+                'PlonePAS: *NOT* wrapping already wrapped method at '
+                '{0}.{1}'.format(
+                    klass.__name__, name)
+            )
+
+            return
+        logger.info('PlonePAS: Wrapping method at %s.%s', klass.__name__, name)
+        setattr(klass, new_name, old_method)
+        setattr(method, ORIG_NAME, new_name)
+        setattr(method, WRAPPER, True)
+        setattr(method, ADDED, False)
+    else:
+        logger.info('PlonePAS: Adding method at %s.%s', klass.__name__, name)
+        setattr(method, WRAPPER, False)
+        setattr(method, ADDED, True)
+
+    if deprecated:
+        setattr(klass, name, deprecation.deprecated(method, deprecated))
+    else:
+        setattr(klass, name, method)
+
+    if roles is not None:
+        roles_attr = '{0}__roles__'.format(name)
+        logger.info(
+            'PlonePAS: Setting new permission roles at {0}.{1}'.format(
+                klass.__name__, name
+            )
+        )
+        setattr(klass, roles_attr, roles)
+
+
+def unwrap_method(klass, name):
+    # seems to be dead code, nowwhere used nor tested
+    old_method = getattr(klass, name)
+    if not isWrapperMethod(old_method):
+        raise ValueError('Trying to unwrap non-wrapped '
+                         'method at %s.%s' % (klass.__name__, name))
+    orig_name = getattr(old_method, ORIG_NAME)
+    new_method = getattr(klass, orig_name)
+    delattr(klass, orig_name)
+    setattr(klass, name, new_method)
diff --git a/src/Products/PlonePAS/permissions.py b/src/Products/PlonePAS/permissions.py
new file mode 100644
index 0000000..126932a
--- /dev/null
+++ b/src/Products/PlonePAS/permissions.py
@@ -0,0 +1,17 @@
+# -*- coding: utf-8 -*-
+from Products.CMFCore.permissions import setDefaultRoles
+
+AddGroups = 'Add Groups'
+setDefaultRoles(AddGroups, ('Manager',))
+
+ManageGroups = 'Manage Groups'
+setDefaultRoles(ManageGroups, ('Manager',))
+
+ViewGroups = 'View Groups'
+setDefaultRoles(ViewGroups, ('Manager', 'Owner', 'Member'))
+
+DeleteGroups = 'Delete Groups'
+setDefaultRoles(DeleteGroups, ('Manager', ))
+
+SetGroupOwnership = 'Set Group Ownership'
+setDefaultRoles(SetGroupOwnership, ('Manager', 'Owner'))
diff --git a/src/Products/PlonePAS/plugins/__init__.py b/src/Products/PlonePAS/plugins/__init__.py
new file mode 100644
index 0000000..40a96af
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/__init__.py
@@ -0,0 +1 @@
+# -*- coding: utf-8 -*-
diff --git a/src/Products/PlonePAS/plugins/autogroup.py b/src/Products/PlonePAS/plugins/autogroup.py
new file mode 100644
index 0000000..8ec0ee3
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/autogroup.py
@@ -0,0 +1,148 @@
+# -*- coding: utf-8 -*-
+from App.class_init import InitializeClass
+from Products.PageTemplates.PageTemplateFile import PageTemplateFile
+from Products.PlonePAS.interfaces.group import IGroupIntrospection
+from Products.PluggableAuthService.PropertiedUser import PropertiedUser
+from Products.PluggableAuthService.interfaces.plugins import \
+    IGroupEnumerationPlugin
+from Products.PluggableAuthService.interfaces.plugins import IGroupsPlugin
+from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
+from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from zope.interface import implementer
+
+manage_addAutoGroupForm = PageTemplateFile("../zmi/AutoGroupForm", globals())
+
+
+def manage_addAutoGroup(self, id, title='', group='', description='',
+                        RESPONSE=None):
+    """Add an Auto Group plugin."""
+
+    plugin = AutoGroup(id, title, group, description)
+    self._setObject(id, plugin)
+
+    if RESPONSE is not None:
+        return RESPONSE.redirect(
+            "%s/manage_workspace?manage_tabs_message=AutoGroup+plugin+added"
+            % self.absolute_url())
+
+
+class VirtualGroup(PropertiedUser):
+    def __init__(self, id, title='', description=''):
+        super(VirtualGroup, self).__init__(id)
+        self.id = id
+        self.title = title
+        self.description = description
+
+    def getId(self):
+        return self.id
+
+    def getUserName(self):
+        return self.id
+
+    def getName(self):
+        return self.id
+
+    def getMemberIds(self, transitive=1):
+        return []
+
+    def getRolesInContext(self, context):
+        return []
+
+    def getRoles(self):
+        return []
+
+    def allowed(self, object, object_roles=None):
+        return 0
+
+    def getDomains(self):
+        return []
+
+    def isGroup(self):
+        return True
+
+
+@implementer(
+    IGroupEnumerationPlugin,
+    IGroupsPlugin,
+    IGroupIntrospection,
+    IPropertiesPlugin
+)
+class AutoGroup(BasePlugin):
+    meta_type = "Automatic Group Plugin"
+
+    _properties = (
+        {'id': 'title',
+         'label': 'Title',
+         'type': 'string',
+         'mode': 'w'},
+        {'id': 'group',
+         'label': 'Group',
+         'type': 'string',
+         'mode': 'w'},
+        {'id': 'description',
+         'label': 'Description',
+         'type': 'string',
+         'mode': 'w'},
+    )
+
+    def __init__(self, id, title='', group=None, description=''):
+        self._setId(id)
+        self.title = title
+        self.group = group
+        self.description = description
+
+    # IGroupEnumerationPlugin implementation
+    def enumerateGroups(self, id=None, exact_match=False, sort_by=None,
+                        max_results=None, **kw):
+        if kw:
+            return []
+
+        if id:
+            id = id.lower()
+            mygroup = self.group.lower()
+
+            if exact_match and id != mygroup:
+                return []
+
+            if not exact_match and id not in mygroup:
+                return []
+
+        return [{'id': self.group,
+                 'groupid': self.group,
+                 'title': self.title,
+                 'pluginid': self.getId()}]
+
+    # IGroupsPlugin implementation
+    def getGroupsForPrincipal(self, principal, request=None):
+        if principal.getUserName() == self.group:
+            return ()
+
+        return (self.group,)
+
+    # IGroupIntrospection implementation
+    def getGroupById(self, group_id):
+        if group_id != self.group:
+            return None
+
+        return VirtualGroup(self.group, title=self.title,
+                            description=self.description)
+
+    def getGroups(self):
+        return [self.getGroupById(id) for id in self.getGroupIds()]
+
+    def getGroupIds(self):
+        return [self.group]
+
+    def getGroupMembers(self, group_id):
+        return ()
+
+    # IPropertiesPlugin:
+    def getPropertiesForUser(self, user, request=None):
+        if user == self.group:
+            return {'title': self.title,
+                    'description': self.description}
+        else:
+            return {}
+
+
+InitializeClass(AutoGroup)
diff --git a/src/Products/PlonePAS/plugins/cookie_handler.py b/src/Products/PlonePAS/plugins/cookie_handler.py
new file mode 100644
index 0000000..9c65297
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/cookie_handler.py
@@ -0,0 +1,113 @@
+# -*- coding: utf-8 -*-
+""" Class: ExtendedCookieAuthHelper
+
+Simply extends the standard CookieAuthHelper provided via regular
+PluggableAuthService but overrides the updateCookie mechanism to
+provide similar functionality as CookieCrumbler does... by giving
+the portal the ability to provide a setAuthCookie method.
+"""
+from AccessControl.SecurityInfo import ClassSecurityInfo
+from AccessControl.SecurityManagement import getSecurityManager
+from Acquisition import aq_base
+from Acquisition import aq_parent
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from Products.PluggableAuthService.interfaces.authservice import \
+    IPluggableAuthService
+from Products.PluggableAuthService.interfaces.plugins \
+    import IChallengePlugin
+from Products.PluggableAuthService.interfaces.plugins \
+    import ICredentialsResetPlugin
+from Products.PluggableAuthService.interfaces.plugins \
+    import ICredentialsUpdatePlugin
+from Products.PluggableAuthService.interfaces.plugins \
+    import ILoginPasswordHostExtractionPlugin
+from Products.PluggableAuthService.plugins.CookieAuthHelper \
+    import CookieAuthHelper as BasePlugin
+from base64 import encodestring
+from urllib import quote
+from zope.interface import implementer
+
+
+def manage_addExtendedCookieAuthHelper(self, id, title='',
+                                       RESPONSE=None, **kw):
+    """Create an instance of a extended cookie auth helper.
+    """
+
+    self = self.this()
+
+    o = ExtendedCookieAuthHelper(id, title, **kw)
+    self._setObject(o.getId(), o)
+    o = getattr(aq_base(self), id)
+
+    if RESPONSE is not None:
+        RESPONSE.redirect('manage_workspace')
+
+manage_addExtendedCookieAuthHelperForm = DTMLFile(
+    "../zmi/ExtendedCookieAuthHelperForm",
+    globals()
+)
+
+
+@implementer(
+    ILoginPasswordHostExtractionPlugin,
+    IChallengePlugin,
+    ICredentialsUpdatePlugin,
+    ICredentialsResetPlugin
+)
+class ExtendedCookieAuthHelper(BasePlugin):
+    """Multi-plugin which adds ability to override the updating of cookie via
+    a setAuthCookie method/script.
+    """
+
+    meta_type = 'Extended Cookie Auth Helper'
+    security = ClassSecurityInfo()
+
+    @security.private
+    def updateCredentials(self, request, response, login, new_password):
+        """Override standard updateCredentials method
+        """
+
+        setAuthCookie = getattr(self, 'setAuthCookie', None)
+        if setAuthCookie:
+            cookie_val = encodestring('%s:%s' % (login, new_password))
+            cookie_val = cookie_val.rstrip()
+            setAuthCookie(response, self.cookie_name, quote(cookie_val))
+        else:
+            BasePlugin.updateCredentials(self, request, response, login,
+                                         new_password)
+
+    @security.public
+    def login(self):
+        """Set a cookie and redirect to the url that we tried to
+        authenticate against originally.
+
+        Override standard login method to avoid calling
+        'return response.redirect(came_from)' as there is additional
+        processing to ignore known bad come_from templates at
+        login_next.cpy script.
+        """
+        request = self.REQUEST
+        response = request['RESPONSE']
+
+        password = request.get('__ac_password', '')
+
+        user = getSecurityManager().getUser()
+        login = user.getUserName()
+        user_pas = aq_parent(user)
+
+        if IPluggableAuthService.providedBy(user_pas):
+            # Delegate to the users own PAS if possible
+            user_pas.updateCredentials(request, response, login, password)
+        else:
+            # User does not originate from a PAS user folder, so lets try
+            # to do our own thing.
+            # XXX Perhaps we should do nothing here; test with pure User
+            # Folder!
+            pas_instance = self._getPAS()
+            if pas_instance is not None:
+                pas_instance.updateCredentials(request, response, login,
+                                               password)
+
+
+InitializeClass(ExtendedCookieAuthHelper)
diff --git a/src/Products/PlonePAS/plugins/crumbler.py b/src/Products/PlonePAS/plugins/crumbler.py
new file mode 100644
index 0000000..9838693
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/crumbler.py
@@ -0,0 +1,73 @@
+# -*- coding: utf-8 -*-
+""" Class: CookieCrumblingPlugin
+
+Acts as auth plugin, but injects cookie form credentials as HTTPBasicAuth.
+This allows form logins to fall through to parent user folders.
+
+"""
+from AccessControl.SecurityInfo import ClassSecurityInfo
+from Acquisition import aq_base
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from OFS.Folder import Folder
+from Products.CMFCore.CookieCrumbler import manage_addCC
+from Products.PluggableAuthService.interfaces.plugins import IExtractionPlugin
+from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from zope.interface import implementer
+import logging
+
+logger = logging.getLogger('PlonePAS')
+
+CC_ID = 'cookie_auth'
+
+
+def manage_addCookieCrumblingPlugin(self, id, title='',
+                                    RESPONSE=None, **kw):
+    """
+    Create an instance of a cookie crumbling plugin.
+    """
+    self = self.this()
+
+    o = CookieCrumblingPlugin(id, title, **kw)
+    self._setObject(o.getId(), o)
+    o = getattr(aq_base(self), id)
+
+    manage_addCC(o, CC_ID)
+
+    if RESPONSE is not None:
+        RESPONSE.redirect('manage_workspace')
+
+manage_addCookieCrumblingPluginForm = \
+    DTMLFile("../zmi/CookieCrumblingPluginForm", globals())
+
+
+@implementer(IExtractionPlugin)
+class CookieCrumblingPlugin(Folder, BasePlugin):
+    """Multi-plugin for injecting HTTP Basic Authentication
+    credentials from form credentials.
+    """
+    meta_type = 'Cookie Crumbling Plugin'
+
+    security = ClassSecurityInfo()
+
+    def __init__(self, id, title=None):
+        self._setId(id)
+        self.title = title
+
+    def _getCC(self):
+        return getattr(aq_base(self), CC_ID, None)
+
+    @security.private
+    def extractCredentials(self, request):
+        """ Extract basic auth credentials from 'request'.
+        """
+
+        try:
+            self._getCC().modifyRequest(request, request.RESPONSE)
+
+        except Exception, e:
+            logger.error("PlonePAS error: %s", e, exc_info=1)
+
+        return {}
+
+InitializeClass(CookieCrumblingPlugin)
diff --git a/src/Products/PlonePAS/plugins/group.py b/src/Products/PlonePAS/plugins/group.py
new file mode 100644
index 0000000..1e24d5c
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/group.py
@@ -0,0 +1,294 @@
+# -*- coding: utf-8 -*-
+"""
+ZODB Group Implementation with basic introspection and
+management (ie. rw) capabilities.
+
+"""
+from AccessControl import ClassSecurityInfo
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from BTrees.OOBTree import OOBTree
+from BTrees.OOBTree import OOSet
+from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
+from Products.PlonePAS.interfaces.capabilities import IGroupCapability
+from Products.PlonePAS.interfaces.group import IGroupIntrospection
+from Products.PlonePAS.interfaces.group import IGroupManagement
+from Products.PluggableAuthService.PluggableAuthService \
+    import _SWALLOWABLE_PLUGIN_EXCEPTIONS
+from Products.PluggableAuthService.interfaces.plugins \
+    import IGroupEnumerationPlugin
+from Products.PluggableAuthService.interfaces.plugins \
+    import IPropertiesPlugin
+from Products.PluggableAuthService.interfaces.plugins import IRolesPlugin
+from Products.PluggableAuthService.plugins.ZODBGroupManager \
+    import ZODBGroupManager
+from ufactory import PloneUser
+from zope.interface import implementer
+import logging
+
+manage_addGroupManagerForm = DTMLFile("../zmi/GroupManagerForm", globals())
+logger = logging.getLogger('PlonePAS')
+
+
+def manage_addGroupManager(self, id, title='', RESPONSE=None):
+    """
+    Add a zodb group manager with management and introspection
+    capabilities to pas.
+    """
+    grum = GroupManager(id, title)
+
+    self._setObject(grum.getId(), grum)
+
+    if RESPONSE is not None:
+        return RESPONSE.redirect('manage_workspace')
+
+
+@implementer(
+    IGroupManagement,
+    IGroupIntrospection,
+    IGroupCapability,
+    IDeleteCapability
+)
+class GroupManager(ZODBGroupManager):
+
+    meta_type = "Group Manager"
+    security = ClassSecurityInfo()
+
+    def __init__(self, *args, **kw):
+        ZODBGroupManager.__init__(self, *args, **kw)
+        # reverse index of groups->principal
+        self._group_principal_map = OOBTree()
+
+    #################################
+    # overrides to ease group principal lookups for introspection api
+
+    def addGroup(self, group_id, *args, **kw):
+        ZODBGroupManager.addGroup(self, group_id, *args, **kw)
+        self._group_principal_map[group_id] = OOSet()
+        return True
+
+    def removeGroup(self, group_id):
+        ZODBGroupManager.removeGroup(self, group_id)
+        del self._group_principal_map[group_id]
+        return True
+
+    def addPrincipalToGroup(self, principal_id, group_id):
+        ZODBGroupManager.addPrincipalToGroup(self, principal_id, group_id)
+        self._group_principal_map[group_id].insert(principal_id)
+        return True
+
+    def removePrincipalFromGroup(self, principal_id, group_id):
+        already = ZODBGroupManager.removePrincipalFromGroup(self, principal_id,
+                                                            group_id)
+        if already:
+            self._group_principal_map[group_id].remove(principal_id)
+        return True
+
+    #################################
+    # overrides for api matching/massage
+
+    def updateGroup(self, group_id, title=None, description=None):
+        ZODBGroupManager.updateGroup(self, group_id, title=title,
+                                     description=description)
+        return True
+
+    #################################
+    # introspection interface
+
+    def getGroupById(self, group_id, default=None):
+        plugins = self._getPAS()._getOb('plugins')
+        title = None
+        if group_id not in self.getGroupIds():
+            return default
+
+        return self._findGroup(plugins, group_id, title)
+
+    def getGroups(self):
+        return map(self.getGroupById, self.getGroupIds())
+
+    def getGroupIds(self):
+        return self.listGroupIds()
+
+    def getGroupMembers(self, group_id):
+        return tuple(self._group_principal_map.get(group_id, ()))
+
+    #################################
+    # capabilties interface impls.
+
+    @security.public
+    def allowDeletePrincipal(self, principal_id):
+        """True iff this plugin can delete a certain group.
+        This is true if this plugin manages the group.
+        """
+        if self._groups.get(principal_id) is not None:
+            return 1
+        return 0
+
+    def getGroupInfo(self, group_id):
+        """Over-ride parent to not explode when getting group info dict by
+        group id."""
+        return self._groups.get(group_id, None)
+
+    def allowGroupAdd(self, user_id, group_id):
+        """True iff this plugin will allow adding a certain user to a
+        certain group."""
+        present = self.getGroupInfo(group_id)
+        # if we have a group, we can add users to it
+        # slightly naive, but should be okay.
+        if present:
+            return 1
+
+        return 0
+
+    def allowGroupRemove(self, user_id, group_id):
+        """True iff this plugin will allow removing a certain user from a
+        certain group."""
+        present = self.getGroupInfo(group_id)
+        # if we don't have a group, we can't do anything
+        if not present:
+            return 0
+
+        group_members = self.getGroupMembers(group_id)
+        if user_id in group_members:
+            return 1
+        return 0
+
+    #################################
+    # group wrapping mechanics
+
+    @security.private
+    def _createGroup(self, plugins, group_id, name):
+        """ Create group object. For users, this can be done with a
+        plugin, but I don't care to define one for that now. Just uses
+        PloneGroup.  But, the code's still here, just commented out.
+        This method based on PluggableAuthervice._createUser
+        """
+        return PloneGroup(group_id, name).__of__(self)
+
+    @security.private
+    def _findGroup(self, plugins, group_id, title=None, request=None):
+        """ group_id -> decorated_group
+        This method based on PluggableAuthService._findGroup
+        """
+        group = self._createGroup(plugins, group_id, title)
+
+        propfinders = plugins.listPlugins(IPropertiesPlugin)
+        for propfinder_id, propfinder in propfinders:
+
+            data = propfinder.getPropertiesForUser(group, request)
+            if data:
+                group.addPropertysheet(propfinder_id, data)
+
+        groups = self._getPAS()._getGroupsForPrincipal(group, request,
+                                                       plugins=plugins)
+        group._addGroups(groups)
+
+        rolemakers = plugins.listPlugins(IRolesPlugin)
+
+        for rolemaker_id, rolemaker in rolemakers:
+            roles = rolemaker.getRolesForPrincipal(group, request)
+            if roles:
+                group._addRoles(roles)
+
+        group._addRoles(['Authenticated'])
+
+        return group.__of__(self)
+
+    @security.private
+    def _verifyGroup(self, plugins, group_id=None, title=None):
+
+        """ group_id -> boolean
+        This method based on PluggableAuthService._verifyUser
+        """
+        criteria = {}
+
+        if group_id is not None:
+            criteria['id'] = group_id
+            criteria['exact_match'] = True
+
+        if title is not None:
+            criteria['title'] = title
+
+        if criteria:
+            enumerators = plugins.listPlugins(IGroupEnumerationPlugin)
+
+            for enumerator_id, enumerator in enumerators:
+                try:
+                    info = enumerator.enumerateGroups(**criteria)
+
+                    if info:
+                        return info[0]['id']
+
+                except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+                    logger.info(
+                        'PluggableAuthService: GroupEnumerationPlugin %s '
+                        'error',
+                        enumerator_id,
+                        exc_info=1
+                    )
+
+        return 0
+
+
+InitializeClass(GroupManager)
+
+
+class PloneGroup(PloneUser):
+    """Plone expects a user to come, with approximately the same
+    behavior as a user.
+    """
+
+    security = ClassSecurityInfo()
+    _isGroup = True
+
+    def getId(self, unprefixed=None):
+        """ -> user ID
+        Modified to accept silly GRUF param.
+        """
+        return self._id
+
+    @security.private
+    def getMemberIds(self, transitive=1):
+        """Return member ids of this group, including or not
+        transitive groups.
+        """
+        # acquired from the groups_source
+        plugins = self._getPAS().plugins
+        introspectors = plugins.listPlugins(IGroupIntrospection)
+        members = []
+        for iid, introspector in introspectors:
+            try:
+                members.extend(
+                    list(introspector.getGroupMembers(self.getId())))
+            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+                logger.info(
+                    'PluggableAuthService: getGroupMembers %s error',
+                    iid, exc_info=1)
+
+        return members
+
+    @security.public
+    def addMember(self, id):
+        """Add the existing member with the given id to the group
+        """
+        self.addPrincipalToGroup(id, self.getId())
+
+    @security.public
+    def removeMember(self, id):
+        """Remove the member with the provided id from the group.
+        """
+        self.removePrincipalFromGroup(id, self.getId())
+
+    @security.public
+    def getRolesInContext(self, object):
+        """Since groups can't actually log in, do nothing.
+        """
+        return []
+
+    @security.public
+    def allowed(self, object, object_roles=None):
+        """Since groups can't actually log in, do nothing.
+        """
+        return 0
+
+InitializeClass(PloneGroup)
diff --git a/src/Products/PlonePAS/plugins/local_role.py b/src/Products/PlonePAS/plugins/local_role.py
new file mode 100644
index 0000000..f09ef38
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/local_role.py
@@ -0,0 +1,188 @@
+# -*- coding: utf-8 -*-
+"""
+A Local Roles Plugin Implementation that respects Black Listing markers.
+
+ie. containers/objects which denote that they do not wish to acquire local
+roles from their containment structure.
+
+"""
+from AccessControl import ClassSecurityInfo
+from Acquisition import aq_inner
+from Acquisition import aq_parent
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
+from Products.PluggableAuthService.plugins.LocalRolePlugin \
+    import LocalRolePlugin
+from zope.interface import implementer
+
+
+def manage_addLocalRolesManager(dispatcher, id, title=None, RESPONSE=None):
+    """
+    add a local roles manager
+    """
+    lrm = LocalRolesManager(id, title)
+    dispatcher._setObject(lrm.getId(), lrm)
+
+    if RESPONSE is not None:
+        RESPONSE.redirect('manage_workspace')
+
+manage_addLocalRolesManagerForm = \
+    DTMLFile('../zmi/LocalRolesManagerForm', globals())
+
+
+@implementer(ILocalRolesPlugin)
+class LocalRolesManager(LocalRolePlugin):
+    """Class incorporating local role storage with
+    PlonePAS-specific local role permission checking.
+    """
+
+    meta_type = "Local Roles Manager"
+    security = ClassSecurityInfo()
+
+    def __init__(self, id, title=None):
+        self._id = self.id = id
+        self.title = title
+
+    # security.declarePrivate( 'getRolesInContext' )
+    def getRolesInContext(self, user, object):
+        user_id = user.getId()
+        group_ids = user.getGroups()
+
+        principal_ids = list(group_ids)
+        principal_ids.insert(0, user_id)
+
+        local = {}
+        object = aq_inner(object)
+
+        while 1:
+            local_roles = getattr(object, '__ac_local_roles__', None)
+
+            if local_roles and callable(local_roles):
+                local_roles = local_roles()
+
+            if local_roles:
+                dict = local_roles
+
+                for principal_id in principal_ids:
+                    for role in dict.get(principal_id, []):
+                        local[role] = 1
+
+            inner = aq_inner(object)
+            parent = aq_parent(inner)
+
+            if getattr(object, '__ac_local_roles_block__', None):
+                break
+
+            if parent is not None:
+                object = parent
+                continue
+
+            new = getattr(object, 'im_self', None)
+
+            if new is not None:
+                object = aq_inner(new)
+                continue
+
+            break
+
+        return local.keys()
+
+    # security.declarePrivate('checkLocalRolesAllowed')
+    def checkLocalRolesAllowed(self, user, object, object_roles):
+        # Still have not found a match, so check local roles. We do
+        # this manually rather than call getRolesInContext so that
+        # we can incur only the overhead required to find a match.
+        inner_obj = aq_inner(object)
+        user_id = user.getId()
+        group_ids = user.getGroups()
+
+        principal_ids = list(group_ids)
+        principal_ids.insert(0, user_id)
+
+        while 1:
+
+            local_roles = getattr(inner_obj, '__ac_local_roles__', None)
+
+            if local_roles and callable(local_roles):
+                local_roles = local_roles()
+
+            if local_roles:
+                dict = local_roles
+
+                for principal_id in principal_ids:
+                    local_roles = dict.get(principal_id, [])
+
+                    # local_roles is empty most of the time, where as
+                    # object_roles is usually not.
+                    if not local_roles:
+                        continue
+
+                    for role in object_roles:
+                        if role in local_roles:
+                            if user._check_context(object):
+                                return 1
+                            return 0
+
+            inner = aq_inner(inner_obj)
+            parent = aq_parent(inner)
+
+            if getattr(inner_obj, '__ac_local_roles_block__', None):
+                break
+
+            if parent is not None:
+                inner_obj = parent
+                continue
+
+            new = getattr(inner_obj, 'im_self', None)
+
+            if new is not None:
+                inner_obj = aq_inner(new)
+                continue
+
+            break
+
+        return None
+
+    def getAllLocalRolesInContext(self, context):
+        roles = {}
+        object = aq_inner(context)
+
+        while True:
+
+            local_roles = getattr(object, '__ac_local_roles__', None)
+
+            if local_roles and callable(local_roles):
+                local_roles = local_roles()
+
+            if local_roles:
+
+                dict = local_roles
+
+                for principal, localroles in dict.items():
+                    if principal not in roles:
+                        roles[principal] = set()
+
+                    roles[principal].update(localroles)
+
+            inner = aq_inner(object)
+            parent = aq_parent(inner)
+
+            if getattr(object, '__ac_local_roles_block__', None):
+                break
+
+            if parent is not None:
+                object = parent
+                continue
+
+            new = getattr(object, 'im_self', None)
+
+            if new is not None:
+                object = aq_inner(new)
+                continue
+
+            break
+
+        return roles
+
+InitializeClass(LocalRolesManager)
diff --git a/src/Products/PlonePAS/plugins/passwordpolicy.py b/src/Products/PlonePAS/plugins/passwordpolicy.py
new file mode 100644
index 0000000..0b3c29a
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/passwordpolicy.py
@@ -0,0 +1,77 @@
+# -*- coding: utf-8 -*-
+"""
+Password Validation plugin (IValidationPlugin)
+Mutable Property Provider
+"""
+from AccessControl import ClassSecurityInfo
+from App.class_init import InitializeClass
+from Products.PageTemplates.PageTemplateFile import PageTemplateFile
+from Products.PluggableAuthService.interfaces.plugins import IValidationPlugin
+from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from zope.i18nmessageid import MessageFactory
+from zope.interface import implementer
+
+_ = MessageFactory('plone')
+
+manage_addPasswordPolicyForm = PageTemplateFile(
+    "../zmi/PasswordPolicyForm",
+    globals()
+)
+
+
+def manage_addPasswordPolicyPlugin(self, id, title='',
+                                   RESPONSE=None, schema=None, **kw):
+    """
+    Create an instance of a password validation plugin.
+    """
+    o = PasswordPolicyPlugin(id, title)
+    self._setObject(o.getId(), o)
+
+    if RESPONSE is not None:
+        return RESPONSE.redirect(
+            "%s/manage_workspace?"
+            "manage_tabs_message=DefaultPasswordPlugin+plugin+added" %
+            self.absolute_url()
+        )
+
+
+@implementer(IValidationPlugin)
+class PasswordPolicyPlugin(BasePlugin):
+    """Simple Password Policy to ensure password is 5 chars long.
+    """
+
+    meta_type = 'Default Plone Password Policy'
+
+    security = ClassSecurityInfo()
+
+    def __init__(self, id, title=''):
+        """Create a default plone password policy to ensure 5 char passwords
+        """
+        self.id = id
+        self.title = title
+
+    @security.private
+    def validateUserInfo(self, user, set_id, set_info):
+        """ See IValidationPlugin. Used to validate password property
+        """
+
+        if not set_info:
+            return []
+        password = set_info.get('password', None)
+        if password is None:
+            return []
+        elif password == '':
+            return [{'id': 'password', 'error': _(u'Minimum 5 characters.')}]
+        elif len(password) < 5:
+            return [
+                {
+                    'id': 'password',
+                    'error': _(
+                        u'Your password must contain at least 5 characters.'
+                    )
+                }
+            ]
+        else:
+            return []
+
+InitializeClass(PasswordPolicyPlugin)
diff --git a/src/Products/PlonePAS/plugins/property.py b/src/Products/PlonePAS/plugins/property.py
new file mode 100644
index 0000000..25e8ee5
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/property.py
@@ -0,0 +1,293 @@
+# -*- coding: utf-8 -*-
+"""
+Mutable Property Provider
+"""
+from AccessControl import ClassSecurityInfo
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from BTrees.OOBTree import OOBTree
+from Products.CMFCore.utils import getToolByName
+from Products.PlonePAS.interfaces.plugins import IMutablePropertiesPlugin
+from Products.PlonePAS.sheet import MutablePropertySheet
+from Products.PlonePAS.sheet import validateValue
+from Products.PlonePAS.utils import safe_unicode
+from Products.PluggableAuthService.UserPropertySheet import _guessSchema
+from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
+from Products.PluggableAuthService.interfaces.plugins \
+    import IUserEnumerationPlugin
+from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from ZODB.PersistentMapping import PersistentMapping
+from zope.i18nmessageid import MessageFactory
+from zope.interface import implementer
+import copy
+
+_ = MessageFactory('plone')
+
+
+def manage_addZODBMutablePropertyProvider(self, id, title='',
+                                          RESPONSE=None, schema=None, **kw):
+    """
+    Create an instance of a mutable property manager.
+    """
+    o = ZODBMutablePropertyProvider(id, title, schema, **kw)
+    self._setObject(o.getId(), o)
+
+    if RESPONSE is not None:
+        RESPONSE.redirect('manage_workspace')
+
+manage_addZODBMutablePropertyProviderForm = DTMLFile(
+    "../zmi/MutablePropertyProviderForm", globals())
+
+
+def isStringType(data):
+    return isinstance(data, str) or isinstance(data, unicode)
+
+
+@implementer(
+    IPropertiesPlugin,
+    IUserEnumerationPlugin,
+    IMutablePropertiesPlugin
+)
+class ZODBMutablePropertyProvider(BasePlugin):
+    """Storage for mutable properties in the ZODB for users/groups.
+
+    API sounds like it's only for users, but groups work as well.
+    """
+
+    meta_type = 'ZODB Mutable Property Provider'
+
+    security = ClassSecurityInfo()
+
+    def __init__(self, id, title='', schema=None, **kw):
+        """Create in-ZODB mutable property provider.
+
+        Provide a schema either as a list of (name,type,value) tuples
+        in the 'schema' parameter or as a series of keyword parameters
+        'name=value'. Types will be guessed in this case.
+
+        The 'value' is meant as the default value, and will be used
+        unless the user provides data.
+
+        If no schema is provided by constructor, the properties of the
+        portal_memberdata object will be used.
+
+        Types available: string, text, boolean, int, long, float, lines, date
+        """
+        self.id = id
+        self.title = title
+        self._storage = OOBTree()
+
+        # calculate schema and default values
+        defaultvalues = {}
+        if not schema and not kw:
+            schema = ()
+        elif not schema and kw:
+            schema = _guessSchema(kw)
+            defaultvalues = kw
+        else:
+            valuetuples = [(name, value) for name, type, value in schema]
+            schema = [(name, type) for name, type, value in schema]
+            for name, value in valuetuples:
+                defaultvalues[name] = value
+        self._schema = tuple(schema)
+        self._defaultvalues = defaultvalues
+
+    def _getSchema(self, isgroup=None):
+        # this could probably stand to be cached
+        datatool = isgroup and "portal_groupdata" or "portal_memberdata"
+
+        schema = self._schema
+        if not schema:
+            # if no schema is provided, use portal_memberdata properties
+            schema = ()
+            mdtool = getToolByName(self, datatool, None)
+            # Don't fail badly if tool is not available.
+            if mdtool is not None:
+                mdschema = mdtool.propertyMap()
+                schema = [(elt['id'], elt['type']) for elt in mdschema]
+        return schema
+
+    def _getDefaultValues(self, isgroup=None):
+        """Returns a dictionary mapping of property names to default values.
+        Defaults to portal_*data tool if necessary.
+        """
+        datatool = isgroup and "portal_groupdata" or "portal_memberdata"
+
+        defaultvalues = self._defaultvalues
+        if not self._schema:
+            # if no schema is provided, use portal_*data properties
+            defaultvalues = {}
+            mdtool = getToolByName(self, datatool, None)
+            # Don't fail badly if tool is not available.
+            if mdtool is not None:
+                # we rely on propertyMap and propertyItems mapping
+                mdvalues = mdtool.propertyItems()
+                for name, value in mdvalues:
+                    # For selection types the default value is the name of a
+                    # method which returns the possible values. There is no way
+                    # to set a default value for those types.
+                    ptype = mdtool.getPropertyType(name)
+                    if ptype == "selection":
+                        defaultvalues[name] = ""
+                    elif ptype == "multiple selection":
+                        defaultvalues[name] = []
+                    else:
+                        defaultvalues[name] = value
+
+            # ALERT! if someone gives their *_data tool a title, and want a
+            #        title as a property of the user/group (and groups do by
+            #        default) we don't want them all to have this title, since
+            #        a title is used in the UI if it exists
+            if defaultvalues.get("title"):
+                defaultvalues["title"] = ""
+        return defaultvalues
+
+    @security.private
+    def getPropertiesForUser(self, user, request=None):
+        """Get property values for a user or group.
+        Returns a dictionary of values or a PropertySheet.
+
+        This implementation will always return a MutablePropertySheet.
+
+        NOTE: Must always return something, or else the property sheet
+        won't get created and this will screw up portal_memberdata.
+        """
+        isGroup = getattr(user, 'isGroup', lambda: None)()
+
+        data = self._storage.get(user.getId())
+        defaults = self._getDefaultValues(isGroup)
+
+        # provide default values where missing
+        if not data:
+            data = {}
+        for key, val in defaults.items():
+            if key not in data:
+                data[key] = val
+
+        return MutablePropertySheet(self.id,
+                                    schema=self._getSchema(isGroup), **data)
+
+    @security.private
+    def setPropertiesForUser(self, user, propertysheet):
+        """Set the properties of a user or group based on the contents of a
+        property sheet.
+        """
+        isGroup = getattr(user, 'isGroup', lambda: None)()
+
+        properties = dict(propertysheet.propertyItems())
+
+        for name, property_type in self._getSchema(isGroup) or ():
+            if (
+                name in properties and not
+                validateValue(property_type, properties[name])
+            ):
+                raise ValueError(
+                    'Invalid value: %s does not conform to %s' %
+                    (name, property_type)
+                )
+
+        allowed_prop_keys = [pn for pn, pt in self._getSchema(isGroup) or ()]
+        if allowed_prop_keys:
+            prop_names = set(properties.keys()) - set(allowed_prop_keys)
+            if prop_names:
+                raise ValueError('Unknown Properties: %r' % prop_names)
+
+        userid = user.getId()
+        userprops = self._storage.get(userid)
+        properties.update({'isGroup': isGroup})
+        if userprops is not None:
+            userprops.update(properties)
+            # notify persistence machinery of change
+            self._storage[userid] = self._storage[userid]
+        else:
+            self._storage.insert(user.getId(), properties)
+
+    @security.private
+    def deleteUser(self, user_id):
+        """Delete all user properties
+        """
+        # Do nothing if an unknown user_id is given
+        try:
+            del self._storage[user_id]
+        except KeyError:
+            pass
+
+    @security.private
+    def testMemberData(self, memberdata, criteria, exact_match=False):
+        """Test if a memberdata matches the search criteria.
+        """
+        for (key, value) in criteria.items():
+            testvalue = memberdata.get(key, None)
+            if testvalue is None:
+                return False
+
+            if isStringType(testvalue):
+                testvalue = safe_unicode(testvalue.lower())
+            if isStringType(value):
+                value = safe_unicode(value.lower())
+
+            if exact_match:
+                if value != testvalue:
+                    return False
+            else:
+                try:
+                    if value not in testvalue:
+                        return False
+                except TypeError:
+                    # Fall back to exact match if we can check for
+                    # sub-component
+                    if value != testvalue:
+                        return False
+
+        return True
+
+    @security.private
+    def enumerateUsers(self, id=None, login=None,
+                       exact_match=False, **kw):
+        """ See IUserEnumerationPlugin.
+        """
+        plugin_id = self.getId()
+
+        # This plugin can't search for a user by id or login, because there is
+        # no such keys in the storage (data dict in the comprehensive list)
+        # If kw is empty or not, we continue the search.
+        if id is not None or login is not None:
+            return ()
+
+        criteria = copy.copy(kw)
+
+        users = [(user, data) for (user, data) in self._storage.items()
+                 if self.testMemberData(data, criteria, exact_match)
+                 and not data.get('isGroup', False)]
+
+        user_info = [{'id': self.prefix + user_id,
+                      'login': user_id,
+                      'title': data.get('fullname', user_id),
+                      'description': data.get('fullname', user_id),
+                      'email': data.get('email', ''),
+                      'pluginid': plugin_id} for (user_id, data) in users]
+
+        return tuple(user_info)
+
+    def updateUser(self, user_id, login_name):
+        """ Update the login name of the user with id user_id.
+
+        This is a new part of the IUserEnumerationPlugin interface, but
+        not interesting for us.
+        """
+        pass
+
+    def updateEveryLoginName(self, quit_on_first_error=True):
+        """Update login names of all users to their canonical value.
+
+        This is a new part of the IUserEnumerationPlugin interface, but
+        not interesting for us.
+        """
+        pass
+
+
+InitializeClass(ZODBMutablePropertyProvider)
+
+
+class PersistentProperties(PersistentMapping):
+    pass
diff --git a/src/Products/PlonePAS/plugins/role.py b/src/Products/PlonePAS/plugins/role.py
new file mode 100644
index 0000000..8a0b444
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/role.py
@@ -0,0 +1,167 @@
+# -*- coding: utf-8 -*-
+"""
+group aware role manager, returns roles assigned to group a principal
+is a member of, in addition to the explicit roles assigned directly
+to the principal.
+
+"""
+from AccessControl import ClassSecurityInfo
+from AccessControl.requestmethod import postonly
+from Acquisition import aq_get
+from Acquisition import aq_inner
+from Acquisition import aq_parent
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from Products.PlonePAS.interfaces.capabilities import IAssignRoleCapability
+from Products.PlonePAS.utils import getGroupsForPrincipal
+from Products.PluggableAuthService.permissions import ManageUsers
+from Products.PluggableAuthService.plugins.ZODBRoleManager \
+    import ZODBRoleManager
+from zope.interface import implementer
+
+
+def manage_addGroupAwareRoleManager(self, id, title='', RESPONSE=None):
+    """
+    this is a doc string
+    """
+    garm = GroupAwareRoleManager(id, title)
+    self._setObject(garm.getId(), garm)
+
+    if RESPONSE is not None:
+        RESPONSE.redirect('manage_workspace')
+
+manage_addGroupAwareRoleManagerForm = DTMLFile(
+    '../zmi/GroupAwareRoleManagerForm', globals())
+
+
+@implementer(IAssignRoleCapability)
+class GroupAwareRoleManager(ZODBRoleManager):
+
+    meta_type = "Group Aware Role Manager"
+    security = ClassSecurityInfo()
+
+    def updateRolesList(self):
+        role_holder = aq_parent(aq_inner(self._getPAS()))
+        for role in getattr(role_holder, '__ac_roles__', ()):
+            if role not in ('Anonymous', 'Authenticated') and \
+                    role not in self._roles:
+                try:
+                    self.addRole(role)
+                except KeyError:
+                    pass
+
+    # don't blow up if manager already exists; mostly for ZopeVersionControl
+    def manage_afterAdd(self, item, container):
+        try:
+            self.addRole('Manager')
+        except KeyError:
+            pass
+
+        if item is self:
+            self.updateRolesList()
+
+    @security.protected(ManageUsers)
+    def assignRoleToPrincipal(self, role_id, principal_id, REQUEST=None):
+        try:
+            return ZODBRoleManager.assignRoleToPrincipal(
+                self,
+                role_id,
+                principal_id
+            )
+        except KeyError:
+            # Lazily update our roles list and try again
+            self.updateRolesList()
+            return ZODBRoleManager.assignRoleToPrincipal(
+                self,
+                role_id,
+                principal_id
+            )
+
+    @security.protected(ManageUsers)
+    def assignRolesToPrincipal(self, roles, principal_id, REQUEST=None):
+        """ Assign a specific set of roles, and only those roles, to a
+        principal.
+
+        o no return value
+
+        o Raise KeyError if a role_id is unknown.
+        """
+        for role_id in roles:
+            if role_id not in ('Authenticated', 'Anonymous', 'Owner'):
+                try:
+                    # raise KeyError if unknown!
+                    self._roles[role_id]
+                except KeyError:
+                    # Lazily update our roles list and try again
+                    self.updateRolesList()
+                    if role_id in self._roles:
+                        # check if this role is managed by this plugin, and
+                        # set it
+                        self._roles[role_id]
+
+        self._principal_roles[principal_id] = tuple(roles)
+
+    assignRolesToPrincipal = postonly(assignRolesToPrincipal)
+
+    @security.private
+    def getRolesForPrincipal(self, principal, request=None):
+        """ See IRolesPlugin.
+        """
+        roles = set([])
+        principal_ids = set([])
+        # Some services need to determine the roles obtained from groups
+        # while excluding the directly assigned roles.  In this case
+        # '__ignore_direct_roles__' = True should be pushed in the request.
+        request = aq_get(self, 'REQUEST', None)
+        if request is None \
+           or not request.get('__ignore_direct_roles__', False):
+            principal_ids.add(principal.getId())
+
+        # Some services may need the real roles of an user but **not**
+        # the ones he got through his groups. In this case, the
+        # '__ignore_group_roles__'= True should be previously pushed
+        # in the request.
+        plugins = self._getPAS()['plugins']
+        if request is None \
+           or not request.get('__ignore_group_roles__', False):
+            principal_ids.update(
+                getGroupsForPrincipal(principal, plugins, request)
+            )
+        for pid in principal_ids:
+            roles.update(self._principal_roles.get(pid, ()))
+        return tuple(roles)
+
+    # implement IAssignRoleCapability
+
+    def allowRoleAssign(self, user_id, role_id):
+        """True iff this plugin will allow assigning a certain user a
+        certain role.
+
+        Note that at least currently this only checks if the role_id
+        exists.  If it exists, this method returns True.  Nothing is
+        done with the user_id parameter.  This might be wrong.  See
+        http://dev.plone.org/plone/ticket/7762
+        """
+        present = self.getRoleInfo(role_id)
+        if present:
+            # if we have a role, we can assign it
+            # slightly naive, but should be okay.
+            return 1
+
+        return 0
+
+    def listRoleIds(self):
+        self.updateRolesList()
+        return ZODBRoleManager.listRoleIds(self)
+
+    def listRoleInfo(self):
+        self.updateRolesList()
+        return ZODBRoleManager.listRoleInfo(self)
+
+    def getRoleInfo(self, role_id):
+        if role_id not in self._roles:
+            self.updateRolesList()
+        return ZODBRoleManager.getRoleInfo(self, role_id)
+
+
+InitializeClass(GroupAwareRoleManager)
diff --git a/src/Products/PlonePAS/plugins/ufactory.py b/src/Products/PlonePAS/plugins/ufactory.py
new file mode 100644
index 0000000..db24491
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/ufactory.py
@@ -0,0 +1,235 @@
+# -*- coding: utf-8 -*-
+from AccessControl import ClassSecurityInfo
+from AccessControl.PermissionRole import _what_not_even_god_should_do
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
+from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
+from Products.PluggableAuthService.PropertiedUser import PropertiedUser
+from Products.PluggableAuthService.UserPropertySheet import UserPropertySheet
+from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
+from Products.PluggableAuthService.interfaces.plugins import IUserFactoryPlugin
+from Products.PluggableAuthService.interfaces.propertysheets \
+    import IPropertySheet
+from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from collections import OrderedDict
+from zope.interface import implementer
+
+manage_addPloneUserFactoryForm = DTMLFile('../zmi/PloneUserFactoryForm',
+                                          globals())
+
+_marker = object()
+
+
+def manage_addPloneUserFactory(self, id, title='', RESPONSE=None):
+    """
+    Add a plone user factory
+    """
+
+    puf = PloneUserFactory(id, title)
+    self._setObject(puf.getId(), puf)
+
+    if RESPONSE is not None:
+        return RESPONSE.redirect('manage_workspace')
+
+
+@implementer(IUserFactoryPlugin)
+class PloneUserFactory(BasePlugin):
+
+    security = ClassSecurityInfo()
+    meta_type = 'Plone User Factory'
+
+    def __init__(self, id, title=''):
+        self.id = id
+        self.title = title or self.meta_type
+
+    @security.private
+    def createUser(self, user_id, name):
+        return PloneUser(user_id, name)
+
+
+InitializeClass(PloneUserFactory)
+
+
+class PloneUser(PropertiedUser):
+
+    security = ClassSecurityInfo()
+
+    #################################
+    # GRUF API
+    _isGroup = False
+
+    def __init__(self, id, login=None):
+        super(PloneUser, self).__init__(id, login)
+        self._propertysheets = OrderedDict()
+
+    def _getPAS(self):
+        # XXX This is not very optimal *at all*
+        return self.acl_users
+
+    def _getPlugins(self):
+        # XXX This is not very optimal *at all*
+        return self._getPAS().plugins
+
+    @security.public
+    def isGroup(self):
+        """Return 1 if this user is a group abstraction"""
+        return self._isGroup
+
+    @security.public
+    def getName(self):
+        """Get user's or group's name.
+        This is the id. PAS doesn't do prefixes and such like GRUF.
+        """
+        return self.getId()
+
+    @security.public
+    def getUserId(self):
+        """Get user's or group's name.
+        This is the id. PAS doesn't do prefixes and such like GRUF.
+        """
+        return self.getId()
+
+    @security.public
+    def getGroupNames(self):
+        """Return ids of this user's groups. GRUF compat."""
+        return self.getGroups()
+
+    security.declarePublic('getGroupIds')
+    getGroupIds = getGroupNames
+
+    #################################
+    # acquisition aware
+
+    @security.public
+    def getPropertysheet(self, id):
+        """ -> propertysheet (wrapped if supported)
+        """
+        sheet = self._propertysheets[id]
+        try:
+            return sheet.__of__(self)
+        except AttributeError:
+            return sheet
+
+    @security.private
+    def addPropertysheet(self, id, data):
+        """ -> add a prop sheet, given data which is either
+        a property sheet or a raw mapping.
+        """
+        if IPropertySheet.providedBy(data):
+            sheet = data
+        else:
+            sheet = UserPropertySheet(id, **data)
+
+        if self._propertysheets.get(id) is not None:
+            raise KeyError('Duplicate property sheet: %s' % id)
+
+        self._propertysheets[id] = sheet
+
+    def _getPropertyPlugins(self):
+        return self._getPAS().plugins.listPlugins(IPropertiesPlugin)
+
+    @security.private
+    def getOrderedPropertySheets(self):
+        return self._propertysheets.values()
+
+    #################################
+    # local roles plugin type delegation
+
+    def _getLocalRolesPlugins(self):
+        return self._getPAS().plugins.listPlugins(ILocalRolesPlugin)
+
+    def getRolesInContext(self, object):
+        lrmanagers = self._getLocalRolesPlugins()
+        roles = set([])
+        for lrid, lrmanager in lrmanagers:
+            roles.update(lrmanager.getRolesInContext(self, object))
+        roles.update(self.getRoles())
+        return list(roles)
+
+    def allowed(self, object, object_roles=None):
+        if object_roles is _what_not_even_god_should_do:
+            return 0
+
+        # Short-circuit the common case of anonymous access.
+        if object_roles is None or 'Anonymous' in object_roles:
+            return 1
+
+        # Provide short-cut access if object is protected by 'Authenticated'
+        # role and user is not nobody
+        if 'Authenticated' in object_roles \
+           and self.getUserName() != 'Anonymous User':
+            return 1
+
+        # Check for ancient role data up front, convert if found.
+        # This should almost never happen, and should probably be
+        # deprecated at some point.
+        if 'Shared' in object_roles:
+            object_roles = self._shared_roles(object)
+            if object_roles is None or 'Anonymous' in object_roles:
+                return 1
+
+        # Check for a role match with the normal roles given to
+        # the user, then with local roles only if necessary. We
+        # want to avoid as much overhead as possible.
+        user_roles = self.getRoles()
+        for role in object_roles:
+            if role in user_roles:
+                if self._check_context(object):
+                    return 1
+                return None
+
+        # check for local roles
+        lrmanagers = self._getLocalRolesPlugins()
+
+        for lrid, lrm in lrmanagers:
+            allowed = lrm.checkLocalRolesAllowed(self, object, object_roles)
+            # return values
+            # 0, 1, None
+            # - 1 success
+            # - 0 object context violation
+            # - None - failure
+            if allowed is None:
+                continue
+            return allowed
+        return None
+
+    def setProperties(self, properties=None, **kw):
+        """ Set properties on a given user.
+
+        Accepts either keyword arguments or a mapping for the ``properties``
+        argument. The ``properties`` argument will take precedence over
+        keyword arguments if both are provided; no merging will occur.
+        """
+        if properties is None:
+            properties = kw
+
+        for sheet in self.getOrderedPropertySheets():
+            if not IMutablePropertySheet.providedBy(sheet):
+                continue
+
+            update = {}
+            for (key, value) in properties.items():
+                if sheet.hasProperty(key):
+                    update[key] = value
+                    del properties[key]
+
+            if update:
+                sheet.setProperties(self, update)
+
+    def getProperty(self, id, default=_marker):
+        for sheet in self.getOrderedPropertySheets():
+            if sheet.hasProperty(id):
+                value = sheet.getProperty(id)
+                if isinstance(value, unicode):
+                    # XXX Temporarily work around the fact that
+                    # property sheets blindly store and return
+                    # unicode. This is sub-optimal and should be
+                    # dealed with at the property sheets level by
+                    # using Zope's converters.
+                    return value.encode('utf-8')
+                return value
+
+        return default
+
+InitializeClass(PloneUser)
diff --git a/src/Products/PlonePAS/plugins/user.py b/src/Products/PlonePAS/plugins/user.py
new file mode 100644
index 0000000..79ee8f0
--- /dev/null
+++ b/src/Products/PlonePAS/plugins/user.py
@@ -0,0 +1,132 @@
+# -*- coding: utf-8 -*-
+"""
+ZODB based user manager with introspection and management interfaces.
+"""
+from AccessControl import AuthEncoding
+from AccessControl import ClassSecurityInfo
+from AccessControl.Permissions import manage_users as ManageUsers
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
+from Products.PlonePAS.interfaces.capabilities import IPasswordSetCapability
+from Products.PlonePAS.interfaces.plugins import IUserIntrospection
+from Products.PlonePAS.interfaces.plugins import IUserManagement
+from Products.PluggableAuthService.plugins.ZODBUserManager \
+    import ZODBUserManager as BasePlugin
+from Products.PluggableAuthService.utils import createViewName
+from zope.interface import implementer
+
+manage_addUserManagerForm = DTMLFile('../zmi/UserManagerForm', globals())
+
+
+def manage_addUserManager(dispatcher, id, title=None, REQUEST=None):
+    """ Add a UserManager to a Pluggable Auth Service. """
+
+    pum = UserManager(id, title)
+    dispatcher._setObject(pum.getId(), pum)
+
+    if REQUEST is not None:
+        REQUEST['RESPONSE'].redirect(
+            '%s/manage_workspace'
+            '?manage_tabs_message='
+            'UserManager+added.'
+            % dispatcher.absolute_url())
+
+
+@implementer(
+    IUserManagement,
+    IUserIntrospection,
+    IDeleteCapability,
+    IPasswordSetCapability
+)
+class UserManager(BasePlugin):
+    """PAS plugin for managing users. (adds write API)
+    """
+
+    meta_type = 'User Manager'
+    security = ClassSecurityInfo()
+
+    @security.protected(ManageUsers)
+    def addUser(self, user_id, login_name, password):
+        """Original ZODBUserManager.addUser, modified to check if
+        incoming password is already encypted.
+
+        This support clean migration from default user source.
+        Should go into PAS.
+        """
+        if self._user_passwords.get(user_id) is not None:
+            raise KeyError('Duplicate user ID: %s' % user_id)
+
+        if self._login_to_userid.get(login_name) is not None:
+            raise KeyError('Duplicate login name: %s' % login_name)
+
+        if not AuthEncoding.is_encrypted(password):
+            password = AuthEncoding.pw_encrypt(password)
+        self._user_passwords[user_id] = password
+        self._login_to_userid[login_name] = user_id
+        self._userid_to_login[user_id] = login_name
+
+        # enumerateUsers return value has changed
+        view_name = createViewName('enumerateUsers')
+        self.ZCacheable_invalidate(view_name=view_name)
+
+    # User Management interface
+
+    @security.private
+    def doDeleteUser(self, userid):
+        """Given a user id, delete that user
+        """
+        return self.removeUser(userid)
+
+    @security.private
+    def doChangeUser(self, principal_id, password):
+        """Change a user's password
+        """
+        if self._user_passwords.get(principal_id) is None:
+            raise RuntimeError("User does not exist: %s" % principal_id)
+        self._user_passwords[principal_id] = AuthEncoding.pw_encrypt(password)
+
+    # implement interfaces IDeleteCapability, IPasswordSetCapability
+
+    @security.public
+    def allowDeletePrincipal(self, principal_id):
+        """True iff this plugin can delete a certain user/group.
+        This is true if this plugin manages the user.
+        """
+        if self._user_passwords.get(principal_id) is not None:
+            return 1
+        return 0
+
+    @security.public
+    def allowPasswordSet(self, principal_id):
+        """True iff this plugin can set the password a certain user.
+        This is true if this plugin manages the user.
+        """
+        return self.allowDeletePrincipal(principal_id)
+
+    # User Introspection interface
+
+    @security.protected(ManageUsers)
+    def getUserIds(self):
+        """
+        Return a list of user ids
+        """
+        return self.listUserIds()
+
+    @security.protected(ManageUsers)
+    def getUserNames(self):
+        """
+        Return a list of usernames
+        """
+        return [x['login_name'] for x in self.listUserInfo()]
+
+    @security.protected(ManageUsers)
+    def getUsers(self):
+        """
+        Return a list of users
+        """
+        uf = self.acl_users
+        return [uf.getUserById(x) for x in self.getUserIds()]
+
+
+InitializeClass(UserManager)
diff --git a/src/Products/PlonePAS/profiles.zcml b/src/Products/PlonePAS/profiles.zcml
new file mode 100644
index 0000000..8410395
--- /dev/null
+++ b/src/Products/PlonePAS/profiles.zcml
@@ -0,0 +1,14 @@
+<configure
+    xmlns="http://namespaces.zope.org/zope"
+    xmlns:genericsetup="http://namespaces.zope.org/genericsetup"
+    i18n_domain="plonepas">
+
+  <genericsetup:registerProfile
+      name="PlonePAS"
+      title="PlonePAS"
+      directory="profiles/default"
+      description="Extension profile for default PlonePAS setup."
+      provides="Products.GenericSetup.interfaces.EXTENSION"
+      />
+
+</configure>
diff --git a/src/Products/PlonePAS/profiles/default/metadata.xml b/src/Products/PlonePAS/profiles/default/metadata.xml
new file mode 100644
index 0000000..dab4dc0
--- /dev/null
+++ b/src/Products/PlonePAS/profiles/default/metadata.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0"?>
+<metadata>
+  <version>4</version>
+</metadata>
diff --git a/src/Products/PlonePAS/profiles/default/plone-pas.txt b/src/Products/PlonePAS/profiles/default/plone-pas.txt
new file mode 100644
index 0000000..9b080f9
--- /dev/null
+++ b/src/Products/PlonePAS/profiles/default/plone-pas.txt
@@ -0,0 +1 @@
+The plone-pas step is run if this file is present in the profile
diff --git a/src/Products/PlonePAS/setuphandlers.py b/src/Products/PlonePAS/setuphandlers.py
new file mode 100644
index 0000000..df107e2
--- /dev/null
+++ b/src/Products/PlonePAS/setuphandlers.py
@@ -0,0 +1,496 @@
+# -*- coding: utf-8 -*-
+from Acquisition import aq_parent
+from Products.CMFCore.utils import getToolByName
+from Products.PlonePAS import config
+from Products.PlonePAS.interfaces import group as igroup
+from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin
+from Products.PlonePAS.interfaces.plugins import IUserIntrospection
+from Products.PlonePAS.interfaces.plugins import IUserManagement
+from Products.PluggableAuthService.Extensions.upgrade import replace_acl_users
+from Products.PluggableAuthService.interfaces.authservice \
+    import IPluggableAuthService
+from Products.PluggableAuthService.interfaces.plugins import IChallengePlugin
+from Products.PluggableAuthService.interfaces.plugins \
+    import ICredentialsResetPlugin
+from Products.PluggableAuthService.plugins.RecursiveGroupsPlugin \
+    import addRecursiveGroupsPlugin
+from plone.session.plugins.session import manage_addSessionPlugin
+import logging
+
+logger = logging.getLogger('PlonePAS setup')
+
+
+def activatePluginInterfaces(portal, plugin, disable=None):
+    if disable is None:
+        disable = []
+    pas = portal.acl_users
+    plugin_obj = pas[plugin]
+
+    activatable = []
+
+    for info in plugin_obj.plugins.listPluginTypeInfo():
+        interface = info['interface']
+        interface_name = info['id']
+        if plugin_obj.testImplements(interface):
+            if interface_name in disable:
+                disable.append(interface_name)
+                logger.debug("Disabling: " + info['title'])
+            else:
+                activatable.append(interface_name)
+                logger.debug("Activating: " + info['title'])
+    plugin_obj.manage_activateInterfaces(activatable)
+    logger.debug(plugin + " activated.")
+
+
+def setupRoles(portal):
+    rmanager = portal.acl_users.role_manager
+    rmanager.addRole('Member', title="Portal Member")
+    rmanager.addRole('Reviewer', title="Content Reviewer")
+
+
+def registerPluginType(pas, plugin_type, plugin_info):
+    # Make sure there's no dupes in _plugin_types, otherwise your PAS
+    # will *CRAWL*
+    plugin_types = list(set(pas.plugins._plugin_types))
+    if plugin_type not in plugin_types:
+        plugin_types.append(plugin_type)
+
+    # Order doesn't seem to matter, but let's store it ordered.
+    plugin_types.sort()
+
+    # Re-assign to the object, because this is a non-persistent list.
+    pas.plugins._plugin_types = plugin_types
+
+    # It's safe to assign over a existing key here.
+    pas.plugins._plugin_type_info[plugin_type] = plugin_info
+
+
+def registerPluginTypes(pas):
+
+    PluginInfo = {
+        'id': 'IUserManagement',
+        'title': 'user_management',
+        'description': ("The User Management plugins allow the "
+                        "Pluggable Auth Service to add/delete/modify users")
+    }
+
+    registerPluginType(pas, IUserManagement, PluginInfo)
+
+    PluginInfo = {
+        'id': 'IUserIntrospection',
+        'title': 'user_introspection',
+        'description': ("The User Introspection plugins allow the "
+                        "Pluggable Auth Service to provide lists of users")
+    }
+
+    registerPluginType(pas, IUserIntrospection, PluginInfo)
+
+    PluginInfo = {
+        'id': 'IGroupManagement',
+        'title': 'group_management',
+        'description': ("Group Management provides add/write/deletion "
+                        "of groups and member management")
+    }
+
+    registerPluginType(pas, igroup.IGroupManagement, PluginInfo)
+
+    PluginInfo = {
+        'id': 'IGroupIntrospection',
+        'title': 'group_introspection',
+        'description': ("Group Introspection provides listings "
+                        "of groups and membership")
+    }
+
+    registerPluginType(pas, igroup.IGroupIntrospection, PluginInfo)
+
+    PluginInfo = {
+        'id': 'ILocalRolesPlugin',
+        'title': 'local_roles',
+        'description': "Defines Policy for getting Local Roles"
+    }
+
+    registerPluginType(pas, ILocalRolesPlugin, PluginInfo)
+
+
+def setupPlugins(portal):
+    uf = portal.acl_users
+    logger.debug("\nPlugin setup")
+
+    pas = uf.manage_addProduct['PluggableAuthService']
+    plone_pas = uf.manage_addProduct['PlonePAS']
+
+    setupAuthPlugins(portal, pas, plone_pas)
+
+    found = uf.objectIds(['User Manager'])
+    if not found:
+        plone_pas.manage_addUserManager('source_users')
+        logger.debug("Added User Manager.")
+    activatePluginInterfaces(portal, 'source_users')
+
+    found = uf.objectIds(['Group Aware Role Manager'])
+    if not found:
+        plone_pas.manage_addGroupAwareRoleManager('portal_role_manager')
+        logger.debug("Added Group Aware Role Manager.")
+        activatePluginInterfaces(portal, 'portal_role_manager')
+
+    found = uf.objectIds(['Local Roles Manager'])
+    if not found:
+        plone_pas.manage_addLocalRolesManager('local_roles')
+        logger.debug("Added Group Aware Role Manager.")
+        activatePluginInterfaces(portal, 'local_roles')
+
+    found = uf.objectIds(['Group Manager'])
+    if not found:
+        plone_pas.manage_addGroupManager('source_groups')
+        logger.debug("Added ZODB Group Manager.")
+        activatePluginInterfaces(portal, 'source_groups')
+
+    found = uf.objectIds(['Plone User Factory'])
+    if not found:
+        plone_pas.manage_addPloneUserFactory('user_factory')
+        logger.debug("Added Plone User Factory.")
+        activatePluginInterfaces(portal, "user_factory")
+
+    found = uf.objectIds(['ZODB Mutable Property Provider'])
+    if not found:
+        plone_pas.manage_addZODBMutablePropertyProvider('mutable_properties')
+        logger.debug("Added Mutable Property Manager.")
+        activatePluginInterfaces(portal, "mutable_properties")
+
+    found = uf.objectIds(['Automatic Group Plugin'])
+    if not found:
+        plone_pas.manage_addAutoGroup(
+            "auto_group", "Authenticated Users (Virtual Group)",
+            "AuthenticatedUsers", "Automatic Group Provider")
+        logger.debug("Added Automatic Group.")
+        activatePluginInterfaces(portal, "auto_group")
+
+    found = uf.objectIds(['Plone Session Plugin'])
+    if not found:
+        manage_addSessionPlugin(plone_pas, 'session')
+        logger.debug("Added Plone Session Plugin.")
+        activatePluginInterfaces(portal, "session")
+
+    found = uf.objectIds(['Recursive Groups Plugin'])
+    if not found:
+        addRecursiveGroupsPlugin(plone_pas, 'recursive_groups',
+                                 "Recursive Groups Plugin")
+        activatePluginInterfaces(portal, 'recursive_groups')
+        logger.debug("Added Recursive Groups plugin.")
+
+    setupPasswordPolicyPlugin(portal)
+
+
+def setupAuthPlugins(portal, pas, plone_pas,
+                     deactivate_basic_reset=True,
+                     deactivate_cookie_challenge=False):
+    uf = portal.acl_users
+    logger.debug("Cookie plugin setup")
+
+    login_path = 'login_form'
+    cookie_name = '__ac'
+
+    crumbler = getToolByName(portal, 'cookie_authentication', None)
+    if crumbler is not None:
+        login_path = crumbler.auto_login_page
+        cookie_name = crumbler.auth_cookie
+
+    found = uf.objectIds(['Extended Cookie Auth Helper'])
+    if not found:
+        plone_pas.manage_addExtendedCookieAuthHelper('credentials_cookie_auth',
+                                                     cookie_name=cookie_name)
+    logger.debug("Added Extended Cookie Auth Helper.")
+    if deactivate_basic_reset:
+        disable = ['ICredentialsResetPlugin', 'ICredentialsUpdatePlugin']
+    else:
+        disable = []
+    activatePluginInterfaces(
+        portal,
+        'credentials_cookie_auth',
+        disable=disable
+    )
+
+    credentials_cookie_auth = uf._getOb('credentials_cookie_auth')
+    if 'login_form' in credentials_cookie_auth:
+        credentials_cookie_auth.manage_delObjects(ids=['login_form'])
+        logger.debug("Removed default login_form from credentials cookie "
+                     "auth.")
+    credentials_cookie_auth.cookie_name = cookie_name
+    credentials_cookie_auth.login_path = login_path
+
+    # remove cookie crumbler(s)
+    if 'cookie_authentication' in portal:
+        portal.manage_delObjects(['cookie_authentication'])
+    logger.debug("Removed old Cookie Crumbler")
+
+    found = uf.objectIds(['HTTP Basic Auth Helper'])
+    if not found:
+        pas.addHTTPBasicAuthHelper(
+            'credentials_basic_auth',
+            title="HTTP Basic Auth"
+        )
+    logger.debug("Added Basic Auth Helper.")
+    activatePluginInterfaces(portal, 'credentials_basic_auth')
+
+    if deactivate_basic_reset:
+        uf.plugins.deactivatePlugin(
+            ICredentialsResetPlugin,
+            'credentials_basic_auth'
+        )
+    if deactivate_cookie_challenge:
+        uf.plugins.deactivatePlugin(
+            IChallengePlugin,
+            'credentials_cookie_auth'
+        )
+
+
+def updateProperties(tool, properties):
+    dependency_keys = ('selection', 'multiple selection')
+    propsWithNoDeps = [prop for prop in properties
+                       if prop['type'] not in dependency_keys]
+    propsWithDeps = [prop for prop in properties
+                     if prop['type'] in dependency_keys]
+    for prop in propsWithNoDeps:
+        updateProp(tool, prop)
+    for prop in propsWithDeps:
+        updateProp(tool, prop)
+
+
+def updateProp(prop_manager, prop_dict):
+    """Provided a PropertyManager and a property dict of {id, value,
+    type}, set or update that property as applicable.
+
+    Doesn't deal with existing properties changing type.
+    """
+    id = prop_dict['id']
+    value = prop_dict['value']
+    type = prop_dict['type']
+    if type in ('selection', 'multiple selection'):
+        value = prop_dict['select_variable']
+    if prop_manager.hasProperty(id):
+        prop_manager._updateProperty(id, value)
+    else:
+        prop_manager._setProperty(id, value, type)
+    if type in ('selection', 'multiple selection'):
+        prop_manager._updateProperty(id, prop_dict['value'])
+
+
+def addPAS(portal):
+    logger.debug("Adding PAS user folder")
+    portal.manage_addProduct['PluggableAuthService'].addPluggableAuthService()
+
+
+def migrate_root_uf(self):
+    # Acquire parent user folder.
+    parent = self.getPhysicalRoot()
+    uf = getToolByName(parent, 'acl_users')
+    if IPluggableAuthService.providedBy(uf):
+        # It's a PAS already, fixup if needed.
+        pas_fixup(parent)
+
+        # Configure Challenge Chooser plugin if available
+        challenge_chooser_setup(parent)
+        return
+
+    if not uf.meta_type == 'User Folder':
+        # It's not a standard User Folder at the root. Nothing we can do.
+        return
+
+    # It's a standard User Folder, replace it.
+    replace_acl_users(parent)
+
+    # Get the new uf
+    uf = getToolByName(parent, 'acl_users')
+
+    pas = uf.manage_addProduct['PluggableAuthService']
+    plone_pas = uf.manage_addProduct['PlonePAS']
+    # Setup authentication plugins
+    setupAuthPlugins(parent, pas, plone_pas,
+                     deactivate_basic_reset=False,
+                     deactivate_cookie_challenge=True)
+
+    # Activate *all* interfaces for user manager. IUserAdder is not
+    # activated for some reason by default.
+    activatePluginInterfaces(parent, 'users')
+
+    # Configure Challenge Chooser plugin if available
+    challenge_chooser_setup(parent)
+
+
+def pas_fixup(self):
+    from Products.PluggableAuthService.PluggableAuthService \
+        import _PLUGIN_TYPE_INFO
+
+    pas = getToolByName(self, 'acl_users')
+    if not IPluggableAuthService.providedBy(pas):
+        logger.debug('PAS UF not found, skipping PAS fixup.')
+        return
+
+    plugins = pas['plugins']
+
+    plugin_types = list(set(plugins._plugin_types))
+    for key, id, title, description in _PLUGIN_TYPE_INFO:
+        if key in plugin_types:
+            logger.debug("Plugin type '%s' already registered." % id)
+            continue
+        logger.debug("Plugin type '%s' was not registered." % id)
+        plugin_types.append(key)
+        plugins._plugin_type_info[key] = {
+            'id': id,
+            'title': title,
+            'description': description,
+        }
+    # Make it ordered
+    plugin_types.sort()
+
+    # Re-assign because it's a non-persistent property.
+    plugins._plugin_types = plugin_types
+
+
+def challenge_chooser_setup(self):
+    uf = getToolByName(self, 'acl_users')
+    pas = uf.manage_addProduct['PluggableAuthService']
+
+    # Only install plugins if available
+    req = ('addChallengeProtocolChooserPlugin',
+           'addRequestTypeSnifferPlugin')
+    for m in req:
+        if getattr(pas, m, None) is None:
+            logger.debug('Needed plugins have not been found, ignoring')
+            return
+
+    found = uf.objectIds(['Challenge Protocol Chooser Plugin'])
+    if not found:
+        logger.debug('Adding Challenge Protocol Chooser Plugin.')
+        pas.addChallengeProtocolChooserPlugin(
+            'chooser',
+            mapping=config.DEFAULT_PROTO_MAPPING)
+        activatePluginInterfaces(self, 'chooser')
+    else:
+        assert len(found) == 1, 'Found extra plugins %s' % found
+        logger.debug('Found existing Challenge Protocol Chooser Plugin.')
+        plugin = uf[found[0]]
+        plugin.manage_updateProtocolMapping(
+            mapping=config.DEFAULT_PROTO_MAPPING)
+        activatePluginInterfaces(self, found[0])
+
+    found = uf.objectIds(['Request Type Sniffer Plugin'])
+    if not found:
+        logger.debug('Adding Request Type Sniffer Plugin.')
+        pas.addRequestTypeSnifferPlugin('sniffer')
+        activatePluginInterfaces(self, 'sniffer')
+    else:
+        assert len(found) == 1, 'Found extra plugins %s' % found
+        logger.debug('Found existing Request Type Sniffer Plugin.')
+        activatePluginInterfaces(self, found[0])
+
+
+def setupPasswordPolicyPlugin(portal):
+    uf = portal.acl_users
+    plone_pas = uf.manage_addProduct['PlonePAS']
+
+    found = uf.objectIds(['Default Plone Password Policy'])
+    logger.debug("\nDefault Password Ploicy Plugin setup")
+    if not found:
+        plone_pas.manage_addPasswordPolicyPlugin(
+            'password_policy',
+            title="Default Plone Password Policy"
+        )
+        logger.debug("Added Default Plone Password Policy.")
+        activatePluginInterfaces(portal, 'password_policy')
+
+
+def setLoginFormInCookieAuth(context):
+    """Makes sure the cookie auth redirects to 'require_login' instead
+       of 'login_form'."""
+    uf = getattr(context, 'acl_users', None)
+    if uf is None or getattr(uf.aq_base, '_getOb', None) is None:
+        # we have no user folder or it's not a PAS folder, do nothing
+        return
+    cookie_auth = uf._getOb('credentials_cookie_auth', None)
+    if cookie_auth is None:
+        # there's no cookie auth object, do nothing
+        return
+    current_login_form = cookie_auth.getProperty('login_path')
+    if current_login_form != 'login_form':
+        # it's customized already, do nothing
+        return
+    cookie_auth.manage_changeProperties(login_path='require_login')
+
+
+def addRolesToPlugIn(p):
+    """
+    XXX This is horrible.. need to switch PlonePAS to a GenericSetup
+    based install so this doesn't need to happen.
+
+    Have to manually register the roles from the 'rolemap' step
+    with the roles plug-in.
+    """
+    uf = getToolByName(p, 'acl_users')
+    rmanager = uf.portal_role_manager
+    roles = ('Reviewer', 'Member')
+    existing = rmanager.listRoleIds()
+    for role in roles:
+        if role not in existing:
+            rmanager.addRole(role)
+
+
+def setupGroups(site):
+    """
+    Create Plone's default set of groups.
+    """
+    uf = getToolByName(site, 'acl_users')
+    gtool = getToolByName(site, 'portal_groups')
+    if not uf.searchGroups(id='Administrators'):
+        gtool.addGroup(
+            'Administrators',
+            title='Administrators',
+            roles=['Manager']
+        )
+
+    if not uf.searchGroups(id='Site Administrators'):
+        gtool.addGroup(
+            'Site Administrators',
+            title='Site Administrators',
+            roles=['Site Administrator']
+        )
+
+    if not uf.searchGroups(id='Reviewers'):
+        gtool.addGroup('Reviewers', title='Reviewers', roles=['Reviewer'])
+
+
+def installPAS(portal):
+    # Add user folder
+    portal.manage_addProduct['PluggableAuthService'].addPluggableAuthService()
+
+    # Configure Challenge Chooser plugin if available
+    challenge_chooser_setup(portal)
+
+    # A bunch of general configuration settings
+    registerPluginTypes(portal.acl_users)
+    setupPlugins(portal)
+
+    # XXX Why are we doing this?
+    # According to Sidnei, "either cookie or basic auth for a user in the root
+    # folder doesn't work
+    # if it's not a PAS UF when you sign in to Plone. IIRC."
+    # See: http://twitter.com/#!/sidneidasilva/status/14030732112429056
+    # And here's the original commit:
+    # http://dev.plone.org/collective/changeset/10720/PlonePAS/trunk/Extensions/Install.py
+    if aq_parent(portal):
+        migrate_root_uf(portal)
+
+
+def setupPlonePAS(context):
+    """
+    Setup PlonePAS step.
+    """
+    # Only run step if a flag file is present (e.g. not an extension profile)
+    if context.readDataFile('plone-pas.txt') is None:
+        return
+    site = context.getSite()
+    if 'acl_users' not in site:
+        installPAS(site)
+        addRolesToPlugIn(site)
+        setupGroups(site)
+        setLoginFormInCookieAuth(site)
diff --git a/src/Products/PlonePAS/sheet.py b/src/Products/PlonePAS/sheet.py
new file mode 100644
index 0000000..570fd21
--- /dev/null
+++ b/src/Products/PlonePAS/sheet.py
@@ -0,0 +1,136 @@
+# -*- coding: utf-8 -*-
+"""
+Add Mutable Property Sheets and Schema Mutable Property Sheets to PAS
+
+also a property schema type registry which is extensible.
+
+"""
+from Products.CMFCore.interfaces import ISiteRoot
+from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
+from Products.PluggableAuthService.UserPropertySheet import UserPropertySheet
+from Products.PluggableAuthService.UserPropertySheet import _SequenceTypes
+from zope.component import getUtility
+from zope.interface import implementer
+
+
+class PropertyValueError(ValueError):
+    pass
+
+
+class PropertySchemaTypeMap(object):
+
+    def __init__(self):
+        self.tmap = {}
+        self.tmap_order = []
+
+    def addType(self, type_name, identifier, order=None):
+        self.tmap[type_name] = identifier
+        if order is not None and isinstance(order, int):
+            self.tmap_order.insert(order, type_name)
+        else:
+            self.tmap_order.append(type_name)
+
+    def getTypeFor(self, value):
+        ptypes = [(ptype, self.tmap[ptype]) for ptype in self.tmap_order]
+        for ptype, inspector in ptypes:
+            if inspector(value):
+                return ptype
+        raise TypeError('Invalid property type: %s' % type(value))
+
+    def validate(self, property_type, value):
+        inspector = self.tmap[property_type]
+        return inspector(value)
+
+PropertySchema = PropertySchemaTypeMap()
+PropertySchema.addType(
+    'string',
+    lambda x: x is None or isinstance(x, basestring)
+)
+PropertySchema.addType(
+    'text',
+    lambda x: x is None or isinstance(x, basestring)
+)
+PropertySchema.addType(
+    'boolean',
+    lambda x: 1  # anything can be boolean
+)
+PropertySchema.addType(
+    'int',
+    lambda x: x is None or isinstance(x, int)
+)
+PropertySchema.addType(
+    'long',
+    lambda x: x is None or isinstance(x, long)
+)
+PropertySchema.addType(
+    'float',
+    lambda x: x is None or isinstance(x, float)
+)
+PropertySchema.addType(
+    'lines',
+    lambda x: x is None or isinstance(x, _SequenceTypes)
+)
+PropertySchema.addType(
+    'selection',
+    lambda x: x is None or isinstance(x, basestring)
+)
+PropertySchema.addType(
+    'multiple selection',
+    lambda x: x is None or isinstance(x, _SequenceTypes)
+)
+PropertySchema.addType(
+    'date',
+    lambda x: 1
+)
+validateValue = PropertySchema.validate
+
+
+@implementer(IMutablePropertySheet)
+class MutablePropertySheet(UserPropertySheet):
+
+    def validateProperty(self, id, value):
+        if id not in self._properties:
+            raise PropertyValueError('No such property found on this schema')
+
+        proptype = self.getPropertyType(id)
+        if not validateValue(proptype, value):
+            raise PropertyValueError(
+                "Invalid value (%s) for property '%s' of type %s" %
+                (value, id, proptype)
+            )
+
+    def setProperty(self, user, id, value):
+        self.validateProperty(id, value)
+
+        self._properties[id] = value
+        self._properties = self._properties
+
+        # cascade to plugin
+        provider = self._getPropertyProviderForUser(user)
+        provider.setPropertiesForUser(user, self)
+
+    def setProperties(self, user, mapping):
+        prop_keys = self._properties.keys()
+        prop_update = mapping.copy()
+
+        for key, value in tuple(prop_update.items()):
+            if key not in prop_keys:
+                prop_update.pop(key)
+                continue
+            self.validateProperty(key, value)
+
+        self._properties.update(prop_update)
+
+        # cascade to plugin
+        provider = self._getPropertyProviderForUser(user)
+        provider.setPropertiesForUser(user, self)
+
+    def _getPropertyProviderForUser(self, user):
+        # XXX This assumes that the acl_users that we want is in the portal
+        # root. This may not always be the case.
+        portal = getUtility(ISiteRoot)
+        return portal.acl_users._getOb(self._id)
+
+
+class SchemaMutablePropertySheet(MutablePropertySheet):
+    pass
diff --git a/src/Products/PlonePAS/tests/__init__.py b/src/Products/PlonePAS/tests/__init__.py
new file mode 100644
index 0000000..633f866
--- /dev/null
+++ b/src/Products/PlonePAS/tests/__init__.py
@@ -0,0 +1,2 @@
+# -*- coding: utf-8 -*-
+
diff --git a/src/Products/PlonePAS/tests/base.py b/src/Products/PlonePAS/tests/base.py
new file mode 100644
index 0000000..2003845
--- /dev/null
+++ b/src/Products/PlonePAS/tests/base.py
@@ -0,0 +1,3 @@
+# -*- coding: utf-8 -*-
+from plone.app.testing.bbb import PloneTestCase as TestCase  # noqa
+from plone.app.testing.bbb import PloneTestCase as FunctionalTestCase  # noqa
diff --git a/src/Products/PlonePAS/tests/cookie_auth.rst b/src/Products/PlonePAS/tests/cookie_auth.rst
new file mode 100644
index 0000000..cb249b5
--- /dev/null
+++ b/src/Products/PlonePAS/tests/cookie_auth.rst
@@ -0,0 +1,98 @@
+Test for Cookie Auth
+====================
+
+  >>> from zope.interface import implementedBy
+  >>> from plone.app.testing import TEST_USER_NAME
+  >>> from plone.app.testing import TEST_USER_PASSWORD
+
+User in Plone Site
+------------------
+
+Plone Site has PAS installed
+
+  >>> portal = layer['portal']
+  >>> print portal.acl_users.meta_type
+  Pluggable Auth Service
+
+User exists in the user folder inside the Plone Site.
+
+  >>> uf = portal.acl_users
+  >>> print uf.meta_type
+  Pluggable Auth Service
+
+  >>> user_name, user_password, user_role = ('foo', 'bar', 'Manager')
+  >>> uf.userFolderAddUser(user_name, user_password, [user_role], [])
+
+  >>> uf.getUserById(user_name)
+  <PloneUser 'foo'>
+
+Login to Plone Site using Basic Auth works.
+
+  >>> from plone.testing.z2 import Browser
+  >>> browser = Browser(layer['app'])
+  >>> browser.addHeader('Authorization', 'Basic %s:%s' % (TEST_USER_NAME, TEST_USER_PASSWORD,))
+  >>> browser.open('%s/manage' % portal.absolute_url())
+  >>> print browser.headers
+  Status: 200 Ok...
+
+Make sure cookie plugin is installed and activated.
+
+  >>> uf.objectIds('Extended Cookie Auth Helper')
+  ['credentials_cookie_auth']
+
+  >>> plugins = uf.plugins
+  >>> cookie = uf['credentials_cookie_auth']
+
+  >>> ifaces = tuple(implementedBy(cookie.__class__).flattened())
+
+  >>> actives = []
+  >>> for iface in ifaces:
+  ...    try:
+  ...       actives.append((plugins.listPlugins(iface), iface))
+  ...    except KeyError:
+  ...       pass
+
+  >>> for active, iface in actives:
+  ...     print iface,
+  ...     for id, plugin in active:
+  ...         if id == 'credentials_cookie_auth':
+  ...            print True
+  <...IExtraction...> True
+  <...IChallenge...> True
+  <...ICredentialsUpdate...> <...ICredentialsReset...>
+
+User in parent folder
+---------------------
+
+User Exists on the folder containing the Plone Site, which should be a
+Pluggable Auth Service too.
+
+  >>> uf = layer['app'].acl_users
+  >>> print uf.meta_type
+  Pluggable Auth Service
+
+  >>> user_name, user_password, user_role = ('baz', 'bar', 'Manager')
+  >>> uf.userFolderAddUser(user_name, user_password, [user_role], [])
+
+  >>> uf.getUserById(user_name)
+  <PropertiedUser 'baz'>
+
+  >>> import transaction
+  >>> transaction.commit()
+
+Login directly to containing folder using Basic Auth works.
+
+  >>> browser = Browser(layer['app'])
+  >>> browser.addHeader('Authorization', 'Basic %s:%s' % (user_name, user_password,))
+  >>> browser.open('%s/manage' % layer['app'].absolute_url())
+  >>> print browser.headers
+  Status: 200 Ok...
+
+Login to Plone Site using Basic Auth works.
+
+  >>> browser = Browser(layer['app'])
+  >>> browser.addHeader('Authorization', 'Basic %s:%s' % (user_name, user_password,))
+  >>> browser.open('%s/manage' % portal.absolute_url())
+  >>> print browser.headers
+  Status: 200 Ok...
+
diff --git a/src/Products/PlonePAS/tests/dummy.py b/src/Products/PlonePAS/tests/dummy.py
new file mode 100644
index 0000000..346e046
--- /dev/null
+++ b/src/Products/PlonePAS/tests/dummy.py
@@ -0,0 +1,59 @@
+# -*- coding: utf-8 -*-
+from OFS.SimpleItem import SimpleItem
+from ZPublisher.HTTPRequest import FileUpload
+
+TEXT = 'file data'
+
+
+class FieldStorage(object):
+    def __init__(self, file, filename='testfile', headers=None):
+        self.file = file
+        if headers is None:
+            headers = {}
+        self.headers = headers
+        self.filename = filename
+
+
+class File(FileUpload):
+    '''Dummy upload object
+       Used to fake uploaded files.
+    '''
+
+    __allow_access_to_unprotected_subobjects__ = 1
+    filename = 'dummy.txt'
+    data = TEXT
+    headers = {}
+
+    def __init__(self, filename=None, data=None, headers=None):
+        if filename is not None:
+            self.filename = filename
+        if data is not None:
+            self.data = data
+        if headers is not None:
+            self.headers = headers
+
+    def seek(self, *args):
+        pass
+
+    def tell(self, *args):
+        return 1
+
+    def read(self, *args):
+        return self.data
+
+
+class Error(Exception):
+    '''Dummy exception'''
+
+
+class Raiser(SimpleItem):
+    '''Raises the stored exception when called'''
+
+    exception = Error
+
+    def __init__(self, exception=None):
+        if exception is not None:
+            self.exception = exception
+
+    def __call__(self, *args, **kw):
+        raise self.exception
diff --git a/src/Products/PlonePAS/tests/images/test.gif b/src/Products/PlonePAS/tests/images/test.gif
new file mode 100644
index 0000000..b1ac85b
Binary files /dev/null and b/src/Products/PlonePAS/tests/images/test.gif differ
diff --git a/src/Products/PlonePAS/tests/images/test.jpg b/src/Products/PlonePAS/tests/images/test.jpg
new file mode 100644
index 0000000..d444aff
Binary files /dev/null and b/src/Products/PlonePAS/tests/images/test.jpg differ
diff --git a/src/Products/PlonePAS/tests/images/test.png b/src/Products/PlonePAS/tests/images/test.png
new file mode 100644
index 0000000..078487d
Binary files /dev/null and b/src/Products/PlonePAS/tests/images/test.png differ
diff --git a/src/Products/PlonePAS/tests/test_basic_ops.py b/src/Products/PlonePAS/tests/test_basic_ops.py
new file mode 100644
index 0000000..5518805
--- /dev/null
+++ b/src/Products/PlonePAS/tests/test_basic_ops.py
@@ -0,0 +1,152 @@
+# -*- coding: utf-8 -*-
+from Products.PlonePAS.tests import base
+from Products.PluggableAuthService.PluggableAuthService import \
+    _SWALLOWABLE_PLUGIN_EXCEPTIONS
+from Products.PluggableAuthService.interfaces.authservice import \
+    IPluggableAuthService
+from Products.PluggableAuthService.interfaces.events import \
+    IPrincipalDeletedEvent
+from Products.PluggableAuthService.interfaces.plugins import IRolesPlugin
+from zope.component import adapter
+from zope.component import getGlobalSiteManager
+
+
+class BasicOpsTestCase(base.TestCase):
+
+    def afterSetUp(self):
+        self.loginAsPortalOwner()
+        self.acl_users = self.portal.acl_users
+
+    def compareRoles(self, target, user, roles):
+        """
+        compareRoles(self, target, user, roles) => do not raise if
+        user has exactly the specified roles.
+
+        If target is None, test user roles (no local roles)
+        """
+        u = self.acl_users.getUser(user)
+        if not u:
+            raise RuntimeError("compareRoles: Invalid user: '%s'" % user)
+        non_roles = ('Authenticated', 'Anonymous', '')
+        if target is None:
+            user_roles = list(u.getRoles())
+        else:
+            user_roles = list(u.getRolesInContext(target))
+        actual_roles = filter(lambda x: x not in non_roles, user_roles)
+        actual_roles.sort()
+        wished_roles = list(roles)
+        wished_roles.sort()
+        if actual_roles == wished_roles:
+            return 1
+        raise RuntimeError("User %s: Whished roles: %s BUT current "
+                           "roles: %s" % (user, wished_roles, actual_roles))
+
+    def createUser(self, login="created_user", password="secret",
+                   roles=[], groups=[], domains=()):
+        self.acl_users.userFolderAddUser(
+            login, password, roles=roles, groups=groups, domains=domains,)
+
+    def test_installed(self):
+        self.assertTrue(IPluggableAuthService.providedBy(self.acl_users))
+
+    def test_add(self):
+        self.createUser()
+        self.assertTrue(self.acl_users.getUser("created_user"))
+
+    def test_edit(self):
+        # this will fail unless the PAS role plugin is told it manages
+        # the new role.
+        self.createUser()
+        self.compareRoles(None, "created_user", [])
+        self.acl_users.userFolderEditUser(
+            "created_user",  # name
+            "secret2",  # password
+            roles=["Member"],
+            groups=["g1"],
+            domains=(),)
+        self.compareRoles(None, "created_user", ['Member'])
+
+    def test_edit_userDefinedRole(self):
+        roleplugins = self.acl_users.plugins.listPlugins(IRolesPlugin)
+        for id, plugin in roleplugins:
+            try:
+                plugin.addRole('r1')
+            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+                pass
+            else:
+                break
+
+        self.createUser()
+        self.compareRoles(None, "created_user", [])
+        self.acl_users.userFolderEditUser(
+            "created_user",  # name
+            "secret2",  # password
+            roles=["r1"],
+            groups=["g1"],
+            domains=(),)
+        self.compareRoles(None, "created_user", ['r1'])
+
+    def test_del(self):
+        self.createUser()
+        self.assertTrue(self.acl_users.getUser("created_user"))
+        self.acl_users.userFolderDelUsers(['created_user'])
+        self.assertFalse(self.acl_users.getUser("created_user"))
+
+    def test_principal_del_event(self):
+        eventsFired = []
+
+        @adapter(IPrincipalDeletedEvent)
+        def gotDeletion(event):
+            eventsFired.append(event)
+
+        gsm = getGlobalSiteManager()
+        gsm.registerHandler(gotDeletion)
+        self.createUser()
+        self.acl_users.userFolderDelUsers(['created_user'])
+        self.assertEqual(len(eventsFired), 1)
+        self.assertEqual(eventsFired[0].principal, 'created_user')
+        gsm.unregisterHandler(gotDeletion)
+
+    def test_search(self):
+        self.createUser("created_user1")
+        self.createUser("created_user2")
+        mt = self.portal.portal_membership
+        retlist = mt.searchForMembers(REQUEST=None, login="created_user1")
+        usernames = [user.getUserName() for user in retlist]
+        self.assertEqual(len(usernames), 1)
+        self.assertTrue("created_user1" in usernames,
+                        "'created_user1' not in %s" % usernames)
+
+    def test_setpw(self):
+        # there is more than one place where one can set the password.
+        # insane. anyway we have to check the patch in pas.py userSetPassword
+        # here its checked in the general setup using ZODBUserManager.
+        self.createUser()
+        uf = self.acl_users
+        new_secret = 'new_secret'
+        uf.userSetPassword('created_user', new_secret)
+
+        # possible to authenticate with new password?
+        from Products.PluggableAuthService.interfaces.plugins \
+            import IAuthenticationPlugin
+        authenticators = uf.plugins.listPlugins(IAuthenticationPlugin)
+        credentials = {'login': 'created_user', 'password': new_secret}
+        result = None
+        for aid, authenticator in authenticators:
+            result = authenticator.authenticateCredentials(credentials)
+            if result is not None:
+                break
+        self.assertTrue(result)
+
+    def test_setProperties(self):
+        self.createUser()
+        user = self.acl_users.getUser('created_user')
+        user.setProperties(fullname='Test User', email='test@example.org')
+        self.assertEqual(user.getProperty('fullname'), 'Test User')
+        self.assertEqual(user.getProperty('email'), 'test@example.org')
+
+        user.setProperties(
+            properties={'fullname': 'Test User2', 'email': 'test2@example.org'}
+        )
+        self.assertEqual(user.getProperty('fullname'), 'Test User2')
+        self.assertEqual(user.getProperty('email'), 'test2@example.org')
diff --git a/src/Products/PlonePAS/tests/test_doctests.py b/src/Products/PlonePAS/tests/test_doctests.py
new file mode 100644
index 0000000..9e2c509
--- /dev/null
+++ b/src/Products/PlonePAS/tests/test_doctests.py
@@ -0,0 +1,26 @@
+# -*- coding: utf-8 -*-
+from plone.app.testing.bbb import PTC_FUNCTIONAL_TESTING
+from plone.testing import layered
+import doctest
+import unittest
+
+
+def test_suite():
+    suite = unittest.TestSuite()
+    suite.addTest(
+        layered(
+            doctest.DocFileSuite(
+                'cookie_auth.rst',
+                package='Products.PlonePAS.tests',
+                optionflags=doctest.ELLIPSIS
+            ),
+            layer=PTC_FUNCTIONAL_TESTING
+        )
+    )
+    suite.addTest(
+        doctest.DocTestSuite(
+            'Products.PlonePAS.utils',
+            optionflags=doctest.ELLIPSIS
+        )
+    )
+    return suite
diff --git a/src/Products/PlonePAS/tests/test_groupdatatool.py b/src/Products/PlonePAS/tests/test_groupdatatool.py
new file mode 100644
index 0000000..adf6b3d
--- /dev/null
+++ b/src/Products/PlonePAS/tests/test_groupdatatool.py
@@ -0,0 +1,184 @@
+# -*- coding: utf-8 -*-
+from AccessControl import Permissions
+from AccessControl import Unauthorized
+from Products.CMFCore.tests.base.testcase import WarningInterceptor
+from Products.PlonePAS.tests import base
+from plone.app.testing import TEST_USER_ID
+from plone.app.testing import TEST_USER_NAME
+
+
+def sortTuple(t):
+    l = list(t)
+    l.sort()
+    return tuple(l)
+
+
+class TestGroupDataTool(base.TestCase):
+
+    def afterSetUp(self):
+        self.acl_users = self.portal.acl_users
+        self.groups = self.portal.portal_groups
+        self.groupdata = self.portal.portal_groupdata
+        self.groups.addGroup('foo')
+        # MUST reset _v_ attributes!
+        self.groupdata._v_temps = None
+        if 'auto_group' in self.acl_users:
+            self.acl_users.manage_delObjects(['auto_group'])
+
+    def testWrapGroup(self):
+        g = self.acl_users.getGroup('foo')
+        self.assertEqual(g.__class__.__name__, 'PloneGroup')
+        g = self.groupdata.wrapGroup(g)
+        self.assertEqual(g.__class__.__name__, 'GroupData')
+        self.assertEqual(g.aq_parent.__class__.__name__, 'PloneGroup')
+        self.assertEqual(g.aq_parent.aq_parent.__class__.__name__,
+                         'GroupManager')
+
+
+class TestGroupData(base.TestCase, WarningInterceptor):
+
+    def afterSetUp(self):
+        self.membership = self.portal.portal_membership
+        self.memberdata = self.portal.portal_memberdata
+        self.acl_users = self.portal.acl_users
+        self.groups = self.portal.portal_groups
+        self.groupdata = self.portal.portal_groupdata
+        self.groups.addGroup('foo')
+        if 'auto_group' in self.acl_users:
+            self.acl_users.manage_delObjects(['auto_group'])
+        # MUST reset _v_ attributes!
+        self.memberdata._v_temps = None
+        self.groupdata._v_temps = None
+        self._trap_warning_output()
+
+    def testGetGroup(self):
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(g.__class__.__name__, 'GroupData')
+        g = g.getGroup()
+        self.assertEqual(g.__class__.__name__, 'PloneGroup')
+
+    def testGetTool(self):
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(g.getTool().getId(), 'portal_groupdata')
+
+    def testGetGroupMembers(self):
+        g = self.groups.getGroupById('foo')
+        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
+        self.assertEqual(g.getGroupMembers()[0].getId(), TEST_USER_ID)
+
+    def testGroupMembersAreWrapped(self):
+        g = self.groups.getGroupById('foo')
+        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
+        ms = g.getGroupMembers()
+        self.assertEqual(ms[0].__class__.__name__, 'MemberData')
+        self.assertEqual(ms[0].aq_parent.__class__.__name__, 'PloneUser')
+        self.assertEqual(ms[0].aq_parent.aq_parent.__class__.__name__,
+                         'PluggableAuthService')
+
+    def testAddMember(self):
+        self.setPermissions([Permissions.manage_users])
+        g = self.groups.getGroupById('foo')
+        g.addMember(TEST_USER_ID)
+        self.assertEqual(g.getGroupMembers()[0].getId(), TEST_USER_ID)
+
+    def testRemoveMember(self):
+        self.setPermissions([Permissions.manage_users])
+        g = self.groups.getGroupById('foo')
+        g.addMember(TEST_USER_ID)
+        g.removeMember(TEST_USER_ID)
+        self.assertEqual(len(g.getGroupMembers()), 0)
+
+    def testSetGroupProperties(self):
+        g = self.groups.getGroupById('foo')
+        g.setGroupProperties({'email': 'foo@bar.com'})
+        gd = self.groups.getGroupById('foo')
+        self.assertEqual(gd.getProperty('email'), 'foo@bar.com')
+
+    def testSetMemberProperties(self):
+        # For reference
+        m = self.membership.getMemberById(TEST_USER_ID)
+        m.setMemberProperties({'email': 'foo@bar.com'})
+        md = self.membership.getMemberById(TEST_USER_ID)
+        self.assertEqual(md.getProperty('email'), 'foo@bar.com')
+
+    def testGetProperty(self):
+        g = self.groups.getGroupById('foo')
+        g.setGroupProperties({'email': 'foo@bar.com'})
+        self.assertEqual(g.getProperty('email'), 'foo@bar.com')
+        self.assertEqual(g.getProperty('id'), 'foo')
+
+    def testGetGroupName(self):
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(g.getGroupName(), 'foo')
+
+    def testGetGroupId(self):
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(g.getGroupId(), 'foo')
+
+    def testGetRoles(self):
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(tuple(g.getRoles()), ('Authenticated',))
+        self.groups.editGroup(g.getId(), roles=['Member'])
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(sortTuple(tuple(g.getRoles())),
+                         ('Authenticated', 'Member'))
+
+    def testGetRolesInContext(self):
+        g = self.groups.getGroupById('foo')
+        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
+        user = self.acl_users.getUser(TEST_USER_NAME)
+        self.assertEqual(
+            user.getRolesInContext(self.folder).sort(),
+            ['Member', 'Authenticated', 'Owner'].sort()
+        )
+        self.folder.manage_setLocalRoles(g.getId(), ['NewRole'])
+        self.assertEqual(
+            user.getRolesInContext(self.folder).sort(),
+            ['Member', 'Authenticated', 'Owner', 'NewRole'].sort()
+        )
+
+    def testGetDomains(self):
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(g.getDomains(), ())
+
+    def testHasRole(self):
+        g = self.groups.getGroupById('foo')
+        self.groups.editGroup(g.getId(), roles=['Member'])
+        g = self.groups.getGroupById('foo')
+        self.assertTrue(g.has_role('Member'))
+
+    def beforeTearDown(self):
+        self._free_warning_output()
+
+
+class TestMethodProtection(base.TestCase):
+
+    def afterSetUp(self):
+        self.groups = self.portal.portal_groups
+        self.groups.addGroup('foo')
+        self.groupdata = self.groups.getGroupById('foo')
+
+    def testAnonAddMember(self):
+        self.logout()
+        self.assertRaises(Unauthorized, self.groupdata.addMember, TEST_USER_ID)
+
+    def testAnonRemoveMember(self):
+        self.logout()
+        self.assertRaises(Unauthorized, self.groupdata.removeMember,
+                          TEST_USER_ID)
+
+    def testMemberAddMember(self):
+        self.assertRaises(Unauthorized, self.groupdata.addMember, TEST_USER_ID)
+
+    def testMemberRemoveMember(self):
+        self.assertRaises(Unauthorized, self.groupdata.removeMember,
+                          TEST_USER_ID)
+
+    def testManagerAddMember(self):
+        self.setPermissions([Permissions.manage_users])
+        self.groupdata.addMember(TEST_USER_ID)
+
+    def testManagerRemoveMember(self):
+        self.setPermissions([Permissions.manage_users])
+        self.groupdata.addMember(TEST_USER_ID)
+        self.groupdata.removeMember(TEST_USER_ID)
diff --git a/src/Products/PlonePAS/tests/test_groupstool.py b/src/Products/PlonePAS/tests/test_groupstool.py
new file mode 100644
index 0000000..dba2052
--- /dev/null
+++ b/src/Products/PlonePAS/tests/test_groupstool.py
@@ -0,0 +1,258 @@
+# -*- coding: utf-8 -*-
+from AccessControl import Permissions
+from AccessControl import Unauthorized
+from Acquisition import aq_base
+from Acquisition import aq_parent
+from Products.CMFCore.tests.base.testcase import WarningInterceptor
+from Products.CMFCore.utils import getToolByName
+from Products.PlonePAS.plugins.group import PloneGroup
+from Products.PlonePAS.tests import base
+from Products.PlonePAS.tools.groupdata import GroupData
+from plone.app.testing import TEST_USER_ID
+
+
+def sortTuple(t):
+    l = list(t)
+    l.sort()
+    return tuple(l)
+
+
+class GroupsToolTest(base.TestCase):
+
+    def afterSetUp(self):
+        self.gt = getToolByName(self.portal, 'portal_groups')
+        self.gd = getToolByName(self.portal, 'portal_groupdata')
+
+        self.group_id = 'group1'
+        # Create a new Group
+        self.loginAsPortalOwner()
+        self.gt.addGroup(
+            self.group_id,
+            ['Reviewer'],
+            [],
+            {'email': 'group1@host.com', 'title': 'Group #1'}
+        )
+
+    def test_get_group(self):
+        # Use PAS (monkeypatched) API method to get a group by id.
+        group = self.portal.acl_users.getGroup(self.group_id)
+        self.assertFalse(group is None)
+
+        # Should be wrapped into the GroupManagement, which is wrapped
+        # into the PAS.
+        got = aq_base(aq_parent(aq_parent(group)))
+        expected = aq_base(self.portal.acl_users)
+        self.assertEqual(got, expected)
+
+        self.assertTrue(isinstance(group, PloneGroup))
+
+    def test_get_group_by_id(self):
+        # Use tool way of getting group by id. This returns a
+        # GroupData object wrapped by the group
+        group = self.gt.getGroupById(self.group_id)
+        self.assertFalse(group is None)
+        self.assertTrue(isinstance(group, GroupData))
+        self.assertTrue(isinstance(aq_parent(group), PloneGroup))
+
+    def test_edit_group(self):
+        # Use the tool way to edit a group.
+        properties = {
+            'email': 'group1@host2.com',
+            'title': 'Group #1 new title'
+        }
+        self.gt.editGroup(
+            self.group_id,
+            roles=['Manager'],
+            **properties
+        )
+
+        # test edition of roles and properties
+        group = self.gt.getGroupById(self.group_id)
+        self.assertTrue(group.has_role('Manager'))
+        self.assertEqual(group.getProperty('email'), properties['email'])
+        self.assertEqual(group.getProperty('title'), properties['title'])
+
+        # test for empty list of roles
+        self.gt.editGroup(self.group_id, roles=[])
+        self.assertTrue(group.has_role('Authenticated'))
+
+        # test edition of group groups
+        self.gt.editGroup(
+            self.group_id,
+            groups=['Reviewers'],
+            **properties
+        )
+        group = self.gt.getGroupById(self.group_id)
+        self.assertTrue('Reviewers' in group.getGroups())
+
+
+class TestMethodProtection(base.TestCase):
+    # GroupData has wrong security declarations
+
+    def afterSetUp(self):
+        self.groups = self.portal.portal_groups
+        self.groups.addGroup('foo')
+        self.groupdata = self.groups.getGroupById('foo')
+
+    def testAnonAddMember(self):
+        self.logout()
+        self.assertRaises(Unauthorized, self.groupdata.addMember, TEST_USER_ID)
+
+    def testAnonRemoveMember(self):
+        self.logout()
+        self.assertRaises(Unauthorized, self.groupdata.removeMember,
+                          TEST_USER_ID)
+
+    def testMemberAddMember(self):
+        self.assertRaises(Unauthorized, self.groupdata.addMember, TEST_USER_ID)
+
+    def testMemberRemoveMember(self):
+        self.assertRaises(Unauthorized, self.groupdata.removeMember,
+                          TEST_USER_ID)
+
+    def testManagerAddMember(self):
+        self.setPermissions([Permissions.manage_users])
+        self.groupdata.addMember(TEST_USER_ID)
+
+    def testManagerRemoveMember(self):
+        self.setPermissions([Permissions.manage_users])
+        self.groupdata.addMember(TEST_USER_ID)
+        self.groupdata.removeMember(TEST_USER_ID)
+
+
+class TestGroupsTool(base.TestCase, WarningInterceptor):
+
+    def afterSetUp(self):
+        self.membership = self.portal.portal_membership
+        self.acl_users = self.portal.acl_users
+        self.groups = self.portal.portal_groups
+        self._trap_warning_output()
+
+        if 'auto_group' in self.acl_users:
+            self.acl_users.manage_delObjects(['auto_group'])
+
+        # Nuke Administators and Reviewers groups added in 2.1a2 migrations
+        # (and any other migrated-in groups) to avoid test confusion
+        self.groups.removeGroups(self.groups.listGroupIds())
+
+    def testAddGroup(self):
+        self.groups.addGroup('foo', [], [])
+        self.assertEqual(self.groups.listGroupIds(), ['foo'])
+
+    def testGetGroupById(self):
+        self.groups.addGroup('foo', [], [])
+        g = self.groups.getGroupById('foo')
+        self.assertNotEqual(g, None)
+
+    def testGetBadGroupById(self):
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(g, None)
+
+    def testGroupByIdIsWrapped(self):
+        self.groups.addGroup('foo', [], [])
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(g.__class__.__name__, 'GroupData')
+        self.assertEqual(g.aq_parent.__class__.__name__, 'PloneGroup')
+        self.assertEqual(g.aq_parent.aq_parent.__class__.__name__,
+                         'GroupManager')
+
+    def testEditGroup(self):
+        self.groups.addGroup('foo', )
+        self.groups.editGroup('foo', roles=['Reviewer'])
+        g = self.groups.getGroupById('foo')
+        self.assertEqual(sortTuple(g.getRoles()),
+                         ('Authenticated', 'Reviewer'))
+
+    def testEditBadGroup(self):
+        # Error type depends on the user folder...
+        try:
+            self.groups.editGroup('foo', [], [])
+        except (KeyError, ValueError):
+            pass        # Ok, this is the wanted behaviour
+        else:
+            self.fail("Should have raised KeyError or ValueError")
+
+    def testRemoveGroups(self):
+        self.groups.addGroup('foo', [], [])
+        self.groups.removeGroups(['foo'])
+        self.assertEqual(len(self.groups.listGroupIds()), 0)
+
+    def testListGroupIds(self):
+        self.groups.addGroup('foo', [], [])
+        self.groups.addGroup('bar', [], [])
+        grps = self.groups.listGroupIds()
+        grps.sort()
+        self.assertEqual(grps, ['bar', 'foo'])
+
+    def testGetGroupsByUserId(self):
+        self.groups.addGroup('foo', [], [])
+        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
+        gs = self.groups.getGroupsByUserId(TEST_USER_ID)
+        self.assertEqual(gs[0].getId(), 'foo')
+
+    def testGroupsByUserIdAreWrapped(self):
+        self.groups.addGroup('foo', [], [])
+        self.acl_users.userSetGroups(TEST_USER_ID, groupnames=['foo'])
+        gs = self.groups.getGroupsByUserId(TEST_USER_ID)
+        self.assertEqual(gs[0].__class__.__name__, 'GroupData')
+        self.assertEqual(gs[0].aq_parent.__class__.__name__, 'PloneGroup')
+        self.assertEqual(gs[0].aq_parent.aq_parent.__class__.__name__,
+                         'GroupManager')
+
+    def testListGroups(self):
+        self.groups.addGroup('foo', [], [])
+        self.groups.addGroup('bar', [], [])
+        gs = self.groups.listGroups()
+        self.assertEqual(gs[0].getId(), 'bar')
+        self.assertEqual(gs[1].getId(), 'foo')
+
+    def testListedGroupsAreWrapped(self):
+        self.groups.addGroup('foo', [], [])
+        gs = self.groups.listGroups()
+        self.assertEqual(gs[0].__class__.__name__, 'GroupData')
+        self.assertEqual(gs[0].aq_parent.__class__.__name__, 'PloneGroup')
+        self.assertEqual(gs[0].aq_parent.aq_parent.__class__.__name__,
+                         'GroupManager')
+
+    def testSetGroupOwnership(self):
+        self.groups.addGroup('foo', [], [])
+        self.folder.invokeFactory('Document', 'doc')
+        doc = self.folder.doc
+        g = self.groups.getGroupById('foo')
+        self.groups.setGroupOwnership(g, doc)
+        self.assertEqual(doc.getOwnerTuple()[1], 'foo')
+        self.assertEqual(doc.get_local_roles_for_userid('foo'), ('Owner',))
+        self.assertEqual(doc.get_local_roles_for_userid(TEST_USER_ID),
+                         ('Owner',))
+
+    def testWrapGroup(self):
+        self.groups.addGroup('foo', [], [])
+        g = self.acl_users.getGroup('foo')
+        self.assertEqual(g.__class__.__name__, 'PloneGroup')
+        g = self.groups.wrapGroup(g)
+        self.assertEqual(g.__class__.__name__, 'GroupData')
+        self.assertEqual(g.aq_parent.__class__.__name__, 'PloneGroup')
+        self.assertEqual(g.aq_parent.aq_parent.__class__.__name__,
+                         'GroupManager')
+
+    def testGetGroupInfo(self):
+        self.groups.addGroup('foo', title='Foo', description='Bar',
+                             email='foo@foo.com')
+        info = self.groups.getGroupInfo('foo')
+        self.assertEqual(info.get('title'), 'Foo')
+        self.assertEqual(info.get('description'), 'Bar')
+        self.assertEqual(info.get('email'), None)  # No email!
+
+    def testGetGroupInfoAsAnonymous(self):
+        self.groups.addGroup('foo', title='Foo', description='Bar')
+        self.logout()
+        info = self.groups.restrictedTraverse('getGroupInfo')('foo')
+        self.assertEqual(info.get('title'), 'Foo')
+        self.assertEqual(info.get('description'), 'Bar')
+
+    def testGetBadGroupInfo(self):
+        info = self.groups.getGroupInfo('foo')
+        self.assertEqual(info, None)
+
+    def beforeTearDown(self):
+        self._free_warning_output()
diff --git a/src/Products/PlonePAS/tests/test_memberdatatool.py b/src/Products/PlonePAS/tests/test_memberdatatool.py
new file mode 100644
index 0000000..b7ae400
--- /dev/null
+++ b/src/Products/PlonePAS/tests/test_memberdatatool.py
@@ -0,0 +1,70 @@
+# -*- coding: utf-8 -*-
+from DateTime import DateTime
+from OFS.Image import Image
+from Products.PlonePAS.tests import base
+from Products.PlonePAS.tests import dummy
+from plone.app.testing import TEST_USER_ID as default_user
+
+
+class TestMemberDataTool(base.TestCase):
+
+    def afterSetUp(self):
+        self.memberdata = self.portal.portal_memberdata
+        self.membership = self.portal.portal_membership
+        self.membership.memberareaCreationFlag = 0
+        # Don't let default_user disturb results
+        self.portal.acl_users._doDelUsers([default_user])
+        # Add some members
+        self.addMember('fred', 'Fred Flintstone', 'fred@bedrock.com',
+                       ['Member', 'Reviewer'], '2002-01-01')
+        self.addMember('barney', 'Barney Rubble', 'barney@bedrock.com',
+                       ['Member'], '2002-01-01')
+        self.addMember('brubble', 'Bambam Rubble', 'bambam@bambam.net',
+                       ['Member'], '2003-12-31')
+        # MUST reset this
+        self.memberdata._v_temps = None
+
+    def addMember(self, username, fullname, email, roles, last_login_time):
+        self.membership.addMember(username, 'secret', roles, [])
+        member = self.membership.getMemberById(username)
+        member.setMemberProperties({
+            'fullname': fullname,
+            'email': email,
+            'last_login_time': DateTime(last_login_time), })
+
+    def testSetPortrait(self):
+        self.memberdata._setPortrait(
+            Image(id=default_user, file=dummy.File(), title=''),
+            default_user)
+        self.assertEqual(self.memberdata._getPortrait(default_user).getId(),
+                         default_user)
+        self.assertEqual(self.memberdata._getPortrait(default_user).meta_type,
+                         'Image')
+
+    def testDeletePortrait(self):
+        self.memberdata._setPortrait(
+            Image(id=default_user, file=dummy.File(), title=''),
+            default_user)
+        self.memberdata._deletePortrait(default_user)
+        self.assertEqual(self.memberdata._getPortrait(default_user), None)
+
+    def testPruneMemberDataContents(self):
+        # Only test what is not already tested elswhere
+        self.memberdata._setPortrait(
+            Image(id=default_user, file=dummy.File(), title=''),
+            default_user)
+        self.memberdata._setPortrait(
+            Image(id=default_user, file=dummy.File(), title=''),
+            'dummy')
+        self.memberdata.pruneMemberDataContents()
+        self.assertEqual(len(self.memberdata.portraits), 1)
+
+    def testFulltextMemberSearch(self):
+        # Search for a user by id, name, email, ...
+        search = self.memberdata.searchFulltextForMembers
+        self.assertEqual(len(search('')), 3)
+        self.assertEqual(len(search('rubble')), 2)
+        self.assertEqual(len(search('stone')), 1)
+        self.assertEqual(len(search('bambam.net')), 1)
+        self.assertEqual(len(search('bedrock.com')), 2)
+        self.assertEqual(len(search('brubble')), 1)
diff --git a/src/Products/PlonePAS/tests/test_membershiptool.py b/src/Products/PlonePAS/tests/test_membershiptool.py
new file mode 100644
index 0000000..42b3b98
--- /dev/null
+++ b/src/Products/PlonePAS/tests/test_membershiptool.py
@@ -0,0 +1,968 @@
+# -*- coding: utf-8 -*-
+from AccessControl import Unauthorized
+from AccessControl import getSecurityManager
+from AccessControl.User import nobody
+from Acquisition import aq_base
+from Acquisition import aq_parent
+from DateTime import DateTime
+from OFS.Image import Image
+from Products.CMFCore.interfaces import IPropertiesTool
+from Products.CMFCore.tests.base.testcase import WarningInterceptor
+from Products.CMFCore.utils import getToolByName
+from Products.PlonePAS.browser.member import PASMemberView
+from Products.PlonePAS.interfaces.membership import IMembershipTool
+from Products.PlonePAS.plugins.ufactory import PloneUser
+from Products.PlonePAS.tests import base
+from Products.PlonePAS.tests import dummy
+from Products.PlonePAS.tools.memberdata import MemberData
+from Products.PlonePAS.tools.membership import MembershipTool
+from Products.PlonePAS.utils import getGroupsForPrincipal
+from cStringIO import StringIO
+from plone.app.testing import PLONE_SITE_ID
+from plone.app.testing import SITE_OWNER_NAME
+from plone.app.testing import TEST_USER_ID
+from plone.app.testing import TEST_USER_NAME
+from plone.app.testing import TEST_USER_PASSWORD
+from zExceptions import BadRequest
+from zope.component import getUtility
+import os
+
+
+class MembershipToolTest(base.TestCase):
+
+    def afterSetUp(self):
+        self.mt = getToolByName(self.portal, 'portal_membership')
+        self.md = getToolByName(self.portal, 'portal_memberdata')
+
+        self.member_id = 'member1'
+        # Create a new Member
+        self.mt.addMember(
+            self.member_id,
+            'pw',
+            ['Member'],
+            [],
+            {'email': 'member1@host.com', 'title': 'Member #1'}
+        )
+
+    def test_get_member(self):
+        member = self.portal.acl_users.getUserById(self.member_id)
+        self.assertFalse(member is None)
+
+        # Should be wrapped into the PAS.
+        got = aq_base(aq_parent(member))
+        expected = aq_base(self.portal.acl_users)
+        self.assertEqual(got, expected)
+
+        self.assertTrue(isinstance(member, PloneUser))
+
+    def test_get_member_by_id(self):
+        # Use tool way of getting member by id. This returns a
+        # MemberData object wrapped by the member
+        member = self.mt.getMemberById(self.member_id)
+        self.assertFalse(member is None)
+        self.assertTrue(isinstance(member, MemberData))
+        self.assertTrue(isinstance(aq_parent(member), PloneUser))
+
+    def test_id_clean(self):
+        from Products.PlonePAS.utils import cleanId, decleanId
+        a = [
+            "asdfasdf",
+            "asdf-asdf",
+            "asdf--asdf",
+            "asdf---asdf",
+            "asdf----asdf",
+            "asdf-----asdf",
+            "asdf%asdf",
+            "asdf%%asdf",
+            "asdf%%%asdf",
+            "asdf%%%%asdf",
+            "asdf%%%%%asdf",
+            "asdf-%asdf",
+            "asdf%-asdf",
+            "asdf-%-asdf",
+            "asdf%-%asdf",
+            "asdf--%asdf",
+            "asdf%--asdf",
+            "asdf--%-asdf",
+            "asdf-%--asdf",
+            "asdf--%--asdf",
+            "asdf%-%asdf",
+            "asdf%--%asdf",
+            "asdf%---%asdf",
+            "-asdf",
+            "--asdf",
+            "---asdf",
+            "----asdf",
+            "-----asdf",
+            "asdf-",
+            "asdf--",
+            "asdf---",
+            "asdf----",
+            "asdf-----",
+            "%asdf",
+            "%%asdf",
+            "%%%asdf",
+            "%%%%asdf",
+            "%%%%%asdf",
+            "asdf%",
+            "asdf%%",
+            "asdf%%%",
+            "asdf%%%%",
+            "asdf%%%%%",
+            "asdf\x00asdf",
+        ]
+        b = [cleanId(id) for id in a]
+        c = [decleanId(id) for id in b]
+        ac = zip(a, c)
+        for aa, cc in ac:
+            self.assertTrue(aa == cc)
+
+
+class MemberAreaTest(base.TestCase):
+
+    def afterSetUp(self):
+        self.mt = getToolByName(self.portal, 'portal_membership')
+        self.md = getToolByName(self.portal, 'portal_memberdata')
+        # Enable member-area creation
+        self.mt.memberareaCreationFlag = 1
+        # Those are all valid chars in Zope.
+        self.mid = "Member #1 - Houston, TX. ($100)"
+        self.pas = self.portal.acl_users
+        self.loginAsPortalOwner()
+
+    def test_funky_member_ids_1(self):
+        mid = self.mid
+        minfo = (mid, 'pw', ['Member'], [])
+
+        # Create a new User
+        self.pas._doAddUser(*minfo)
+        self.mt.createMemberArea, (mid)
+
+    def test_funky_member_ids_2(self):
+        # Forward-slash is not allowed
+        mid = self.mid + '/'
+        minfo = (mid, 'pw', ['Member'], [])
+
+        # Create a new User
+        self.pas._doAddUser(*minfo)
+        self.mt.createMemberArea(mid)
+
+    def test_memberareaCreationFlag_respected(self):
+        self.pas._doAddUser('foo', 'pw', ['Member'], [])
+        self.pas._doAddUser('bar', 'pw', ['Member'], [])
+
+        self.assertFalse('foo' in self.portal.Members)
+        self.assertFalse('bar' in self.portal.Members)
+
+        self.mt.createMemberarea('foo')
+        self.assertTrue('foo' in self.portal.Members)
+
+        self.mt.memberareaCreationFlag = 0
+        self.mt.createMemberArea('bar')
+        self.assertFalse('bar' in self.portal.Members)
+
+
+class TestMembershipTool(base.TestCase, WarningInterceptor):
+
+    def afterSetUp(self):
+        self.membership = self.portal.portal_membership
+        self.groups = self.portal.portal_groups
+        self._trap_warning_output()
+
+    def test_interface(self):
+        from zope.interface.verify import verifyClass
+        verifyClass(IMembershipTool, MembershipTool)
+
+    def addMember(self, username, fullname, email, roles, last_login_time):
+        self.membership.addMember(username, 'secret', roles, [])
+        member = self.membership.getMemberById(username)
+        member.setMemberProperties({
+            'fullname': fullname, 'email': email,
+            'last_login_time': DateTime(last_login_time), })
+
+    def makeRealImage(self):
+        import Products.PlonePAS as ppas
+        pas_path = os.path.dirname(ppas.__file__)
+        path = os.path.join(pas_path, 'tool.gif')
+        image = open(path, 'rb')
+        image_upload = dummy.FileUpload(dummy.FieldStorage(image))
+        return image_upload
+
+    def testNoMorePersonalFolder(self):
+        # .personal folders are history
+        personal = getattr(self.folder, self.membership.personal_id, None)
+        self.assertEqual(personal, None)
+        self.assertEqual(self.membership.getPersonalFolder(TEST_USER_ID), None)
+
+    def testGetPersonalFolderIfNoHome(self):
+        # Should return None as the user has no home folder
+        members = self.membership.getMembersFolder()
+        members._delObject(TEST_USER_ID)
+        self.assertEqual(self.membership.getPersonalFolder(TEST_USER_ID), None)
+
+    def testGetPersonalPortrait(self):
+        # Should return the default portrait
+        self.assertEqual(
+            self.membership.getPersonalPortrait(TEST_USER_ID).getId(),
+            'defaultUser.png')
+
+    def testChangeOwnMemberPortrait(self):
+        # Should change the portrait image
+        # first we need a valid image
+        image = self.makeRealImage()
+        self.membership.changeMemberPortrait(image, TEST_USER_ID)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(TEST_USER_ID).getId(),
+            TEST_USER_ID)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(TEST_USER_ID).meta_type,
+            'Image')
+
+    def testChangeOwnMemberPortraitWithEmailUsers(self):
+        member_id = 'member2@host.com'
+        self.membership.addMember(
+            member_id,
+            'pw',
+            ['Member'],
+            [],
+            {'email': 'member2@host.com', 'title': 'Member #2'}
+        )
+
+        self.login(member_id)
+        image = self.makeRealImage()
+        safe_member_id = self.membership._getSafeMemberId(member_id)
+
+        self.membership.changeMemberPortrait(image, member_id)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(member_id).getId(),
+            safe_member_id)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(member_id).meta_type,
+            'Image')
+
+    def testCannotChangeOtherMemberPortrait(self):
+        # A normal member should not be able to change the portrait of
+        # another member.
+        image = self.makeRealImage()
+        self.membership.addMember('joe', 'secret', ['Member'], [])
+        self.assertRaises(Unauthorized, self.membership.changeMemberPortrait,
+                          image, 'joe')
+
+    def testChangeMemberPortraitAsManager(self):
+        # Managers should be able to change the portrait of another
+        # member.
+        image = self.makeRealImage()
+        self.membership.addMember('joe', 'secret', ['Member'], [])
+        self.setRoles(['Manager'])
+        # This should not raise Unauthorized:
+        self.membership.changeMemberPortrait(image, 'joe')
+        self.assertEqual(self.membership.getPersonalPortrait('joe').getId(),
+                         'joe')
+        self.assertEqual(self.membership.getPersonalPortrait('joe').meta_type,
+                         'Image')
+
+    def testDeleteOwnPersonalPortrait(self):
+        # Should delete the portrait image
+        image = self.makeRealImage()
+        self.membership.changeMemberPortrait(image, TEST_USER_ID)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(TEST_USER_ID).getId(),
+            TEST_USER_ID)
+        self.membership.deletePersonalPortrait(TEST_USER_ID)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(TEST_USER_ID).getId(),
+            'defaultUser.png')
+
+    def testCannotDeleteOtherPersonalPortrait(self):
+        # A normal member should not be able to delete the portrait of
+        # another member.
+        image = self.makeRealImage()
+        self.membership.addMember('joe', 'secret', ['Member'], [])
+        self.setRoles(['Manager'])
+        self.membership.changeMemberPortrait(image, 'joe')
+        self.setRoles(['Member'])
+        self.assertRaises(Unauthorized, self.membership.deletePersonalPortrait,
+                          'joe')
+
+    def testDeleteOtherPersonalPortraitAsManager(self):
+        # Managers should be able to change the portrait of another
+        # member.
+        image = self.makeRealImage()
+        self.membership.addMember('joe', 'secret', ['Member'], [])
+        self.setRoles(['Manager'])
+        self.membership.changeMemberPortrait(image, 'joe')
+        self.membership.deletePersonalPortrait('joe')
+        self.assertEqual(
+            self.membership.getPersonalPortrait('joe').getId(),
+            'defaultUser.png'
+        )
+
+    def testGetPersonalPortraitWithoutPassingId(self):
+        # Should return the logged in users portrait if no id is given
+        image = self.makeRealImage()
+        self.membership.changeMemberPortrait(image, TEST_USER_ID)
+        self.assertEqual(self.membership.getPersonalPortrait().getId(),
+                         TEST_USER_ID)
+        self.assertEqual(self.membership.getPersonalPortrait().meta_type,
+                         'Image')
+
+    def testPortraitForNonStandardUserId(self):
+        # Some characters in a user id can give problems for getting
+        # or saving a portrait, especially '-', '+', '@'.
+        image = self.makeRealImage()
+        user_id = 'bob-jones+test@example.org'
+        safe_id = self.membership._getSafeMemberId(user_id)
+        self.assertEqual(safe_id, 'bob--jones-2Btest-40example.org')
+        self.membership.addMember(user_id, 'secret', ['Member'], [])
+        self.login(user_id)
+
+        # Should return the default portrait
+        self.assertEqual(
+            self.membership.getPersonalPortrait(user_id).getId(),
+            'defaultUser.png')
+
+        # Change your own portrait.
+        self.membership.changeMemberPortrait(image, user_id)
+        self.assertEqual(self.membership.getPersonalPortrait().getId(),
+                         safe_id)
+        self.assertEqual(self.membership.getPersonalPortrait().meta_type,
+                         'Image')
+
+        # Other users should be able to see your portrait.
+        self.login(TEST_USER_NAME)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(user_id).getId(),
+            safe_id)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(user_id).meta_type,
+            'Image')
+
+        # You can delete your own portrait.
+        self.login(user_id)
+        self.membership.deletePersonalPortrait(user_id)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(user_id).getId(),
+            'defaultUser.png')
+
+        # Managers should be able to change the portrait of another
+        # member and delete it.
+        manager_image = self.makeRealImage()
+        self.loginAsPortalOwner()
+        # This should not raise Unauthorized:
+        self.membership.changeMemberPortrait(manager_image, user_id)
+        self.assertEqual(self.membership.getPersonalPortrait(user_id).getId(),
+                         safe_id)
+        self.membership.deletePersonalPortrait(user_id)
+        self.assertEqual(
+            self.membership.getPersonalPortrait(user_id).getId(),
+            'defaultUser.png'
+        )
+
+    def testListMembers(self):
+        # Should return the members list
+        members = self.membership.listMembers()
+        self.assertEqual(len(members), 1)
+        self.assertEqual(members[0].getId(), TEST_USER_ID)
+
+    def testListMembersSkipsGroups(self):
+        # Should only return real members, not groups
+        uf = self.portal.acl_users
+        self.groups.addGroup('Foo')
+        self.groups.addGroup('Bar')
+        self.assertEqual(len(uf.getUserNames()), 1)
+        members = self.membership.listMembers()
+        self.assertEqual(len(members), 1)
+        self.assertEqual(members[0].getId(), TEST_USER_ID)
+
+    def testListMemberIds(self):
+        # Should return the members ids list
+        memberids = self.membership.listMemberIds()
+        self.assertEqual(len(memberids), 1)
+        self.assertEqual(memberids[0], TEST_USER_ID)
+
+    def testListMemberIdsSkipsGroups(self):
+        # Should only return real members, not groups
+        uf = self.portal.acl_users
+        self.groups.addGroup('Foo')
+        self.groups.addGroup('Bar')
+        self.assertEqual(len(uf.getUserNames()), 1)
+        memberids = self.membership.listMemberIds()
+        self.assertEqual(len(memberids), 1)
+        self.assertEqual(memberids[0], TEST_USER_ID)
+
+    def testCurrentPassword(self):
+        # Password checking should work
+        self.assertTrue(self.membership.testCurrentPassword('secret'))
+        self.assertFalse(self.membership.testCurrentPassword('geheim'))
+
+    def testSetPassword(self):
+        # Password should be changed
+        self.membership.setPassword('geheim')
+        self.assertTrue(self.membership.testCurrentPassword('geheim'))
+
+    def testSetPasswordIfAnonymous(self):
+        # Anonymous should not be able to change password
+        self.logout()
+        try:
+            self.membership.setPassword('geheim')
+        except BadRequest:
+            import sys
+            e, v, tb = sys.exc_info()
+            del tb
+            if str(v) == 'Not logged in.':
+                pass
+            else:
+                raise
+
+    def testSetPasswordAndKeepGroups(self):
+        # Password should be changed and user must not change group membership
+        group2 = 'g2'
+        groups = self.groups
+        groups.addGroup(group2, None, [], [])
+        group = groups.getGroupById(group2)
+        self.loginAsPortalOwner()
+        group.addMember(TEST_USER_ID)
+        self.login(TEST_USER_NAME)  # Back to normal
+        ugroups = self.portal.acl_users.getUserById(TEST_USER_ID).getGroups()
+        self.membership.setPassword('geheim')
+        t_groups = self.portal.acl_users.getUserById(TEST_USER_ID).getGroups()
+        self.assertTrue(t_groups == ugroups)
+
+    def testGetMemberById(self):
+        # This should work for portal users,
+        self.assertNotEqual(self.membership.getMemberById(TEST_USER_ID), None)
+        self.assertEqual(self.membership.getMemberById('foo'), None)
+        self.assertNotEqual(
+            self.membership.getMemberById(SITE_OWNER_NAME),
+            None
+        )
+
+    def testGetMemberByIdIsWrapped(self):
+        member = self.membership.getMemberById(TEST_USER_ID)
+        self.assertNotEqual(member, None)
+        self.assertEqual(member.__class__.__name__, 'MemberData')
+        self.assertEqual(member.aq_parent.__class__.__name__, 'PloneUser')
+
+    def testGetAuthenticatedMember(self):
+        member = self.membership.getAuthenticatedMember()
+        self.assertEqual(member.getUserName(), TEST_USER_NAME)
+
+    def testGetAuthenticatedMemberIsWrapped(self):
+        member = self.membership.getAuthenticatedMember()
+        self.assertEqual(member.getUserName(), TEST_USER_NAME)
+        self.assertEqual(member.__class__.__name__, 'MemberData')
+        self.assertEqual(member.aq_parent.__class__.__name__, 'PloneUser')
+
+    def testGetAuthenticatedMemberIfAnonymous(self):
+        self.logout()
+        member = self.membership.getAuthenticatedMember()
+        self.assertEqual(member.getUserName(), 'Anonymous User')
+
+    def testAnonymousMemberIsNotWrapped(self):
+        # Also see http://dev.plone.org/plone/ticket/1851
+        self.logout()
+        member = self.membership.getAuthenticatedMember()
+        self.assertNotEqual(member.__class__.__name__, 'MemberData')
+        self.assertEqual(member.__class__.__name__, 'SpecialUser')
+
+    def testIsAnonymousUser(self):
+        self.assertFalse(self.membership.isAnonymousUser())
+        self.logout()
+        self.assertTrue(self.membership.isAnonymousUser())
+
+    def testWrapUserWrapsBareUser(self):
+        user = self.portal.acl_users.getUserById(TEST_USER_ID)
+        # TODO: GRUF users are wrapped
+        self.assertTrue(hasattr(user, 'aq_base'))
+        user = aq_base(user)
+        user = self.membership.wrapUser(user)
+        self.assertEqual(user.__class__.__name__, 'MemberData')
+        self.assertEqual(user.aq_parent.__class__.__name__, 'PloneUser')
+        self.assertEqual(user.aq_parent.aq_parent.__class__.__name__,
+                         'PluggableAuthService')
+
+    def testWrapUserWrapsWrappedUser(self):
+        user = self.portal.acl_users.getUserById(TEST_USER_ID)
+        # TODO: GRUF users are wrapped
+        self.assertTrue(hasattr(user, 'aq_base'))
+        user = self.membership.wrapUser(user)
+        self.assertEqual(user.__class__.__name__, 'MemberData')
+        self.assertEqual(user.aq_parent.__class__.__name__, 'PloneUser')
+        self.assertEqual(user.aq_parent.aq_parent.__class__.__name__,
+                         'PluggableAuthService')
+
+    def testWrapUserDoesntWrapMemberData(self):
+        user = self.portal.acl_users.getUserById(TEST_USER_ID)
+        user.getMemberId = lambda x: 1
+        user = self.membership.wrapUser(user)
+        self.assertEqual(user.__class__.__name__, 'PloneUser')
+
+    def testWrapUserDoesntWrapAnonymous(self):
+        user = self.membership.wrapUser(nobody)
+        self.assertEqual(user.__class__.__name__, 'SpecialUser')
+
+    def testWrapUserWrapsAnonymous(self):
+        self.assertFalse(hasattr(nobody, 'aq_base'))
+        user = self.membership.wrapUser(nobody, wrap_anon=1)
+        self.assertEqual(user.__class__.__name__, 'MemberData')
+        self.assertEqual(user.aq_parent.__class__.__name__, 'SpecialUser')
+        self.assertEqual(user.aq_parent.aq_parent.__class__.__name__,
+                         'PluggableAuthService')
+
+    def testGetCandidateLocalRoles(self):
+        self.assertEqual(self.membership.getCandidateLocalRoles(self.folder),
+                         ('Owner',))
+        self.setRoles(['Member', 'Reviewer'])
+        self.assertEqual(self.membership.getCandidateLocalRoles(self.folder),
+                         ('Owner', 'Reviewer'))
+
+    def testSetLocalRoles(self):
+        self.assertTrue(
+            'Owner' in self.folder.get_local_roles_for_userid(TEST_USER_ID))
+        self.setRoles(['Member', 'Reviewer'])
+        self.membership.setLocalRoles(self.folder, [TEST_USER_ID, 'user2'],
+                                      'Reviewer')
+        self.assertEqual(self.folder.get_local_roles_for_userid(TEST_USER_ID),
+                         ('Owner', 'Reviewer'))
+        self.assertEqual(self.folder.get_local_roles_for_userid('user2'),
+                         ('Reviewer',))
+
+    def testDeleteLocalRoles(self):
+        self.setRoles(['Member', 'Reviewer'])
+        self.membership.setLocalRoles(self.folder, ['user2'], 'Reviewer')
+        self.assertEqual(self.folder.get_local_roles_for_userid('user2'),
+                         ('Reviewer',))
+        self.membership.deleteLocalRoles(self.folder, ['user2'])
+        self.assertEqual(self.folder.get_local_roles_for_userid('user2'), ())
+
+    def testGetHomeFolder(self):
+        self.assertNotEqual(self.membership.getHomeFolder(), None)
+        self.assertEqual(self.membership.getHomeFolder('user2'), None)
+
+    def testGetHomeUrl(self):
+        self.assertNotEqual(self.membership.getHomeUrl(), None)
+        self.assertEqual(self.membership.getHomeUrl('user2'), None)
+
+    def testGetAuthenticatedMemberInfo(self):
+        member = self.membership.getAuthenticatedMember()
+        member.setMemberProperties({'fullname': 'Test user'})
+        info = self.membership.getMemberInfo()
+        self.assertEqual(info['fullname'], 'Test user')
+
+    def testGetMemberInfo(self):
+        self.membership.addMember('user2', 'secret', ['Member'], [],
+                                  properties={'fullname': 'Second user'})
+        info = self.membership.getMemberInfo('user2')
+        self.assertEqual(info['fullname'], 'Second user')
+
+    def testGetCandidateLocalRolesIncludesLocalRolesOnObjectForManager(self):
+        self.folder._addRole('my_test_role')
+        self.folder.manage_setLocalRoles(TEST_USER_ID,
+                                         ('Manager', 'Owner'))
+        roles = self.membership.getCandidateLocalRoles(self.folder)
+        self.assertTrue('my_test_role' in roles,
+                        'my_test_role not in: %s' % str(roles))
+
+    def testGetCandidateLocalRolesIncludesLocalRolesOnObjectForAssignees(self):
+        self.folder._addRole('my_test_role')
+        self.folder.manage_setLocalRoles(TEST_USER_ID,
+                                         ('my_test_role', 'Owner'))
+        roles = self.membership.getCandidateLocalRoles(self.folder)
+        self.assertTrue('Owner' in roles)
+        self.assertTrue('my_test_role' in roles)
+        self.assertEqual(len(roles), 2)
+
+    def testGetCandidateLocalRolesForManager(self):
+        self.folder._addRole('my_test_role')
+        self.folder.manage_setLocalRoles(TEST_USER_ID, ('Manager', 'Owner'))
+        roles = self.membership.getCandidateLocalRoles(self.folder)
+        self.assertTrue('Manager' in roles)
+        self.assertTrue('Owner' in roles)
+        self.assertTrue('Reviewer' in roles)
+
+    def testGetCandidateLocalRolesForOwner(self):
+        self.folder._addRole('my_test_role')
+        roles = self.membership.getCandidateLocalRoles(self.folder)
+        self.assertTrue('Owner' in roles)
+        self.assertEqual(len(roles), 1)
+
+    def testGetCandidateLocalRolesForAssigned(self):
+        self.folder._addRole('my_test_role')
+        self.folder.manage_setLocalRoles(TEST_USER_ID, ('Reviewer', 'Owner'))
+        roles = self.membership.getCandidateLocalRoles(self.folder)
+        self.assertTrue('Owner' in roles)
+        self.assertTrue('Reviewer' in roles)
+        self.assertEqual(len(roles), 2)
+
+    def test_bug4333_delete_user_remove_memberdata(self):
+        # delete user should delete portal_memberdata
+        memberdata = self.portal.portal_memberdata
+        self.setRoles(['Manager'])
+        self.addMember('barney', 'Barney Rubble', 'barney@bedrock.com',
+                       ['Member'], '2002-01-01')
+        barney = self.membership.getMemberById('barney')
+        self.assertEqual(barney.getProperty('email'), 'barney@bedrock.com')
+        del barney
+
+        self.membership.deleteMembers(['barney'])
+        md = memberdata._members
+        self.assertFalse('barney' in md)
+
+        # There is an _v_ variable that is killed at the end of each request
+        # which stores a temporary version of the member object, this is
+        # a problem in this test.  In fact, this test does not really
+        # demonstrate the bug, which is actually caused by the script not
+        # using the tool.
+        memberdata._v_temps = None
+
+        self.membership.addMember('barney', 'secret', ['Member'], [])
+        barney = self.membership.getMemberById('barney')
+        self.assertNotEqual(barney.getProperty('fullname'), 'Barney Rubble')
+        self.assertNotEqual(barney.getProperty('email'), 'barney@bedrock.com')
+
+    def testBogusMemberPortrait(self):
+        # Should change the portrait image
+        bad_file = dummy.File(data='<div>This is a lie!!!</div>',
+                              headers={'content_type': 'image/jpeg'})
+        self.assertRaises(IOError, self.membership.changeMemberPortrait,
+                          bad_file, TEST_USER_ID)
+
+    def testGetBadMembers(self):
+        # Should list members with bad images
+        # We should not have any bad images out of the box
+        self.assertEqual(self.membership.getBadMembers(), [])
+        # Let's add one
+        bad_file = Image(
+            id=TEST_USER_ID,
+            title='',
+            file=StringIO('<div>This is a lie!!!</div>')
+        )
+        # Manually set a bad image using private methods
+        self.portal.portal_memberdata._setPortrait(bad_file, TEST_USER_ID)
+        self.assertEqual(self.membership.getBadMembers(), [TEST_USER_ID])
+        # Try an empty image
+        empty_file = Image(id=TEST_USER_ID, title='', file=StringIO(''))
+        self.portal.portal_memberdata._setPortrait(empty_file, TEST_USER_ID)
+        self.assertEqual(self.membership.getBadMembers(), [])
+        # And a good image
+        self.membership.changeMemberPortrait(self.makeRealImage(),
+                                             TEST_USER_ID)
+        self.assertEqual(self.membership.getBadMembers(), [])
+
+    def beforeTearDown(self):
+        self._free_warning_output()
+
+
+class TestCreateMemberarea(base.TestCase):
+
+    def afterSetUp(self):
+        self.membership = self.portal.portal_membership
+        self.membership.addMember('user2', 'secret', ['Member'], [])
+
+    def testCreateMemberarea(self):
+        # Should create a memberarea for user2
+        if self.membership.memberareaCreationFlag is True:
+            self.membership.createMemberarea('user2')
+            memberfolder = self.membership.getHomeFolder('user2')
+            self.assertTrue(memberfolder,
+                            'createMemberarea failed to create memberarea')
+            # member area creation should be on by default
+            self.assertTrue(self.membership.getMemberareaCreationFlag())
+
+    def testCreatMemberareaUsesCurrentUser(self):
+        if self.membership.memberareaCreationFlag is True:
+            # Should create a memberarea for user2
+            self.login('user2')
+            self.membership.createMemberarea()
+            memberfolder = self.membership.getHomeFolder('user2')
+            self.assertTrue(
+                memberfolder,
+                'createMemberarea failed to create memberarea for current '
+                'user'
+            )
+        else:
+            pass
+
+    def testNoMemberareaIfNoMembersFolder(self):
+        # Should not create a memberarea if the Members folder is missing
+        self.portal._delObject('Members')
+        self.membership.createMemberarea('user2')
+        memberfolder = self.membership.getHomeFolder('user2')
+        self.assertFalse(
+            memberfolder,
+            'createMemberarea unexpectedly created a memberarea'
+        )
+
+    def testNoMemberareaIfMemberareaExists(self):
+        # Should not attempt to create a memberarea if a memberarea already
+        # exists
+        self.membership.createMemberarea('user2')
+        # The second call should do nothing (not cause an error)
+        self.membership.createMemberarea('user2')
+
+    def testNotifyScriptIsCalled(self):
+        # The notify script should be called
+        if self.membership.memberareaCreationFlag is True:
+            self.portal.notifyMemberAreaCreated = dummy.Raiser(dummy.Error)
+            self.assertRaises(dummy.Error, self.membership.createMemberarea,
+                              'user2')
+
+    def testCreateMemberareaAlternateName(self):
+        # Alternate method name 'createMemberaArea' should work
+        if self.membership.memberareaCreationFlag is True:
+            self.membership.createMemberArea('user2')
+            memberfolder = self.membership.getHomeFolder('user2')
+            self.assertTrue(memberfolder,
+                            'createMemberArea failed to create memberarea')
+
+    def testCreateMemberareaAlternateType(self):
+        # Should be able to create another type instead of a normal Folder
+        if self.membership.memberareaCreationFlag is True:
+            self.membership.setMemberAreaType('Document')
+            self.membership.createMemberarea('user2')
+            memberfolder = self.membership.getHomeFolder('user2')
+            self.assertEqual(memberfolder.getPortalTypeName(), 'Document')
+
+    def testCreateMemberareaWhenDisabled(self):
+        # Should not create a member area
+        self.membership.setMemberareaCreationFlag = False
+        self.assertFalse(self.membership.getMemberareaCreationFlag())
+        self.membership.createMemberarea('user2')
+        memberfolder = self.membership.getHomeFolder('user2')
+        self.assertFalse(
+            memberfolder,
+            'createMemberarea created memberarea despite flag'
+        )
+
+
+class TestMemberareaSetup(base.TestCase):
+
+    def afterSetUp(self):
+        self.membership = self.portal.portal_membership
+        self.membership.addMember('user2', 'secret', ['Member'], [])
+        self.membership.createMemberarea('user2')
+        self.home = self.membership.getHomeFolder('user2')
+
+    def testMemberareaIsFolder(self):
+        if self.membership.memberareaCreationFlag is True:
+            # Memberarea should be a folder
+            self.assertEqual(self.home.meta_type, 'ATFolder')
+            self.assertEqual(self.home.portal_type, 'Folder')
+
+    def testMemberareaIsOwnedByMember(self):
+        if self.membership.memberareaCreationFlag is True:
+            # Memberarea should be owned by member
+            try:
+                owner_info = self.home.getOwnerTuple()
+            except AttributeError:
+                owner_info = self.home.getOwner(info=1)
+            self.assertEqual(owner_info[0], [PLONE_SITE_ID, 'acl_users'])
+            self.assertEqual(owner_info[1], 'user2')
+            self.assertEqual(len(self.home.get_local_roles()), 1)
+            self.assertEqual(self.home.get_local_roles_for_userid('user2'),
+                             ('Owner',))
+
+    def testMemberareaIsCataloged(self):
+        if self.membership.memberareaCreationFlag is True:
+            # Memberarea should be cataloged
+            catalog = self.portal.portal_catalog
+            self.assertTrue(catalog(id='user2', Type='Folder', Title="user2"),
+                            "Could not find user2's home folder in the "
+                            "catalog")
+
+    def testHomePageNotExists(self):
+        if self.membership.memberareaCreationFlag is True:
+            # Should not have an index_html document anymore
+            self.assertFalse('index_html' in self.home)
+
+
+class TestSearchForMembers(base.TestCase, WarningInterceptor):
+
+    def afterSetUp(self):
+        self.memberdata = self.portal.portal_memberdata
+        self.membership = self.portal.portal_membership
+        # Don't let default_user disturb results
+        self.portal.acl_users._doDelUsers([TEST_USER_ID])
+        # Add some members
+        self.addMember('fred', 'Fred Flintstone',
+                       'fred@bedrock.com', ['Member', 'Reviewer'],
+                       '2002-01-01')
+        self.addMember('barney', 'Barney Rubble',
+                       'barney@bedrock.com', ['Member'],
+                       '2002-01-01')
+        self.addMember('brubble', 'Bambam Rubble',
+                       'bambam@bambam.net', ['Member'],
+                       '2003-12-31')
+        # MUST reset this
+        self.memberdata._v_temps = None
+        self._trap_warning_output()
+
+    def addMember(self, username, fullname, email, roles, last_login_time):
+        self.membership.addMember(username, 'secret', roles, [])
+        member = self.membership.getMemberById(username)
+        member.setMemberProperties({
+            'fullname': fullname,
+            'email': email,
+            'last_login_time': DateTime(last_login_time), })
+
+    def testSearchById(self):
+        # Should search id and fullname
+        search = self.membership.searchForMembers
+        self.assertEqual(len(search(name='brubble')), 0)
+        self.assertEqual(len(search(name='barney')), 1)
+        self.assertEqual(len(search(name='rubble')), 2)
+
+    def testSearchByName(self):
+        # Should search id and fullname
+        search = self.membership.searchForMembers
+        self.assertEqual(len(search(name='rubble')), 2)
+        self.assertEqual(len(search(name='stone')), 1)
+
+    def testSearchByEmail(self):
+        search = self.membership.searchForMembers
+        self.assertEqual(len(search(email='bedrock')), 2)
+        self.assertEqual(len(search(email='bambam')), 1)
+
+    def testSearchByRoles(self):
+        search = self.membership.searchForMembers
+        self.assertEqual(len(search(roles=['Member'])), 3)
+        self.assertEqual(len(search(roles=['Reviewer'])), 1)
+
+    def testSearchByNameAndEmail(self):
+        search = self.membership.searchForMembers
+        self.assertEqual(len(search(name='rubble', email='bedrock')), 1)
+        self.assertEqual(len(search(name='bambam', email='bedrock')), 0)
+
+    def testSearchByNameAndRoles(self):
+        search = self.membership.searchForMembers
+        self.assertEqual(len(search(name='fred', roles=['Reviewer'])), 1)
+        self.assertEqual(len(search(name='fred', roles=['Manager'])), 0)
+
+    def testSearchByEmailAndRoles(self):
+        search = self.membership.searchForMembers
+        self.assertEqual(len(search(email='fred', roles=['Reviewer'])), 1)
+        self.assertEqual(len(search(email='fred', roles=['Manager'])), 0)
+
+    def testSearchByRequestObj(self):
+        search = self.membership.searchForMembers
+        self.addMember(u'jürgen', u'Jürgen Internationalist',
+                       'juergen@example.com', ['Member'],
+                       '2014-02-03')
+
+        self.assertEqual(len(search(
+            REQUEST=dict(name=u'jürgen'))), 1)
+
+        ptool = getUtility(IPropertiesTool)
+        ptool._setProperty('default_charset', 'iso8859-1')
+        self.assertEqual(len(search(
+            REQUEST=dict(name=u'jürgen'.encode('iso8859-1')))), 1)
+
+    def beforeTearDown(self):
+        self._free_warning_output()
+
+
+class TestDefaultUserAndPasswordNotChanged(base.TestCase):
+    # A test for a silly transaction/persistency bug in PlonePAS
+
+    def afterSetUp(self):
+        self.membership = self.portal.portal_membership
+
+    def testDefaultUserAndPasswordUnchanged(self):
+        member = self.membership.getAuthenticatedMember()
+        self.assertEqual(member.getUserName(), TEST_USER_NAME)
+        self.assertTrue(
+            self.membership.testCurrentPassword(TEST_USER_PASSWORD)
+        )
+        self.assertFalse(self.membership.testCurrentPassword('geheim'))
+
+
+class TestMethodProtection(base.TestCase):
+    # MembershipTool is missing security declarations
+    # http://dev.plone.org/plone/ticket/5432
+
+    _unprotected = (
+        'changeMemberPortrait',
+        'deletePersonalPortrait',
+        'testCurrentPassword',
+        'searchForMembers',
+    )
+
+    def afterSetUp(self):
+        self.membership = self.portal.portal_membership
+
+    def assertUnprotected(self, object, method):
+        self.logout()
+        object.restrictedTraverse(method)
+
+    def assertProtected(self, object, method):
+        self.logout()
+        self.assertRaises(Unauthorized, object.restrictedTraverse, method)
+
+    for method in _unprotected:
+        exec "def testUnprotected_%s(self):" \
+             "    self.assertProtected(self.membership, '%s')" \
+             % (method, method)
+
+        exec "def testMemberAccessible_%s(self):" \
+             "    self.membership.restrictedTraverse('%s')" % (method, method)
+
+
+class TestMemberInfoView(base.TestCase):
+
+    def afterSetUp(self):
+        self.membership = self.portal.portal_membership
+        self.view = PASMemberView(self.portal, self.portal.REQUEST)
+
+    def testMemberInfoViewForAuthenticated(self):
+        member = self.membership.getAuthenticatedMember()
+        member.setMemberProperties({'fullname': 'Test user'})
+        info = self.view.info()
+        self.assertEqual(info['username'], 'test-user')
+        self.assertEqual(info['fullname'], 'Test user')
+        self.assertEqual(info['name_or_id'], 'Test user')
+
+    def testGetMemberInfoViewForMember(self):
+        self.membership.addMember('user2', 'secret', ['Member'], [],
+                                  properties={'fullname': 'Second user'})
+        info = self.view.info('user2')
+        self.assertEqual(info['username'], 'user2')
+        self.assertEqual(info['fullname'], 'Second user')
+        self.assertEqual(info['name_or_id'], 'Second user')
+
+    def testGetMemberInfoViewForNonMember(self):
+        # When content is owned by a user who has meanwhile been
+        # removed, we do not want to throw an exception when asking
+        # for his member info.
+        self.assertFalse(self.membership.getMemberById('charon'))
+        info = self.view.info('charon')
+        self.assertEqual(info['username'], 'charon')
+        self.assertEqual(info['fullname'], '')
+        self.assertEqual(info['name_or_id'], 'charon')
+
+    def testGetMemberInfoViewForAnonymous(self):
+        self.logout()
+        self.assertTrue(self.membership.isAnonymousUser())
+        info = self.view.info()
+        self.assertEqual(info['username'], 'Anonymous User')
+        self.assertEqual(info['fullname'], None)
+        self.assertEqual(info['name_or_id'], 'Anonymous User')
+
+    def testSetGroupsWithUserNameIdDifference(self):
+        pas = self.portal['acl_users']
+        self.portal.portal_groups.addGroup('Editors', [], [])
+        self.setGroups(['Editors'], name=TEST_USER_ID)
+        self.login(TEST_USER_NAME)
+        user = getSecurityManager().getUser()
+        self.assertTrue(
+            'Editors' in getGroupsForPrincipal(user, pas['plugins'])
+        )
+        self.login()
+
+    def testSetGroupsWithSameUserNameAndId(self):
+        pas = self.portal['acl_users']
+        self.portal.portal_groups.addGroup('Editors', [], [])
+        self.setGroups(['Editors'])
+        user = getSecurityManager().getUser()
+        self.assertTrue(
+            'Editors' in getGroupsForPrincipal(user, pas['plugins'])
+        )
diff --git a/src/Products/PlonePAS/tests/test_properties.py b/src/Products/PlonePAS/tests/test_properties.py
new file mode 100644
index 0000000..3dab964
--- /dev/null
+++ b/src/Products/PlonePAS/tests/test_properties.py
@@ -0,0 +1,289 @@
+# -*- coding: utf-8 -*-
+from Products.CMFCore.utils import getToolByName
+from Products.PlonePAS.plugins.property import ZODBMutablePropertyProvider
+from Products.PlonePAS.tests import base
+from Products.PluggableAuthService.interfaces.plugins import \
+    IUserEnumerationPlugin
+
+
+class PropertiesTest(base.TestCase):
+
+    def test_user_properties(self):
+        mt = getToolByName(self.portal, 'portal_membership')
+        md = getToolByName(self.portal, 'portal_memberdata')
+
+        # Create a new Member
+        mt.addMember('user1', 'u1', ['Member'], [],
+                     {'email': 'user1@host.com',
+                      'fullname': 'User #1'})
+        member = mt.getMemberById('user1')
+        self.assertFalse(member is None)
+
+        # Assert user doesn't have the property yet
+        self.assertFalse(member.hasProperty('age'))
+
+        # Add new property
+        md.manage_addProperty('age', 20, 'int')
+
+        # Assert user has the property now
+        self.assertTrue(member.hasProperty('age'))
+
+        # Get the property, should have the default value
+        got = member.getProperty('age', None)
+        expected = 20
+        self.assertEqual(got, expected)
+
+        # get a handle on the member
+        member = mt.getMemberById('user1')
+
+        # Set some member properties. Needs to be logged in as the user.
+        self.login('user1')
+        member.setMemberProperties({'age': 30, 'fullname': 'User #1 Is Cool',
+                                    'email': 'user1@anotherhost.qa'})
+
+        # Check the properties have been set
+        got = member.getProperty('age', None)
+        expected = 30
+        self.assertEqual(got, expected)
+
+        got = member.getProperty('fullname', None)
+        expected = 'User #1 Is Cool'
+        self.assertEqual(got, expected)
+
+        got = member.getProperty('email', None)
+        expected = 'user1@anotherhost.qa'
+        self.assertEqual(got, expected)
+
+        # Delete the property
+        md.manage_delProperties(ids=('age',))
+
+        # re-get the member to reflect the new memberdata schema
+        member = mt.getMemberById('user1')
+
+        # Assert property is gone
+        self.assertFalse(member.hasProperty('age'))
+
+        # Get the property, should return default (None)
+        got = member.getProperty('age', None)
+        expected = None
+        self.assertEqual(got, expected)
+
+        # Other properties should still be there.
+        got = member.getProperty('fullname', None)
+        expected = 'User #1 Is Cool'
+        self.assertEqual(got, expected)
+
+        got = member.getProperty('email', None)
+        expected = 'user1@anotherhost.qa'
+        self.assertEqual(got, expected)
+
+    def test_group_properties(self):
+        gt = getToolByName(self.portal, 'portal_groups')
+        gd = getToolByName(self.portal, 'portal_groupdata')
+
+        self.loginAsPortalOwner()
+
+        # Create a new Group
+        gt.addGroup(
+            'group1',
+            ['Reviewer'],
+            [],
+            {'email': 'group1@host.com', 'title': 'Group #1'}
+        )
+        group = gt.getGroupById('group1')
+        self.assertFalse(group is None)
+
+        # Assert group doesn't have the property yet
+        self.assertFalse(group.hasProperty('karma'))
+
+        # Add new property
+        gd.manage_addProperty('karma', 20, 'int')
+
+        # get group again to re-create with new groupdata schema
+        group = gt.getGroupById('group1')
+
+        # Assert group has the property now
+        self.assertTrue(group.hasProperty('karma'))
+
+        # Get the property, should have the default value
+        got = group.getProperty('karma', None)
+        expected = 20
+
+        self.assertEqual(got, expected)
+
+        # Set some group properties
+        group.setGroupProperties({'karma': 30, 'title': 'Group #1 Is Cool',
+                                  'email': 'group1@anotherhost.qa'})
+
+        # Check the properties have been set
+        got = group.getProperty('karma', None)
+        expected = 30
+        self.assertEqual(got, expected)
+
+        got = group.getProperty('title', None)
+        expected = 'Group #1 Is Cool'
+        self.assertEqual(got, expected)
+
+        got = group.getProperty('email', None)
+        expected = 'group1@anotherhost.qa'
+        self.assertEqual(got, expected)
+
+        # Delete the property
+        gd.manage_delProperties(ids=('karma',))
+
+        # get group again to re-create with new groupdata schema
+        group = gt.getGroupById('group1')
+
+        # Assert property is gone
+        self.assertFalse(group.hasProperty('karma'))
+
+        # Get the property, should return default (None)
+        got = group.getProperty('karma', None)
+        expected = None
+        self.assertEqual(got, expected)
+
+        # Other properties should still be there.
+        got = group.getProperty('title', None)
+        expected = 'Group #1 Is Cool'
+        self.assertEqual(got, expected)
+
+        got = group.getProperty('email', None)
+        expected = 'group1@anotherhost.qa'
+        self.assertEqual(got, expected)
+
+    def test_schema_for_mutable_property_provider(self):
+        """Add a schema to a ZODBMutablePropertyProvider.
+        """
+
+        # Schema is list of tuples with name, type (string), value.
+        # From the types it seems only 'lines' is handled differently.
+        address_schema = [
+            ('addresses', 'lines', ['Here', 'There']),
+            ('city', 'str', 'Somewhere'),
+            ('telephone', 'int', 1234567),
+        ]
+
+        # This used to give a ValueError, so we just check that it
+        # does not.
+        provider = ZODBMutablePropertyProvider(
+            'address_plugin', "Address Plugin", schema=address_schema)
+
+        # When this test passes, we are happy already, but let's add a
+        # few more basic tests.
+
+        # Create a new Member
+        mt = getToolByName(self.portal, 'portal_membership')
+        mt.addMember('user1', 'u1', ['Member'], [],
+                     {'email': 'user1@host.com',
+                      'fullname': 'User #1'})
+        member = mt.getMemberById('user1')
+        sheet = provider.getPropertiesForUser(member)
+        self.assertEqual(
+            sheet.propertyIds(), ['addresses', 'city', 'telephone'])
+        self.assertEqual(sheet.propertyInfo('city'),
+                         {'type': 'str', 'id': 'city', 'mode': ''})
+        self.assertEqual(sheet.getProperty('addresses'), ('Here', 'There'))
+
+
+class PropertySearchTest(base.TestCase):
+
+    def afterSetUp(self):
+        self.mt = getToolByName(self.portal, 'portal_membership')
+        self.md = getToolByName(self.portal, 'portal_memberdata')
+        self.gt = getToolByName(self.portal, 'portal_groups')
+
+        # Create a new Member
+        self.mt.addMember(
+            'member1',
+            'pw',
+            ['Member'],
+            [],
+            {'email': 'member1@host.com', 'title': 'Member #1'}
+        )
+        member = self.mt.getMemberById('member1')
+        self.assertFalse(member is None)
+
+        self.mt.addMember(
+            'member2',
+            'pw',
+            ['Member'],
+            [],
+            {'email': 'user2@otherhost.com', 'fullname': 'User #2'}
+        )
+        member = self.mt.getMemberById('member2')
+        self.assertFalse(member is None)
+
+        # Add a Group to make sure searchUsers isn't returning them in results.
+        self.gt.addGroup('group1', title="Group 1")
+        group = self.gt.getGroupById('group1')
+        self.assertFalse(group is None)
+
+        self.pas = getToolByName(self.portal, "acl_users")
+        for plugin in self.pas.plugins \
+                          .getAllPlugins('IUserEnumerationPlugin')['active']:
+            if plugin != 'mutable_properties':
+                self.pas.plugins.deactivatePlugin(IUserEnumerationPlugin,
+                                                  plugin)
+
+    def testPluginActivated(self):
+        plugins = self.pas.plugins \
+                      .getAllPlugins('IUserEnumerationPlugin')['active']
+        self.assertEqual(plugins, ('mutable_properties',))
+
+    def testEmptySearch(self):
+        results = self.pas.searchUsers()
+        self.assertEqual(len(results), 2)
+
+    def testInexactStringSearch(self):
+        results = self.pas.searchUsers(email="something@somewhere.tld")
+        self.assertEqual(results, ())
+
+        results = self.pas.searchUsers(email="member1@host.com",
+                                       exact_match=False)
+        results = [info['userid'] for info in results]
+        self.assertEqual(results, ['member1'])
+
+        results = self.pas.searchUsers(email="@host.com", exact_match=False)
+        results = [info['userid'] for info in results]
+        self.assertEqual(results, ['member1'])
+
+        results = self.pas.searchUsers(email="member1@host.com",
+                                       exact_match=True)
+        results = [info['userid'] for info in results]
+        self.assertEqual(results, ['member1'])
+
+        results = self.pas.searchUsers(email="@host.com", exact_match=True)
+        results = [info['userid'] for info in results]
+        self.assertEqual(results, [])
+
+    def testBooleanSearch(self):
+        results = self.pas.searchUsers(visible_ids=True)
+        results = [info['userid'] for info in results]
+        self.assertEqual(results, [])
+
+        results = self.pas.searchUsers(visible_ids=False)
+        results = [info['userid'] for info in results]
+        self.assertEqual(results, ['member1', 'member2'])
+
+    def testGroupsNotReturnedByEnumerateUsers(self):
+        """Check to make sure that groups aren't returned by a enumerateUsers
+           call.
+           See http://dev.plone.org/plone/ticket/9435"""
+        results = self.pas.searchUsers()
+        resultIds = [a['id'] for a in results]
+        self.assertFalse('group1' in resultIds)
+
+    def testSearchEmptyId(self):
+        self.assertEqual(self.pas.mutable_properties.enumerateUsers(id=''), ())
+        self.assertEqual(
+            self.pas.mutable_properties.enumerateUsers(login=''),
+            ()
+        )
+
+    def testCantSearchByIdOrLogin(self):
+        # we can't search by id
+        results = self.pas.searchUsers(id='member1')
+        self.assertEqual(results, ())
+        # or login
+        results = self.pas.searchUsers(login='member1')
+        self.assertEqual(results, ())
diff --git a/src/Products/PlonePAS/tests/test_role_plugin.py b/src/Products/PlonePAS/tests/test_role_plugin.py
new file mode 100644
index 0000000..00ec703
--- /dev/null
+++ b/src/Products/PlonePAS/tests/test_role_plugin.py
@@ -0,0 +1,86 @@
+# -*- coding: utf-8 -*-
+# $Id$
+"""Tests for Products.PlonePAS.plugins.role.GroupAwareRoleManager"""
+
+from Products.PlonePAS.tests import base
+from Products.PluggableAuthService.PluggableAuthService import \
+    _PLUGIN_TYPE_INFO
+from Products.PluggableAuthService.interfaces.plugins import IGroupsPlugin
+from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from Products.PluggableAuthService.plugins.tests.helpers import DummyUser
+from Products.PluggableAuthService.plugins.tests.helpers import FauxPAS
+from Products.PluggableAuthService.plugins.tests.helpers import \
+    makeRequestAndResponse
+from Products.PluginRegistry.PluginRegistry import PluginRegistry
+from zope.interface import implementer
+
+
+@implementer(IGroupsPlugin)
+class FauxGroupsPlugin(BasePlugin):
+
+    def getGroupsForPrincipal(self, principal, request=None):
+        return principal._groups
+
+
+class GroupAwareRoleManagerTests(base.TestCase):
+    """Roles manager that takes care of goup of principal"""
+
+    def _getTargetClass(self):
+
+        from Products.PlonePAS.plugins.role import GroupAwareRoleManager
+        return GroupAwareRoleManager
+
+    def _makeOne(self, id='test', *args, **kw):
+
+        plugin = self._getTargetClass()(id=id, *args, **kw)
+        # We need to bind a fake request to this plugin
+        request, dummy_response = makeRequestAndResponse()
+        setattr(plugin, 'REQUEST', request)
+        return plugin
+
+    def test_roles_for_control_panel(self):
+        """There's a special case, the users control panel for which
+        we should never grant to users the roles they have got through
+        the groups they belong.
+        In that intent, the control panels view pushes
+        '__ignore_group_roles__' = True
+        in the request.
+        """
+        root = FauxPAS()
+
+        # Add a minimal PluginRegistry with a mock IGroupsPlugin, because the
+        # roles plugin depends on it:
+        root._setObject('plugins', PluginRegistry(_PLUGIN_TYPE_INFO))
+        root._setObject('groups', FauxGroupsPlugin())
+        root['plugins'].activatePlugin(IGroupsPlugin, 'groups')
+
+        garm = self._makeOne('garm').__of__(root)
+
+        # 2 roles
+        garm.addRole('foo_role')
+        garm.addRole('bar_role')
+
+        # Group 'somegroup' has 'bar_role'
+        garm.assignRoleToPrincipal('bar_role', 'somegroup')
+
+        # 'johndoe' has 'foo_role'
+        johndoe = DummyUser('johndoe', ('somegroup',))
+        garm.assignRoleToPrincipal('foo_role', 'johndoe')
+
+        # 'johndoe' should have 'foo_role' and 'bar_roles'
+        got = garm.getRolesForPrincipal(johndoe)
+        expected = ['foo_role', 'bar_role']
+        self.assertEqual(set(got), set(expected))
+
+        # For the users control panel, johndoe has only the 'foo_role'
+        garm.REQUEST.set('__ignore_group_roles__', True)
+        got = garm.getRolesForPrincipal(johndoe)
+        self.assertEqual(got, ('foo_role',))
+
+        # Confirm we can get only the inherited roles
+        garm.REQUEST.set('__ignore_group_roles__', False)
+        garm.REQUEST.set('__ignore_direct_roles__', True)
+        got = garm.getRolesForPrincipal(johndoe)
+        self.assertEqual(got, ('bar_role',))
+
+        return
diff --git a/src/Products/PlonePAS/tests/test_views.py b/src/Products/PlonePAS/tests/test_views.py
new file mode 100644
index 0000000..d0a7f60
--- /dev/null
+++ b/src/Products/PlonePAS/tests/test_views.py
@@ -0,0 +1,19 @@
+# -*- encoding: utf-8 -*-
+from Products.PlonePAS.tests import base
+
+
+class TestPASSearchView(base.TestCase):
+
+    def test_sort(self):
+        pas_search = self.portal.restrictedTraverse('@@pas_search')
+        values = [{'title': u'Sociologie'}, {'title': u'Économie'},
+                  {'title': u'anthropologie'}]
+        sorted_values = pas_search.sort(values, 'title')
+        # do not modify original
+        self.assertEqual(values,
+                         [{'title': u'Sociologie'}, {'title': u'Économie'},
+                          {'title': u'anthropologie'}])
+        # sorted here
+        self.assertEqual(sorted_values,
+                         [{'title': u'anthropologie'}, {'title': u'Économie'},
+                          {'title': u'Sociologie'}])
diff --git a/src/Products/PlonePAS/tool.gif b/src/Products/PlonePAS/tool.gif
new file mode 100644
index 0000000..2d866bb
Binary files /dev/null and b/src/Products/PlonePAS/tool.gif differ
diff --git a/src/Products/PlonePAS/tools/__init__.py b/src/Products/PlonePAS/tools/__init__.py
new file mode 100644
index 0000000..40a96af
--- /dev/null
+++ b/src/Products/PlonePAS/tools/__init__.py
@@ -0,0 +1 @@
+# -*- coding: utf-8 -*-
diff --git a/src/Products/PlonePAS/tools/groupdata.py b/src/Products/PlonePAS/tools/groupdata.py
new file mode 100644
index 0000000..a7b74e6
--- /dev/null
+++ b/src/Products/PlonePAS/tools/groupdata.py
@@ -0,0 +1,523 @@
+# -*- coding: utf-8 -*-
+from AccessControl import ClassSecurityInfo
+from AccessControl import Permissions
+from AccessControl import Unauthorized
+from AccessControl import getSecurityManager
+from AccessControl.requestmethod import postonly
+from Acquisition import aq_base
+from Acquisition import aq_inner
+from Acquisition import aq_parent
+from App.class_init import InitializeClass
+from BTrees.OOBTree import OOBTree
+from OFS.PropertyManager import PropertyManager
+from OFS.SimpleItem import SimpleItem
+from Products.CMFCore.utils import UniqueObject
+from Products.CMFCore.utils import getToolByName
+from Products.CMFCore.utils import registerToolInterface
+from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
+from Products.PlonePAS.interfaces.capabilities import IManageCapabilities
+from Products.PlonePAS.interfaces.group import IGroupData
+from Products.PlonePAS.interfaces.group import IGroupDataTool
+from Products.PlonePAS.interfaces.group import IGroupManagement
+from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
+from Products.PlonePAS.tools.memberdata import MemberData
+from Products.PlonePAS.utils import CleanupTemp
+from Products.PluggableAuthService.PluggableAuthService import \
+    _SWALLOWABLE_PLUGIN_EXCEPTIONS
+from Products.PluggableAuthService.interfaces.authservice import \
+    IPluggableAuthService
+from ZPublisher.Converters import type_converters
+from zope.interface import implementer
+
+import logging
+
+logger = logging.getLogger('PlonePAS')
+_marker = object()
+
+
+@implementer(IGroupDataTool)
+class GroupDataTool(UniqueObject, SimpleItem, PropertyManager):
+    """This tool wraps group objects, allowing transparent access to
+    properties.
+    """
+
+    id = 'portal_groupdata'
+    meta_type = "PlonePAS GroupData Tool"
+    toolicon = 'tool.gif'
+
+    _v_temps = None
+    _properties = ({'id': 'title', 'type': 'string', 'mode': 'wd'},)
+    security = ClassSecurityInfo()
+
+    def __init__(self):
+        self._members = OOBTree()
+        # Create the default properties.
+        self._setProperty('description', '', 'text')
+        self._setProperty('email', '', 'string')
+
+    def wrapGroup(self, g):
+        """Returns an object implementing the GroupData interface."""
+
+        gid = g.getId()
+        members = self._members
+        if gid not in members:
+            # Get a temporary member that might be
+            # registered later via registerMemberData().
+            temps = self._v_temps
+            if temps is not None and gid in temps:
+                portal_group = temps[gid]
+            else:
+                base = aq_base(self)
+                portal_group = GroupData(base, gid)
+                if temps is None:
+                    self._v_temps = {gid: portal_group}
+                    if hasattr(self, 'REQUEST'):
+                        self.REQUEST._hold(CleanupTemp(self))
+                else:
+                    temps[gid] = portal_group
+        else:
+            portal_group = members[gid]
+        # Return a wrapper with self as containment and
+        # the user as context.
+        return portal_group.__of__(self).__of__(g)
+
+    @security.private
+    def registerGroupData(self, g, id):
+        '''
+        Adds the given member data to the _members dict.
+        This is done as late as possible to avoid side effect
+        transactions and to reduce the necessary number of
+        entries.
+        '''
+        self._members[id] = aq_base(g)
+
+
+InitializeClass(GroupDataTool)
+registerToolInterface('portal_groupdata', IGroupDataTool)
+
+
+@implementer(IGroupData, IManageCapabilities)
+class GroupData(SimpleItem):
+
+    security = ClassSecurityInfo()
+
+    id = None
+    _tool = None
+
+    def __init__(self, tool, id):
+        self.id = id
+        # Make a temporary reference to the tool.
+        # The reference will be removed by notifyModified().
+        self._tool = tool
+
+    def _getGRUF(self,):
+        return self.acl_users
+
+    @security.private
+    def notifyModified(self):
+        # Links self to parent for full persistence.
+        tool = getattr(self, '_tool', None)
+        if tool is not None:
+            del self._tool
+            tool.registerGroupData(self, self.getId())
+
+    @security.public
+    def getGroup(self):
+        """ Returns the actual group implementation. Varies by group
+        implementation (GRUF/Nux/et al). In GRUF this is a user object."""
+        # The user object is our context, but it's possible for
+        # restricted code to strip context while retaining
+        # containment.  Therefore we need a simple security check.
+        parent = aq_parent(self)
+        bcontext = aq_base(parent)
+        bcontainer = aq_base(aq_parent(aq_inner(self)))
+        if bcontext is bcontainer or not hasattr(bcontext, 'getUserName'):
+            raise 'GroupDataError', "Can't find group data"
+        # Return the user object, which is our context.
+        return parent
+
+    def getTool(self):
+        return aq_parent(aq_inner(self))
+
+    @security.public
+    def getGroupMemberIds(self):
+        """
+        Return a list of group member ids
+        """
+        return map(lambda x: x.getMemberId(), self.getGroupMembers())
+
+    @security.public
+    def getAllGroupMemberIds(self):
+        """
+        Return a list of group member ids
+        """
+        return map(lambda x: x.getMemberId(), self.getAllGroupMembers())
+
+    @security.public
+    def getGroupMembers(self):
+        """
+        Returns a list of the portal_memberdata-ish members of the group.
+        This doesn't include TRANSITIVE groups/users.
+        """
+        md = self.portal_memberdata
+        gtool = self.portal_groups
+        ret = []
+        for u_name in gtool.getGroupMembers(self.getId()):
+            usr = self._getGRUF().getUserById(u_name)
+            # getUserById from
+            #   Products.PluggableAuthService.PluggableAuthService
+            # The returned object is not wrapped, we wrapped it below
+            if not usr:
+                usr = self._getGRUF().getGroupById(u_name)
+                # getGroupById from Products.PlonePAS.pas
+                # The returned object is already wrapped
+                if not usr:
+                    logger.debug(
+                        "Group has a non-existing principal {0}".format(u_name)
+                    )
+                    continue
+                ret.append(usr)
+            else:
+                ret.append(md.wrapUser(usr))
+        return ret
+
+    @security.public
+    def getAllGroupMembers(self):
+        """
+        Returns a list of the portal_memberdata-ish members of the group.
+        This will include transitive groups / users
+        """
+        md = self.portal_memberdata
+        ret = []
+        for u_name in self.getGroup().getMemberIds():
+            usr = self._getGRUF().getUserById(u_name)
+            if not usr:
+                usr = self._getGRUF().getGroupById(u_name)
+                if not usr:
+                    logger.debug(
+                        "Group has a non-existing principal {0}".format(u_name)
+                    )
+                    continue
+                ret.append(usr)
+            else:
+                ret.append(md.wrapUser(usr))
+        return ret
+
+    def _getGroup(self):
+        """Get the underlying group object in a PAS-acceptable way.
+        (I don't even know why there's the two different ways for GRUF. Speed?)
+        """
+        return self.getGroup()
+
+    @security.private
+    def canAdministrateGroup(self):
+        """
+        Return true if the #current# user can administrate this group
+        """
+        user = getSecurityManager().getUser()
+        tool = self.getTool()
+        portal = getToolByName(tool, 'portal_url').getPortalObject()
+
+        # Has manager users pemission?
+        if user.has_permission(Permissions.manage_users, portal):
+            return True
+
+        # Is explicitly mentioned as a group administrator?
+        managers = self.getProperty('delegated_group_member_managers', ())
+        if user.getId() in managers:
+            return True
+
+        # Belongs to a group which is explicitly mentionned as a group
+        # administrator
+        meth = getattr(user, "getAllGroupNames", None)
+        if meth:
+            groups = meth()
+        else:
+            groups = ()
+        for v in groups:
+            if v in managers:
+                return True
+
+        # No right to edit this: we complain.
+        return False
+
+    @security.public
+    @postonly
+    def addMember(self, id, REQUEST=None):
+        """ Add the existing member with the given id to the group"""
+        if not self.canAdministrateGroup():
+            raise Unauthorized("You cannot add a member to the group.")
+
+        plugins = self._getPlugins()
+        managers = plugins.listPlugins(IGroupManagement)
+        for mid, manager in managers:
+            try:
+                if manager.addPrincipalToGroup(id, self.getId()):
+                    break
+            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+                pass
+
+    @security.public
+    @postonly
+    def removeMember(self, id, REQUEST=None):
+        """Remove the member with the provided id from the group.
+        """
+        if not self.canAdministrateGroup():
+            raise Unauthorized("You cannot remove a member from the group.")
+
+        plugins = self._getPlugins()
+        managers = plugins.listPlugins(IGroupManagement)
+        for mid, manager in managers:
+            try:
+                if manager.removePrincipalFromGroup(id, self.getId()):
+                    break
+            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+                pass
+
+    @security.protected(Permissions.manage_users)
+    def setProperties(self, properties=None, **kw):
+        """Allows the manager group to set his/her own properties.
+        Accepts either keyword arguments or a mapping for the "properties"
+        argument.
+        """
+        if properties is None:
+            properties = kw
+        return self.setGroupProperties(properties)
+
+    @security.protected(Permissions.manage_users)
+    def setGroupProperties(self, mapping):
+        """PAS-specific method to set the properties of a group.
+        """
+        sheets = None
+
+        if not IPluggableAuthService.providedBy(self.acl_users):
+            # Defer to base impl in absence of PAS, a PAS group, or
+            # property sheets
+            return self._gruf_setGroupProperties(mapping)
+        else:
+            # It's a PAS! Whee!
+            group = self.getGroup()
+            sheets = getattr(group, 'getOrderedPropertySheets', lambda: [])()
+
+            # We won't always have PlonePAS groups, due to acquisition,
+            # nor are guaranteed property sheets
+            if not sheets:
+                # Defer to base impl if we have a PAS but no property
+                # sheets.
+                return self._gruf_setGroupProperties(mapping)
+
+        # If we got this far, we have a PAS and some property sheets.
+        # XXX track values set to defer to default impl
+        # property routing?
+        modified = False
+        for k, v in mapping.items():
+            for sheet in sheets:
+                if not sheet.hasProperty(k):
+                    continue
+                if IMutablePropertySheet.providedBy(sheet):
+                    sheet.setProperty(group, k, v)
+                    modified = True
+                else:
+                    raise RuntimeError("Mutable property provider "
+                                       "shadowed by read only provider")
+        if modified:
+            self.notifyModified()
+
+    def _gruf_setGroupProperties(self, mapping):
+        '''Sets the properties of the member.
+        '''
+        # Sets the properties given in the MemberDataTool.
+        tool = self.getTool()
+        for id in tool.propertyIds():
+            if id in mapping:
+                if id not in self.__class__.__dict__:
+                    value = mapping[id]
+                    if isinstance(value, str):
+                        proptype = tool.getPropertyType(id) or 'string'
+                        if proptype in type_converters:
+                            value = type_converters[proptype](value)
+                    setattr(self, id, value)
+
+        # Hopefully we can later make notifyModified() implicit.
+        self.notifyModified()
+
+    @security.public
+    def getProperties(self):
+        """ Return the properties of this group. Properties are as usual
+            in Zope.
+        """
+        tool = self.getTool()
+        ret = {}
+        for pty in tool.propertyIds():
+            try:
+                ret[pty] = self.getProperty(pty)
+            except ValueError:
+                # We ignore missing ptys
+                continue
+        return ret
+
+    @security.public
+    def getProperty(self, id, default=None):
+        """PAS-specific method to fetch a group's properties. Looks
+        through the ordered property sheets.
+        """
+        group = self.getGroup()
+        sheets = getattr(group, 'getOrderedPropertySheets', lambda: [])()
+
+        # If we made this far, we found a PAS and some property sheets.
+        for sheet in sheets:
+            if sheet.hasProperty(id):
+                # Return the first one that has the property.
+                return sheet.getProperty(id)
+        # we won't always have PlonePAS groups, due to acquisition,
+        # nor are guaranteed property sheets
+        # Couldn't find the property in the property sheets. Try to
+        # delegate back to the base implementation.
+
+        tool = self.getTool()
+        base = aq_base(self)
+
+        # Then, check the user object, the tool, and attrs of myself for a
+        # value:
+        user_value = getattr(aq_base(self.getGroup()), id, _marker)
+        tool_value = tool.getProperty(id, _marker)
+        value = getattr(base, id, _marker)
+
+        # Take the first of the above that is filled out:
+        for v in [user_value, tool_value, value]:
+            if v is not _marker:
+                return v
+
+        return default
+
+    def __str__(self):
+        return self.getGroupId()
+
+    @security.public
+    def isGroup(self):
+        """
+        isGroup(self,) => Return true if this is a group.
+        Will always return true for groups.
+        As MemberData objects do not support this method, it is quite useless
+        by now.
+        So one can use groupstool.isGroup(g) instead to get this information.
+        """
+        return 1
+
+    # Group object interface ###
+
+    @security.public
+    def getGroupName(self):
+        return self.getName()
+
+    @security.public
+    def getGroupId(self):
+        """Get the ID of the group. The ID can be used, at least from
+        Python, to get the user from the user's UserDatabase.
+        Within Plone, all group ids are UNPREFIXED."""
+        return self.getGroup().getId()
+
+    def getGroupTitleOrName(self):
+        """Get the Title property of the group. If there is none
+        then return the name """
+        title = self.getProperty('title', None)
+        return title or self.getGroupName()
+
+    @security.public
+    def getMemberId(self):
+        """This exists only for a basic user/group API compatibility
+        """
+        return self.getGroupId()
+
+    @security.public
+    def getRoles(self):
+        """Return the list of roles assigned to a user."""
+        return self.getGroup().getRoles()
+
+    @security.public
+    def getRolesInContext(self, object):
+        """Return the list of roles assigned to the user,  including local
+        roles assigned in context of the passed in object."""
+        return self.getGroup().getRolesInContext(object)
+
+    @security.public
+    def getDomains(self):
+        """Return the list of domain restrictions for a user"""
+        return self.getGroup().getDomains()
+
+    @security.public
+    def has_role(self, roles, object=None):
+        """Check to see if a user has a given role or roles."""
+        return self.getGroup().has_role(roles, object)
+
+    # GRUF 3.2 methods...
+
+    def getUserName(self):
+        return self.getName()
+    getUserNameWithoutGroupPrefix = getUserName
+
+    # IManageCapabilities methods
+    def canDelete(self):
+        """True iff user can be removed from the Plone UI.
+        """
+        # IGroupManagement provides removeGroup
+        plugins = self._getPlugins()
+        managers = plugins.listPlugins(IGroupManagement)
+        if managers:
+            for mid, manager in managers:
+                if (IDeleteCapability.providedBy(manager) and
+                        manager.allowDeletePrincipal(self.getId())):
+                    return True
+        return False
+
+    def canPasswordSet(self):
+        """Always false for groups, which have no password.
+        """
+        return False
+
+    def passwordInClear(self):
+        """True iff password can be retrieved in the clear (not hashed.)
+
+        False for PAS. It provides no API for getting passwords,
+        though it would be possible to add one in the future.
+        """
+        return False
+
+    def _groupdataHasProperty(self, prop_name):
+        gdata = getToolByName(self, 'portal_groupdata', None)
+        if gdata:
+            return gdata.hasProperty(prop_name)
+        return 0
+
+    def canWriteProperty(self, prop_name):
+        """True iff the group property named in 'prop_name'
+        can be changed.
+        """
+        # this looks almost exactly like in memberdata. refactor?
+        if not IPluggableAuthService.providedBy(self.acl_users):
+            # not PAS; Groupdata is writable
+            return self._groupdataHasProperty(prop_name)
+        else:
+            # it's PAS
+            group = self.getGroup()
+            sheets = getattr(group, 'getOrderedPropertySheets', lambda: [])()
+            for sheet in sheets:
+                if not sheet.hasProperty(prop_name):
+                    continue
+                if IMutablePropertySheet.providedBy(sheet):
+                    return 1
+                else:
+                    break  # shadowed by read-only
+        return 0
+
+    canAddToGroup = MemberData.canAddToGroup.im_func
+    canRemoveFromGroup = MemberData.canRemoveFromGroup.im_func
+    canAssignRole = MemberData.canAssignRole.im_func
+
+    # plugin getters
+
+    @security.private
+    def _getPlugins(self):
+        return self.acl_users.plugins
+
+InitializeClass(GroupData)
diff --git a/src/Products/PlonePAS/tools/groups.py b/src/Products/PlonePAS/tools/groups.py
new file mode 100644
index 0000000..1e1d5e1
--- /dev/null
+++ b/src/Products/PlonePAS/tools/groups.py
@@ -0,0 +1,441 @@
+# -*- coding: utf-8 -*-
+from AccessControl import ClassSecurityInfo
+from AccessControl.User import nobody
+from AccessControl.requestmethod import postonly
+from Acquisition import aq_base
+from App.class_init import InitializeClass
+from OFS.SimpleItem import SimpleItem
+from Products.CMFCore.utils import UniqueObject
+from Products.CMFCore.utils import getToolByName
+from Products.CMFCore.utils import registerToolInterface
+from Products.PlonePAS.interfaces import group as igroup
+from Products.PlonePAS.permissions import AddGroups
+from Products.PlonePAS.permissions import DeleteGroups
+from Products.PlonePAS.permissions import ManageGroups
+from Products.PlonePAS.permissions import SetGroupOwnership
+from Products.PlonePAS.permissions import ViewGroups
+from Products.PlonePAS.utils import getGroupsForPrincipal
+from Products.PluggableAuthService.PluggableAuthService import \
+    _SWALLOWABLE_PLUGIN_EXCEPTIONS
+from Products.PluggableAuthService.interfaces.plugins import \
+    IRoleAssignerPlugin
+from ZODB.POSException import ConflictError
+from zope.interface import implementer
+import logging
+
+logger = logging.getLogger('PluggableAuthService')
+
+
+class NotSupported(Exception):
+    pass
+
+
+@implementer(igroup.IGroupTool)
+class GroupsTool(UniqueObject, SimpleItem):
+    """ This tool accesses group data through a acl_users object.
+
+    It can be replaced with something that groups member data in a
+    different way.
+    """
+
+    id = 'portal_groups'
+    meta_type = 'PlonePAS Groups Tool'
+    security = ClassSecurityInfo()
+    toolicon = 'tool.gif'
+
+    ##
+    # basic group mgmt
+    ##
+
+    @security.protected(AddGroups)
+    @postonly
+    def addGroup(self, id, roles=[], groups=[], properties=None,
+                 REQUEST=None, *args, **kw):
+        """Create a group, with the supplied id, roles, and domains.
+
+        Underlying user folder must support adding users via the usual
+        Zope API.
+        """
+        group = None
+        success = 0
+        managers = self._getGroupManagers()
+        if roles is None:
+            roles = []
+        if groups is None:
+            groups = []
+
+        # Check to see if a user with the id already exists fail if it does
+        results = self.acl_users.searchPrincipals(id=id, exact_match=True)
+        if results:
+            return 0
+
+        if not managers:
+            raise NotSupported('No plugins allow for group management')
+        for mid, manager in managers:
+            success = manager.addGroup(id, title=kw.get('title', id),
+                                       description=kw.get('description', ''))
+            if success:
+                self.setRolesForGroup(id, roles)
+                for g in groups:
+                    manager.addPrincipalToGroup(g, id)
+                break
+
+        if success:
+            group = self.getGroupById(id)
+            group.setGroupProperties(properties or kw)
+
+        return success
+
+    @security.protected(ManageGroups)
+    @postonly
+    def editGroup(self, id, roles=None, groups=None, REQUEST=None,
+                  *args, **kw):
+        """Edit the given group with the supplied roles.
+
+        Passwords for groups seem to be irrelevant.
+        PlonePAS doesn't deal with domains either.
+
+        If group is not present, returns without exception.
+        """
+        g = self.getGroupById(id)
+        if not g:
+            raise KeyError('Trying to edit a non-existing group: %s' % id)
+
+        # Update title/description properties of original group
+        gTools = self._getGroupTools()
+        if not gTools:
+            raise NotSupported('No plugins allow for both group management '
+                               'and introspection')
+
+        for tid, tool in gTools:
+            if id in tool.getGroupIds():
+                tool.updateGroup(
+                    id,
+                    title=kw.get('title'),
+                    description=kw.get('description')
+                )
+                break
+
+        if roles is not None:
+            self.setRolesForGroup(id, roles)
+
+        g.setGroupProperties(kw)
+        if groups:
+            # remove absent groups
+            groupset = set(groups)
+            p_groups = set(self.getGroupsForPrincipal(g))
+            rmgroups = p_groups - groupset
+            for gid in rmgroups:
+                if gid != 'AuthenticatedUsers':
+                    self.removePrincipalFromGroup(g, gid)
+
+            # add groups
+            try:
+                groupmanagers = self.acl_users.plugins.listPlugins(
+                    igroup.IGroupManagement
+                )
+            except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+                logger.exception('Plugin listing error')
+                groupmanagers = ()
+
+            for group in groups:
+                for gm_id, gm in groupmanagers:
+                    try:
+                        if gm.addPrincipalToGroup(id, group):
+                            break
+                    except _SWALLOWABLE_PLUGIN_EXCEPTIONS:
+                        logger.exception(
+                            'AuthenticationPlugin {0} error'.format(gm_id)
+                        )
+
+    @security.protected(DeleteGroups)
+    @postonly
+    def removeGroup(self, group_id, REQUEST=None):
+        """Remove a single group.
+        """
+        retval = False
+        managers = self._getGroupManagers()
+        if not managers:
+            raise NotSupported('No plugins allow for group management')
+
+        for mid, manager in managers:
+            if manager.removeGroup(group_id):
+                retval = True
+
+        return retval
+
+    @security.protected(DeleteGroups)
+    @postonly
+    def removeGroups(self, ids, REQUEST=None):
+        """Remove the group in the provided list (if possible).
+        """
+        for gid in ids:
+            self.removeGroup(gid)
+
+    @security.protected(ManageGroups)
+    @postonly
+    def setRolesForGroup(self, group_id, roles=(), REQUEST=None):
+        rmanagers = self._getPlugins().listPlugins(IRoleAssignerPlugin)
+        if not (rmanagers):
+            raise NotImplementedError(
+                'There is no plugin that can assign roles to groups'
+            )
+        for rid, rmanager in rmanagers:
+            rmanager.assignRolesToPrincipal(roles, group_id)
+
+    ##
+    # basic principal mgmt
+    ##
+
+    @security.protected(ManageGroups)
+    @postonly
+    def addPrincipalToGroup(self, principal_id, group_id, REQUEST=None):
+        managers = self._getGroupManagers()
+        if not managers:
+            raise NotSupported('No plugins allow for group management')
+        for mid, manager in managers:
+            if manager.addPrincipalToGroup(principal_id, group_id):
+                return True
+        return False
+
+    @security.protected(ManageGroups)
+    @postonly
+    def removePrincipalFromGroup(self, principal_id, group_id, REQUEST=None):
+        managers = self._getGroupManagers()
+        if not managers:
+            raise NotSupported('No plugins allow for group management')
+        for mid, manager in managers:
+            if manager.removePrincipalFromGroup(principal_id, group_id):
+                return True
+        return False
+
+    ##
+    # group getters
+    ##
+
+    @security.protected(ViewGroups)
+    def getGroupById(self, group_id):
+        group = self.acl_users.getGroup(group_id)
+        if group is not None:
+            group = self.wrapGroup(group)
+        return group
+
+    @security.protected(ManageGroups)
+    def searchGroups(self, *args, **kw):
+        return self.acl_users.searchGroups(*args, **kw)
+
+    def searchForGroups(self, REQUEST={}, **kw):
+        """Search for groups by keyword.
+        The following properties can be searched:
+        - name
+        #- email
+        #- title
+
+        Only id/title search is implemented for groups. Is the rest of
+        this junk used anywhere?
+
+        This is an 'AND' request.
+
+        When it takes 'name' as keyword (or in REQUEST) and searches on
+        Full name and id.
+
+        Simple name searches are "fast".
+        """
+        acl_users = self.acl_users
+        if REQUEST:
+            dict = REQUEST
+        else:
+            dict = kw
+
+        name = dict.get('name', None)
+        title_or_name = dict.get('title_or_name', None)
+        if name:
+            name = name.strip().lower()
+        if name is not None:
+            name = None
+        if title_or_name is not None:
+            name = title_or_name
+
+        md_groups = []
+        uf_groups = []
+
+        if name is not None:
+            # This will allow us to retrieve groups by their id only
+            uf_groups = acl_users.searchGroups(id=name)
+
+            # PAS allows search to return dupes. We must winnow...
+            uf_groups_new = []
+            for group in uf_groups:
+                if group not in uf_groups_new:
+                    uf_groups_new.append(group)
+            uf_groups = uf_groups_new
+
+        groups = []
+        if md_groups or uf_groups:
+            getGroupById = self.getGroupById
+
+            for groupid in md_groups:
+                groups.append(getGroupById(groupid))
+            for group in uf_groups:
+                groupid = group['groupid']
+                if groupid in md_groups:
+                    continue             # Kill dupes
+                groups.append(getGroupById(groupid))
+
+        return groups
+
+    @security.protected(ViewGroups)
+    def listGroups(self):
+        # potentially not all groups may be found by this interface
+        # if the underlying group source doesn't support introspection
+        groups = []
+        introspectors = self._getGroupIntrospectors()
+        for iid, introspector in introspectors:
+            groups.extend(introspector.getGroups())
+        return [self.wrapGroup(elt) for elt in groups]
+
+    @security.protected(ViewGroups)
+    def getGroupIds(self):
+        groups = []
+        introspectors = self._getGroupIntrospectors()
+        for iid, introspector in introspectors:
+            groups.extend(introspector.getGroupIds())
+        return groups
+
+    listGroupIds = getGroupIds
+
+    @security.protected(ViewGroups)
+    def getGroupMembers(self, group_id):
+        members = set()
+        introspectors = self._getGroupIntrospectors()
+        for iid, introspector in introspectors:
+            members.update(introspector.getGroupMembers(group_id))
+        return list(members)
+
+    @security.protected(ViewGroups)
+    def getGroupsForPrincipal(self, principal):
+        return getGroupsForPrincipal(principal, self._getPlugins())
+
+    ##
+    # plugin getters
+    ##
+
+    @security.private
+    def _getPlugins(self):
+        return self.acl_users.plugins
+
+    @security.private
+    def _getGroupManagers(self):
+        return self._getPlugins().listPlugins(
+            igroup.IGroupManagement
+        )
+
+    @security.private
+    def _getGroupIntrospectors(self):
+        return self._getPlugins().listPlugins(
+            igroup.IGroupIntrospection
+        )
+
+    @security.private
+    def _getGroupTools(self):
+        managers = self._getPlugins().listPlugins(
+            igroup.IGroupManagement
+        )
+        return [(id, manager) for (id, manager) in managers
+                if igroup.IGroupIntrospection.providedBy(manager)]
+
+    ##
+    # BBB
+    ##
+
+    @security.public
+    def getGroupInfo(self, groupId):
+        """
+        Return default group info of any group
+        """
+        group = self.getGroupById(groupId)
+
+        if group is None:
+            return None
+
+        groupinfo = {'title': group.getProperty('title'),
+                     'description': group.getProperty('description')}
+
+        return groupinfo
+
+    @security.protected(ViewGroups)
+    def getGroupsByUserId(self, userid):
+        """Return a list of the groups the user corresponding to 'userid'
+        belongs to."""
+        user = self.acl_users.getUserById(userid)
+        if user:
+            groups = user.getGroups() or []
+        else:
+            groups = []
+        return [self.getGroupById(elt) for elt in groups]
+
+    @security.protected(ViewGroups)
+    def listGroupNames(self):
+        """Return a list of the available groups' ids as entered
+        (without group prefixes)."""
+        return self.acl_users.getGroupNames()
+
+    @security.public
+    def isGroup(self, u):
+        """Test if a user/group object is a group or not.
+        You must pass an object you get earlier with wrapUser() or wrapGroup()
+        """
+        base = aq_base(u)
+        if hasattr(base, "isGroup") and base.isGroup():
+            return 1
+        return 0
+
+    @security.protected(SetGroupOwnership)
+    @postonly
+    def setGroupOwnership(self, group, object, REQUEST=None):
+        """Make the object  'object' owned by group 'group'
+        (a portal_groupdata-ish object).
+
+        For GRUF this is easy. Others may have to re-implement."""
+        user = group.getGroup()
+        if user is None:
+            raise ValueError("Invalid group: '%s'." % (group, ))
+        object.changeOwnership(user)
+        object.manage_setLocalRoles(user.getId(), ['Owner'])
+
+    @security.private
+    def wrapGroup(self, g, wrap_anon=0):
+        ''' Sets up the correct acquisition wrappers for a group
+        object and provides an opportunity for a portal_memberdata
+        tool to retrieve and store member data independently of
+        the user object.
+        '''
+        b = getattr(g, 'aq_base', None)
+        if b is None:
+            # u isn't wrapped at all.  Wrap it in self.acl_users.
+            b = g
+            g = g.__of__(self.acl_users)
+        if (b is nobody and not wrap_anon) or hasattr(b, 'getMemberId'):
+            # This user is either not recognized by acl_users or it is
+            # already registered with something that implements the
+            # member data tool at least partially.
+            return g
+
+        parent = self.aq_inner.aq_parent
+        base = getattr(parent, 'aq_base', None)
+        if hasattr(base, 'portal_groupdata'):
+            # Get portal_groupdata to do the wrapping.
+            gd = getToolByName(parent, 'portal_groupdata')
+            try:
+                portal_group = gd.wrapGroup(g)
+                return portal_group
+            except ConflictError:
+                raise
+            except:
+                logger.exception('Error during wrapGroup')
+        # Failed.
+        return g
+
+
+InitializeClass(GroupsTool)
+registerToolInterface('portal_groups', igroup.IGroupTool)
diff --git a/src/Products/PlonePAS/tools/memberdata.py b/src/Products/PlonePAS/tools/memberdata.py
new file mode 100644
index 0000000..6d62f45
--- /dev/null
+++ b/src/Products/PlonePAS/tools/memberdata.py
@@ -0,0 +1,448 @@
+# -*- coding: utf-8 -*-
+from AccessControl import ClassSecurityInfo
+from AccessControl.requestmethod import postonly
+from Acquisition import aq_base
+from App.class_init import InitializeClass
+from Products.BTreeFolder2.BTreeFolder2 import BTreeFolder2
+from Products.CMFCore.MemberDataTool import MemberData as BaseMemberData
+from Products.CMFCore.MemberDataTool import MemberDataTool as BaseTool
+from Products.CMFCore.permissions import ManagePortal
+from Products.CMFCore.utils import getToolByName
+from Products.PlonePAS.interfaces.capabilities import IAssignRoleCapability
+from Products.PlonePAS.interfaces.capabilities import IDeleteCapability
+from Products.PlonePAS.interfaces.capabilities import IGroupCapability
+from Products.PlonePAS.interfaces.capabilities import IManageCapabilities
+from Products.PlonePAS.interfaces.capabilities import IPasswordSetCapability
+from Products.PlonePAS.interfaces.group import IGroupManagement
+from Products.PlonePAS.interfaces.plugins import IUserManagement
+from Products.PlonePAS.interfaces.propertysheets import IMutablePropertySheet
+from Products.PluggableAuthService.interfaces.authservice import \
+    IPluggableAuthService
+from Products.PluggableAuthService.interfaces.plugins import IPropertiesPlugin
+from Products.PluggableAuthService.interfaces.plugins import \
+    IRoleAssignerPlugin
+from zope.interface import implementer
+
+_marker = object()
+
+
+class MemberDataTool(BaseTool):
+    """PAS-specific implementation of memberdata tool.
+    """
+
+    meta_type = "PlonePAS MemberData Tool"
+    security = ClassSecurityInfo()
+    toolicon = 'tool.gif'
+
+    def __init__(self):
+        BaseTool.__init__(self)
+        self.portraits = BTreeFolder2(id='portraits')
+
+    def _getPortrait(self, member_id):
+        "return member_id's portrait if you can "
+        return self.portraits.get(member_id, None)
+
+    def _setPortrait(self, portrait, member_id):
+        " store portrait which must be a raw image in _portrais "
+        if member_id in self.portraits:
+            self.portraits._delObject(member_id)
+        self.portraits._setObject(id=member_id, object=portrait)
+
+    def _deletePortrait(self, member_id):
+        " remove member_id's portrait "
+        if member_id in self.portraits:
+            self.portraits._delObject(member_id)
+
+    @security.private
+    def pruneMemberDataContents(self):
+        '''
+        Compare the user IDs stored in the member data
+        tool with the list in the actual underlying acl_users
+        and delete anything not in acl_users
+        '''
+        BaseTool.pruneMemberDataContents(self)
+        membertool = getToolByName(self, 'portal_membership')
+        portraits = self.portraits
+        user_list = membertool.listMemberIds()
+
+        for tuple in portraits.items():
+            member_id = tuple[0]
+            if member_id not in user_list:
+                self.portraits._delObject(member_id)
+
+    @security.protected(ManagePortal)
+    def purgeMemberDataContents(self):
+        '''
+        Delete ALL MemberData information. This is required for us as we change
+        the MemberData class.
+        '''
+        members = self._members
+
+        for tuple in members.items():
+            member_name = tuple[0]
+            del members[member_name]
+
+        return "Done."
+
+    @security.private
+    def updateMemberDataContents(self,):
+        """Update former MemberData objects to new MemberData objects
+        """
+        count = 0
+        members = self._members
+        properties = self.propertyIds()
+
+        # Scan members for old MemberData
+        for member_name, member_obj in members.items():
+            values = {}
+            if getattr(member_obj, "_is_new_kind", None):
+                continue        # Do not have to upgrade that object
+
+            # Have to upgrade. Create the values mapping.
+            for pty_name in properties:
+                user_value = getattr(member_obj, pty_name, _marker)
+                if user_value is not _marker:
+                    values[pty_name] = user_value
+
+            # Wrap a new user object of the RIGHT class
+            u = self.acl_users.getUserById(member_name, None)
+            if not u:
+                continue                # User is not in main acl_users anymore
+            self.wrapUser(u)
+
+            # Set its properties
+            mbr = self._members.get(member_name, None)
+            if not mbr:
+                raise RuntimeError(
+                    "Error while upgrading user '{0}'.".format(member_name)
+                )
+            mbr.setProperties(values, force_local=1)
+            count += 1
+
+        return count
+
+    @security.private
+    def searchMemberDataContents(self, search_param, search_term):
+        """
+        Search members.
+        This is the same as CMFCore except that it doesn't check term case.
+        """
+        res = []
+
+        search_term = search_term.strip().lower()
+
+        if search_param == 'username':
+            search_param = 'id'
+
+        mtool = getToolByName(self, 'portal_membership')
+
+        for member_id in self._members.keys():
+            user_wrapper = mtool.getMemberById(member_id)
+
+            if user_wrapper is not None:
+                memberProperty = user_wrapper.getProperty
+                searched = memberProperty(search_param, None)
+
+                if searched is not None:
+                    if searched.strip().lower().find(search_term) != -1:
+
+                        res.append({'username': memberProperty('id'),
+                                    'email': memberProperty('email', '')})
+        return res
+
+    @security.public
+    def searchFulltextForMembers(self, s):
+        """search for members which do have string 's' in name, email or full
+        name (if defined)
+
+        this is mainly used for the localrole form
+        """
+        s = s.strip().lower()
+        mu = getToolByName(self, 'portal_membership')
+
+        res = []
+        for member in mu.listMembers():
+            u = member.getUser()
+            if u.getUserName().lower().find(s) != -1 \
+               or member.getProperty('fullname').lower().find(s) != -1 \
+               or member.getProperty('email').lower().find(s) != -1:
+                res.append(member)
+        return res
+
+    # check to see if we can add users. Need to be careful here
+    # so we do not write on read
+    def canAddMemberData(self):
+        try:
+            if self.REQUEST.REQUEST_METHOD != 'POST':
+                return False
+            if getattr(self, '_p_jar', None) and \
+                    len(self._p_jar._registered_objects) > 0:
+                # XXX do not write on read
+                return True
+        except AttributeError:
+            pass
+        return False
+
+    # an exact copy from the base, so that we pick up the new MemberData.
+    # wrapUser should have a MemberData factory method to over-ride (or even
+    # set at run-time!) so that we don't have to do this.
+    def wrapUser(self, u):
+        '''
+        If possible, returns the Member object that corresponds
+        to the given User object.
+        We override this to ensure OUR MemberData class is used
+        '''
+        user_id = u.getId()
+        members = self._members
+        if user_id not in members:
+            base = aq_base(self)
+            md = MemberData(base, user_id)
+            if self.canAddMemberData():
+                # XXX do not write on read
+                members[user_id] = md
+            return md.__of__(self).__of__(u)
+        else:
+            # Return a wrapper with self as containment and
+            # the user as context.
+            return members[user_id].__of__(self).__of__(u)
+
+    @postonly
+    def deleteMemberData(self, member_id, REQUEST=None):
+        """ Delete member data of specified member.
+        """
+        if IPluggableAuthService.providedBy(self.acl_users):
+            # It's a PAS! Whee!
+            # XXX: can we safely assume that user name == member_id
+            plugins = self._getPlugins()
+            prop_managers = plugins.listPlugins(IPropertiesPlugin)
+            for mid, prop_manager in prop_managers:
+                # Not all PropertiesPlugins support user deletion
+                try:
+                    prop_manager.deleteUser(member_id)
+                except AttributeError:
+                    pass
+
+        # we won't always have PlonePAS users, due to acquisition,
+        # nor are guaranteed property sheets
+        members = self._members
+        if member_id in members:
+            del members[member_id]
+            return 1
+        else:
+            return 0
+
+    # plugin getter
+    def _getPlugins(self):
+        return self.acl_users.plugins
+
+InitializeClass(MemberDataTool)
+
+
+@implementer(IManageCapabilities)
+class MemberData(BaseMemberData):
+
+    security = ClassSecurityInfo()
+
+    # setProperties uses setMemberProperties. no need to override.
+
+    def setMemberProperties(self, mapping, force_local=0):
+        """PAS-specific method to set the properties of a
+        member. Ignores 'force_local', which is not reliably present.
+        """
+        sheets = None
+
+        # We could pay attention to force_local here...
+        if not IPluggableAuthService.providedBy(self.acl_users):
+            # Defer to base impl in absence of PAS, a PAS user, or
+            # property sheets
+            return BaseMemberData.setMemberProperties(self, mapping)
+        else:
+            # It's a PAS! Whee!
+            user = self.getUser()
+            sheets = getattr(user, 'getOrderedPropertySheets', lambda: None)()
+
+            # We won't always have PlonePAS users, due to acquisition,
+            # nor are guaranteed property sheets
+            if not sheets:
+                # Defer to base impl if we have a PAS but no property
+                # sheets.
+                return BaseMemberData.setMemberProperties(self, mapping)
+
+        # If we got this far, we have a PAS and some property sheets.
+        # XXX track values set to defer to default impl
+        # property routing?
+        modified = False
+        for k, v in mapping.items():
+            if v is None:
+                continue
+            for sheet in sheets:
+                if not sheet.hasProperty(k):
+                    continue
+                if IMutablePropertySheet.providedBy(sheet):
+                    sheet.setProperty(user, k, v)
+                    modified = True
+                else:
+                    break
+        if modified:
+            self.notifyModified()
+
+    def getProperty(self, id, default=_marker):
+        """PAS-specific method to fetch a user's properties. Looks
+        through the ordered property sheets.
+        """
+        sheets = None
+        if not IPluggableAuthService.providedBy(self.acl_users):
+            return BaseMemberData.getProperty(self, id)
+        else:
+            # It's a PAS! Whee!
+            user = self.getUser()
+            sheets = getattr(user, 'getOrderedPropertySheets', lambda: None)()
+
+            # we won't always have PlonePAS users, due to acquisition,
+            # nor are guaranteed property sheets
+            if not sheets:
+                return BaseMemberData.getProperty(self, id, default)
+
+        # If we made this far, we found a PAS and some property sheets.
+        for sheet in sheets:
+            if sheet.hasProperty(id):
+                # Return the first one that has the property.
+                value = sheet.getProperty(id)
+                if isinstance(value, unicode):
+                    # XXX Temporarily work around the fact that
+                    # property sheets blindly store and return
+                    # unicode. This is sub-optimal and should be
+                    # dealed with at the property sheets level by
+                    # using Zope's converters.
+                    return value.encode('utf-8')
+                return value
+
+        # Couldn't find the property in the property sheets. Try to
+        # delegate back to the base implementation.
+        return BaseMemberData.getProperty(self, id, default)
+
+    def getPassword(self):
+        """Returns None. Present to avoid NotImplementedError."""
+        return None
+
+    # IManageCapabilities methods
+
+    def canDelete(self):
+        """True iff user can be removed from the Plone UI."""
+        # IUserManagement provides doDeleteUser
+        plugins = self._getPlugins()
+        managers = plugins.listPlugins(IUserManagement)
+        for mid, manager in managers:
+            if (IDeleteCapability.providedBy(manager) and
+                    manager.allowDeletePrincipal(self.getId())):
+                return True
+        return False
+
+    def canPasswordSet(self):
+        """True iff user can change password."""
+        # IUserManagement provides doChangeUser
+        plugins = self._getPlugins()
+        managers = plugins.listPlugins(IUserManagement)
+        for mid, manager in managers:
+            if (IPasswordSetCapability.providedBy(manager) and
+                    manager.allowPasswordSet(self.getId())):
+                return True
+        return False
+
+    def passwordInClear(self):
+        """True iff password can be retrieved in the clear (not hashed.)
+
+        False for PAS. It provides no API for getting passwords,
+        though it would be possible to add one in the future.
+        """
+        return 0
+
+    def _memberdataHasProperty(self, prop_name):
+        mdata = getToolByName(self, 'portal_memberdata', None)
+        if mdata:
+            return mdata.hasProperty(prop_name)
+        return 0
+
+    def canWriteProperty(self, prop_name):
+        """True iff the member/group property named in 'prop_name'
+        can be changed.
+        """
+        if not IPluggableAuthService.providedBy(self.acl_users):
+            # not PAS; Memberdata is writable
+            return self._memberdataHasProperty(prop_name)
+        else:
+            # it's PAS
+            user = self.getUser()
+            sheets = getattr(user, 'getOrderedPropertySheets', lambda: None)()
+            if not sheets:
+                return self._memberdataHasProperty(prop_name)
+
+            for sheet in sheets:
+                if not sheet.hasProperty(prop_name):
+                    continue
+                if IMutablePropertySheet.providedBy(sheet):
+                    # BBB for plugins implementing an older version of
+                    # IMutablePropertySheet
+                    if hasattr(sheet, 'canWriteProperty'):
+                        return sheet.canWriteProperty(user, prop_name)
+                    return True
+                else:
+                    break  # shadowed by read-only
+        return False
+
+    def canAddToGroup(self, group_id):
+        """True iff member can be added to group."""
+        # IGroupManagement provides IGroupCapability
+        plugins = self._getPlugins()
+        managers = plugins.listPlugins(IGroupManagement)
+        for mid, manager in managers:
+            if (IGroupCapability.providedBy(manager) and
+                    manager.allowGroupAdd(self.getId(), group_id)):
+                return True
+        return False
+
+    def canRemoveFromGroup(self, group_id):
+        """True iff member can be removed from group."""
+        # IGroupManagement provides IGroupCapability
+        plugins = self._getPlugins()
+        managers = plugins.listPlugins(IGroupManagement)
+        for mid, manager in managers:
+            if (IGroupCapability.providedBy(manager) and
+                    manager.allowGroupRemove(self.getId(), group_id)):
+                return True
+        return False
+
+    def canAssignRole(self, role_id):
+        """True iff member can be assigned role. Role id is string."""
+        # IRoleAssignerPlugin provides IAssignRoleCapability
+        plugins = self._getPlugins()
+        managers = plugins.listPlugins(IRoleAssignerPlugin)
+        for mid, manager in managers:
+            if (IAssignRoleCapability.providedBy(manager) and
+                    manager.allowRoleAssign(self.getId(), role_id)):
+                return True
+        return False
+
+    @security.private
+    def setSecurityProfile(self, password=None, roles=None, domains=None):
+        """Set the user's basic security profile"""
+        u = self.getUser()
+
+        # The Zope User API is stupid, it should check for None.
+        if roles is None:
+            roles = list(u.getRoles())
+            if 'Authenticated' in roles:
+                roles.remove('Authenticated')
+        if domains is None:
+            domains = u.getDomains()
+
+        u.userFolderEditUser(u.getUserId(), password, roles, domains)
+
+    # plugin getters
+
+    @security.private
+    def _getPlugins(self):
+        return self.acl_users.plugins
+
+
+InitializeClass(MemberData)
diff --git a/src/Products/PlonePAS/tools/membership.py b/src/Products/PlonePAS/tools/membership.py
new file mode 100644
index 0000000..d8d8acb
--- /dev/null
+++ b/src/Products/PlonePAS/tools/membership.py
@@ -0,0 +1,762 @@
+# -*- coding: utf-8 -*-
+from AccessControl import ClassSecurityInfo
+from AccessControl import Unauthorized
+from AccessControl import getSecurityManager
+from AccessControl.SecurityManagement import noSecurityManager
+from AccessControl.requestmethod import postonly
+from Acquisition import aq_get
+from Acquisition import aq_inner
+from Acquisition import aq_parent
+from App.class_init import InitializeClass
+from App.special_dtml import DTMLFile
+from DateTime import DateTime
+from OFS.Image import Image
+from Products.CMFCore.MembershipTool import MembershipTool as BaseTool
+from Products.CMFCore.interfaces import IPropertiesTool
+from Products.CMFCore.permissions import ListPortalMembers
+from Products.CMFCore.permissions import ManagePortal
+from Products.CMFCore.permissions import ManageUsers
+from Products.CMFCore.permissions import SetOwnPassword
+from Products.CMFCore.permissions import SetOwnProperties
+from Products.CMFCore.permissions import View
+from Products.CMFCore.utils import _checkPermission
+from Products.CMFCore.utils import getToolByName
+from Products.PlonePAS.config import HAS_PIL
+from Products.PlonePAS.events import UserInitialLoginInEvent
+from Products.PlonePAS.events import UserLoggedInEvent
+from Products.PlonePAS.events import UserLoggedOutEvent
+from Products.PlonePAS.interfaces import membership
+from Products.PlonePAS.utils import cleanId
+from Products.PlonePAS.utils import scale_image
+from ZODB.POSException import ConflictError
+from cStringIO import StringIO
+from zExceptions import BadRequest
+from zope import event
+from zope.component import getUtility
+from zope.interface import implementer
+import logging
+import transaction
+
+default_portrait = 'defaultUser.png'
+logger = logging.getLogger('PlonePAS')
+
+_marker = dict()
+
+
+def _unicodify_structure(value, charset=_marker):
+    """ Convert value to unicode.
+    """
+    if charset is _marker:
+        ptool = getUtility(IPropertiesTool)
+        charset = ptool.getProperty('default_charset', None)
+
+    if isinstance(value, str):
+        return charset and unicode(value, charset) or unicode(value)
+    if isinstance(value, list):
+        return [_unicodify_structure(val, charset) for val in value]
+    if isinstance(value, tuple):
+        return tuple([_unicodify_structure(entry, charset) for entry in value])
+    if isinstance(value, dict):
+        for key, val in value.items():
+            value[key] = _unicodify_structure(val, charset)
+        return value
+    return value
+
+
+@implementer(membership.IMembershipTool)
+class MembershipTool(BaseTool):
+    """PAS-based customization of MembershipTool.
+    """
+
+    meta_type = "PlonePAS Membership Tool"
+    toolicon = 'tool.gif'
+    personal_id = '.personal'
+    portrait_id = 'MyPortrait'
+    default_portrait = 'defaultUser.gif'
+    memberarea_type = 'Folder'
+    membersfolder_id = 'Members'
+    memberareaCreationFlag = False
+    security = ClassSecurityInfo()
+
+    user_search_keywords = ('login', 'fullname', 'email', 'exact_match',
+                            'sort_by', 'max_results')
+
+    _properties = (getattr(BaseTool, '_properties', ()) +
+                   ({'id': 'user_search_keywords',
+                     'type': 'lines',
+                     'mode': 'rw',
+                     },))
+
+    manage_options = (BaseTool.manage_options +
+                      ({'label': 'Portraits',
+                        'action': 'manage_portrait_fix'},))
+
+    # TODO I'm not quite sure why getPortalRoles is declared 'Managed'
+    #    in CMFCore.MembershipTool - but in Plone we are not so anal ;-)
+    security.declareProtected(View, 'getPortalRoles')
+
+    security.declareProtected(ManagePortal, 'manage_mapRoles')
+    manage_mapRoles = DTMLFile('../zmi/membershipRolemapping', globals())
+
+    security.declareProtected(ManagePortal, 'manage_portrait_fix')
+    manage_portrait_fix = DTMLFile('../zmi/portrait_fix', globals())
+
+    @security.protected(ManagePortal)
+    def manage_setMemberAreaType(self, type_name, REQUEST=None):
+        """ ZMI method to set the home folder type by its type name.
+        """
+        self.setMemberAreaType(type_name)
+        if REQUEST is not None:
+            REQUEST['RESPONSE'].redirect(
+                self.absolute_url() +
+                '/manage_mapRoles'
+                '?manage_tabs_message=Member+area+type+changed.'
+            )
+
+    @security.protected(ManagePortal)
+    def manage_setMembersFolderById(self, id, REQUEST=None):
+        """ ZMI method to set the members folder object by its id.
+        """
+        self.setMembersFolderById(id)
+        if REQUEST is not None:
+            REQUEST['RESPONSE'].redirect(
+                self.absolute_url() +
+                '/manage_mapRoles'
+                '?manage_tabs_message=Members+folder+id+changed.'
+            )
+
+    @security.protected(ManagePortal)
+    def setMemberAreaType(self, type_name):
+        """ Sets the portal type to use for new home folders.
+        """
+        # No check for folderish since someone somewhere may actually want
+        # members to have objects instead of folders as home "directory".
+        self.memberarea_type = str(type_name).strip()
+
+    @security.protected(ManagePortal)
+    def setMembersFolderById(self, id=''):
+        """ Set the members folder object by its id.
+        """
+        self.membersfolder_id = id.strip()
+
+    @security.public
+    def getMembersFolder(self):
+        """ Get the members folder object.
+        """
+        parent = aq_parent(aq_inner(self))
+        members = getattr(parent, self.membersfolder_id, None)
+        return members
+
+    @security.private
+    def addMember(self, id, password, roles, domains, properties=None):
+        """Adds a new member to the user folder.
+
+        Security checks will have already been performed.  Called by
+        portal_registration.  This one specific to PAS. PAS ignores
+        domains. Adding members with login_name also not yet
+        supported.
+        """
+        acl_users = self.acl_users
+        acl_users._doAddUser(id, password, roles, domains)
+
+        if properties is not None:
+            member = self.getMemberById(id)
+            member.setMemberProperties(properties)
+
+    @security.protected(ListPortalMembers)
+    def searchForMembers(self, REQUEST=None, **kw):
+        """Hacked up version of Plone searchForMembers.
+
+        The following properties can be provided:
+        - name
+        - email
+        - last_login_time
+        - before_specified_time
+        - roles (any role will cause a match)
+        - groupname
+
+        This is an 'AND' request.
+
+        Simple name searches are "fast".
+        """
+        logger.debug('searchForMembers: started.')
+
+        acl_users = getToolByName(self, "acl_users")
+
+        if REQUEST is not None:
+            searchmap = REQUEST
+            for key, value in searchmap.items():
+                if isinstance(value, str):
+                    searchmap[key] = _unicodify_structure(value)
+        else:
+            searchmap = kw
+
+        # While the parameter is called name it is actually used to search a
+        # users name, which is stored in the fullname property. We need to fix
+        # that here so the right name is used when calling into PAS plugins.
+        if 'name' in searchmap:
+            searchmap['fullname'] = searchmap['name']
+            del searchmap['name']
+
+        user_search = dict(
+            [x for x in searchmap.items()
+             if x[0] in self.user_search_keywords and x[1]]
+        )
+
+        fullname = searchmap.get('fullname', None)
+        email = searchmap.get('email', None)
+        roles = searchmap.get('roles', None)
+        last_login_time = searchmap.get('last_login_time', None)
+        before_specified_time = searchmap.get('before_specified_time', None)
+        groupname = searchmap.get('groupname', '').strip()
+
+        if fullname:
+            fullname = fullname.strip().lower()
+        if not fullname:
+            fullname = None
+        if email:
+            email = email.strip().lower()
+        if not email:
+            email = None
+
+        uf_users = []
+
+        logger.debug(
+            'searchForMembers: searching PAS '
+            'with arguments %r.' % user_search)
+        for user in acl_users.searchUsers(**user_search):
+            uf_users.append(user['userid'])
+
+        if not uf_users:
+            return []
+
+        getUserById = acl_users.getUserById
+
+        def dedupe(seq):
+            # Thanks http://www.peterbe.com/plog/uniqifiers-benchmark
+            seen = set()
+            seen_add = seen.add
+            # nice trick! set.add() does always return None
+            return [x for x in seq if x not in seen and not seen_add(x)]
+
+        uf_users = dedupe(uf_users)
+        members = [getUserById(userid) for userid in uf_users]
+        members = [member for member in members if member is not None]
+
+        if not (email or fullname or roles or groupname or last_login_time):
+            logger.debug(
+                'searchForMembers: searching users '
+                'with no extra filter, immediate return.')
+            return members
+
+        # Now perform individual checks on each user
+        res = []
+
+        for member in members:
+            if groupname and groupname not in member.getGroupIds():
+                continue
+
+            if roles:
+                user_roles = member.getRoles()
+                found = 0
+                for r in roles:
+                    if r in user_roles:
+                        found = 1
+                        break
+                if not found:
+                    continue
+
+            if last_login_time:
+                last_login = member.getProperty('last_login_time', '')
+
+                if isinstance(last_login, basestring):
+                    # value is a string when member hasn't yet logged in
+                    last_login = DateTime(last_login or '2000/01/01')
+
+                if before_specified_time:
+                    if last_login >= last_login_time:
+                        continue
+                elif last_login < last_login_time:
+                    continue
+
+            res.append(member)
+
+        logger.debug('searchForMembers: finished.')
+        return res
+
+    ############
+    # sanitize home folders (we may get URL-illegal ids)
+
+    @security.public
+    def createMemberarea(self, member_id=None, minimal=None):
+        """
+        Create a member area for 'member_id' or the authenticated
+        user, but don't assume that member_id is url-safe.
+        """
+        if not self.getMemberareaCreationFlag():
+            return None
+        membership = getToolByName(self, 'portal_membership')
+        members = self.getMembersFolder()
+
+        if not member_id:
+            # member_id is optional (see CMFCore.interfaces.portal_membership:
+            #     Create a member area for 'member_id' or authenticated user.)
+            member = membership.getAuthenticatedMember()
+            member_id = member.getId()
+
+        if hasattr(members, 'aq_explicit'):
+            members = members.aq_explicit
+
+        if members is None:
+            # no members area
+            logger.debug('createMemberarea: members area does not exist.')
+            return
+
+        safe_member_id = cleanId(member_id)
+        if hasattr(members, safe_member_id):
+            # has already this member
+            logger.debug(
+                'createMemberarea: member area '
+                'for %r already exists.' % safe_member_id)
+            return
+
+        if not safe_member_id:
+            # Could be one of two things:
+            # - A Emergency User
+            # - cleanId made a empty string out of member_id
+            logger.debug(
+                'createMemberarea: empty member id '
+                '(%r, %r), skipping member area creation.' %
+                (member_id, safe_member_id)
+            )
+            return
+
+        # Create member area without security checks
+        typesTool = getToolByName(members, 'portal_types')
+        fti = typesTool.getTypeInfo(self.memberarea_type)
+        member_folder = fti._constructInstance(members, safe_member_id)
+
+        # Get the user object from acl_users
+        acl_users = getToolByName(self, "acl_users")
+        user = acl_users.getUserById(member_id)
+        if user is not None:
+            user = user.__of__(acl_users)
+        else:
+            user = getSecurityManager().getUser()
+            # check that we do not do something wrong
+            if user.getId() != member_id:
+                raise NotImplementedError(
+                    'cannot get user for member area creation'
+                )
+
+        member_object = self.getMemberById(member_id)
+
+        # Modify member folder
+        member_folder = self.getHomeFolder(member_id)
+        # Grant Ownership and Owner role to Member
+        member_folder.changeOwnership(user)
+        member_folder.__ac_local_roles__ = None
+        member_folder.manage_setLocalRoles(member_id, ['Owner'])
+        # We use ATCT now use the mutators
+        fullname = member_object.getProperty('fullname')
+        member_folder.setTitle(fullname or member_id)
+        member_folder.reindexObject()
+
+        # Hook to allow doing other things after memberarea creation.
+        notify_script = getattr(member_folder, 'notifyMemberAreaCreated', None)
+        if notify_script is not None:
+            notify_script()
+
+    # deal with ridiculous API change in CMF
+    security.declarePublic('createMemberArea')
+    createMemberArea = createMemberarea
+
+    @security.public
+    def getMemberInfo(self, memberId=None):
+        # Return 'harmless' Memberinfo of any member, such as Full name,
+        # Location, etc
+        if not memberId:
+            member = self.getAuthenticatedMember()
+        else:
+            member = self.getMemberById(memberId)
+
+        if member is None:
+            return None
+
+        memberinfo = {
+            'fullname': member.getProperty('fullname'),
+            'description': member.getProperty('description'),
+            'location': member.getProperty('location'),
+            'language': member.getProperty('language'),
+            'home_page': member.getProperty('home_page'),
+            'username': member.getUserName(),
+            'has_email': bool(member.getProperty('email')),
+        }
+
+        return memberinfo
+
+    def _getSafeMemberId(self, id=None):
+        """Return a safe version of a member id.
+
+        If no id is given return the id for the currently authenticated user.
+        """
+
+        if id is None:
+            member = self.getAuthenticatedMember()
+            if not hasattr(member, 'getMemberId'):
+                return None
+            id = member.getMemberId()
+
+        return cleanId(id)
+
+    @security.public
+    def getHomeFolder(self, id=None, verifyPermission=0):
+        """ Return a member's home folder object, or None.
+
+        Specially instrumented for URL-quoted-member-id folder
+        names.
+        """
+        safe_id = self._getSafeMemberId(id)
+        if safe_id is None:
+            member = self.getAuthenticatedMember()
+            if not hasattr(member, 'getMemberId'):
+                return None
+            safe_id = member.getMemberId()
+        members = self.getMembersFolder()
+        if members:
+            try:
+                folder = members._getOb(safe_id)
+                if verifyPermission and not _checkPermission(View, folder):
+                    # Don't return the folder if the user can't get to it.
+                    return None
+                return folder
+            # KeyError added to deal with btree member folders
+            except (AttributeError, KeyError, TypeError):
+                pass
+        return None
+
+    def getHomeUrl(self, id=None, verifyPermission=0):
+        """ Return the URL to a member's home folder, or None.
+        """
+        home = self.getHomeFolder(id, verifyPermission)
+        if home is not None:
+            return home.absolute_url()
+        else:
+            return None
+
+    @security.public
+    def getPersonalFolder(self, member_id=None):
+        """
+        returns the Personal Item folder for a member
+        if no Personal Folder exists will return None
+        """
+        home = self.getHomeFolder(member_id)
+        personal = None
+        if home:
+            personal = getattr(home, self.personal_id, None)
+        return personal
+
+    @security.public
+    def getPersonalPortrait(self, id=None, verifyPermission=0):
+        """Return a members personal portait.
+
+        Modified from CMFPlone version to URL-quote the member id.
+        """
+        if not id:
+            id = self.getAuthenticatedMember().getId()
+        safe_id = self._getSafeMemberId(id)
+        membertool = getToolByName(self, 'portal_memberdata')
+        portrait = membertool._getPortrait(safe_id)
+        if isinstance(portrait, str):
+            portrait = None
+        if portrait is not None:
+            if verifyPermission and not _checkPermission('View', portrait):
+                # Don't return the portrait if the user can't get to it
+                portrait = None
+        if portrait is None:
+            portal = getToolByName(self, 'portal_url').getPortalObject()
+            portrait = getattr(portal, default_portrait, None)
+
+        return portrait
+
+    @security.protected(SetOwnProperties)
+    def deletePersonalPortrait(self, id=None):
+        """deletes the Portait of a member.
+        """
+        authenticated_id = self.getAuthenticatedMember().getId()
+        if not id:
+            id = authenticated_id
+        safe_id = self._getSafeMemberId(id)
+        if id != authenticated_id and not _checkPermission(
+                ManageUsers, self):
+            raise Unauthorized
+
+        membertool = getToolByName(self, 'portal_memberdata')
+        return membertool._deletePortrait(safe_id)
+
+    @security.protected(SetOwnProperties)
+    def changeMemberPortrait(self, portrait, id=None):
+        """update the portait of a member.
+
+        We URL-quote the member id if needed.
+
+        Note that this method might be called by an anonymous user who
+        is getting registered.  This method will then be called from
+        plone.app.users and this is fine.  When called from restricted
+        python code or with a curl command by a hacker, the
+        declareProtected line will kick in and prevent use of this
+        method.
+        """
+        authenticated_id = self.getAuthenticatedMember().getId()
+        if not id:
+            id = authenticated_id
+        safe_id = self._getSafeMemberId(id)
+        if authenticated_id and id != authenticated_id:
+            # Only Managers can change portraits of others.
+            if not _checkPermission(ManageUsers, self):
+                raise Unauthorized
+        if portrait and portrait.filename:
+            scaled, mimetype = scale_image(portrait)
+            portrait = Image(id=safe_id, file=scaled, title='')
+            membertool = getToolByName(self, 'portal_memberdata')
+            membertool._setPortrait(portrait, safe_id)
+
+    @security.protected(ManageUsers)
+    def listMembers(self):
+        '''Gets the list of all members.
+        THIS METHOD MIGHT BE VERY EXPENSIVE ON LARGE USER FOLDERS AND MUST
+        BE USED WITH CARE! We plan to restrict its use in the future (ie.
+        force large requests to use searchForMembers instead of listMembers,
+        so that it will not be possible anymore to have a method returning
+        several hundred of users :)
+        '''
+        return BaseTool.listMembers(self)
+
+    @security.protected(ManageUsers)
+    def listMemberIds(self):
+        '''Lists the ids of all members.  This may eventually be
+        replaced with a set of methods for querying pieces of the
+        list rather than the entire list at once.
+        '''
+        return self.acl_users.getUserIds()
+
+    @security.protected(SetOwnPassword)
+    def testCurrentPassword(self, password):
+        """ test to see if password is current """
+        REQUEST = getattr(self, 'REQUEST', {})
+        member = self.getAuthenticatedMember()
+        acl_users = self._findUsersAclHome(member.getUserId())
+        if not acl_users:
+            return 0
+        return acl_users.authenticate(member.getUserName(), password, REQUEST)
+
+    def _findUsersAclHome(self, userid):
+        portal = getToolByName(self, 'portal_url').getPortalObject()
+        acl_users = portal.acl_users
+        parent = acl_users
+        while parent:
+            if acl_users.aq_explicit.getUserById(userid, None) is not None:
+                break
+            parent = aq_parent(aq_inner(parent)).aq_parent
+            acl_users = getattr(parent, 'acl_users')
+        if parent:
+            return acl_users
+        else:
+            return None
+
+    @security.protected(SetOwnPassword)
+    def setPassword(self, password, domains=None, REQUEST=None):
+        '''Allows the authenticated member to set his/her own password.
+        '''
+        registration = getToolByName(self, 'portal_registration', None)
+        if not self.isAnonymousUser():
+            member = self.getAuthenticatedMember()
+            acl_users = self._findUsersAclHome(member.getUserId())
+            if not acl_users:
+                # should not possibly ever happen
+                raise BadRequest('did not find current user in any '
+                                 'user folder')
+            if registration:
+                failMessage = registration.testPasswordValidity(password)
+                if failMessage is not None:
+                    raise BadRequest(failMessage)
+
+            if domains is None:
+                domains = []
+            user = acl_users.getUserById(member.getUserId(), None)
+            # we must change the users password trough grufs changepassword
+            # to keep her  group settings
+            if hasattr(user, 'changePassword'):
+                user.changePassword(password)
+            else:
+                acl_users._doChangeUser(member.getUserId(), password,
+                                        member.getRoles(), domains)
+            if REQUEST is None:
+                REQUEST = aq_get(self, 'REQUEST', None)
+            self.credentialsChanged(password, REQUEST=REQUEST)
+        else:
+            raise BadRequest('Not logged in.')
+    setPassword = postonly(setPassword)
+
+    @security.protected(View)
+    def getCandidateLocalRoles(self, obj):
+        """ What local roles can I assign?
+            Override the CMFCore version so that we can see the local roles on
+            an object, and so that local managers can assign all roles locally.
+        """
+        member = self.getAuthenticatedMember()
+        # Use getRolesInContext as someone may be a local manager
+        if 'Manager' in member.getRolesInContext(obj):
+            # Use valid_roles as we may want roles defined only on a subobject
+            local_roles = [r for r in obj.valid_roles() if r not in
+                           ('Anonymous', 'Authenticated', 'Shared')]
+        else:
+            local_roles = [role for role in member.getRolesInContext(obj)
+                           if role not in ('Member', 'Authenticated')]
+        local_roles.sort()
+        return tuple(local_roles)
+
+    @security.protected(View)
+    def loginUser(self, REQUEST=None):
+        """ Handle a login for the current user.
+
+        This method takes care of all the standard work that needs to be
+        done when a user logs in:
+        - clear the copy/cut/paste clipboard
+        - PAS credentials update
+        - sending a logged-in event
+        - storing the login time
+        - create the member area if it does not exist
+        """
+        user = getSecurityManager().getUser()
+        if user is None:
+            return
+
+        if self.setLoginTimes():
+            event.notify(UserInitialLoginInEvent(user))
+        else:
+            event.notify(UserLoggedInEvent(user))
+
+        if REQUEST is None:
+            REQUEST = getattr(self, 'REQUEST', None)
+        if REQUEST is None:
+            return
+
+        # Expire the clipboard
+        if REQUEST.get('__cp', None) is not None:
+            REQUEST.RESPONSE.expireCookie('__cp', path='/')
+
+        self.createMemberArea()
+
+        try:
+            pas = getToolByName(self, 'acl_users')
+            pas.credentials_cookie_auth.login()
+        except AttributeError:
+            # The cookie plugin may not be present
+            pass
+
+    @security.protected(View)
+    def logoutUser(self, REQUEST=None):
+        """Process a user logout.
+
+        This takes care of all the standard logout work:
+        - ask the user folder to logout
+        - expire a skin selection cookie
+        - invalidate a Zope session if there is one
+        """
+        # Invalidate existing sessions, but only if they exist.
+        sdm = getToolByName(self, 'session_data_manager', None)
+        if sdm is not None:
+                session = sdm.getSessionData(create=0)
+                if session is not None:
+                            session.invalidate()
+
+        if REQUEST is None:
+            REQUEST = getattr(self, 'REQUEST', None)
+        if REQUEST is not None:
+            pas = getToolByName(self, 'acl_users')
+            try:
+                pas.logout(REQUEST)
+            except:
+                # XXX Bare except copied from logout.cpy. This should be
+                # changed in the next Plone release.
+                pass
+
+            # Expire the skin cookie if it is not configured to persist
+            st = getToolByName(self, "portal_skins")
+            skinvar = st.getRequestVarname()
+            if skinvar in REQUEST and not st.getCookiePersistence():
+                portal = getToolByName(self, "portal_url") .getPortalObject()
+                path = '/' + portal.absolute_url(1)
+                # XXX check if this path is sane
+                REQUEST.RESPONSE.expireCookie(skinvar, path=path)
+
+        user = getSecurityManager().getUser()
+        if user is not None:
+            event.notify(UserLoggedOutEvent(user))
+
+    @security.protected(View)
+    def immediateLogout(self):
+        """ Log the current user out immediately.  Used by logout.py so that
+            we do not have to do a redirect to show the logged out status. """
+        noSecurityManager()
+
+    @security.public
+    def setLoginTimes(self):
+        """ Called by logged_in to set the login time properties
+            even if members lack the "Set own properties" permission.
+
+            The return value indicates if this is the first logged
+            login time.
+        """
+        res = False
+        if not self.isAnonymousUser():
+            member = self.getAuthenticatedMember()
+            default = DateTime('2000/01/01')
+            login_time = member.getProperty('login_time', default)
+            if login_time == default:
+                res = True
+                login_time = DateTime()
+            member.setProperties(login_time=self.ZopeTime(),
+                                 last_login_time=login_time)
+        return res
+
+    @security.protected(ManagePortal)
+    def getBadMembers(self):
+        """Will search for members with bad images in the portal_memberdata
+        delete their portraits and return their member ids"""
+        memberdata = getToolByName(self, 'portal_memberdata')
+        portraits = getattr(memberdata, 'portraits', None)
+        if portraits is None:
+            return []
+        bad_member_ids = []
+        TXN_THRESHOLD = 50
+        counter = 1
+        for member_id in tuple(portraits.keys()):
+            portrait = portraits[member_id]
+            portrait_data = str(portrait.data)
+            if portrait_data == '':
+                continue
+            if not HAS_PIL:
+                raise RuntimeError(
+                    'No Python Imaging Libraries (PIL) found. '
+                    'Unable to validate profile image. '
+                )
+            try:
+                import PIL
+                PIL.Image.open(StringIO(portrait_data))
+            except ConflictError:
+                pass
+            except:
+                # Anything else we have a bad bad image and we destroy it
+                # and ask questions later.
+                portraits._delObject(member_id)
+                bad_member_ids.append(member_id)
+            if not counter % TXN_THRESHOLD:
+                transaction.savepoint(optimistic=True)
+            counter = counter + 1
+
+        return bad_member_ids
+
+
+InitializeClass(MembershipTool)
diff --git a/src/Products/PlonePAS/utils.py b/src/Products/PlonePAS/utils.py
new file mode 100644
index 0000000..4a7d55c
--- /dev/null
+++ b/src/Products/PlonePAS/utils.py
@@ -0,0 +1,198 @@
+# -*- coding: utf-8 -*-
+from Products.PlonePAS.config import IMAGE_SCALE_PARAMS
+from Products.PluggableAuthService.interfaces.plugins import IGroupsPlugin
+from cStringIO import StringIO
+from urllib import quote as url_quote
+from urllib import unquote as url_unquote
+
+
+def unique(iterable):
+    d = {}
+    for i in iterable:
+        d[i] = None
+    return d.keys()
+
+
+def cleanId(id):
+    """'url_quote' turns strange chars into '%xx', which is not a valid char
+    for ObjectManager. Here we encode '%' into '-' (and '-' into '--' as
+    escaping).
+    De-clean is possible; see 'decleanId'.
+    Assumes that id can start with non-alpha(numeric), which is true.
+    """
+    __traceback_info__ = (id,)
+    if id:
+        # note: we provide the 'safe' param to get '/' encoded
+        return url_quote(id, '').replace('-', '--').replace('%', '-')
+    return ''
+
+
+def decleanId(id):
+    """Reverse cleanId."""
+    if id:
+        id = id.replace('--', '\x00').replace('-', '%').replace('\x00', '-')
+        return url_unquote(id)
+    return ''
+
+
+def scale_image(image_file, max_size=None, default_format=None):
+    """Scales an image down to at most max_size preserving aspect ratio
+    from an input file
+
+        >>> from Products.PlonePAS import config
+        >>> import os
+        >>> from StringIO import StringIO
+        >>> from Products.PlonePAS.utils import scale_image
+        >>> from PIL import Image
+
+    Let's make a couple test images and see how it works (all are
+    100x100), the gif is palletted mode::
+
+        >>> pas_path = os.path.dirname(config.__file__)
+        >>> pjoin = os.path.join
+        >>> path = pjoin(pas_path, 'tests', 'images')
+        >>> orig_jpg = open(pjoin(path, 'test.jpg'), 'rb')
+        >>> orig_png = open(pjoin(path, 'test.png'), 'rb')
+        >>> orig_gif = open(pjoin(path, 'test.gif'), 'rb')
+
+    We'll also make some evil non-images, including one which
+    masquerades as a jpeg (which would trick OFS.Image)::
+
+        >>> invalid = StringIO('<div>Evil!!!</div>')
+        >>> sneaky = StringIO('\377\330<div>Evil!!!</div>')
+
+    OK, let's get to it, first check that our bad images fail:
+
+        >>> scale_image(invalid, (50, 50))
+        Traceback (most recent call last):
+        ...
+        IOError: cannot identify image file...
+        >>> scale_image(sneaky, (50, 50))
+        Traceback (most recent call last):
+        ...
+        IOError: cannot identify image file...
+
+    Now that that's out of the way we check on our real images to make
+    sure the format and mode are preserved, that they are scaled, and that they
+    return the correct mimetype::
+
+        >>> new_jpg, mimetype = scale_image(orig_jpg, (50, 50))
+        >>> img = Image.open(new_jpg)
+        >>> img.size
+        (50, 50)
+        >>> img.format
+        'JPEG'
+        >>> mimetype
+        'image/jpeg'
+
+        >>> new_png, mimetype = scale_image(orig_png, (50, 50))
+        >>> img = Image.open(new_png)
+        >>> img.size
+        (50, 50)
+        >>> img.format
+        'PNG'
+        >>> mimetype
+        'image/png'
+
+        >>> new_gif, mimetype = scale_image(orig_gif, (50, 50))
+        >>> img = Image.open(new_gif)
+        >>> img.size
+        (50, 50)
+        >>> img.format
+        'GIF'
+        >>> img.mode
+        'P'
+        >>> mimetype
+        'image/gif'
+
+    We should also preserve the aspect ratio by scaling to the given
+    width only unless told not to (we need to reset out files before
+    trying again though::
+
+        >>> orig_jpg.seek(0)
+        >>> new_jpg, mimetype = scale_image(orig_jpg, (70, 100))
+        >>> img = Image.open(new_jpg)
+        >>> img.size
+        (70, 70)
+
+        >>> orig_jpg.seek(0)
+        >>> new_jpg, mimetype = scale_image(orig_jpg, (70, 50))
+        >>> img = Image.open(new_jpg)
+        >>> img.size
+        (50, 50)
+
+    """
+    from PIL import Image
+
+    if max_size is None:
+        max_size = IMAGE_SCALE_PARAMS['scale']
+    if default_format is None:
+        default_format = IMAGE_SCALE_PARAMS['default_format']
+    # Make sure we have ints
+    size = (int(max_size[0]), int(max_size[1]))
+    # Load up the image, don't try to catch errors, we want to fail miserably
+    # on invalid images
+    image = Image.open(image_file)
+    # When might image.format not be true?
+    format = image.format
+    mimetype = 'image/%s' % format.lower()
+
+    # from Archetypes ImageField
+    # consider image mode when scaling
+    # source images can be mode '1','L,','P','RGB(A)'
+    # convert to greyscale or RGBA before scaling
+    # preserve palletted mode (but not pallette)
+    # for palletted-only image formats, e.g. GIF
+    # PNG compression is OK for RGBA thumbnails
+    original_mode = image.mode
+    if original_mode == '1':
+        image = image.convert('L')
+    elif original_mode == 'P':
+        image = image.convert('RGBA')
+    # Rescale in place with an method that will not alter the aspect ratio
+    # and will only shrink the image not enlarge it.
+    image.thumbnail(size, resample=IMAGE_SCALE_PARAMS['algorithm'])
+    # preserve palletted mode for GIF and PNG
+    if original_mode == 'P' and format in ('GIF', 'PNG'):
+        image = image.convert('P')
+    # Save
+    new_file = StringIO()
+    image.save(new_file, format, quality=IMAGE_SCALE_PARAMS['quality'])
+    new_file.seek(0)
+    # Return the file data and the new mimetype
+    return new_file, mimetype
+
+
+def getGroupsForPrincipal(principal, plugins, request=None):
+    groups = set()
+    for iid, plugin in plugins.listPlugins(IGroupsPlugin):
+        groups.update(plugin.getGroupsForPrincipal(principal, request))
+    return list(groups)
+
+
+def safe_unicode(value, encoding='utf-8'):
+    """Converts a value to unicode, even it is already a unicode string.
+    """
+    if isinstance(value, unicode):
+        return value
+    elif isinstance(value, basestring):
+        try:
+            value = unicode(value, encoding)
+        except UnicodeDecodeError:
+            value = value.decode('utf-8', 'replace')
+    return value
+
+
+# Imported from Products.CMFCore.MemberdataTool as it has now been removed.
+class CleanupTemp:
+    """Used to cleanup _v_temps at the end of the request."""
+
+    def __init__(self, tool):
+        self._tool = tool
+
+    def __del__(self):
+        try:
+            del self._tool._v_temps
+        except (AttributeError, KeyError):
+            # The object has already been deactivated.
+            pass
diff --git a/src/Products/PlonePAS/zmi/AutoGroupForm.zpt b/src/Products/PlonePAS/zmi/AutoGroupForm.zpt
new file mode 100644
index 0000000..187abc6
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/AutoGroupForm.zpt
@@ -0,0 +1,66 @@
+<h1 tal:replace="structure here/manage_page_header">Header</h1>
+
+<h2 tal:define="form_title string:Add Auto Group plugin"
+    tal:replace="structure here/manage_form_title">Form Title</h2>
+
+<p class="form-help">
+The Auto Group plugin automatically puts all authenticated users in a virtual
+group.
+</p>
+
+<form action="manage_addAutoGroup" method="post">
+<table cellspacing="0" cellpadding="2" border="0">
+  <tr>
+    <td align="left" valign="top">
+    <div class="form-label">
+    Id
+    </div>
+    </td>
+    <td align="left" valign="top">
+    <input type="text" name="id" size="40" />
+    </td>
+  </tr>
+  <tr>
+    <td align="left" valign="top">
+    <div class="form-optional">
+    Title
+    </div>
+    </td>
+    <td align="left" valign="top">
+    <input type="text" name="title" size="40" />
+    </td>
+  </tr>
+  <tr>
+    <td align="left" valign="top">
+    <div class="form-label">
+    Group id
+    </div>
+    </td>
+    <td align="left" valign="top">
+    <input type="text" name="group" size="40" />
+    </td>
+  </tr>
+  <tr>
+    <td align="left" valign="top">
+    <div class="form-label">
+    Description
+    </div>
+    </td>
+    <td align="left" valign="top">
+    <input type="text" name="description" size="40" />
+    </td>
+  </tr>
+  <tr>
+    <td align="left" valign="top">
+    </td>
+    <td align="left" valign="top">
+    <div class="form-element">
+    <input class="form-element" type="submit" name="submit" 
+     value=" Add " /> 
+    </div>
+    </td>
+  </tr>
+</table>
+</form>
+
+<h1 tal:replace="structure here/manage_page_footer">Footer</h1>
diff --git a/src/Products/PlonePAS/zmi/CookieCrumblingPluginForm.dtml b/src/Products/PlonePAS/zmi/CookieCrumblingPluginForm.dtml
new file mode 100644
index 0000000..56facac
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/CookieCrumblingPluginForm.dtml
@@ -0,0 +1,39 @@
+<dtml-var manage_page_header>
+
+<h2> Add A CookieCrumblingPlugin For PAS</h2>
+
+<p class="form-help">
+ This user factory allows form-based logins to be authenticated against regular user folders
+ in parent folders. Otherwise, users from, say, the root's <code>acl_users</code> won't be able
+ to log in via a form
+</p>
+
+<p>
+ It does this by injecting form-provided credentials into the REQUEST as CookieCrumbler does.
+</p>
+
+<form action="manage_addCookieCrumblingPlugin" method="POST">
+
+<table>
+<tr>
+   <td class="form-label"> Id </td>
+   <td> <input type="text" name="id" /> </td>
+</tr>
+<tr>
+   <td class="form-label"> Title </td>
+   <td> <input type="text" name="title" /> </td>
+</tr>
+<tr>
+   <td colspan="2"> 
+    <div class="form-element">
+     <input type="submit" value="submit"/>
+     </div>
+   </td>
+</tr>
+
+</table>
+
+</form>
+
+</body>
+</html>
diff --git a/src/Products/PlonePAS/zmi/ExtendedCookieAuthHelperForm.dtml b/src/Products/PlonePAS/zmi/ExtendedCookieAuthHelperForm.dtml
new file mode 100644
index 0000000..285c6d3
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/ExtendedCookieAuthHelperForm.dtml
@@ -0,0 +1,30 @@
+<dtml-var manage_page_header>
+
+<h2> Add An ExtendedCookieAuthHelper For PAS</h2>
+
+
+<form action="manage_addExtendedCookieAuthHelper" method="POST">
+
+<table>
+<tr>
+   <td class="form-label"> Id </td>
+   <td> <input type="text" name="id" /> </td>
+</tr>
+<tr>
+   <td class="form-label"> Title </td>
+   <td> <input type="text" name="title" /> </td>
+</tr>
+<tr>
+   <td colspan="2"> 
+    <div class="form-element">
+     <input type="submit" value="submit"/>
+     </div>
+   </td>
+</tr>
+
+</table>
+
+</form>
+
+</body>
+</html>
diff --git a/src/Products/PlonePAS/zmi/GroupAwareRoleManagerForm.dtml b/src/Products/PlonePAS/zmi/GroupAwareRoleManagerForm.dtml
new file mode 100644
index 0000000..cf2c5f2
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/GroupAwareRoleManagerForm.dtml
@@ -0,0 +1,35 @@
+<dtml-var manage_page_header>
+
+<h2> Add A Group Aware Role Manager For PAS </h2>
+
+<p class="form-help">
+  install a group aware role manager. returns roles assigned to group 
+  a principal is a member of, in addition to the explicit roles
+  assigned directly to the principal.
+</p>
+
+<form action="manage_addGroupAwareRoleManager" method="POST">
+
+<table>
+
+<tr>
+   <td class="form-label"> Id </td>
+   <td> <input type="text" name="id" /> </td>
+</tr>
+<tr>
+   <td class="form-label"> Title </td>
+   <td> <input type="text" name="title" /> </td>
+</tr>
+<tr>
+   <td colspan="2"> 
+   <div class="form-element">
+    <input type="submit" value="add group aware role manager"/>
+   </div>
+   </td>
+</tr>
+</table>   
+
+</form>
+
+</body>
+</html>
diff --git a/src/Products/PlonePAS/zmi/GroupManagerForm.dtml b/src/Products/PlonePAS/zmi/GroupManagerForm.dtml
new file mode 100644
index 0000000..fcb2974
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/GroupManagerForm.dtml
@@ -0,0 +1,35 @@
+<dtml-var manage_page_header>
+
+<h2> Add A Group Manager For PAS </h2>
+
+<p class="form-help">
+ This group manager allows for zodb based storage of groups, as well
+ exposing a management interface for adding, deleting, modifying, and
+ introspecting groups. 
+</p>
+
+<form action="manage_addGroupManager" method="POST">
+
+<table>
+<tr>
+   <td class="form-label"> Id </td>
+   <td> <input type="text" name="id" /> </td>
+</tr>
+<tr>
+   <td class="form-label"> Title </td>
+   <td> <input type="text" name="title" /> </td>
+</tr>
+<tr>
+   <td colspan="2"> 
+    <div class="form-element">
+     <input type="submit" value="submit"/>
+     </div>
+   </td>
+</tr>
+
+</table>
+
+</form>
+
+</body>
+</html>
diff --git a/src/Products/PlonePAS/zmi/LocalRolesManagerForm.dtml b/src/Products/PlonePAS/zmi/LocalRolesManagerForm.dtml
new file mode 100644
index 0000000..1a136b6
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/LocalRolesManagerForm.dtml
@@ -0,0 +1,34 @@
+<dtml-var manage_page_header>
+
+<h2> Add A Local Roles Manager For PAS </h2>
+
+<p class="form-help">
+ This local roles manager checks for both user and the user's groups
+ local roles as well allowing for local roles blocking on containers.
+</p>
+
+<form action="manage_addLocalRolesManager" method="POST">
+
+<table>
+<tr>
+   <td class="form-label"> Id </td>
+   <td> <input type="text" name="id" /> </td>
+</tr>
+<tr>
+   <td class="form-label"> Title </td>
+   <td> <input type="text" name="title" /> </td>
+</tr>
+<tr>
+   <td colspan="2"> 
+    <div class="form-element">
+     <input type="submit" value="submit"/>
+     </div>
+   </td>
+</tr>
+
+</table>
+
+</form>
+
+</body>
+</html>
diff --git a/src/Products/PlonePAS/zmi/MutablePropertyProviderForm.dtml b/src/Products/PlonePAS/zmi/MutablePropertyProviderForm.dtml
new file mode 100644
index 0000000..53731fa
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/MutablePropertyProviderForm.dtml
@@ -0,0 +1,34 @@
+<dtml-var manage_page_header>
+
+<h2> Add A Mutable Property Provider For PAS </h2>
+
+<p class="form-help">
+  install a ZODB-based mutable property provider. provides property sheets like
+  a regular property manager, but allows writing as well.
+</p>
+
+<form action="manage_addZODBMutablePropertyProvider" method="POST">
+
+<table>
+
+<tr>
+   <td class="form-label"> Id </td>
+   <td> <input type="text" name="id" /> </td>
+</tr>
+<tr>
+   <td class="form-label"> Title </td>
+   <td> <input type="text" name="title" /> </td>
+</tr>
+<tr>
+   <td colspan="2"> 
+   <div class="form-element">
+    <input type="submit" value="add mutable property provider"/>
+   </div>
+   </td>
+</tr>
+</table>   
+
+</form>
+
+</body>
+</html>
diff --git a/src/Products/PlonePAS/zmi/PasswordPolicyForm.zpt b/src/Products/PlonePAS/zmi/PasswordPolicyForm.zpt
new file mode 100644
index 0000000..43a2726
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/PasswordPolicyForm.zpt
@@ -0,0 +1,45 @@
+<h1 tal:replace="structure here/manage_page_header">Header</h1>
+
+<h2 tal:define="form_title string:Add Default Plone Password Policy plugin"
+    tal:replace="structure here/manage_form_title">Form Title</h2>
+
+<p class="form-help">
+The Default Plone Password Policy validates passwords to be at least 5 chars long
+</p>
+
+<form action="manage_addPasswordPolicyPlugin" method="post">
+<table cellspacing="0" cellpadding="2" border="0">
+  <tr>
+    <td align="left" valign="top">
+    <div class="form-label">
+    Id
+    </div>
+    </td>
+    <td align="left" valign="top">
+    <input type="text" name="id" size="40" />
+    </td>
+  </tr>
+  <tr>
+    <td align="left" valign="top">
+    <div class="form-optional">
+    Title
+    </div>
+    </td>
+    <td align="left" valign="top">
+    <input type="text" name="title" size="40" />
+    </td>
+  </tr>
+  <tr>
+    <td align="left" valign="top">
+    </td>
+    <td align="left" valign="top">
+    <div class="form-element">
+    <input class="form-element" type="submit" name="submit"
+     value=" Add " />
+    </div>
+    </td>
+  </tr>
+</table>
+</form>
+
+<h1 tal:replace="structure here/manage_page_footer">Footer</h1>
diff --git a/src/Products/PlonePAS/zmi/PloneUserFactoryForm.dtml b/src/Products/PlonePAS/zmi/PloneUserFactoryForm.dtml
new file mode 100644
index 0000000..a4b8a08
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/PloneUserFactoryForm.dtml
@@ -0,0 +1,35 @@
+<dtml-var manage_page_header>
+
+<h2> Add A PloneUser Factory For PAS </h2>
+
+<p class="form-help">
+ This user factory allows for creation of plone compatible users from
+ PAS, specifically it performs name/id demangling and allows for local
+ roles black listing.
+</p>
+
+<form action="manage_addPloneUserFactory" method="POST">
+
+<table>
+<tr>
+   <td class="form-label"> Id </td>
+   <td> <input type="text" name="id" /> </td>
+</tr>
+<tr>
+   <td class="form-label"> Title </td>
+   <td> <input type="text" name="title" /> </td>
+</tr>
+<tr>
+   <td colspan="2"> 
+    <div class="form-element">
+     <input type="submit" value="submit"/>
+     </div>
+   </td>
+</tr>
+
+</table>
+
+</form>
+
+</body>
+</html>
diff --git a/src/Products/PlonePAS/zmi/UserManagerForm.dtml b/src/Products/PlonePAS/zmi/UserManagerForm.dtml
new file mode 100644
index 0000000..1601847
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/UserManagerForm.dtml
@@ -0,0 +1,35 @@
+<dtml-var manage_page_header>
+
+<h2> Add A User Manager For PAS </h2>
+
+<p class="form-help">
+ This user manager allows for zodb based storage of users, as well
+ exposing a management interface for adding, deleting, and modifying
+ users. 
+</p>
+
+<form action="manage_addUserManager" method="POST">
+
+<table>
+<tr>
+   <td class="form-label"> Id </td>
+   <td> <input type="text" name="id" /> </td>
+</tr>
+<tr>
+   <td class="form-label"> Title </td>
+   <td> <input type="text" name="title" /> </td>
+</tr>
+<tr>
+   <td colspan="2"> 
+    <div class="form-element">
+     <input type="submit" value="submit"/>
+     </div>
+   </td>
+</tr>
+
+</table>
+
+</form>
+
+</body>
+</html>
diff --git a/src/Products/PlonePAS/zmi/membershipRolemapping.dtml b/src/Products/PlonePAS/zmi/membershipRolemapping.dtml
new file mode 100644
index 0000000..1b535af
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/membershipRolemapping.dtml
@@ -0,0 +1,136 @@
+<dtml-let form_title="'Membership Tool Role Mappings'">
+<dtml-if manage_page_header>
+ <dtml-var manage_page_header>
+<dtml-else>
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.or
+ <html lang="en">
+ <head>
+ <title>&dtml-form_title;</title>
+ </head>
+ <body bgcolor="#FFFFFF" link="#000099" vlink="#555555">
+ <h3>&dtml-form_title;</h3>
+</dtml-if>
+</dtml-let>
+
+<dtml-var name="manage_tabs">
+
+<h2>Membership role mappings</h2>
+
+<p>Use this screen if you are using a userfolder other than the built-in folder
+existing role names to roles understood by the CMF.</p>
+
+<dtml-in expr="getPortalRoles()">
+  <dtml-if name="sequence-start">
+    <table border="1" cellpadding="3">
+      <tr>
+        <td class="form-label"><b>Portal Role</b></td>
+        <td class="form-label"><b>User Folder-defined Role</b></td>
+        <td>&nbsp;</td>
+      </tr>
+  </dtml-if>
+
+  <tr>
+    <form method="post" action="setRoleMapping">
+
+    <td class="form-label"><dtml-var name="sequence-item"><input type="hidden"
+        name="portal_role" value="&dtml-sequence-item;"></td>
+    <td class="form-element"><input type="text" size="30" name="userfolder_role"
+              value="<dtml-var expr="getMappedRole(_['sequence-item'])">"></td>
+    <td><input type="submit" value="Set Mapping"></td>
+    </form>
+  </tr>
+
+  <dtml-if name="sequence-end">
+    </table>
+  </dtml-if>
+</dtml-in>
+
+<p><hr></p>
+
+<h2>Control creation of member areas</h2>
+
+<p>This feature controls whether users
+will have their own folder created upon first login or not.</p>
+
+<form method="post" action="setMemberareaCreationFlag">
+
+<dtml-if expr="getMemberareaCreationFlag() == 1">
+  <p><b>Member areas are created upon first login.</b>
+  <input type="submit" value=" Turn folder creation off ">
+<dtml-else>
+  <p><b>No member areas are created.</b>
+  <input type="submit" value=" Turn folder creation on ">
+</dtml-if>
+
+</form>
+
+<p><hr></p>
+
+<h2>Set member area type</h2>
+
+<p>Select the (folderish) type to use when creating new
+member areas. You have all the freedom you want but be aware that
+non-folderish types may cause problems.</p>
+
+<form action="manage_setMemberAreaType" method="post">
+<table cellspacing="2">
+<tr>
+  <td align="left" valign="top">
+    <div class="form-label">Member area type</div>
+  </td>
+  <td align="left" valign="top">
+    <select name="type_name">
+      <dtml-let types="[x.getId() for x in portal_types.listTypeInfo()]"
+                dummy="types.sort()">
+        <dtml-in types>
+          <dtml-let id="_['sequence-item']">
+            <option
+              <dtml-if expr="id == memberarea_type">
+                selected="selected"
+              </dtml-if>
+              name="<dtml-var id>"><dtml-var id></option>
+          </dtml-let>
+        </dtml-in>
+      </dtml-let>
+    </select>
+  </td>
+</tr>
+<tr>
+  <td>
+  </td>
+  <td align="left" valign="top">
+    <input class="form-element" type="submit" value=" Change ">
+  </td>
+</tr>
+</table>
+</form>
+
+<p><hr></p>
+
+<h2>Set members folder</h2>
+
+<p>The members folder has to be in the same container as the membership tool.</p>
+
+<form action="manage_setMembersFolderById" method="post">
+<table cellspacing="2">
+<tr>
+  <td align="left" valign="top">
+    <div class="form-label">Members folder id</div>
+  </td>
+  <td align="left" valign="top">
+    <input class="form-element" type="text" name="id"
+        value="&dtml-membersfolder_id;">
+  </td>
+</tr>
+<tr>
+  <td>
+  </td>
+  <td align="left" valign="top">
+    <input class="form-element" type="submit" value=" Change ">
+  </td>
+</tr>
+</table>
+</form>
+
+</body>
+</html>
diff --git a/src/Products/PlonePAS/zmi/portrait_fix.dtml b/src/Products/PlonePAS/zmi/portrait_fix.dtml
new file mode 100644
index 0000000..6109e31
--- /dev/null
+++ b/src/Products/PlonePAS/zmi/portrait_fix.dtml
@@ -0,0 +1,55 @@
+<dtml-var manage_page_header>
+<dtml-var manage_tabs>
+
+<p>This is a simple tool for purging members who have uploaded non-image files
+as their member portraits in an attempted cross site scripting attack.  The
+issue which allowed such portraits to be uploaded has been resolved, and this
+tool will remove any existing bad portraits and give you the option of removing
+the members to whom those portraits belonged.
+</p>
+
+<hr />
+<dtml-if search_for_bad_members>
+  <dtml-let ids="getBadMembers()">
+    <dtml-if ids>
+      <p>Found <dtml-var "len(ids)"> bad member portraits and removed them.
+         You may optionally delete these members as well using the form below.
+      </p>
+      <form name="purge_bad_members"
+            method="POST"
+            action="manage_portrait_fix">
+        <ul>
+          <dtml-in ids>
+            <li><dtml-var sequence-item></li>
+            <input type="hidden"
+                   name="member_ids:list"
+                   value="&dtml-sequence-item;"/>
+          </dtml-in>
+        </ul>
+        <input type="checkbox"
+               name="delete_memberareas:bool"
+               checked="true">Delete member areas
+        <br />
+        <input type="submit"
+               name="purge_bad_members"
+               value="Remove These Members" />
+      </form>
+    <dtml-else>
+      <p>No bad members found</p>
+    </dtml-if>
+  </dtml-let>
+<dtml-elif purge_bad_members>
+  
+  <dtml-let deleted="deleteMembers(member_ids, REQUEST.get('delete_memberareas', False), REQUEST=REQUEST)">
+    <dtml-call "portal_memberdata.pruneMemberDataContents()">
+    <p>Deleted <dtml-var "len(deleted)"> bad members</p>
+  </dtml-let>
+<dtml-else>
+  <form name="get_bad_members"
+        method="POST"
+        action="manage_portrait_fix">
+
+    <input type="submit" name="search_for_bad_members"
+           value="Remove Bad Portraits" />
+  </form>
+</dtml-if>
diff --git a/src/Products/__init__.py b/src/Products/__init__.py
new file mode 100644
index 0000000..68c04af
--- /dev/null
+++ b/src/Products/__init__.py
@@ -0,0 +1,2 @@
+# -*- coding: utf-8 -*-
+__import__('pkg_resources').declare_namespace(__name__)
diff --git a/travis.cfg b/travis.cfg
new file mode 100644
index 0000000..c6b1471
--- /dev/null
+++ b/travis.cfg
@@ -0,0 +1,18 @@
+[buildout]
+develop = .
+extends =
+    https://raw.githubusercontent.com/collective/buildout.plonetest/master/qa.cfg
+    https://raw.githubusercontent.com/collective/buildout.plonetest/master/travis-5.x.cfg
+
+package-name = Products.PlonePAS
+package-extras = [test]
+
+[versions]
+setuptools =
+zc.buildout =
+
+[code-analysis]
+flake8-ignore = C901
+utf8-header = True
+imports = True
+debug-statements = True


