Repository: plone.session


Branch: refs/heads/master
Date: 2015-06-02T14:30:03+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.session/commit/afa188c305ed1324f938db9a30bc7f169f2d0552

plone documentation style and some ReST fixes

Files changed:
M README.rst

diff --git a/README.rst b/README.rst
index fb6acb2..f52421a 100644
--- a/README.rst
+++ b/README.rst
@@ -1,40 +1,36 @@
 Overview
 ========
 
-plone.session implements secure session management for Zope sites.
+*plone.session* implements secure session management for Zope sites.
 
-In its default configuration plone.session uses an HMAC_ SHA-256_ secure
-cryptographic hash to authenticate sessions. The hash is generated using the
-userid and a secret stored in the PAS plugin. Otherwise, the cookie
-format is identical to that of Apache's mod_auth_tkt_. For single sign on with
-the original mod_auth_tkt or another compatible implementation, set the
-``mod_auth_tkt`` property to true. This invokes an MD5_ based double hashing
-scheme. You will need to use the same secret across all servers.
+In its default configuration *plone.session* uses an HMAC_ SHA-256_ secure cryptographic hash to authenticate sessions.
+The hash is generated using the userid and a secret stored in the PAS plugin.
+Otherwise, the cookie format is identical to that of Apache's mod_auth_tkt_.
+For single sign on with the original mod_auth_tkt or another compatible implementation, set the ``mod_auth_tkt`` property to true.
+This invokes an MD5_ based double hashing scheme.
+You will need to use the same secret across all servers.
 
 This has several advantages over other session management systems:
 
-* passwords are not sent to the server in a cookie on every request, as
-  is done by the *Cookie Auth Helper*
-* it does not require any ZODB write for sessions, as is needed by the
-  *Session Crumbler*. This allows it to scale very well.
-* it allows you to invalidate all existing authentication cookies for
-  users by updating the secret.
-* The cookie is only valid for the period specified by the `timeout` property.
+* passwords are not sent to the server in a cookie on every request, as is done by the *Cookie Auth Helper*
+* it does not require any ZODB write for sessions, as is needed by the *Session Crumbler*.
+  This allows it to scale very well.
+* it allows you to invalidate all existing authentication cookies for users by updating the secret.
+* The cookie is only valid for the period specified by the ``timeout`` property.
 
 There are some downsides to this approach:
 
-* if a user's password is changed or disabled session identifiers will
-  continue to work, making it hard to lock out individual users.
+* if a user's password is changed or disabled session identifiers will continue to work, making it hard to lock out individual users.
 * a user must have cookies enabled.
 
-A session cookie is used to track sessions; that means that as long as
-a user keeps his browser open (and does not explicitly log out) the session
-remains open until the timeout limit is reached. This can be changed by setting
-the ``timeout`` property of the plugin to the number of seconds the cookie
-should remain valid *after the moment of login*.
+A session cookie is used to track sessions;
+that means that as long as a user keeps his browser open (and does not explicitly log out) the session remains open until the timeout limit is reached.
+This can be changed by setting the ``timeout`` property of the plugin to the number of seconds the cookie should remain valid *after the moment of login*.
 
-`tktauth.py` implements the core mod_auth_tkt functionality. It is
-self-contained and may be of useful to other frameworks.
+*plone.session* does **not** excuse you from setting up TLS (aka HTTPS) for your site.
+
+``tktauth.py`` implements the core mod_auth_tkt functionality.
+It is self-contained and may be of useful to other frameworks.
 
 .. _mod_auth_tkt: http://www.openfusion.com.au/labs/mod_auth_tkt/
 .. _MD5: http://en.wikipedia.org/wiki/MD5
@@ -45,20 +41,16 @@ self-contained and may be of useful to other frameworks.
 Using plone.session
 ===================
 
-plone.session only takes care of handling sessions for already authenticated
-users. This means it can not be used stand-alone: you need to have another
-PAS plugin, such as the standard *Cookie Auth Helper* to take care of
-authentication.
+*plone.session* only takes care of handling sessions for already authenticated users.
+This means it can not be used stand-alone: you need to have another PAS plugin, such as the standard *Cookie Auth Helper* to take care of authentication.
 
-After a user has been authenticated plone.session can take over via the
-PAS *credentials update* mechanism.
+After a user has been authenticated *plone.session* can take over via the PAS *credentials update* mechanism.
 
 Python 2.4 / Zope 2.10 / Plone 3
 --------------------------------
 
-To use this version of plone.session under Python 2.4, add the `backported
-hmac`_ module to your buildout (which will also bring in the backported
-hashlib_ module.)
+To use this version of *plone.session* under Python 2.4, add the `backported hmac`_ module to your buildout
+(which will also bring in the backported hashlib_ module).
 
 .. _`backported hmac`: http://pypi.python.org/pypi/hmac
 .. _hashlib: http://pypi.python.org/pypi/hashlib
@@ -67,105 +59,92 @@ hashlib_ module.)
 Configuration options
 =====================
 
-To enable logins between sites or other mod_auth_tkt systems, set the shared
-secret through the Zope Management Interface. You can manage the plone.keyring
-secrets through the same page.
+To enable logins between sites or other mod_auth_tkt systems, set the shared secret through the Zope Management Interface.
+You can manage the ``plone.keyring`` secrets through the same page.
 
-The following properties may be set through the Properties tab:
+The following properties may be set through the ``Properties`` tab:
 
-  Cookie validity timeout (in seconds)
-    After this, the session is invalid and the user must login again. Set to 0
-    for the cookie to remain valid indefinitely. Note that when the user
-    folder has caching enabled, cookie validity may not be checked on every
-    request.
+Cookie validity timeout (in seconds)
+    After this, the session is invalid and the user must login again.
+    Set to 0 for the cookie to remain valid indefinitely.
+    Note that when the user folder has caching enabled, cookie validity may not be checked on every request.
 
-  Refresh interval (in seconds, -1 to disable refresh)
+Refresh interval (in seconds, -1 to disable refresh)
     This controls the refresh CSS max-age (see below.)
 
-  Use mod_auth_tkt compatible hashing algorithm
-    Compatibility with other implemenations, but at the cost of using a weaker
-    hashing algorithm.
+Use mod_auth_tkt compatible hashing algorithm
+    Compatibility with other implemenations, but at the cost of using a weaker hashing algorithm.
 
-  Cookie name
-    Which cookie to use. This must also be set on the
-    ``credentials_cookie_auth`` plugin.
+Cookie name
+    Which cookie to use. This must also be set on the ``credentials_cookie_auth`` plugin.
 
-  Cookie lifetime (in days)
+Cookie lifetime (in days)
     This makes the cookie persistent across opening and closing the browser.
 
-  Cookie domain (blank for default)
-    A cookie may be shared across www1.example.com and www2.example.com by
-    setting the cookie domain to ``.example.com``.
+Cookie domain (blank for default)
+    A cookie may be shared across www1.example.com and www2.example.com by setting the cookie domain to ``.example.com``.
 
-  Cookie path
-    What path the cookie is set valid (defaults to ``/``.)
+Cookie path
+    What path the cookie is set valid (defaults to ``/``).
 
 
 Ticket refresh
 ==============
 
-To enable short validity timeouts you must ensure that the cookie is regularly
-updated. One option is to put mod_auth_tkt in front of your site and set a
-``TktAuthTimeoutRefresh``. As of plone.session 3.1, an independent javascript
-solution is also supplied, installable as an optional add-on in Plone.
+To enable short validity timeouts you must ensure that the cookie is regularly updated.
+One option is to put mod_auth_tkt in front of your site and set a ``TktAuthTimeoutRefresh``.
+As of *plone.session 3.1*, an independent javascript solution is also supplied, installable as an optional add-on in Plone.
 
 Theory of operation
 -------------------
 
-The optional add-on installs a css resource which updates the cookie when
-loaded. This allows the cookie to be updated every time a page is loaded.
-While this CSS cannot cached by proxy servers, it may be cached for a time on
-the client. By controlling the ``max-age`` of the CSS resource, it is possible
-to control how often the browser actually fetches the CSS and hence how often
-the cookie is updated.
-
-With short timeouts (15 or 30 minutes say), a user may not have loaded a new
-page before their cookie becomes invalid. A javascript is included which polls
-the cookie refresh CSS periodically while the user is active on the page (key
-presses or mouse moves.) If the refresh CSS max-age has passed, then the
-browser will refetch the CSS and the cookie will be updated. The poll interval
-may be configured on the refresh CSS query string ``minutes`` parameter, with
-the default being 5 minutes.
+The optional add-on installs a css resource which updates the cookie when loaded.
+This allows the cookie to be updated every time a page is loaded.
+While this CSS cannot cached by proxy servers, it may be cached for a time on the client.
+By controlling the ``max-age`` of the CSS resource, it is possible to control how often the browser actually fetches the CSS and hence how often the cookie is updated.
+
+With short timeouts (15 or 30 minutes say), a user may not have loaded a new page before their cookie becomes invalid.
+A javascript is included which polls the cookie refresh CSS periodically while the user is active on the page (key presses or mouse moves.)
+If the refresh CSS max-age has passed, then the browser will refetch the CSS and the cookie will be updated.
+The poll interval may be configured on the refresh CSS query string ``minutes`` parameter, with the default being 5 minutes.
 
 Caveat
 ------
 
-This has been tested and shown to work on Internet Explorer 7, Firefox 4,
-Safari 5 and Chrome 6. Unfortunately Internet Explorer 6 does not seem to
-respect the caching headers for javascript fetched resources, so if you have a
-lot of IE6 users you may want to increase the poll interval to reduce server
-load.
+This has been tested and shown to work on Internet Explorer 7, Firefox 4, Safari 5 and Chrome 6.
+Unfortunately Internet Explorer 6 does not seem to respect the caching headers for javascript fetched resources.
+So if you have a lot of IE6 users you may want to increase the poll interval to reduce server load.
 
 
 Ticket removal
 ==============
 
-When login sessions are shared across domains, it can be helpful to log users
-out of all domains when they log out of a Plone site. This may be configured
-in `portal_css` by adding a resource with the following settings
+When login sessions are shared across domains, it can be helpful to log users out of all domains when they log out of a Plone site.
+This may be configured in ``portal_css`` by adding a resource with the following settings
 
-  ID/URL
+ID/URL
     ``http://example.com/portal_path/acl_users/session/remove?type=css``
     (adjusted to the url of the portal to be logged out.)
 
-  Condition
+Condition
     ``python:request.URL.endswith('/logged_out')``
 
-  Render type
+Render type
     link
 
-  Compression type
+Compression type
     none
 
-  Merging allowed?
+Merging allowed?
     No
 
-  Caching allowed?
+Caching allowed?
     No
 
-  CSS Media
+CSS Media
     (blank)
 
+
 Single Sign On with IIS
 =======================
 
@@ -175,14 +154,14 @@ For intranet setups with users on a Windows domain, it's possible to configure I
 Requirements
 ------------
 
-- You need a Microsoft Windows Server running IIS. Preferably Windows Server
-  2003 or a later version.
+- You need a Microsoft Windows Server running IIS.
+  Preferably Windows Server 2003 or a later version.
 
-- The server must be a member of the Windows domain you want to authenticate
-  users for. It does not need to be an Active Directory server itself.
+- The server must be a member of the Windows domain you want to authenticate users for.
+  It does not need to be an Active Directory server itself.
 
-- You site should use LDAPMultiPlugins_ to use the same Active Directory as a
-  user source. (Use plone.app.ldap_ to set this up with Plone.)
+- You site should use LDAPMultiPlugins_ to use the same Active Directory as a user source
+  (i.e. use plone.app.ldap_ to set this up with Plone).
 
 .. _LDAPMultiPlugins: http://pypi.python.org/pypi/Products.LDAPMultiPlugins
 .. _plone.app.ldap: http://pypi.python.org/pypi/plone.app.ldap
@@ -191,32 +170,21 @@ Requirements
 Python
 ------
 
-- The Windows server needs to have `Python 2.6
-  <http://www.python.org/download/>` and the `Python Win 32 extensions
-  <http://sourceforge.net/projects/pywin32/files/>`_ installed. (Currently
-  Python 2.6.5 and pywin32-214.)
-
-- Until pywin32-215 is released, apply this `fix
-  <http://mail.python.org/pipermail/python-win32/2009-October/009639.html>`_
-  to the file::
-
-    C:\Python26\Lib\site-packages\win32comext\axscript\client\framework.py
-
-  and remove the framework.pyc and framework.pyo files.
+- The Windows server needs to have `Python 2.7 <http://www.python.org/download/>`_ and the `Python Win 32 extensions build >=216 <http://sourceforge.net/projects/pywin32/files/>`_ installed.
 
 - Place a copy of ``tktauth.py`` (from plone/session of this package) into::
 
     C:\Python26\Lib\site-packages\
 
-- Follow these `instructions on how to configure Python for IIS
-  <http://support.microsoft.com/kb/276494>`_. In bullet point 2.d. use::
+- Follow these `instructions on how to configure Python for IIS <http://support.microsoft.com/kb/276494>`_.
+  In bullet point 2.d. use::
 
     Executable: "C:\Python26\python.exe -u %s %s"
 
-  instead. This will ensure files are opened in universal newline mode. You
-  can choose to only configure these settings for the specific web site and
-  not the entire IIS. Adjust settings accordingly and create the web site
-  first as detailed in the next chapter.
+  instead.
+  This will ensure files are opened in universal newline mode.
+  You can choose to only configure these settings for the specific web site and not the entire IIS.
+  Adjust settings accordingly and create the web site first as detailed in the next chapter.
 
 
 IIS
@@ -224,8 +192,8 @@ IIS
 
 - Find and open the IIS management console.
 
-- Create a new `Web Site`, by going into the `Web Sites` folder and using the
-  right-click menu. You should get a wizard asking you for various questions::
+- Create a new `Web Site`, by going into the ``Web Sites`` folder and using the right-click menu.
+  You should get a wizard asking you for various questions::
 
     Description: SSO login service
 
@@ -237,103 +205,80 @@ IIS
 
     Permissions: Read, Run scripts, Execute
 
-- If you are running IIS 6, you need to go to the `Web Service Extensions`
-  folder and change `Active Server Pages` to be `Allowed`. Otherwise you
-  will get rather unhelpful `404 Not Found` errors for the asp scripts.
+- If you are running IIS 6, you need to go to the ``Web Service Extensions`` folder and change ``Active Server Pages`` to be ``Allowed``.
+  Otherwise you will get rather unhelpful ``404 Not Found`` errors for the asp scripts.
 
 
 IIS script
 ----------
 
-- Copy the `login.asp` and `test.asp` scripts (from the iis-login folder of
-  this package) into root path of the web site (for example C:\Inetpub\sso).
+- Copy the ``login.asp`` and ``test.asp`` scripts (from the iis-login folder of this package) into root path of the web site (for example C:\Inetpub\sso).
 
-- You need to modify the `SECRET` constant found in the `login.asp` to the
-  same shared secret set on plone.session's `Manage secrets` tab.
+- You need to modify the ``SECRET`` constant found in the ``login.asp`` to the same shared secret set on *plone.session's* ``Manage secrets`` tab.
 
-- Modify the `ALLOWED_SITES` constant in `login.asp` to include the URLs of
-  your Plone sites.
+- Modify the ``ALLOWED_SITES`` constant in ``login.asp`` to include the URLs of your Plone sites.
 
-- Modify the `DEFAULT_NEXT` constant in `login.asp` to refer the the URL of
-  `logged_in` on one of your Plone sites.
+- Modify the ``DEFAULT_NEXT`` constant in ``login.asp`` to refer the the URL of ``logged_in`` on one of your Plone sites.
 
-- Access http://LOGONSERVER/test.asp to confirm access permissions are
-  correctly configured.
+- Access ``http://LOGONSERVER/test.asp`` to confirm access permissions are correctly configured.
 
 
 Configuring browsers to allow automatic logon
 ---------------------------------------------
 
-Browsers must be configured to "trust" the logon server for user
-authentication data to be sent automatically.
+Browsers must be configured to *trust* the logon server for user authentication data to be sent automatically.
 
-By default, Internet Explorer sends logon information to servers within the
-"Intranet Zone", so long as the site is accessed using it's intranet name
-(http://LOGONSERVER/login.asp). If the site is accessed using a fully
-qualified domain name or IP address, it must be explicitly added to the list
-of `trusted sites <http://support.microsoft.com/kb/174360>`_.
+By default, Internet Explorer sends logon information to servers within the *Intranet Zone*, so long as the site is accessed using it's intranet name (``http://LOGONSERVER/login.asp``).
+If the site is accessed using a fully qualified domain name or IP address, it must be explicitly added to the list of `trusted sites <http://support.microsoft.com/kb/174360>`_.
 
-Firefox configuration information may be found in this `article
-<http://support.mozilla.com/en-US/kb/Firefox+asks+for+user+name+and+password+on+internal+sites>`_.
+Firefox configuration information may be found in this `article <http://support.mozilla.com/en-US/kb/Firefox+asks+for+user+name+and+password+on+internal+sites>`_.
 
 
 Configuring your Plone site
 ---------------------------
 
-Ensure that you have setup authentication to Active Directory and that you can
-login with the your current Windows user name.
+Ensure that you have setup authentication to Active Directory and that you can login with the your current Windows user name.
 
 Set the following configuration options through the Zope interface:
 
-- In `/Plone/acl_users/session`. On the `Manage secrets` tab set a shared
-  secret.
+- In ``/Plone/acl_users/session``. On the ``Manage secrets`` tab set a shared secret.
 
-- In `/Plone/portal_properties/site_properties` set `external_login_url` to
-  `http://LOGONSERVER/login.asp`.
+- In ``/Plone/portal_properties/site_properties`` set ``external_login_url`` to ``http://LOGONSERVER/login.asp``.
 
 For Plone versions before 4.1:
 
-- In `/Plone/portal_actions/user/login`. On the `Properties` tab set `URL
-  (Expression)` to `${portal/portal_properties/site_properties/external_login_url}?next=${globals_view/navigationRootUrl}/logged_in`.
+- In ``/Plone/portal_actions/user/login``.
+  On the ``Properties`` tab set ``URL (Expression)`` to ``${portal/portal_properties/site_properties/external_login_url}?next=${globals_view/navigationRootUrl}/logged_in``.
 
 For Plone 4.1 and later you may instead set:
 
-- In `/Plone/portal_properties/site_properties` set `external_login_iframe` to
-  True.
+- In ``/Plone/portal_properties/site_properties`` set ``external_login_iframe`` to true.
 
 Note for developers testing this under Windows XP
 -------------------------------------------------
 
-- IIS may be installed as an additional component using the Windows XP
-  installation CD.
+- IIS may be installed as an additional component using the Windows XP installation CD.
 
 - The IIS management console can be located at::
 
     Start -> Control Panel -> Adminstrative Tools -> Internet Information Services
 
-- The pywin32 installer setup IIS sufficiently for me not to need to follow
-  the `instructions on how to configure Python for IIS`.
+- The pywin32 installer setup IIS sufficiently for me not to need to follow the *instructions on how to configure Python for IIS*.
 
-- I could not find how to setup a separate site, so placed the asp scripts
-  directly in C:\Inetpub\wwwroot - the "Default Web Site"
+- I could not find how to setup a separate site, so placed the asp scripts directly in ``C:\Inetpub\wwwroot`` - the *Default Web Site*
 
-- From the IIS management console, select "Default Web Site". You should see
-  `login.asp` and `test.asp` in the right hand pane. With each file,
-  right-click Properties. On the `File Security` tab click Edit... on
-  `Anonymous access and authentication control`. Uncheck `Anonymous access`
-  and check `Basic authentication` (to be used as a fallback) and `Integrated
-  Windows authentication`.
+- From the IIS management console, select "Default Web Site".
+  You should see ``login.asp`` and ``test.asp`` in the right hand pane.
+  With each file, right-click Properties.
+  On the `File Security` tab click Edit... on ``Anonymous access and authentication control``.
+  Uncheck ``Anonymous access`` and check ``Basic authentication`` (to be used as a fallback) and ``Integrated Windows authentication``.
 
-- Access http://localhost/test.asp to confirm IIS authentication works as
-  expected.
+- Access ``http://localhost/test.asp`` to confirm IIS authentication works as expected.
 
-- Set the secret in `login.asp` and `Manage secrets` of plone.session.
+- Set the secret in ``login.asp`` and ``Manage secrets`` of *plone.session*.
 
-- Set SITE_URL in `login.asp` to `http://localhost:8080/Plone` (or whatever
-  the address of your site is.)
+- Set SITE_URL in ``login.asp`` to ``http://localhost:8080/Plone`` (or whatever the address of your site is).
 
-- Add a Plone user with the same name as your Windows login name (e.g.
-  Administrator), this avoids setting up Active Directory.
+- Add a Plone user with the same name as your Windows login name (e.g. *Administrator*), this avoids setting up Active Directory.
 
-- Follow the section above to configure your Plone site, but set `Login Form`
-  to `http://localhost/login.asp`.
+- Follow the section above to configure your Plone site, but set ``Login Form``  to ``http://localhost/login.asp``.


Repository: plone.session


Branch: refs/heads/master
Date: 2015-06-02T14:30:46+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.session/commit/1572ff11cc065fa51e236608ce8188d801b47129

indent, other minor cleanup

Files changed:
M setup.py

diff --git a/setup.py b/setup.py
index 1983d83..41b17b1 100644
--- a/setup.py
+++ b/setup.py
@@ -1,46 +1,51 @@
-from setuptools import setup, find_packages
+# -*- coding: utf-8 -*-
+from setuptools import find_packages
+from setuptools import setup
 
 version = '3.5.6.dev0'
+longdescription = open("README.rst").read()
+longdescription += '\n'
+longdescription += open("CHANGES.rst").read()
 
-setup(name='plone.session',
-      version=version,
-      description="Session based authentication for Zope",
-      long_description=open("README.rst").read() + "\n" +
-                       open("CHANGES.rst").read(),
-      classifiers=[
-          "Environment :: Web Environment",
-          "Framework :: Plone",
-          "Framework :: Plone :: 4.3",
-          "Framework :: Plone :: 5.0",
-          "Framework :: Zope2",
-          "License :: OSI Approved :: BSD License",
-          "Operating System :: OS Independent",
-          "Programming Language :: Python",
-          "Programming Language :: Python :: 2.7",
-          "Topic :: System :: Systems Administration :: Authentication/Directory",
-        ],
-      keywords='PAS session authentication Zope',
-      author='Plone Foundation',
-      author_email='plone-developers@lists.sourceforge.net',
-      url='http://pypi.python.org/pypi/plone.session',
-      license='BSD',
-      packages=find_packages(exclude=['ez_setup']),
-      namespace_packages=['plone'],
-      include_package_data=True,
-      zip_safe=False,
-      extras_require=dict(
-        test=[
-            'zope.configuration',
-            'zope.publisher',
-        ]
-      ),
-      install_requires=[
-        'setuptools',
-        'plone.keyring',
-        'plone.protect',
-        'zope.component',
-        'zope.interface',
-        'Products.PluggableAuthService',
-        'Zope2',
-      ],
-      )
+setup(
+    name='plone.session',
+    version=version,
+    description="Session based auth tkt authentication for Zope",
+    long_description=longdescription,
+    classifiers=[
+        "Environment :: Web Environment",
+        "Framework :: Plone :: 4.3",
+        "Framework :: Plone :: 5.0",
+        "Framework :: Plone",
+        "Framework :: Zope2",
+        "License :: OSI Approved :: BSD License",
+        "Operating System :: OS Independent",
+        "Programming Language :: Python :: 2.7",
+        "Programming Language :: Python",
+        "Topic :: System :: Systems Administration :: Authentication/Directory",  # noqa
+    ],
+    keywords='PAS session authentication Zope auth_tkt',
+    author='Plone Foundation',
+    author_email='plone-developers@lists.sourceforge.net',
+    url='http://pypi.python.org/pypi/plone.session',
+    license='BSD',
+    packages=find_packages(exclude=['ez_setup']),
+    namespace_packages=['plone'],
+    include_package_data=True,
+    zip_safe=False,
+    extras_require=dict(
+      test=[
+          'zope.configuration',
+          'zope.publisher',
+      ]
+    ),
+    install_requires=[
+      'plone.keyring',
+      'plone.protect',
+      'Products.PluggableAuthService',
+      'setuptools',
+      'zope.component',
+      'zope.interface',
+      'Zope2',
+    ],
+)


Repository: plone.session


Branch: refs/heads/master
Date: 2015-06-02T15:10:42+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.session/commit/a334ba868f3c94a8ac024572074887ef8aa39114

cleanup: followpep8, plone code conventions, better readability

Files changed:
M CHANGES.rst
M plone/session/__init__.py
M plone/session/configure.zcml
M plone/session/interfaces.py
M plone/session/plugins/__init__.py
M plone/session/plugins/session.py
M plone/session/profiles.zcml
M plone/session/resources.zcml
M plone/session/tktauth.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 2a94aa4..8544186 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,7 +4,8 @@ Changelog
 3.5.6 (unreleased)
 ------------------
 
-- Nothing changed yet.
+- Cleanup: Pep8, plone style conventions, better readbility.
+  [jensens]
 
 
 3.5.5 (2015-04-29)
diff --git a/plone/session/__init__.py b/plone/session/__init__.py
index c081135..e111fe7 100644
--- a/plone/session/__init__.py
+++ b/plone/session/__init__.py
@@ -1,15 +1,18 @@
+# -*- coding: utf-8 -*-
 from AccessControl.Permissions import add_user_folders
+from plone.session.plugins import session
 from Products.PluggableAuthService.PluggableAuthService import \
     registerMultiPlugin
-from plone.session.plugins import session
-
 
 registerMultiPlugin(session.SessionPlugin.meta_type)
 
 
 def initialize(context):
-    context.registerClass(session.SessionPlugin,
-            permission = add_user_folders,
-            constructors = (session.manage_addSessionPluginForm,
-                            session.manage_addSessionPlugin),
-            visibility = None)
+    context.registerClass(
+        session.SessionPlugin,
+        permission=add_user_folders,
+        constructors=(
+            session.manage_addSessionPluginForm,
+            session.manage_addSessionPlugin),
+        visibility=None
+    )
diff --git a/plone/session/configure.zcml b/plone/session/configure.zcml
index ea77bd0..6a4af78 100644
--- a/plone/session/configure.zcml
+++ b/plone/session/configure.zcml
@@ -3,15 +3,17 @@
     xmlns:five="http://namespaces.zope.org/five"
     xmlns:zcml="http://namespaces.zope.org/zcml">
 
-    <five:registerPackage package="." initialize=".initialize" />
+  <five:registerPackage
+      initialize=".initialize"
+      package="."
+  />
 
-    <include package="plone.protect" />
+  <include package="plone.protect" />
+  <include file="resources.zcml" />
 
-    <include file="resources.zcml" />
-
-    <include
-        zcml:condition="installed Products.CMFPlone"
-        file="profiles.zcml"
-        />
+  <include
+      file="profiles.zcml"
+      zcml:condition="installed Products.CMFPlone"
+  />
 
 </configure>
diff --git a/plone/session/interfaces.py b/plone/session/interfaces.py
index e420722..4f836a4 100644
--- a/plone/session/interfaces.py
+++ b/plone/session/interfaces.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from zope.interface import Interface
 
 
diff --git a/plone/session/plugins/__init__.py b/plone/session/plugins/__init__.py
index 792d600..40a96af 100644
--- a/plone/session/plugins/__init__.py
+++ b/plone/session/plugins/__init__.py
@@ -1 +1 @@
-#
+# -*- coding: utf-8 -*-
diff --git a/plone/session/plugins/session.py b/plone/session/plugins/session.py
index 3f70a56..5bcacc4 100644
--- a/plone/session/plugins/session.py
+++ b/plone/session/plugins/session.py
@@ -1,19 +1,22 @@
-from AccessControl.SecurityInfo import ClassSecurityInfo
+# -*- coding: utf-8 -*-
 from AccessControl.requestmethod import postonly
+from AccessControl.SecurityInfo import ClassSecurityInfo
 from App.config import getConfiguration
-from Products.PageTemplates.PageTemplateFile import PageTemplateFile
-from Products.PluggableAuthService.interfaces.plugins \
-        import IExtractionPlugin, IAuthenticationPlugin, \
-                ICredentialsResetPlugin, ICredentialsUpdatePlugin
-from Products.PluggableAuthService.permissions import ManageUsers
-from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
-from Products.PluggableAuthService.utils import classImplements
+from email.Utils import formatdate
 from plone.keyring.interfaces import IKeyManager
 from plone.session import tktauth
 from plone.session.interfaces import ISessionPlugin
-from zope.component import getUtility, queryUtility
+from Products.PageTemplates.PageTemplateFile import PageTemplateFile
+from Products.PluggableAuthService.interfaces.plugins import IAuthenticationPlugin  # noqa
+from Products.PluggableAuthService.interfaces.plugins import ICredentialsResetPlugin  # noqa
+from Products.PluggableAuthService.interfaces.plugins import ICredentialsUpdatePlugin  # noqa
+from Products.PluggableAuthService.interfaces.plugins import IExtractionPlugin
+from Products.PluggableAuthService.permissions import ManageUsers
+from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from zope.component import getUtility
+from zope.component import queryUtility
+from zope.interface import implementer
 
-from email.Utils import formatdate
 import binascii
 import time
 
@@ -29,13 +32,16 @@
 def manage_addSessionPlugin(dispatcher, id, title=None, path='/',
                             REQUEST=None):
     """Add a session plugin."""
-    sp=SessionPlugin(id, title=title, path=path)
+    sp = SessionPlugin(id, title=title, path=path)
     dispatcher._setObject(id, sp)
 
     if REQUEST is not None:
-        REQUEST.response.redirect('%s/manage_workspace?'
-                               'manage_tabs_message=Session+plugin+created.' %
-                               dispatcher.absolute_url())
+        REQUEST.response.redirect(
+            '{0}/manage_workspace?'
+            'manage_tabs_message=Session+plugin+created.'.format(
+                dispatcher.absolute_url()
+            )
+        )
 
 
 def cookie_expiration_date(days):
@@ -43,6 +49,13 @@ def cookie_expiration_date(days):
     return formatdate(expires, usegmt=True)
 
 
+@implementer(
+    ISessionPlugin,
+    IExtractionPlugin,
+    IAuthenticationPlugin,
+    ICredentialsResetPlugin,
+    ICredentialsUpdatePlugin
+)
 class SessionPlugin(BasePlugin):
     """Session authentication plugin.
     """
@@ -54,66 +67,66 @@ class SessionPlugin(BasePlugin):
     cookie_lifetime = 0
     cookie_domain = ''
     mod_auth_tkt = False
-    timeout = 12*60*60 # 12h. Default is 2h in mod_auth_tkt
-    refresh_interval = 1*60*60 # -1 to disable
+    timeout = 12*60*60  # 12h. Default is 2h in mod_auth_tkt
+    refresh_interval = 1*60*60  # -1 to disable
     external_ticket_name = 'ticket'
     secure = False
     _shared_secret = None
 
-    # These mod_auth_tkt options are not yet implemented
-    #ignoreIP = True # you always want this on the public internet
-    #timeoutRefresh = 0 # default is 0.5 in mod_auth_tkt
+    # These mod_auth_tkt options are not yet implemented (by intent)
+    # ignoreIP = True # you always want this on the public internet
+    # timeoutRefresh = 0 # default is 0.5 in mod_auth_tkt
 
     _properties = (
-            {
-                 "id": "timeout",
-                 "label": "Cookie validity timeout (in seconds)",
-                 "type": "int",
-                 "mode": "w",
-             },
-            {
-                 "id": "refresh_interval",
-                 "label": "Refresh interval (in seconds, -1 to disable refresh)",
-                 "type": "int",
-                 "mode": "w",
-             },
-            {
-                 "id": "mod_auth_tkt",
-                 "label": "Use mod_auth_tkt compatible hashing algorithm",
-                 "type": "boolean",
-                 "mode": "w",
-             },
-            {
-                "id": "cookie_name",
-                "label": "Cookie name",
-                "type": "string",
-                "mode": "w",
-            },
-            {
-                "id": "cookie_lifetime",
-                "label": "Cookie lifetime (in days)",
-                "type": "int",
-                "mode": "w",
-            },
-            {
-                 "id": "cookie_domain",
-                 "label": "Cookie domain (blank for default)",
-                 "type": "string",
-                 "mode": "w",
-            },
-            {
-                 "id": "path",
-                 "label": "Cookie path",
-                 "type": "string",
-                 "mode": "w",
-            },
-            {
-                "id": "secure",
-                "label": "Only Send Cookie Over HTTPS",
-                "type": "boolean",
-                "mode": "w",
-            },
-            )
+        {
+            "id": "timeout",
+            "label": "Cookie validity timeout (in seconds)",
+            "type": "int",
+            "mode": "w",
+         },
+        {
+            "id": "refresh_interval",
+            "label": "Refresh interval (in seconds, -1 to disable refresh)",
+            "type": "int",
+            "mode": "w",
+         },
+        {
+            "id": "mod_auth_tkt",
+            "label": "Use mod_auth_tkt compatible hashing algorithm",
+            "type": "boolean",
+            "mode": "w",
+         },
+        {
+           "id": "cookie_name",
+           "label": "Cookie name",
+           "type": "string",
+           "mode": "w",
+        },
+        {
+           "id": "cookie_lifetime",
+           "label": "Cookie lifetime (in days)",
+           "type": "int",
+           "mode": "w",
+        },
+        {
+            "id": "cookie_domain",
+            "label": "Cookie domain (blank for default)",
+            "type": "string",
+            "mode": "w",
+        },
+        {
+            "id": "path",
+            "label": "Cookie path",
+            "type": "string",
+            "mode": "w",
+        },
+        {
+           "id": "secure",
+           "label": "Only Send Cookie Over HTTPS",
+           "type": "boolean",
+           "mode": "w",
+        },
+    )
 
     manage_options = (
         dict(label='Manage secrets', action='manage_secret'),
@@ -121,13 +134,13 @@ class SessionPlugin(BasePlugin):
 
     def __init__(self, id, title=None, path="/"):
         self._setId(id)
-        self.title=title
-        self.path=path
+        self.title = title
+        self.path = path
 
     def _getSigningSecret(self):
         if self._shared_secret is not None:
             return self._shared_secret
-        manager=getUtility(IKeyManager)
+        manager = getUtility(IKeyManager)
         return manager.secret()
 
     # ISessionPlugin implementation
@@ -142,7 +155,7 @@ def _setupSession(self, userid, response, tokens=(), user_data=''):
         self._setCookie(cookie, response)
 
     def _setCookie(self, cookie, response):
-        cookie=binascii.b2a_base64(cookie).rstrip()
+        cookie = binascii.b2a_base64(cookie).rstrip()
         # disable secure cookie in development mode, to ease local testing
         if getConfiguration().debug_mode:
             secure = False
@@ -157,34 +170,36 @@ def _setCookie(self, cookie, response):
 
     # IExtractionPlugin implementation
     def extractCredentials(self, request):
-        creds={}
+        creds = {}
 
-        if not self.cookie_name in request:
+        if self.cookie_name not in request:
             return creds
 
         try:
-            creds["cookie"]=binascii.a2b_base64(request.get(self.cookie_name))
+            creds["cookie"] = binascii.a2b_base64(
+                request.get(self.cookie_name)
+            )
         except binascii.Error:
             # If we have a cookie which is not properly base64 encoded it
             # can not be ours.
             return creds
 
-        creds["source"]="plone.session" # XXX should this be the id?
+        creds["source"] = "plone.session"  # XXX should this be the id?
 
         return creds
 
     # IAuthenticationPlugin implementation
     def authenticateCredentials(self, credentials):
-        if not credentials.get("source", None)=="plone.session":
+        if not credentials.get("source", None) == "plone.session":
             return None
 
-        ticket=credentials["cookie"]
+        ticket = credentials["cookie"]
         ticket_data = self._validateTicket(ticket)
         if ticket_data is None:
             return None
         (digest, userid, tokens, user_data, timestamp) = ticket_data
-        pas=self._getPAS()
-        info=pas._verifyUser(pas.plugins, user_id=userid)
+        pas = self._getPAS()
+        info = pas._verifyUser(pas.plugins, user_id=userid)
         if info is None:
             return None
 
@@ -195,8 +210,13 @@ def _validateTicket(self, ticket, now=None):
         if now is None:
             now = time.time()
         if self._shared_secret is not None:
-            ticket_data = tktauth.validateTicket(self._shared_secret, ticket,
-                timeout=self.timeout, now=now, mod_auth_tkt=self.mod_auth_tkt)
+            ticket_data = tktauth.validateTicket(
+                self._shared_secret,
+                ticket,
+                timeout=self.timeout,
+                now=now,
+                mod_auth_tkt=self.mod_auth_tkt
+            )
         else:
             ticket_data = None
             manager = queryUtility(IKeyManager)
@@ -205,23 +225,28 @@ def _validateTicket(self, ticket, now=None):
             for secret in manager[u"_system"]:
                 if secret is None:
                     continue
-                ticket_data = tktauth.validateTicket(secret, ticket,
-                    timeout=self.timeout, now=now, mod_auth_tkt=self.mod_auth_tkt)
+                ticket_data = tktauth.validateTicket(
+                    secret,
+                    ticket,
+                    timeout=self.timeout,
+                    now=now,
+                    mod_auth_tkt=self.mod_auth_tkt
+                )
                 if ticket_data is not None:
                     break
         return ticket_data
 
     # ICredentialsUpdatePlugin implementation
     def updateCredentials(self, request, response, login, new_password):
-        pas=self._getPAS()
-        info=pas._verifyUser(pas.plugins, login=login)
+        pas = self._getPAS()
+        info = pas._verifyUser(pas.plugins, login=login)
         if info is not None:
             # Only setup a session for users in our own user folder.
             self._setupSession(info["id"], response)
 
     # ICredentialsResetPlugin implementation
     def resetCredentials(self, request, response):
-        response=self.REQUEST["RESPONSE"]
+        response = self.REQUEST["RESPONSE"]
         if self.cookie_domain:
             response.expireCookie(
                 self.cookie_name, path=self.path, domain=self.cookie_domain)
@@ -230,35 +255,39 @@ def resetCredentials(self, request, response):
 
     manage_secret = PageTemplateFile("secret.pt", globals())
 
-    security.declareProtected(ManageUsers, 'manage_clearSecrets')
+    @security.protected(ManageUsers)
     @postonly
     def manage_clearSecrets(self, REQUEST):
         """Clear all secrets from this source. This invalidates all current
         sessions and requires users to login again.
         """
-        manager=getUtility(IKeyManager)
+        manager = getUtility(IKeyManager)
         manager.clear()
         manager.rotate()
         response = REQUEST.response
-        response.redirect('%s/manage_secret?manage_tabs_message=%s' %
-            (self.absolute_url(), 'All+secrets+cleared.'))
+        response.redirect(
+            '%s/manage_secret?manage_tabs_message=%s' %
+            (self.absolute_url(), 'All+secrets+cleared.')
+        )
 
-    security.declareProtected(ManageUsers, 'manage_createNewSecret')
+    @security.protected(ManageUsers)
     @postonly
     def manage_createNewSecret(self, REQUEST):
         """Create a new (signing) secret.
         """
-        manager=getUtility(IKeyManager)
+        manager = getUtility(IKeyManager)
         manager.rotate()
         response = REQUEST.response
-        response.redirect('%s/manage_secret?manage_tabs_message=%s' %
-            (self.absolute_url(), 'New+secret+created.'))
+        response.redirect(
+            '%s/manage_secret?manage_tabs_message=%s' %
+            (self.absolute_url(), 'New+secret+created.')
+        )
 
-    security.declareProtected(ManageUsers, 'haveSharedSecret')
+    @security.protected(ManageUsers)
     def haveSharedSecret(self):
         return self._shared_secret is not None
 
-    security.declareProtected(ManageUsers, 'manage_removeSharedSecret')
+    @security.protected(ManageUsers)
     @postonly
     def manage_removeSharedSecret(self, REQUEST):
         """Clear the shared secret. This invalidates all current sessions and
@@ -266,10 +295,12 @@ def manage_removeSharedSecret(self, REQUEST):
         """
         self._shared_secret = None
         response = REQUEST.response
-        response.redirect('%s/manage_secret?manage_tabs_message=%s' %
-            (self.absolute_url(), 'Shared+secret+removed.'))
+        response.redirect(
+            '%s/manage_secret?manage_tabs_message=%s' %
+            (self.absolute_url(), 'Shared+secret+removed.')
+        )
 
-    security.declareProtected(ManageUsers, 'manage_setSharedSecret')
+    @security.protected(ManageUsers)
     @postonly
     def manage_setSharedSecret(self, REQUEST):
         """Set the shared secret.
@@ -277,16 +308,20 @@ def manage_setSharedSecret(self, REQUEST):
         secret = REQUEST.get('shared_secret')
         response = REQUEST.response
         if not secret:
-            response.redirect('%s/manage_secret?manage_tabs_message=%s' %
-                (self.absolute_url(), 'Shared+secret+must+not+be+blank.'))
+            response.redirect(
+                '%s/manage_secret?manage_tabs_message=%s' %
+                (self.absolute_url(), 'Shared+secret+must+not+be+blank.')
+            )
             return
         self._shared_secret = secret
-        response.redirect('%s/manage_secret?manage_tabs_message=%s' %
-            (self.absolute_url(), 'New+shared+secret+set.'))
+        response.redirect(
+            '%s/manage_secret?manage_tabs_message=%s' %
+            (self.absolute_url(), 'New+shared+secret+set.')
+        )
 
     def _refreshSession(self, request, now=None):
         # Refresh a ticket. Does *not* check the user is in the use folder
-        if not self.cookie_name in request:
+        if self.cookie_name not in request:
             return None
         try:
             ticket = binascii.a2b_base64(request.get(self.cookie_name))
@@ -313,12 +348,8 @@ def _refresh_content(self, REQUEST):
         elif type == 'js':
             setHeader('Content-Type', 'text/javascript')
             return ""
-        #if content:
-        #    return "still_logged_in = still_logged_in;\n"
-        #else:
-        #    return "still_logged_in = false;\n"
 
-    security.declarePublic('refresh')
+    @security.public
     def refresh(self, REQUEST):
         """Refresh the cookie"""
         setHeader = REQUEST.response.setHeader
@@ -330,23 +361,28 @@ def refresh(self, REQUEST):
         refreshed = self._refreshSession(REQUEST, now)
         if not refreshed:
             # We have an unauthenticated user
-            setHeader('Cache-Control', 'public, must-revalidate, max-age=%d, s-max-age=86400' % self.refresh_interval)
+            setHeader(
+                'Cache-Control',
+                'public, must-revalidate, max-age=%d, s-max-age=86400' %
+                self.refresh_interval
+            )
             setHeader('Vary', 'Cookie')
         else:
-            setHeader('Cache-Control', 'private, must-revalidate, proxy-revalidate, max-age=%d, s-max-age=0' % self.refresh_interval)
+            setHeader(
+                'Cache-Control',
+                'private, must-revalidate, proxy-revalidate, max-age=%d, '
+                's-max-age=0' % self.refresh_interval)
         return self._refresh_content(REQUEST)
 
-    security.declarePublic('remove')
+    @security.public
     def remove(self, REQUEST):
         """Remove the cookie"""
         self.resetCredentials(REQUEST, REQUEST.response)
         setHeader = REQUEST.response.setHeader
         # Disable HTTP 1.0 Caching
         setHeader('Expires', formatdate(0, usegmt=True))
-        setHeader('Cache-Control', 'public, must-revalidate, max-age=0, s-max-age=86400')
+        setHeader(
+            'Cache-Control',
+            'public, must-revalidate, max-age=0, s-max-age=86400'
+        )
         return self._refresh_content(REQUEST)
-
-
-classImplements(SessionPlugin, ISessionPlugin,
-                IExtractionPlugin, IAuthenticationPlugin,
-                ICredentialsResetPlugin, ICredentialsUpdatePlugin)
diff --git a/plone/session/profiles.zcml b/plone/session/profiles.zcml
index dcdce44..01aec3d 100644
--- a/plone/session/profiles.zcml
+++ b/plone/session/profiles.zcml
@@ -1,13 +1,13 @@
 <configure
-    xmlns="http://namespaces.zope.org/genericsetup"
-    i18n_domain="plone">
+    i18n_domain="plone"
+    xmlns="http://namespaces.zope.org/genericsetup">
 
-    <registerProfile
-        name="default"
-        title="Session refresh support"
-        directory="profiles/default"
-        description="Optional plone.session refresh support."
-        provides="Products.GenericSetup.interfaces.EXTENSION"
-        />
+  <registerProfile
+      description="Optional plone.session refresh support."
+      directory="profiles/default"
+      name="default"
+      provides="Products.GenericSetup.interfaces.EXTENSION"
+      title="Session refresh support"
+  />
 
 </configure>
diff --git a/plone/session/resources.zcml b/plone/session/resources.zcml
index 5ea96da..a940585 100644
--- a/plone/session/resources.zcml
+++ b/plone/session/resources.zcml
@@ -1,8 +1,8 @@
 <configure xmlns="http://namespaces.zope.org/browser">
 
-    <resource
-        name="plone.session.refreshsupport.js"
-        file="resources/refreshsupport.js"
-        />
+  <resource
+      file="resources/refreshsupport.js"
+      name="plone.session.refreshsupport.js"
+  />
 
 </configure>
diff --git a/plone/session/tktauth.py b/plone/session/tktauth.py
index 6e56be6..e5f8989 100755
--- a/plone/session/tktauth.py
+++ b/plone/session/tktauth.py
@@ -46,7 +46,9 @@
 We will create a mod_auth_tkt compatible ticket. In the simplest case no extra
 data is supplied.
 
-  >>> tkt = createTicket(SECRET, userid, timestamp=timestamp, mod_auth_tkt=True)
+  >>> tkt = createTicket(
+  ...     SECRET, userid, timestamp=timestamp, mod_auth_tkt=True
+  ... )
   >>> tkt
   'c7c7300ac5cf529656444123aca345294885afa0jbloggs!'
 
@@ -77,14 +79,18 @@
 We will validate it an hour after it was created:
 
   >>> NOW = timestamp + 60*60
-  >>> data = validateTicket(SECRET, tkt, timeout=TIMEOUT, now=NOW, mod_auth_tkt=True)
+  >>> data = validateTicket(
+  ...     SECRET, tkt, timeout=TIMEOUT, now=NOW, mod_auth_tkt=True
+  ... )
   >>> data is not None
   True
 
 After the timeout the ticket is no longer valid
 
   >>> LATER = NOW + TIMEOUT
-  >>> data = validateTicket(SECRET, tkt, timeout=TIMEOUT, now=LATER, mod_auth_tkt=True)
+  >>> data = validateTicket(
+  ...     SECRET, tkt, timeout=TIMEOUT, now=LATER, mod_auth_tkt=True
+  ... )
   >>> data is not None
   False
 
@@ -98,13 +104,18 @@
 
   >>> user_data = 'Joe Bloggs'
   >>> tokens = ['foo', 'bar']
-  >>> tkt = createTicket(SECRET, userid, tokens, user_data, timestamp=timestamp, mod_auth_tkt=True)
+  >>> tkt = createTicket(
+  ...     SECRET, userid, tokens, user_data, timestamp=timestamp,
+  ...     mod_auth_tkt=True
+  ... )
   >>> tkt
   'eea3630e98177bdbf0e7f803e1632b7e4885afa0jbloggs!foo,bar!Joe Bloggs'
   >>> cookie['auth_tkt'] = binascii.b2a_base64(tkt).strip()
   >>> print cookie
   Set-Cookie: auth_tkt=ZWVhMzYzMGU5ODE3N2JkYmYwZTdmODAzZTE2MzJiN2U0ODg1YWZh...
-  >>> data = validateTicket(SECRET, tkt, timeout=TIMEOUT, now=NOW, mod_auth_tkt=True)
+  >>> data = validateTicket(
+  ...     SECRET, tkt, timeout=TIMEOUT, now=NOW, mod_auth_tkt=True
+  ... )
   >>> data
   ('eea3630e98177bdbf0e7f803e1632b7e', 'jbloggs', ('foo', 'bar'), 'Joe Bloggs', 1216720800)
 
@@ -148,7 +159,8 @@ def mod_auth_tkt_digest(secret, data1, data2):
     return digest
 
 
-def createTicket(secret, userid, tokens=(), user_data='', ip='0.0.0.0', timestamp=None, encoding='utf-8', mod_auth_tkt=False):
+def createTicket(secret, userid, tokens=(), user_data='', ip='0.0.0.0',
+                 timestamp=None, encoding='utf-8', mod_auth_tkt=False):
     """
     By default, use a more compatible
     """
@@ -193,7 +205,7 @@ def splitTicket(ticket, encoding=None):
     remainder = ticket[40:]
     if not val:
         raise ValueError
-    timestamp = int(val, 16) # convert from hexadecimal+
+    timestamp = int(val, 16)  # convert from hexadecimal+
 
     if encoding is not None:
         remainder = remainder.decode(encoding)
@@ -218,8 +230,16 @@ def validateTicket(secret, ticket, ip='0.0.0.0', timeout=0, now=None,
             splitTicket(ticket)
     except ValueError:
         return None
-    new_ticket = createTicket(secret, userid, tokens,
-        user_data, ip, timestamp, encoding, mod_auth_tkt)
+    new_ticket = createTicket(
+        secret,
+        userid,
+        tokens,
+        user_data,
+        ip,
+        timestamp,
+        encoding,
+        mod_auth_tkt
+    )
     if is_equal(new_ticket[:32], digest):
         if not timeout:
             return data
@@ -233,7 +253,9 @@ def validateTicket(secret, ticket, ip='0.0.0.0', timeout=0, now=None,
 # doctest runner
 def _test():
     import doctest
-    doctest.testmod(optionflags=doctest.ELLIPSIS + doctest.NORMALIZE_WHITESPACE)
+    doctest.testmod(
+        optionflags=doctest.ELLIPSIS + doctest.NORMALIZE_WHITESPACE
+    )
 
 if __name__ == "__main__":
     _test()


Repository: plone.session


Branch: refs/heads/master
Date: 2015-07-24T17:57:21+02:00
Author: agitator (agitator) <hpeter@agitator.com>
Commit: https://github.com/plone/plone.session/commit/4ac0377a576bb0586f8df32e948de81797dd4ae3

Merge pull request #5 from plone/cleanup

Cleanup: pep8 et al

Files changed:
M CHANGES.rst
M README.rst
M plone/session/__init__.py
M plone/session/configure.zcml
M plone/session/interfaces.py
M plone/session/plugins/__init__.py
M plone/session/plugins/session.py
M plone/session/profiles.zcml
M plone/session/resources.zcml
M plone/session/tktauth.py
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 2a94aa4..8544186 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,7 +4,8 @@ Changelog
 3.5.6 (unreleased)
 ------------------
 
-- Nothing changed yet.
+- Cleanup: Pep8, plone style conventions, better readbility.
+  [jensens]
 
 
 3.5.5 (2015-04-29)
diff --git a/README.rst b/README.rst
index fb6acb2..f52421a 100644
--- a/README.rst
+++ b/README.rst
@@ -1,40 +1,36 @@
 Overview
 ========
 
-plone.session implements secure session management for Zope sites.
+*plone.session* implements secure session management for Zope sites.
 
-In its default configuration plone.session uses an HMAC_ SHA-256_ secure
-cryptographic hash to authenticate sessions. The hash is generated using the
-userid and a secret stored in the PAS plugin. Otherwise, the cookie
-format is identical to that of Apache's mod_auth_tkt_. For single sign on with
-the original mod_auth_tkt or another compatible implementation, set the
-``mod_auth_tkt`` property to true. This invokes an MD5_ based double hashing
-scheme. You will need to use the same secret across all servers.
+In its default configuration *plone.session* uses an HMAC_ SHA-256_ secure cryptographic hash to authenticate sessions.
+The hash is generated using the userid and a secret stored in the PAS plugin.
+Otherwise, the cookie format is identical to that of Apache's mod_auth_tkt_.
+For single sign on with the original mod_auth_tkt or another compatible implementation, set the ``mod_auth_tkt`` property to true.
+This invokes an MD5_ based double hashing scheme.
+You will need to use the same secret across all servers.
 
 This has several advantages over other session management systems:
 
-* passwords are not sent to the server in a cookie on every request, as
-  is done by the *Cookie Auth Helper*
-* it does not require any ZODB write for sessions, as is needed by the
-  *Session Crumbler*. This allows it to scale very well.
-* it allows you to invalidate all existing authentication cookies for
-  users by updating the secret.
-* The cookie is only valid for the period specified by the `timeout` property.
+* passwords are not sent to the server in a cookie on every request, as is done by the *Cookie Auth Helper*
+* it does not require any ZODB write for sessions, as is needed by the *Session Crumbler*.
+  This allows it to scale very well.
+* it allows you to invalidate all existing authentication cookies for users by updating the secret.
+* The cookie is only valid for the period specified by the ``timeout`` property.
 
 There are some downsides to this approach:
 
-* if a user's password is changed or disabled session identifiers will
-  continue to work, making it hard to lock out individual users.
+* if a user's password is changed or disabled session identifiers will continue to work, making it hard to lock out individual users.
 * a user must have cookies enabled.
 
-A session cookie is used to track sessions; that means that as long as
-a user keeps his browser open (and does not explicitly log out) the session
-remains open until the timeout limit is reached. This can be changed by setting
-the ``timeout`` property of the plugin to the number of seconds the cookie
-should remain valid *after the moment of login*.
+A session cookie is used to track sessions;
+that means that as long as a user keeps his browser open (and does not explicitly log out) the session remains open until the timeout limit is reached.
+This can be changed by setting the ``timeout`` property of the plugin to the number of seconds the cookie should remain valid *after the moment of login*.
 
-`tktauth.py` implements the core mod_auth_tkt functionality. It is
-self-contained and may be of useful to other frameworks.
+*plone.session* does **not** excuse you from setting up TLS (aka HTTPS) for your site.
+
+``tktauth.py`` implements the core mod_auth_tkt functionality.
+It is self-contained and may be of useful to other frameworks.
 
 .. _mod_auth_tkt: http://www.openfusion.com.au/labs/mod_auth_tkt/
 .. _MD5: http://en.wikipedia.org/wiki/MD5
@@ -45,20 +41,16 @@ self-contained and may be of useful to other frameworks.
 Using plone.session
 ===================
 
-plone.session only takes care of handling sessions for already authenticated
-users. This means it can not be used stand-alone: you need to have another
-PAS plugin, such as the standard *Cookie Auth Helper* to take care of
-authentication.
+*plone.session* only takes care of handling sessions for already authenticated users.
+This means it can not be used stand-alone: you need to have another PAS plugin, such as the standard *Cookie Auth Helper* to take care of authentication.
 
-After a user has been authenticated plone.session can take over via the
-PAS *credentials update* mechanism.
+After a user has been authenticated *plone.session* can take over via the PAS *credentials update* mechanism.
 
 Python 2.4 / Zope 2.10 / Plone 3
 --------------------------------
 
-To use this version of plone.session under Python 2.4, add the `backported
-hmac`_ module to your buildout (which will also bring in the backported
-hashlib_ module.)
+To use this version of *plone.session* under Python 2.4, add the `backported hmac`_ module to your buildout
+(which will also bring in the backported hashlib_ module).
 
 .. _`backported hmac`: http://pypi.python.org/pypi/hmac
 .. _hashlib: http://pypi.python.org/pypi/hashlib
@@ -67,105 +59,92 @@ hashlib_ module.)
 Configuration options
 =====================
 
-To enable logins between sites or other mod_auth_tkt systems, set the shared
-secret through the Zope Management Interface. You can manage the plone.keyring
-secrets through the same page.
+To enable logins between sites or other mod_auth_tkt systems, set the shared secret through the Zope Management Interface.
+You can manage the ``plone.keyring`` secrets through the same page.
 
-The following properties may be set through the Properties tab:
+The following properties may be set through the ``Properties`` tab:
 
-  Cookie validity timeout (in seconds)
-    After this, the session is invalid and the user must login again. Set to 0
-    for the cookie to remain valid indefinitely. Note that when the user
-    folder has caching enabled, cookie validity may not be checked on every
-    request.
+Cookie validity timeout (in seconds)
+    After this, the session is invalid and the user must login again.
+    Set to 0 for the cookie to remain valid indefinitely.
+    Note that when the user folder has caching enabled, cookie validity may not be checked on every request.
 
-  Refresh interval (in seconds, -1 to disable refresh)
+Refresh interval (in seconds, -1 to disable refresh)
     This controls the refresh CSS max-age (see below.)
 
-  Use mod_auth_tkt compatible hashing algorithm
-    Compatibility with other implemenations, but at the cost of using a weaker
-    hashing algorithm.
+Use mod_auth_tkt compatible hashing algorithm
+    Compatibility with other implemenations, but at the cost of using a weaker hashing algorithm.
 
-  Cookie name
-    Which cookie to use. This must also be set on the
-    ``credentials_cookie_auth`` plugin.
+Cookie name
+    Which cookie to use. This must also be set on the ``credentials_cookie_auth`` plugin.
 
-  Cookie lifetime (in days)
+Cookie lifetime (in days)
     This makes the cookie persistent across opening and closing the browser.
 
-  Cookie domain (blank for default)
-    A cookie may be shared across www1.example.com and www2.example.com by
-    setting the cookie domain to ``.example.com``.
+Cookie domain (blank for default)
+    A cookie may be shared across www1.example.com and www2.example.com by setting the cookie domain to ``.example.com``.
 
-  Cookie path
-    What path the cookie is set valid (defaults to ``/``.)
+Cookie path
+    What path the cookie is set valid (defaults to ``/``).
 
 
 Ticket refresh
 ==============
 
-To enable short validity timeouts you must ensure that the cookie is regularly
-updated. One option is to put mod_auth_tkt in front of your site and set a
-``TktAuthTimeoutRefresh``. As of plone.session 3.1, an independent javascript
-solution is also supplied, installable as an optional add-on in Plone.
+To enable short validity timeouts you must ensure that the cookie is regularly updated.
+One option is to put mod_auth_tkt in front of your site and set a ``TktAuthTimeoutRefresh``.
+As of *plone.session 3.1*, an independent javascript solution is also supplied, installable as an optional add-on in Plone.
 
 Theory of operation
 -------------------
 
-The optional add-on installs a css resource which updates the cookie when
-loaded. This allows the cookie to be updated every time a page is loaded.
-While this CSS cannot cached by proxy servers, it may be cached for a time on
-the client. By controlling the ``max-age`` of the CSS resource, it is possible
-to control how often the browser actually fetches the CSS and hence how often
-the cookie is updated.
-
-With short timeouts (15 or 30 minutes say), a user may not have loaded a new
-page before their cookie becomes invalid. A javascript is included which polls
-the cookie refresh CSS periodically while the user is active on the page (key
-presses or mouse moves.) If the refresh CSS max-age has passed, then the
-browser will refetch the CSS and the cookie will be updated. The poll interval
-may be configured on the refresh CSS query string ``minutes`` parameter, with
-the default being 5 minutes.
+The optional add-on installs a css resource which updates the cookie when loaded.
+This allows the cookie to be updated every time a page is loaded.
+While this CSS cannot cached by proxy servers, it may be cached for a time on the client.
+By controlling the ``max-age`` of the CSS resource, it is possible to control how often the browser actually fetches the CSS and hence how often the cookie is updated.
+
+With short timeouts (15 or 30 minutes say), a user may not have loaded a new page before their cookie becomes invalid.
+A javascript is included which polls the cookie refresh CSS periodically while the user is active on the page (key presses or mouse moves.)
+If the refresh CSS max-age has passed, then the browser will refetch the CSS and the cookie will be updated.
+The poll interval may be configured on the refresh CSS query string ``minutes`` parameter, with the default being 5 minutes.
 
 Caveat
 ------
 
-This has been tested and shown to work on Internet Explorer 7, Firefox 4,
-Safari 5 and Chrome 6. Unfortunately Internet Explorer 6 does not seem to
-respect the caching headers for javascript fetched resources, so if you have a
-lot of IE6 users you may want to increase the poll interval to reduce server
-load.
+This has been tested and shown to work on Internet Explorer 7, Firefox 4, Safari 5 and Chrome 6.
+Unfortunately Internet Explorer 6 does not seem to respect the caching headers for javascript fetched resources.
+So if you have a lot of IE6 users you may want to increase the poll interval to reduce server load.
 
 
 Ticket removal
 ==============
 
-When login sessions are shared across domains, it can be helpful to log users
-out of all domains when they log out of a Plone site. This may be configured
-in `portal_css` by adding a resource with the following settings
+When login sessions are shared across domains, it can be helpful to log users out of all domains when they log out of a Plone site.
+This may be configured in ``portal_css`` by adding a resource with the following settings
 
-  ID/URL
+ID/URL
     ``http://example.com/portal_path/acl_users/session/remove?type=css``
     (adjusted to the url of the portal to be logged out.)
 
-  Condition
+Condition
     ``python:request.URL.endswith('/logged_out')``
 
-  Render type
+Render type
     link
 
-  Compression type
+Compression type
     none
 
-  Merging allowed?
+Merging allowed?
     No
 
-  Caching allowed?
+Caching allowed?
     No
 
-  CSS Media
+CSS Media
     (blank)
 
+
 Single Sign On with IIS
 =======================
 
@@ -175,14 +154,14 @@ For intranet setups with users on a Windows domain, it's possible to configure I
 Requirements
 ------------
 
-- You need a Microsoft Windows Server running IIS. Preferably Windows Server
-  2003 or a later version.
+- You need a Microsoft Windows Server running IIS.
+  Preferably Windows Server 2003 or a later version.
 
-- The server must be a member of the Windows domain you want to authenticate
-  users for. It does not need to be an Active Directory server itself.
+- The server must be a member of the Windows domain you want to authenticate users for.
+  It does not need to be an Active Directory server itself.
 
-- You site should use LDAPMultiPlugins_ to use the same Active Directory as a
-  user source. (Use plone.app.ldap_ to set this up with Plone.)
+- You site should use LDAPMultiPlugins_ to use the same Active Directory as a user source
+  (i.e. use plone.app.ldap_ to set this up with Plone).
 
 .. _LDAPMultiPlugins: http://pypi.python.org/pypi/Products.LDAPMultiPlugins
 .. _plone.app.ldap: http://pypi.python.org/pypi/plone.app.ldap
@@ -191,32 +170,21 @@ Requirements
 Python
 ------
 
-- The Windows server needs to have `Python 2.6
-  <http://www.python.org/download/>` and the `Python Win 32 extensions
-  <http://sourceforge.net/projects/pywin32/files/>`_ installed. (Currently
-  Python 2.6.5 and pywin32-214.)
-
-- Until pywin32-215 is released, apply this `fix
-  <http://mail.python.org/pipermail/python-win32/2009-October/009639.html>`_
-  to the file::
-
-    C:\Python26\Lib\site-packages\win32comext\axscript\client\framework.py
-
-  and remove the framework.pyc and framework.pyo files.
+- The Windows server needs to have `Python 2.7 <http://www.python.org/download/>`_ and the `Python Win 32 extensions build >=216 <http://sourceforge.net/projects/pywin32/files/>`_ installed.
 
 - Place a copy of ``tktauth.py`` (from plone/session of this package) into::
 
     C:\Python26\Lib\site-packages\
 
-- Follow these `instructions on how to configure Python for IIS
-  <http://support.microsoft.com/kb/276494>`_. In bullet point 2.d. use::
+- Follow these `instructions on how to configure Python for IIS <http://support.microsoft.com/kb/276494>`_.
+  In bullet point 2.d. use::
 
     Executable: "C:\Python26\python.exe -u %s %s"
 
-  instead. This will ensure files are opened in universal newline mode. You
-  can choose to only configure these settings for the specific web site and
-  not the entire IIS. Adjust settings accordingly and create the web site
-  first as detailed in the next chapter.
+  instead.
+  This will ensure files are opened in universal newline mode.
+  You can choose to only configure these settings for the specific web site and not the entire IIS.
+  Adjust settings accordingly and create the web site first as detailed in the next chapter.
 
 
 IIS
@@ -224,8 +192,8 @@ IIS
 
 - Find and open the IIS management console.
 
-- Create a new `Web Site`, by going into the `Web Sites` folder and using the
-  right-click menu. You should get a wizard asking you for various questions::
+- Create a new `Web Site`, by going into the ``Web Sites`` folder and using the right-click menu.
+  You should get a wizard asking you for various questions::
 
     Description: SSO login service
 
@@ -237,103 +205,80 @@ IIS
 
     Permissions: Read, Run scripts, Execute
 
-- If you are running IIS 6, you need to go to the `Web Service Extensions`
-  folder and change `Active Server Pages` to be `Allowed`. Otherwise you
-  will get rather unhelpful `404 Not Found` errors for the asp scripts.
+- If you are running IIS 6, you need to go to the ``Web Service Extensions`` folder and change ``Active Server Pages`` to be ``Allowed``.
+  Otherwise you will get rather unhelpful ``404 Not Found`` errors for the asp scripts.
 
 
 IIS script
 ----------
 
-- Copy the `login.asp` and `test.asp` scripts (from the iis-login folder of
-  this package) into root path of the web site (for example C:\Inetpub\sso).
+- Copy the ``login.asp`` and ``test.asp`` scripts (from the iis-login folder of this package) into root path of the web site (for example C:\Inetpub\sso).
 
-- You need to modify the `SECRET` constant found in the `login.asp` to the
-  same shared secret set on plone.session's `Manage secrets` tab.
+- You need to modify the ``SECRET`` constant found in the ``login.asp`` to the same shared secret set on *plone.session's* ``Manage secrets`` tab.
 
-- Modify the `ALLOWED_SITES` constant in `login.asp` to include the URLs of
-  your Plone sites.
+- Modify the ``ALLOWED_SITES`` constant in ``login.asp`` to include the URLs of your Plone sites.
 
-- Modify the `DEFAULT_NEXT` constant in `login.asp` to refer the the URL of
-  `logged_in` on one of your Plone sites.
+- Modify the ``DEFAULT_NEXT`` constant in ``login.asp`` to refer the the URL of ``logged_in`` on one of your Plone sites.
 
-- Access http://LOGONSERVER/test.asp to confirm access permissions are
-  correctly configured.
+- Access ``http://LOGONSERVER/test.asp`` to confirm access permissions are correctly configured.
 
 
 Configuring browsers to allow automatic logon
 ---------------------------------------------
 
-Browsers must be configured to "trust" the logon server for user
-authentication data to be sent automatically.
+Browsers must be configured to *trust* the logon server for user authentication data to be sent automatically.
 
-By default, Internet Explorer sends logon information to servers within the
-"Intranet Zone", so long as the site is accessed using it's intranet name
-(http://LOGONSERVER/login.asp). If the site is accessed using a fully
-qualified domain name or IP address, it must be explicitly added to the list
-of `trusted sites <http://support.microsoft.com/kb/174360>`_.
+By default, Internet Explorer sends logon information to servers within the *Intranet Zone*, so long as the site is accessed using it's intranet name (``http://LOGONSERVER/login.asp``).
+If the site is accessed using a fully qualified domain name or IP address, it must be explicitly added to the list of `trusted sites <http://support.microsoft.com/kb/174360>`_.
 
-Firefox configuration information may be found in this `article
-<http://support.mozilla.com/en-US/kb/Firefox+asks+for+user+name+and+password+on+internal+sites>`_.
+Firefox configuration information may be found in this `article <http://support.mozilla.com/en-US/kb/Firefox+asks+for+user+name+and+password+on+internal+sites>`_.
 
 
 Configuring your Plone site
 ---------------------------
 
-Ensure that you have setup authentication to Active Directory and that you can
-login with the your current Windows user name.
+Ensure that you have setup authentication to Active Directory and that you can login with the your current Windows user name.
 
 Set the following configuration options through the Zope interface:
 
-- In `/Plone/acl_users/session`. On the `Manage secrets` tab set a shared
-  secret.
+- In ``/Plone/acl_users/session``. On the ``Manage secrets`` tab set a shared secret.
 
-- In `/Plone/portal_properties/site_properties` set `external_login_url` to
-  `http://LOGONSERVER/login.asp`.
+- In ``/Plone/portal_properties/site_properties`` set ``external_login_url`` to ``http://LOGONSERVER/login.asp``.
 
 For Plone versions before 4.1:
 
-- In `/Plone/portal_actions/user/login`. On the `Properties` tab set `URL
-  (Expression)` to `${portal/portal_properties/site_properties/external_login_url}?next=${globals_view/navigationRootUrl}/logged_in`.
+- In ``/Plone/portal_actions/user/login``.
+  On the ``Properties`` tab set ``URL (Expression)`` to ``${portal/portal_properties/site_properties/external_login_url}?next=${globals_view/navigationRootUrl}/logged_in``.
 
 For Plone 4.1 and later you may instead set:
 
-- In `/Plone/portal_properties/site_properties` set `external_login_iframe` to
-  True.
+- In ``/Plone/portal_properties/site_properties`` set ``external_login_iframe`` to true.
 
 Note for developers testing this under Windows XP
 -------------------------------------------------
 
-- IIS may be installed as an additional component using the Windows XP
-  installation CD.
+- IIS may be installed as an additional component using the Windows XP installation CD.
 
 - The IIS management console can be located at::
 
     Start -> Control Panel -> Adminstrative Tools -> Internet Information Services
 
-- The pywin32 installer setup IIS sufficiently for me not to need to follow
-  the `instructions on how to configure Python for IIS`.
+- The pywin32 installer setup IIS sufficiently for me not to need to follow the *instructions on how to configure Python for IIS*.
 
-- I could not find how to setup a separate site, so placed the asp scripts
-  directly in C:\Inetpub\wwwroot - the "Default Web Site"
+- I could not find how to setup a separate site, so placed the asp scripts directly in ``C:\Inetpub\wwwroot`` - the *Default Web Site*
 
-- From the IIS management console, select "Default Web Site". You should see
-  `login.asp` and `test.asp` in the right hand pane. With each file,
-  right-click Properties. On the `File Security` tab click Edit... on
-  `Anonymous access and authentication control`. Uncheck `Anonymous access`
-  and check `Basic authentication` (to be used as a fallback) and `Integrated
-  Windows authentication`.
+- From the IIS management console, select "Default Web Site".
+  You should see ``login.asp`` and ``test.asp`` in the right hand pane.
+  With each file, right-click Properties.
+  On the `File Security` tab click Edit... on ``Anonymous access and authentication control``.
+  Uncheck ``Anonymous access`` and check ``Basic authentication`` (to be used as a fallback) and ``Integrated Windows authentication``.
 
-- Access http://localhost/test.asp to confirm IIS authentication works as
-  expected.
+- Access ``http://localhost/test.asp`` to confirm IIS authentication works as expected.
 
-- Set the secret in `login.asp` and `Manage secrets` of plone.session.
+- Set the secret in ``login.asp`` and ``Manage secrets`` of *plone.session*.
 
-- Set SITE_URL in `login.asp` to `http://localhost:8080/Plone` (or whatever
-  the address of your site is.)
+- Set SITE_URL in ``login.asp`` to ``http://localhost:8080/Plone`` (or whatever the address of your site is).
 
-- Add a Plone user with the same name as your Windows login name (e.g.
-  Administrator), this avoids setting up Active Directory.
+- Add a Plone user with the same name as your Windows login name (e.g. *Administrator*), this avoids setting up Active Directory.
 
-- Follow the section above to configure your Plone site, but set `Login Form`
-  to `http://localhost/login.asp`.
+- Follow the section above to configure your Plone site, but set ``Login Form``  to ``http://localhost/login.asp``.
diff --git a/plone/session/__init__.py b/plone/session/__init__.py
index c081135..e111fe7 100644
--- a/plone/session/__init__.py
+++ b/plone/session/__init__.py
@@ -1,15 +1,18 @@
+# -*- coding: utf-8 -*-
 from AccessControl.Permissions import add_user_folders
+from plone.session.plugins import session
 from Products.PluggableAuthService.PluggableAuthService import \
     registerMultiPlugin
-from plone.session.plugins import session
-
 
 registerMultiPlugin(session.SessionPlugin.meta_type)
 
 
 def initialize(context):
-    context.registerClass(session.SessionPlugin,
-            permission = add_user_folders,
-            constructors = (session.manage_addSessionPluginForm,
-                            session.manage_addSessionPlugin),
-            visibility = None)
+    context.registerClass(
+        session.SessionPlugin,
+        permission=add_user_folders,
+        constructors=(
+            session.manage_addSessionPluginForm,
+            session.manage_addSessionPlugin),
+        visibility=None
+    )
diff --git a/plone/session/configure.zcml b/plone/session/configure.zcml
index ea77bd0..6a4af78 100644
--- a/plone/session/configure.zcml
+++ b/plone/session/configure.zcml
@@ -3,15 +3,17 @@
     xmlns:five="http://namespaces.zope.org/five"
     xmlns:zcml="http://namespaces.zope.org/zcml">
 
-    <five:registerPackage package="." initialize=".initialize" />
+  <five:registerPackage
+      initialize=".initialize"
+      package="."
+  />
 
-    <include package="plone.protect" />
+  <include package="plone.protect" />
+  <include file="resources.zcml" />
 
-    <include file="resources.zcml" />
-
-    <include
-        zcml:condition="installed Products.CMFPlone"
-        file="profiles.zcml"
-        />
+  <include
+      file="profiles.zcml"
+      zcml:condition="installed Products.CMFPlone"
+  />
 
 </configure>
diff --git a/plone/session/interfaces.py b/plone/session/interfaces.py
index e420722..4f836a4 100644
--- a/plone/session/interfaces.py
+++ b/plone/session/interfaces.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from zope.interface import Interface
 
 
diff --git a/plone/session/plugins/__init__.py b/plone/session/plugins/__init__.py
index 792d600..40a96af 100644
--- a/plone/session/plugins/__init__.py
+++ b/plone/session/plugins/__init__.py
@@ -1 +1 @@
-#
+# -*- coding: utf-8 -*-
diff --git a/plone/session/plugins/session.py b/plone/session/plugins/session.py
index 3f70a56..5bcacc4 100644
--- a/plone/session/plugins/session.py
+++ b/plone/session/plugins/session.py
@@ -1,19 +1,22 @@
-from AccessControl.SecurityInfo import ClassSecurityInfo
+# -*- coding: utf-8 -*-
 from AccessControl.requestmethod import postonly
+from AccessControl.SecurityInfo import ClassSecurityInfo
 from App.config import getConfiguration
-from Products.PageTemplates.PageTemplateFile import PageTemplateFile
-from Products.PluggableAuthService.interfaces.plugins \
-        import IExtractionPlugin, IAuthenticationPlugin, \
-                ICredentialsResetPlugin, ICredentialsUpdatePlugin
-from Products.PluggableAuthService.permissions import ManageUsers
-from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
-from Products.PluggableAuthService.utils import classImplements
+from email.Utils import formatdate
 from plone.keyring.interfaces import IKeyManager
 from plone.session import tktauth
 from plone.session.interfaces import ISessionPlugin
-from zope.component import getUtility, queryUtility
+from Products.PageTemplates.PageTemplateFile import PageTemplateFile
+from Products.PluggableAuthService.interfaces.plugins import IAuthenticationPlugin  # noqa
+from Products.PluggableAuthService.interfaces.plugins import ICredentialsResetPlugin  # noqa
+from Products.PluggableAuthService.interfaces.plugins import ICredentialsUpdatePlugin  # noqa
+from Products.PluggableAuthService.interfaces.plugins import IExtractionPlugin
+from Products.PluggableAuthService.permissions import ManageUsers
+from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin
+from zope.component import getUtility
+from zope.component import queryUtility
+from zope.interface import implementer
 
-from email.Utils import formatdate
 import binascii
 import time
 
@@ -29,13 +32,16 @@
 def manage_addSessionPlugin(dispatcher, id, title=None, path='/',
                             REQUEST=None):
     """Add a session plugin."""
-    sp=SessionPlugin(id, title=title, path=path)
+    sp = SessionPlugin(id, title=title, path=path)
     dispatcher._setObject(id, sp)
 
     if REQUEST is not None:
-        REQUEST.response.redirect('%s/manage_workspace?'
-                               'manage_tabs_message=Session+plugin+created.' %
-                               dispatcher.absolute_url())
+        REQUEST.response.redirect(
+            '{0}/manage_workspace?'
+            'manage_tabs_message=Session+plugin+created.'.format(
+                dispatcher.absolute_url()
+            )
+        )
 
 
 def cookie_expiration_date(days):
@@ -43,6 +49,13 @@ def cookie_expiration_date(days):
     return formatdate(expires, usegmt=True)
 
 
+@implementer(
+    ISessionPlugin,
+    IExtractionPlugin,
+    IAuthenticationPlugin,
+    ICredentialsResetPlugin,
+    ICredentialsUpdatePlugin
+)
 class SessionPlugin(BasePlugin):
     """Session authentication plugin.
     """
@@ -54,66 +67,66 @@ class SessionPlugin(BasePlugin):
     cookie_lifetime = 0
     cookie_domain = ''
     mod_auth_tkt = False
-    timeout = 12*60*60 # 12h. Default is 2h in mod_auth_tkt
-    refresh_interval = 1*60*60 # -1 to disable
+    timeout = 12*60*60  # 12h. Default is 2h in mod_auth_tkt
+    refresh_interval = 1*60*60  # -1 to disable
     external_ticket_name = 'ticket'
     secure = False
     _shared_secret = None
 
-    # These mod_auth_tkt options are not yet implemented
-    #ignoreIP = True # you always want this on the public internet
-    #timeoutRefresh = 0 # default is 0.5 in mod_auth_tkt
+    # These mod_auth_tkt options are not yet implemented (by intent)
+    # ignoreIP = True # you always want this on the public internet
+    # timeoutRefresh = 0 # default is 0.5 in mod_auth_tkt
 
     _properties = (
-            {
-                 "id": "timeout",
-                 "label": "Cookie validity timeout (in seconds)",
-                 "type": "int",
-                 "mode": "w",
-             },
-            {
-                 "id": "refresh_interval",
-                 "label": "Refresh interval (in seconds, -1 to disable refresh)",
-                 "type": "int",
-                 "mode": "w",
-             },
-            {
-                 "id": "mod_auth_tkt",
-                 "label": "Use mod_auth_tkt compatible hashing algorithm",
-                 "type": "boolean",
-                 "mode": "w",
-             },
-            {
-                "id": "cookie_name",
-                "label": "Cookie name",
-                "type": "string",
-                "mode": "w",
-            },
-            {
-                "id": "cookie_lifetime",
-                "label": "Cookie lifetime (in days)",
-                "type": "int",
-                "mode": "w",
-            },
-            {
-                 "id": "cookie_domain",
-                 "label": "Cookie domain (blank for default)",
-                 "type": "string",
-                 "mode": "w",
-            },
-            {
-                 "id": "path",
-                 "label": "Cookie path",
-                 "type": "string",
-                 "mode": "w",
-            },
-            {
-                "id": "secure",
-                "label": "Only Send Cookie Over HTTPS",
-                "type": "boolean",
-                "mode": "w",
-            },
-            )
+        {
+            "id": "timeout",
+            "label": "Cookie validity timeout (in seconds)",
+            "type": "int",
+            "mode": "w",
+         },
+        {
+            "id": "refresh_interval",
+            "label": "Refresh interval (in seconds, -1 to disable refresh)",
+            "type": "int",
+            "mode": "w",
+         },
+        {
+            "id": "mod_auth_tkt",
+            "label": "Use mod_auth_tkt compatible hashing algorithm",
+            "type": "boolean",
+            "mode": "w",
+         },
+        {
+           "id": "cookie_name",
+           "label": "Cookie name",
+           "type": "string",
+           "mode": "w",
+        },
+        {
+           "id": "cookie_lifetime",
+           "label": "Cookie lifetime (in days)",
+           "type": "int",
+           "mode": "w",
+        },
+        {
+            "id": "cookie_domain",
+            "label": "Cookie domain (blank for default)",
+            "type": "string",
+            "mode": "w",
+        },
+        {
+            "id": "path",
+            "label": "Cookie path",
+            "type": "string",
+            "mode": "w",
+        },
+        {
+           "id": "secure",
+           "label": "Only Send Cookie Over HTTPS",
+           "type": "boolean",
+           "mode": "w",
+        },
+    )
 
     manage_options = (
         dict(label='Manage secrets', action='manage_secret'),
@@ -121,13 +134,13 @@ class SessionPlugin(BasePlugin):
 
     def __init__(self, id, title=None, path="/"):
         self._setId(id)
-        self.title=title
-        self.path=path
+        self.title = title
+        self.path = path
 
     def _getSigningSecret(self):
         if self._shared_secret is not None:
             return self._shared_secret
-        manager=getUtility(IKeyManager)
+        manager = getUtility(IKeyManager)
         return manager.secret()
 
     # ISessionPlugin implementation
@@ -142,7 +155,7 @@ def _setupSession(self, userid, response, tokens=(), user_data=''):
         self._setCookie(cookie, response)
 
     def _setCookie(self, cookie, response):
-        cookie=binascii.b2a_base64(cookie).rstrip()
+        cookie = binascii.b2a_base64(cookie).rstrip()
         # disable secure cookie in development mode, to ease local testing
         if getConfiguration().debug_mode:
             secure = False
@@ -157,34 +170,36 @@ def _setCookie(self, cookie, response):
 
     # IExtractionPlugin implementation
     def extractCredentials(self, request):
-        creds={}
+        creds = {}
 
-        if not self.cookie_name in request:
+        if self.cookie_name not in request:
             return creds
 
         try:
-            creds["cookie"]=binascii.a2b_base64(request.get(self.cookie_name))
+            creds["cookie"] = binascii.a2b_base64(
+                request.get(self.cookie_name)
+            )
         except binascii.Error:
             # If we have a cookie which is not properly base64 encoded it
             # can not be ours.
             return creds
 
-        creds["source"]="plone.session" # XXX should this be the id?
+        creds["source"] = "plone.session"  # XXX should this be the id?
 
         return creds
 
     # IAuthenticationPlugin implementation
     def authenticateCredentials(self, credentials):
-        if not credentials.get("source", None)=="plone.session":
+        if not credentials.get("source", None) == "plone.session":
             return None
 
-        ticket=credentials["cookie"]
+        ticket = credentials["cookie"]
         ticket_data = self._validateTicket(ticket)
         if ticket_data is None:
             return None
         (digest, userid, tokens, user_data, timestamp) = ticket_data
-        pas=self._getPAS()
-        info=pas._verifyUser(pas.plugins, user_id=userid)
+        pas = self._getPAS()
+        info = pas._verifyUser(pas.plugins, user_id=userid)
         if info is None:
             return None
 
@@ -195,8 +210,13 @@ def _validateTicket(self, ticket, now=None):
         if now is None:
             now = time.time()
         if self._shared_secret is not None:
-            ticket_data = tktauth.validateTicket(self._shared_secret, ticket,
-                timeout=self.timeout, now=now, mod_auth_tkt=self.mod_auth_tkt)
+            ticket_data = tktauth.validateTicket(
+                self._shared_secret,
+                ticket,
+                timeout=self.timeout,
+                now=now,
+                mod_auth_tkt=self.mod_auth_tkt
+            )
         else:
             ticket_data = None
             manager = queryUtility(IKeyManager)
@@ -205,23 +225,28 @@ def _validateTicket(self, ticket, now=None):
             for secret in manager[u"_system"]:
                 if secret is None:
                     continue
-                ticket_data = tktauth.validateTicket(secret, ticket,
-                    timeout=self.timeout, now=now, mod_auth_tkt=self.mod_auth_tkt)
+                ticket_data = tktauth.validateTicket(
+                    secret,
+                    ticket,
+                    timeout=self.timeout,
+                    now=now,
+                    mod_auth_tkt=self.mod_auth_tkt
+                )
                 if ticket_data is not None:
                     break
         return ticket_data
 
     # ICredentialsUpdatePlugin implementation
     def updateCredentials(self, request, response, login, new_password):
-        pas=self._getPAS()
-        info=pas._verifyUser(pas.plugins, login=login)
+        pas = self._getPAS()
+        info = pas._verifyUser(pas.plugins, login=login)
         if info is not None:
             # Only setup a session for users in our own user folder.
             self._setupSession(info["id"], response)
 
     # ICredentialsResetPlugin implementation
     def resetCredentials(self, request, response):
-        response=self.REQUEST["RESPONSE"]
+        response = self.REQUEST["RESPONSE"]
         if self.cookie_domain:
             response.expireCookie(
                 self.cookie_name, path=self.path, domain=self.cookie_domain)
@@ -230,35 +255,39 @@ def resetCredentials(self, request, response):
 
     manage_secret = PageTemplateFile("secret.pt", globals())
 
-    security.declareProtected(ManageUsers, 'manage_clearSecrets')
+    @security.protected(ManageUsers)
     @postonly
     def manage_clearSecrets(self, REQUEST):
         """Clear all secrets from this source. This invalidates all current
         sessions and requires users to login again.
         """
-        manager=getUtility(IKeyManager)
+        manager = getUtility(IKeyManager)
         manager.clear()
         manager.rotate()
         response = REQUEST.response
-        response.redirect('%s/manage_secret?manage_tabs_message=%s' %
-            (self.absolute_url(), 'All+secrets+cleared.'))
+        response.redirect(
+            '%s/manage_secret?manage_tabs_message=%s' %
+            (self.absolute_url(), 'All+secrets+cleared.')
+        )
 
-    security.declareProtected(ManageUsers, 'manage_createNewSecret')
+    @security.protected(ManageUsers)
     @postonly
     def manage_createNewSecret(self, REQUEST):
         """Create a new (signing) secret.
         """
-        manager=getUtility(IKeyManager)
+        manager = getUtility(IKeyManager)
         manager.rotate()
         response = REQUEST.response
-        response.redirect('%s/manage_secret?manage_tabs_message=%s' %
-            (self.absolute_url(), 'New+secret+created.'))
+        response.redirect(
+            '%s/manage_secret?manage_tabs_message=%s' %
+            (self.absolute_url(), 'New+secret+created.')
+        )
 
-    security.declareProtected(ManageUsers, 'haveSharedSecret')
+    @security.protected(ManageUsers)
     def haveSharedSecret(self):
         return self._shared_secret is not None
 
-    security.declareProtected(ManageUsers, 'manage_removeSharedSecret')
+    @security.protected(ManageUsers)
     @postonly
     def manage_removeSharedSecret(self, REQUEST):
         """Clear the shared secret. This invalidates all current sessions and
@@ -266,10 +295,12 @@ def manage_removeSharedSecret(self, REQUEST):
         """
         self._shared_secret = None
         response = REQUEST.response
-        response.redirect('%s/manage_secret?manage_tabs_message=%s' %
-            (self.absolute_url(), 'Shared+secret+removed.'))
+        response.redirect(
+            '%s/manage_secret?manage_tabs_message=%s' %
+            (self.absolute_url(), 'Shared+secret+removed.')
+        )
 
-    security.declareProtected(ManageUsers, 'manage_setSharedSecret')
+    @security.protected(ManageUsers)
     @postonly
     def manage_setSharedSecret(self, REQUEST):
         """Set the shared secret.
@@ -277,16 +308,20 @@ def manage_setSharedSecret(self, REQUEST):
         secret = REQUEST.get('shared_secret')
         response = REQUEST.response
         if not secret:
-            response.redirect('%s/manage_secret?manage_tabs_message=%s' %
-                (self.absolute_url(), 'Shared+secret+must+not+be+blank.'))
+            response.redirect(
+                '%s/manage_secret?manage_tabs_message=%s' %
+                (self.absolute_url(), 'Shared+secret+must+not+be+blank.')
+            )
             return
         self._shared_secret = secret
-        response.redirect('%s/manage_secret?manage_tabs_message=%s' %
-            (self.absolute_url(), 'New+shared+secret+set.'))
+        response.redirect(
+            '%s/manage_secret?manage_tabs_message=%s' %
+            (self.absolute_url(), 'New+shared+secret+set.')
+        )
 
     def _refreshSession(self, request, now=None):
         # Refresh a ticket. Does *not* check the user is in the use folder
-        if not self.cookie_name in request:
+        if self.cookie_name not in request:
             return None
         try:
             ticket = binascii.a2b_base64(request.get(self.cookie_name))
@@ -313,12 +348,8 @@ def _refresh_content(self, REQUEST):
         elif type == 'js':
             setHeader('Content-Type', 'text/javascript')
             return ""
-        #if content:
-        #    return "still_logged_in = still_logged_in;\n"
-        #else:
-        #    return "still_logged_in = false;\n"
 
-    security.declarePublic('refresh')
+    @security.public
     def refresh(self, REQUEST):
         """Refresh the cookie"""
         setHeader = REQUEST.response.setHeader
@@ -330,23 +361,28 @@ def refresh(self, REQUEST):
         refreshed = self._refreshSession(REQUEST, now)
         if not refreshed:
             # We have an unauthenticated user
-            setHeader('Cache-Control', 'public, must-revalidate, max-age=%d, s-max-age=86400' % self.refresh_interval)
+            setHeader(
+                'Cache-Control',
+                'public, must-revalidate, max-age=%d, s-max-age=86400' %
+                self.refresh_interval
+            )
             setHeader('Vary', 'Cookie')
         else:
-            setHeader('Cache-Control', 'private, must-revalidate, proxy-revalidate, max-age=%d, s-max-age=0' % self.refresh_interval)
+            setHeader(
+                'Cache-Control',
+                'private, must-revalidate, proxy-revalidate, max-age=%d, '
+                's-max-age=0' % self.refresh_interval)
         return self._refresh_content(REQUEST)
 
-    security.declarePublic('remove')
+    @security.public
     def remove(self, REQUEST):
         """Remove the cookie"""
         self.resetCredentials(REQUEST, REQUEST.response)
         setHeader = REQUEST.response.setHeader
         # Disable HTTP 1.0 Caching
         setHeader('Expires', formatdate(0, usegmt=True))
-        setHeader('Cache-Control', 'public, must-revalidate, max-age=0, s-max-age=86400')
+        setHeader(
+            'Cache-Control',
+            'public, must-revalidate, max-age=0, s-max-age=86400'
+        )
         return self._refresh_content(REQUEST)
-
-
-classImplements(SessionPlugin, ISessionPlugin,
-                IExtractionPlugin, IAuthenticationPlugin,
-                ICredentialsResetPlugin, ICredentialsUpdatePlugin)
diff --git a/plone/session/profiles.zcml b/plone/session/profiles.zcml
index dcdce44..01aec3d 100644
--- a/plone/session/profiles.zcml
+++ b/plone/session/profiles.zcml
@@ -1,13 +1,13 @@
 <configure
-    xmlns="http://namespaces.zope.org/genericsetup"
-    i18n_domain="plone">
+    i18n_domain="plone"
+    xmlns="http://namespaces.zope.org/genericsetup">
 
-    <registerProfile
-        name="default"
-        title="Session refresh support"
-        directory="profiles/default"
-        description="Optional plone.session refresh support."
-        provides="Products.GenericSetup.interfaces.EXTENSION"
-        />
+  <registerProfile
+      description="Optional plone.session refresh support."
+      directory="profiles/default"
+      name="default"
+      provides="Products.GenericSetup.interfaces.EXTENSION"
+      title="Session refresh support"
+  />
 
 </configure>
diff --git a/plone/session/resources.zcml b/plone/session/resources.zcml
index 5ea96da..a940585 100644
--- a/plone/session/resources.zcml
+++ b/plone/session/resources.zcml
@@ -1,8 +1,8 @@
 <configure xmlns="http://namespaces.zope.org/browser">
 
-    <resource
-        name="plone.session.refreshsupport.js"
-        file="resources/refreshsupport.js"
-        />
+  <resource
+      file="resources/refreshsupport.js"
+      name="plone.session.refreshsupport.js"
+  />
 
 </configure>
diff --git a/plone/session/tktauth.py b/plone/session/tktauth.py
index 6e56be6..e5f8989 100755
--- a/plone/session/tktauth.py
+++ b/plone/session/tktauth.py
@@ -46,7 +46,9 @@
 We will create a mod_auth_tkt compatible ticket. In the simplest case no extra
 data is supplied.
 
-  >>> tkt = createTicket(SECRET, userid, timestamp=timestamp, mod_auth_tkt=True)
+  >>> tkt = createTicket(
+  ...     SECRET, userid, timestamp=timestamp, mod_auth_tkt=True
+  ... )
   >>> tkt
   'c7c7300ac5cf529656444123aca345294885afa0jbloggs!'
 
@@ -77,14 +79,18 @@
 We will validate it an hour after it was created:
 
   >>> NOW = timestamp + 60*60
-  >>> data = validateTicket(SECRET, tkt, timeout=TIMEOUT, now=NOW, mod_auth_tkt=True)
+  >>> data = validateTicket(
+  ...     SECRET, tkt, timeout=TIMEOUT, now=NOW, mod_auth_tkt=True
+  ... )
   >>> data is not None
   True
 
 After the timeout the ticket is no longer valid
 
   >>> LATER = NOW + TIMEOUT
-  >>> data = validateTicket(SECRET, tkt, timeout=TIMEOUT, now=LATER, mod_auth_tkt=True)
+  >>> data = validateTicket(
+  ...     SECRET, tkt, timeout=TIMEOUT, now=LATER, mod_auth_tkt=True
+  ... )
   >>> data is not None
   False
 
@@ -98,13 +104,18 @@
 
   >>> user_data = 'Joe Bloggs'
   >>> tokens = ['foo', 'bar']
-  >>> tkt = createTicket(SECRET, userid, tokens, user_data, timestamp=timestamp, mod_auth_tkt=True)
+  >>> tkt = createTicket(
+  ...     SECRET, userid, tokens, user_data, timestamp=timestamp,
+  ...     mod_auth_tkt=True
+  ... )
   >>> tkt
   'eea3630e98177bdbf0e7f803e1632b7e4885afa0jbloggs!foo,bar!Joe Bloggs'
   >>> cookie['auth_tkt'] = binascii.b2a_base64(tkt).strip()
   >>> print cookie
   Set-Cookie: auth_tkt=ZWVhMzYzMGU5ODE3N2JkYmYwZTdmODAzZTE2MzJiN2U0ODg1YWZh...
-  >>> data = validateTicket(SECRET, tkt, timeout=TIMEOUT, now=NOW, mod_auth_tkt=True)
+  >>> data = validateTicket(
+  ...     SECRET, tkt, timeout=TIMEOUT, now=NOW, mod_auth_tkt=True
+  ... )
   >>> data
   ('eea3630e98177bdbf0e7f803e1632b7e', 'jbloggs', ('foo', 'bar'), 'Joe Bloggs', 1216720800)
 
@@ -148,7 +159,8 @@ def mod_auth_tkt_digest(secret, data1, data2):
     return digest
 
 
-def createTicket(secret, userid, tokens=(), user_data='', ip='0.0.0.0', timestamp=None, encoding='utf-8', mod_auth_tkt=False):
+def createTicket(secret, userid, tokens=(), user_data='', ip='0.0.0.0',
+                 timestamp=None, encoding='utf-8', mod_auth_tkt=False):
     """
     By default, use a more compatible
     """
@@ -193,7 +205,7 @@ def splitTicket(ticket, encoding=None):
     remainder = ticket[40:]
     if not val:
         raise ValueError
-    timestamp = int(val, 16) # convert from hexadecimal+
+    timestamp = int(val, 16)  # convert from hexadecimal+
 
     if encoding is not None:
         remainder = remainder.decode(encoding)
@@ -218,8 +230,16 @@ def validateTicket(secret, ticket, ip='0.0.0.0', timeout=0, now=None,
             splitTicket(ticket)
     except ValueError:
         return None
-    new_ticket = createTicket(secret, userid, tokens,
-        user_data, ip, timestamp, encoding, mod_auth_tkt)
+    new_ticket = createTicket(
+        secret,
+        userid,
+        tokens,
+        user_data,
+        ip,
+        timestamp,
+        encoding,
+        mod_auth_tkt
+    )
     if is_equal(new_ticket[:32], digest):
         if not timeout:
             return data
@@ -233,7 +253,9 @@ def validateTicket(secret, ticket, ip='0.0.0.0', timeout=0, now=None,
 # doctest runner
 def _test():
     import doctest
-    doctest.testmod(optionflags=doctest.ELLIPSIS + doctest.NORMALIZE_WHITESPACE)
+    doctest.testmod(
+        optionflags=doctest.ELLIPSIS + doctest.NORMALIZE_WHITESPACE
+    )
 
 if __name__ == "__main__":
     _test()
diff --git a/setup.py b/setup.py
index 1983d83..41b17b1 100644
--- a/setup.py
+++ b/setup.py
@@ -1,46 +1,51 @@
-from setuptools import setup, find_packages
+# -*- coding: utf-8 -*-
+from setuptools import find_packages
+from setuptools import setup
 
 version = '3.5.6.dev0'
+longdescription = open("README.rst").read()
+longdescription += '\n'
+longdescription += open("CHANGES.rst").read()
 
-setup(name='plone.session',
-      version=version,
-      description="Session based authentication for Zope",
-      long_description=open("README.rst").read() + "\n" +
-                       open("CHANGES.rst").read(),
-      classifiers=[
-          "Environment :: Web Environment",
-          "Framework :: Plone",
-          "Framework :: Plone :: 4.3",
-          "Framework :: Plone :: 5.0",
-          "Framework :: Zope2",
-          "License :: OSI Approved :: BSD License",
-          "Operating System :: OS Independent",
-          "Programming Language :: Python",
-          "Programming Language :: Python :: 2.7",
-          "Topic :: System :: Systems Administration :: Authentication/Directory",
-        ],
-      keywords='PAS session authentication Zope',
-      author='Plone Foundation',
-      author_email='plone-developers@lists.sourceforge.net',
-      url='http://pypi.python.org/pypi/plone.session',
-      license='BSD',
-      packages=find_packages(exclude=['ez_setup']),
-      namespace_packages=['plone'],
-      include_package_data=True,
-      zip_safe=False,
-      extras_require=dict(
-        test=[
-            'zope.configuration',
-            'zope.publisher',
-        ]
-      ),
-      install_requires=[
-        'setuptools',
-        'plone.keyring',
-        'plone.protect',
-        'zope.component',
-        'zope.interface',
-        'Products.PluggableAuthService',
-        'Zope2',
-      ],
-      )
+setup(
+    name='plone.session',
+    version=version,
+    description="Session based auth tkt authentication for Zope",
+    long_description=longdescription,
+    classifiers=[
+        "Environment :: Web Environment",
+        "Framework :: Plone :: 4.3",
+        "Framework :: Plone :: 5.0",
+        "Framework :: Plone",
+        "Framework :: Zope2",
+        "License :: OSI Approved :: BSD License",
+        "Operating System :: OS Independent",
+        "Programming Language :: Python :: 2.7",
+        "Programming Language :: Python",
+        "Topic :: System :: Systems Administration :: Authentication/Directory",  # noqa
+    ],
+    keywords='PAS session authentication Zope auth_tkt',
+    author='Plone Foundation',
+    author_email='plone-developers@lists.sourceforge.net',
+    url='http://pypi.python.org/pypi/plone.session',
+    license='BSD',
+    packages=find_packages(exclude=['ez_setup']),
+    namespace_packages=['plone'],
+    include_package_data=True,
+    zip_safe=False,
+    extras_require=dict(
+      test=[
+          'zope.configuration',
+          'zope.publisher',
+      ]
+    ),
+    install_requires=[
+      'plone.keyring',
+      'plone.protect',
+      'Products.PluggableAuthService',
+      'setuptools',
+      'zope.component',
+      'zope.interface',
+      'Zope2',
+    ],
+)


