Repository: plone.app.theming


Branch: refs/heads/master
Date: 2015-07-09T08:20:55-05:00
Author: Guido A.J. Stevens (gyst) <guido.stevens@cosent.nl>
Commit: https://github.com/plone/plone.app.theming/commit/3756dbd45db394f112fae9ff25a532934013e1b5

Introduce policy API that makes theme switching possible

Files changed:
A src/plone/app/theming/policy.py
A src/plone/app/theming/tests/test_policy.py
M src/plone/app/theming/browser/mapper.py
M src/plone/app/theming/configure.zcml
M src/plone/app/theming/interfaces.py
M src/plone/app/theming/plugins/hooks.py
M src/plone/app/theming/transform.py
M src/plone/app/theming/traversal.py
M src/plone/app/theming/utils.py

diff --git a/src/plone/app/theming/browser/mapper.py b/src/plone/app/theming/browser/mapper.py
index 16a8888..03d3ffd 100644
--- a/src/plone/app/theming/browser/mapper.py
+++ b/src/plone/app/theming/browser/mapper.py
@@ -7,16 +7,15 @@
 from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
 from Products.statusmessages.interfaces import IStatusMessage
 from diazo.utils import quote_param
-from plone.app.theming.interfaces import IThemeSettings
 from plone.app.theming.interfaces import RULE_FILENAME
 from plone.app.theming.interfaces import THEME_EXTENSIONS
 from plone.app.theming.interfaces import THEME_RESOURCE_NAME
 from plone.app.theming.utils import compileThemeTransform
 from plone.app.theming.utils import findContext
-from plone.app.theming.utils import getCurrentTheme
 from plone.app.theming.utils import getPortal
 from plone.app.theming.utils import getThemeFromResourceDirectory
 from plone.app.theming.utils import prepareThemeParameters
+from plone.app.theming.utils import theming_policy
 from plone.memoize import view
 from plone.registry.interfaces import IRegistry
 from plone.resource.interfaces import IWritableResourceDirectory
@@ -73,7 +72,7 @@ def setup(self):
             self.name
         )
         self.themeBasePathEncoded = urllib.quote_plus(self.themeBasePath)
-        self.themeBaseUrl = '/'.join([self.portalUrl, self.themeBasePath]) 
+        self.themeBaseUrl = '/'.join([self.portalUrl, self.themeBasePath])
 
         try:
             registry = getUtility(IRegistry)
@@ -88,12 +87,14 @@ def setup(self):
         )
 
         if self.editable:
-            self.resourceUrl = self.resourceDirectory.context.absolute_url() 
+            self.resourceUrl = self.resourceDirectory.context.absolute_url()
         else:
             self.resourceUrl = None
 
-        settings = getUtility(IRegistry).forInterface(IThemeSettings, False)
-        self.active = (settings.enabled and self.name == getCurrentTheme())
+        policy = theming_policy(self.request)
+        settings = policy.getSettings()
+        self.active = (settings.enabled
+                       and self.name == policy.getCurrentTheme())
 
         self.rulesFileName = RULE_FILENAME
 
@@ -230,8 +231,8 @@ def getFrame(self):
             self.request.response.setHeader('X-Theme-Disabled', '1')
             themeInfo = getThemeFromResourceDirectory(self.context)
 
-            registry = getUtility(IRegistry)
-            settings = registry.forInterface(IThemeSettings, False)
+            policy = theming_policy(self.request)
+            settings = policy.getSettings()
 
             context = self.context
             try:
diff --git a/src/plone/app/theming/configure.zcml b/src/plone/app/theming/configure.zcml
index 4a6bbd8..28e1d7a 100644
--- a/src/plone/app/theming/configure.zcml
+++ b/src/plone/app/theming/configure.zcml
@@ -59,7 +59,21 @@
     <subscriber
         for=".interfaces.IThemeSettings
               plone.registry.interfaces.IRecordModifiedEvent"
-        handler=".transform.invalidateCache"
+        handler=".policy.invalidateCache"
+        />
+
+    <!-- policy adapter
+         You can plug in a custom adapter by registering it for your own layer
+         eg for="your.product.interfaces.IThemeSwitcher".  -->
+    <adapter
+        factory=".policy.ThemingPolicy"
+        for="zope.publisher.interfaces.IRequest"
+        />
+    <!-- fallback default policy adapter
+         Do not override this, it is used by applyTheme -->
+    <adapter
+        factory=".policy.ThemingPolicy"
+        for="plone.app.theming.interfaces.INoRequest"
         />
 
     <!-- Set X-Theme-Enabled header in the request if theming is enabled -->
diff --git a/src/plone/app/theming/interfaces.py b/src/plone/app/theming/interfaces.py
index 9cfb1f0..ae8e1ec 100644
--- a/src/plone/app/theming/interfaces.py
+++ b/src/plone/app/theming/interfaces.py
@@ -231,3 +231,39 @@ def onRequest(request, theme, settings, dependenciesSettings):
 
 class IThemeAppliedEvent(Interface):
     theme = Attribute('theme that is getting applied')
+
+
+class INoRequest(Interface):
+    """Fallback to enable querying for the policy adapter
+    even in the absence of a proper IRequest."""
+
+
+class IThemingPolicy(Interface):
+    """An adapter on request that provides access to the current
+    theme and theme settings.
+    """
+
+    def getSettings():
+        """Settings for current theme."""
+
+    def getCurrentTheme():
+        """The name of the current theme."""
+
+    def isThemeEnabled():
+        """Whether theming is enabled."""
+
+    def getCache(theme=None):
+        """Managing the cache is a policy decision."""
+
+    def getCacheKey(theme=None):
+        """Managing the cache is a policy decision."""
+
+    def invalidateCache():
+        """When our settings are changed, invalidate the cache on all zeo clients.
+        """
+
+    def get_theme():
+        """Returns the current theme object, cached."""
+
+    def set_theme(themeName, themeObj):
+        """Update the theme cache."""
diff --git a/src/plone/app/theming/plugins/hooks.py b/src/plone/app/theming/plugins/hooks.py
index 8fa461f..93b0c6b 100644
--- a/src/plone/app/theming/plugins/hooks.py
+++ b/src/plone/app/theming/plugins/hooks.py
@@ -2,8 +2,7 @@
 from plone.app.theming.interfaces import THEME_RESOURCE_NAME
 from plone.app.theming.plugins.utils import getPluginSettings
 from plone.app.theming.plugins.utils import getPlugins
-from plone.app.theming.utils import getCurrentTheme
-from plone.app.theming.utils import isThemeEnabled
+from plone.app.theming.utils import theming_policy
 from plone.resource.utils import iterDirectoriesOfType
 from plone.resource.utils import queryResourceDirectory
 
@@ -29,11 +28,12 @@ def onRequest(object, event):
     """
 
     request = event.request
+    policy = theming_policy(request)
 
-    if not isThemeEnabled(request):
+    if not policy.isThemeEnabled():
         return
 
-    theme = getCurrentTheme()
+    theme = policy.getCurrentTheme()
     if theme is None:
         return
 
diff --git a/src/plone/app/theming/policy.py b/src/plone/app/theming/policy.py
new file mode 100644
index 0000000..900e773
--- /dev/null
+++ b/src/plone/app/theming/policy.py
@@ -0,0 +1,191 @@
+# -*- coding: utf-8 -*-
+import Globals
+from logging import getLogger
+import threading
+import time
+
+from plone.registry.interfaces import IRegistry
+from zope.component import queryUtility
+from zope.component.hooks import getSite
+from zope.interface import implementer
+from zope.publisher.interfaces import IRequest
+
+from plone.app.theming.interfaces import IThemingPolicy
+from plone.app.theming.interfaces import IThemeSettings
+from plone.app.theming import utils
+
+log = getLogger(__name__)
+_local_cache = threading.local()
+
+
+def invalidateCache(settings, event):
+    """Event handler for registry change"""
+    utils.theming_policy().invalidateCache()
+
+
+@implementer(IThemingPolicy)
+class ThemingPolicy(object):
+
+    def __init__(self, request):
+        """Adapt IRequest.
+        Do not call this class directly, always use a
+        utils.theming_policy(request) adapter lookup.
+
+        This enables overriding of the IThemingPolicy adapter
+        via ZCML by integrators.
+
+        When used as INoRequest adapter, returns the default policy.
+        """
+        if IRequest.providedBy(request):
+            self.request = request
+        else:
+            self.request = None
+
+    def getSettings(self):
+        """Settings for current theme."""
+        registry = queryUtility(IRegistry)
+        if registry is None:
+            return None
+        try:
+            settings = registry.forInterface(IThemeSettings, False)
+        except KeyError:
+            return None
+        return settings
+
+    def getCurrentTheme(self):
+        """The name of the current theme."""
+        settings = self.getSettings()
+        if not settings.rules:
+            return None
+        if settings.currentTheme:
+            return settings.currentTheme
+
+        # BBB: If currentTheme isn't set, look for a theme with a rules file
+        # matching that of the current theme
+        for theme in utils.getAvailableThemes():
+            if theme.rules == settings.rules:
+                return theme.__name__
+
+        return None
+
+    def isThemeEnabled(self, settings=None):
+        """Whether theming is enabled."""
+
+        # Resolve DevelopmentMode late (i.e. not on import time) since it may
+        # be set during import or test setup time
+        DevelopmentMode = Globals.DevelopmentMode
+
+        # Disable theming if the response sets a header
+        if self.request.response.getHeader('X-Theme-Disabled'):
+            return False
+
+        # Check for diazo.off request parameter
+        true_vals = ('1', 'y', 'yes', 't', 'true')
+        if (DevelopmentMode and self.request.get(
+                'diazo.off', '').lower() in true_vals):
+            return False
+
+        if not settings:
+            settings = self.getSettings()
+        if not settings.enabled or not settings.rules:
+            return False
+
+        server_url = self.request.get('SERVER_URL')
+        proto, host = server_url.split('://', 1)
+        host = host.lower()
+        serverPort = self.request.get('SERVER_PORT')
+
+        for hostname in settings.hostnameBlacklist or ():
+            if host == hostname or host == ':'.join((hostname, serverPort)):
+                return False
+
+        return True
+
+    def getCache(self, theme=None):
+        """Managing the cache is a policy decision."""
+        caches = self.getCacheStorage()
+        key = self.getCacheKey(theme)
+        cache = caches.get(key)
+        if cache is None:
+            log.info("initializing local cache on thread %s for %s",
+                     threading.current_thread().ident, key)
+            cache = caches[key] = ThemeCache()
+        return cache
+
+    def getCacheKey(self, theme=None):
+        if not theme:
+            theme = self.getCurrentTheme()
+        key = "%s::%s" % (getSite().absolute_url(), theme)
+        return key
+
+    def getCacheStorage(self):
+        if not hasattr(_local_cache, 'themedata'):
+            self._reset_local_cache()
+        if self._get_shared_invalidation() > _local_cache.themedata['mtime']:
+            log.info("shared invalidation requires local cache reset on %s",
+                     threading.current_thread().ident)
+            self._reset_local_cache()
+        return _local_cache.themedata
+
+    def invalidateCache(self):
+        """When our settings are changed, invalidate the cache on all zeo clients
+        """
+        log.info("invalidating cache across all threads and processes")
+        self._reset_local_cache()
+        self._set_shared_invalidation()
+
+    def _reset_local_cache(self):
+        """
+        Invalidate only the local thread cache
+        Removes actual theme data, leaving only mtime
+        """
+        _local_cache.themedata = {'mtime': time.time()}
+        log.info("local cache invalidated on thread %s",
+                 threading.current_thread().ident)
+
+    def _set_shared_invalidation(self):
+        """Signal to other threads and processes they should invalidate their
+        theme caches."""
+        registry = queryUtility(IRegistry)
+        setattr(registry, '_theme_cache_mtime', time.time())
+        registry._p_changed = True
+        log.info("shared cache invalidation marker updated")
+
+    def _get_shared_invalidation(self):
+        registry = queryUtility(IRegistry)
+        return getattr(registry, '_theme_cache_mtime', 0)
+
+    def get_theme(self):
+        """Managing the theme cache is a plone.app.theming policy
+        decision. Moved out out Products.CMFPlone."""
+        cache = self.getCache()
+        themeObj = cache.themeObj
+        if not themeObj:
+            theme = self.getCurrentTheme()
+            themeObj = utils.getTheme(theme)
+            self.set_theme(theme, themeObj)
+        return themeObj
+
+    def set_theme(self, themeName, themeObj):
+        """Update the theme cache"""
+        cache = self.getCache(themeName)
+        cache.updateTheme(themeObj)
+
+
+class ThemeCache(object):
+    """Simple cache for the transform and theme
+    """
+
+    def __init__(self):
+        self.transform = None
+        self.expressions = None
+        self.themeObj = None
+
+    def updateTransform(self, transform):
+        self.transform = transform
+
+    def updateExpressions(self, expressions):
+        self.expressions = expressions
+
+    def updateTheme(self, themeObj):
+        self.themeObj = themeObj
diff --git a/src/plone/app/theming/tests/test_policy.py b/src/plone/app/theming/tests/test_policy.py
new file mode 100644
index 0000000..258f5c4
--- /dev/null
+++ b/src/plone/app/theming/tests/test_policy.py
@@ -0,0 +1,131 @@
+# -*- coding: utf-8 -*-
+import time
+import multiprocessing
+import threading
+import transaction
+import unittest2 as unittest
+
+from plone.registry.interfaces import IRegistry
+from zope.component import queryUtility
+
+from plone.app.theming.testing import THEMING_FUNCTIONAL_TESTING
+from plone.app.theming.utils import theming_policy
+
+
+class TestFunctional(unittest.TestCase):
+
+    layer = THEMING_FUNCTIONAL_TESTING
+
+    def tearDown(self):
+        request = self.layer['request']
+        policy = theming_policy(request)
+        # static class attribute is cached across test runs
+        policy.invalidateCache()
+
+    def test_getSettings(self):
+        request = self.layer['request']
+        policy = theming_policy(request)
+        settings = policy.getSettings()
+        self.assertEqual(settings.currentTheme,
+                         u'barceloneta')
+        self.assertEqual(settings.rules,
+                         u'/++theme++barceloneta/rules.xml')
+
+    def test_getCurrentTheme(self):
+        request = self.layer['request']
+        policy = theming_policy(request)
+        self.assertEqual(policy.getCurrentTheme(),
+                         u'barceloneta')
+
+    def test_isThemeEnabled(self):
+        request = self.layer['request']
+        policy = theming_policy(request)
+        self.assertTrue(policy.isThemeEnabled())
+
+    def test_isThemeEnabled_blacklist(self):
+        request = self.layer['request']
+        request.set('BASE1', 'http://nohost/path/to/site')
+        policy = theming_policy(request)
+        settings = policy.getSettings()
+        # Should pay no attention to BASE1 and only use SERVER_URL
+        settings.hostnameBlacklist.append('nohost')
+        self.assertFalse(policy.isThemeEnabled())
+
+    def test_getCache(self):
+        request = self.layer['request']
+        policy = theming_policy(request)
+        cache = policy.getCache()
+        self.assertEqual(cache.themeObj, None)
+
+    def test_getCacheKey(self):
+        request = self.layer['request']
+        policy = theming_policy(request)
+        self.assertEqual(policy.getCacheKey(),
+                         u'http://nohost/plone::barceloneta')
+
+    def test_getCacheStorage(self):
+        request = self.layer['request']
+        policy = theming_policy(request)
+        self.assertEqual(policy.getCacheStorage().keys(), ['mtime'])
+        cache = policy.getCache()
+        storage = policy.getCacheStorage()
+        self.assertEqual(
+            [(k, v) for (k, v) in storage.items() if k != 'mtime'],
+            [(u'http://nohost/plone::barceloneta', cache)])
+
+    def test_caching(self):
+        """roundtrip"""
+        request = self.layer['request']
+        policy = theming_policy(request)
+        theme = policy.get_theme()
+        cache = policy.getCache()
+        storage = policy.getCacheStorage()
+        self.assertEqual(
+            [(k, v) for (k, v) in storage.items() if k != 'mtime'],
+            [(u'http://nohost/plone::barceloneta', cache)])
+        self.assertEqual(cache.themeObj, theme)
+        policy.set_theme(u'barceloneta', 'faketheme')
+        self.assertEqual(policy.get_theme(), 'faketheme')
+        policy.invalidateCache()
+        self.assertEqual(policy.getCacheStorage().keys(), ['mtime'])
+        theme2 = policy.get_theme()
+        # different objects but both are barceloneta
+        self.assertEqual(theme.title, theme2.title)
+
+    def test_invalidateCache_locally(self):
+        """Poor man's IPC - verify within same thread"""
+        request = self.layer['request']
+        policy = theming_policy(request)
+        cache = policy.getCache()
+        storage = policy.getCacheStorage()
+        self.assertEqual(
+            [(k, v) for (k, v) in storage.items() if k != 'mtime'],
+            [(u'http://nohost/plone::barceloneta', cache)])
+        shared_mtime_1 = policy._get_shared_invalidation()
+        policy.invalidateCache()
+        shared_mtime_2 = policy._get_shared_invalidation()
+        self.assertTrue(shared_mtime_2 > shared_mtime_1)
+
+    def test_invalidateCache_threaded(self):
+        """Poor man's IPC - verify in other thread"""
+        request = self.layer['request']
+        policy = theming_policy(request)
+        cache = policy.getCache()
+        storage = policy.getCacheStorage()
+        self.assertEqual(
+            [(k, v) for (k, v) in storage.items() if k != 'mtime'],
+            [(u'http://nohost/plone::barceloneta', cache)])
+        shared_mtime_1 = policy._get_shared_invalidation()
+
+        def invalidate(registry):
+            setattr(registry, '_theme_cache_mtime', time.time())
+            registry._p_modified = True
+            transaction.commit()
+
+        registry = queryUtility(IRegistry)
+        t = threading.Thread(target=invalidate, args=(registry, ))
+        t.start()
+        t.join(5.0)
+
+        shared_mtime_2 = policy._get_shared_invalidation()
+        self.assertTrue(shared_mtime_2 > shared_mtime_1)
diff --git a/src/plone/app/theming/transform.py b/src/plone/app/theming/transform.py
index 5ac54a6..9e214df 100644
--- a/src/plone/app/theming/transform.py
+++ b/src/plone/app/theming/transform.py
@@ -1,19 +1,15 @@
 # -*- coding: utf-8 -*-
 from lxml import etree
-from plone.app.theming.interfaces import IThemeSettings
 from plone.app.theming.interfaces import IThemingLayer
 from plone.app.theming.utils import compileThemeTransform
 from plone.app.theming.utils import findContext
 from plone.app.theming.utils import getParser
-from plone.app.theming.utils import isThemeEnabled
 from plone.app.theming.utils import prepareThemeParameters
+from plone.app.theming.utils import theming_policy
 from plone.app.theming.zmi import patch_zmi
-from plone.registry.interfaces import IRegistry
 from plone.transformchain.interfaces import ITransform
 from repoze.xmliter.utils import getHTMLSerializer
 from zope.component import adapter
-from zope.component import queryUtility
-from zope.component.hooks import getSite
 from zope.interface import Interface
 from zope.interface import implementer
 import Globals
@@ -25,46 +21,6 @@
 LOGGER = logging.getLogger('plone.app.theming')
 
 
-class _Cache(object):
-    """Simple cache for the transform
-    """
-
-    def __init__(self):
-        self.transform = None
-        self.expressions = None
-
-    def updateTransform(self, transform):
-        self.transform = transform
-
-    def updateExpressions(self, expressions):
-        self.expressions = expressions
-
-
-def getCache(settings):
-    # We need a persistent object to hang a _v_ attribute off for caching.
-
-    registry = settings.__registry__
-    caches = getattr(registry, '_v_plone_app_theming_caches', None)
-    if caches is None:
-        caches = registry._v_plone_app_theming_caches = {}
-
-    key = getSite().absolute_url()
-
-    cache = caches.get(key)
-    if cache is None:
-        cache = caches[key] = _Cache()
-    return cache
-
-
-def invalidateCache(settings, event):
-    """When our settings are changed, invalidate the cache on all zeo clients
-    """
-    registry = settings.__registry__
-    registry._p_changed = True
-    if hasattr(registry, '_v_plone_app_theming_caches'):
-        del registry._v_plone_app_theming_caches
-
-
 @implementer(ITransform)
 @adapter(Interface, IThemingLayer)
 class ThemeTransform(object):
@@ -79,19 +35,19 @@ def __init__(self, published, request):
         self.request = request
 
     def setupTransform(self, runtrace=False):
-        request = self.request
         DevelopmentMode = Globals.DevelopmentMode
+        policy = theming_policy(self.request)
 
         # Obtain settings. Do nothing if not found
-        settings = self.getSettings()
+        settings = policy.getSettings()
 
         if settings is None:
             return None
 
-        if not isThemeEnabled(request, settings):
+        if not policy.isThemeEnabled():
             return None
 
-        cache = getCache(settings)
+        cache = policy.getCache()
 
         # Apply theme
         transform = None
@@ -121,16 +77,7 @@ def setupTransform(self, runtrace=False):
         return transform
 
     def getSettings(self):
-        registry = queryUtility(IRegistry)
-        if registry is None:
-            return None
-
-        try:
-            settings = registry.forInterface(IThemeSettings, False)
-        except KeyError:
-            return None
-
-        return settings
+        return theming_policy(self.request).getSettings()
 
     def parseTree(self, result):
         contentType = self.request.response.getHeader('Content-Type')
@@ -157,10 +104,11 @@ def transformIterable(self, result, encoding):
         """Apply the transform if required
         """
         # Obtain settings. Do nothing if not found
-        settings = self.getSettings()
+        policy = theming_policy(self.request)
+        settings = policy.getSettings()
         if settings is None:
             return None
-        if not isThemeEnabled(self.request, settings):
+        if not policy.isThemeEnabled():
             return None
         result = self.parseTree(result)
         if result is None:
@@ -187,7 +135,7 @@ def transformIterable(self, result, encoding):
 
             cache = None
             if not DevelopmentMode:
-                cache = getCache(settings)
+                cache = policy.getCache()
 
             parameterExpressions = settings.parameterExpressions or {}
             params = prepareThemeParameters(
diff --git a/src/plone/app/theming/traversal.py b/src/plone/app/theming/traversal.py
index beb73b6..4e1329d 100644
--- a/src/plone/app/theming/traversal.py
+++ b/src/plone/app/theming/traversal.py
@@ -1,11 +1,9 @@
 # -*- coding: utf-8 -*-
-from plone.app.theming.interfaces import IThemeSettings
 from plone.app.theming.interfaces import THEME_RESOURCE_NAME
-from plone.registry.interfaces import IRegistry
+from plone.app.theming.utils import theming_policy
 from plone.resource.traversal import ResourceTraverser
 from plone.resource.utils import queryResourceDirectory
 from zExceptions import NotFound
-from zope.component import getUtility
 import urllib
 
 
@@ -22,9 +20,7 @@ def __init__(self, context, request=None):
         self.context = context
 
     def current_theme(self):
-        registry = getUtility(IRegistry)
-        settings = registry.forInterface(IThemeSettings)
-        return settings.currentTheme
+        return theming_policy(self.request).getCurrentTheme()
 
     def traverse(self, name, remaining):
         if name == '':
diff --git a/src/plone/app/theming/utils.py b/src/plone/app/theming/utils.py
index 9fe505d..0e40ec0 100644
--- a/src/plone/app/theming/utils.py
+++ b/src/plone/app/theming/utils.py
@@ -8,8 +8,8 @@
 from diazo.compiler import compile_theme
 from diazo.compiler import quote_param
 from lxml import etree
-from plone.app.theming.events import ThemeAppliedEvent
-from plone.app.theming.interfaces import IThemeSettings
+from plone.app.theming.interfaces import IThemingPolicy
+from plone.app.theming.interfaces import INoRequest
 from plone.app.theming.interfaces import MANIFEST_FORMAT
 from plone.app.theming.interfaces import RULE_FILENAME
 from plone.app.theming.interfaces import THEME_RESOURCE_NAME
@@ -17,7 +17,6 @@
 from plone.app.theming.plugins.utils import getPlugins
 from plone.app.theming.theme import Theme
 from plone.i18n.normalizer.interfaces import IURLNormalizer
-from plone.registry.interfaces import IRegistry
 from plone.resource.interfaces import IResourceDirectory
 from plone.resource.manifest import MANIFEST_FILENAME
 from plone.resource.manifest import extractManifestFromZipFile
@@ -31,16 +30,30 @@
 from urlparse import urlsplit
 from zope.component import getUtility
 from zope.component import queryMultiAdapter
-from zope.component import queryUtility
-from zope.event import notify
 from zope.globalrequest import getRequest
-import Globals
+from zope.interface import implementer
 import logging
 import pkg_resources
 
 LOGGER = logging.getLogger('plone.app.theming')
 
 
+@implementer(INoRequest)
+class NoRequest(object):
+    """Fallback to enable querying for the policy adapter
+    even in the absence of a proper IRequest."""
+
+
+def theming_policy(request=None):
+    """Primary policy accessor, uses pluggable ZCA lookup.
+    Resolves into a IThemingPolicy adapter."""
+    if not request:
+        request = getRequest()
+    if not request:
+        request = NoRequest()  # the adapter knows how to handle this
+    return IThemingPolicy(request)
+
+
 class NetworkResolver(etree.Resolver):
     """Resolver for network urls
     """
@@ -392,70 +405,26 @@ def getZODBThemes():
 def getCurrentTheme():
     """Get the name of the currently enabled theme
     """
-    settings = getUtility(IRegistry).forInterface(IThemeSettings, False)
-    if not settings.rules:
-        return None
-
-    if settings.currentTheme:
-        return settings.currentTheme
-
-    # BBB: If currentTheme isn't set, look for a theme with a rules file
-    # matching that of the current theme
-    for theme in getAvailableThemes():
-        if theme.rules == settings.rules:
-            return theme.__name__
-
-    return None
+    return theming_policy().getCurrentTheme()
 
 
 def isThemeEnabled(request, settings=None):
     """Determine if a theme is enabled for the given request
     """
-
-    # Resolve DevelopmentMode late (i.e. not on import time) since it may
-    # be set during import or test setup time
-    DevelopmentMode = Globals.DevelopmentMode
-
-    # Disable theming if the response sets a header
-    if request.response.getHeader('X-Theme-Disabled'):
-        return False
-
-    # Check for diazo.off request parameter
-    true_vals = ('1', 'y', 'yes', 't', 'true')
-    if (DevelopmentMode and request.get('diazo.off', '').lower() in true_vals):
-        return False
-
-    if settings is None:
-        registry = queryUtility(IRegistry)
-        if registry is None:
-            return False
-        settings = registry.forInterface(IThemeSettings, False)
-
-    if not settings.enabled or not settings.rules:
-        return False
-
-    server_url = request.get('SERVER_URL')
-    proto, host = server_url.split('://', 1)
-    host = host.lower()
-    serverPort = request.get('SERVER_PORT')
-
-    for hostname in settings.hostnameBlacklist or ():
-        if host == hostname or host == ':'.join((hostname, serverPort)):
-            return False
-
-    return True
+    return theming_policy(request).isThemeEnabled(settings)
 
 
 def applyTheme(theme):
     """Apply an ITheme
     """
-
-    settings = getUtility(IRegistry).forInterface(IThemeSettings, False)
+    # on write, force using default policy
+    policy = IThemingPolicy(NoRequest())
+    settings = policy.getSettings()
 
     plugins = None
     themeDirectory = None
     pluginSettings = None
-    currentTheme = getCurrentTheme()
+    currentTheme = policy.getCurrentTheme()
 
     if currentTheme is not None:
         themeDirectory = queryResourceDirectory(
@@ -510,7 +479,7 @@ def applyTheme(theme):
             for name, plugin in plugins:
                 plugin.onEnabled(currentTheme, pluginSettings[name],
                                  pluginSettings)
-        notify(ThemeAppliedEvent(theme))
+        policy.set_theme(currentTheme, theme)
 
 
 def createThemeFromTemplate(title, description, baseOn='template'):


Repository: plone.app.theming


Branch: refs/heads/master
Date: 2015-07-09T08:21:39-05:00
Author: vangheem (vangheem) <vangheem@gmail.com>
Commit: https://github.com/plone/plone.app.theming/commit/f7f60fe7113dcc58c4d35ce83cd1629471ddc99b

Merge branch 'ploneintranet-master'

Files changed:
A src/plone/app/theming/policy.py
A src/plone/app/theming/tests/test_policy.py
M src/plone/app/theming/browser/mapper.py
M src/plone/app/theming/configure.zcml
M src/plone/app/theming/interfaces.py
M src/plone/app/theming/plugins/hooks.py
M src/plone/app/theming/transform.py
M src/plone/app/theming/traversal.py
M src/plone/app/theming/utils.py

diff --git a/src/plone/app/theming/browser/mapper.py b/src/plone/app/theming/browser/mapper.py
index 16a8888..03d3ffd 100644
--- a/src/plone/app/theming/browser/mapper.py
+++ b/src/plone/app/theming/browser/mapper.py
@@ -7,16 +7,15 @@
 from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
 from Products.statusmessages.interfaces import IStatusMessage
 from diazo.utils import quote_param
-from plone.app.theming.interfaces import IThemeSettings
 from plone.app.theming.interfaces import RULE_FILENAME
 from plone.app.theming.interfaces import THEME_EXTENSIONS
 from plone.app.theming.interfaces import THEME_RESOURCE_NAME
 from plone.app.theming.utils import compileThemeTransform
 from plone.app.theming.utils import findContext
-from plone.app.theming.utils import getCurrentTheme
 from plone.app.theming.utils import getPortal
 from plone.app.theming.utils import getThemeFromResourceDirectory
 from plone.app.theming.utils import prepareThemeParameters
+from plone.app.theming.utils import theming_policy
 from plone.memoize import view
 from plone.registry.interfaces import IRegistry
 from plone.resource.interfaces import IWritableResourceDirectory
@@ -73,7 +72,7 @@ def setup(self):
             self.name
         )
         self.themeBasePathEncoded = urllib.quote_plus(self.themeBasePath)
-        self.themeBaseUrl = '/'.join([self.portalUrl, self.themeBasePath]) 
+        self.themeBaseUrl = '/'.join([self.portalUrl, self.themeBasePath])
 
         try:
             registry = getUtility(IRegistry)
@@ -88,12 +87,14 @@ def setup(self):
         )
 
         if self.editable:
-            self.resourceUrl = self.resourceDirectory.context.absolute_url() 
+            self.resourceUrl = self.resourceDirectory.context.absolute_url()
         else:
             self.resourceUrl = None
 
-        settings = getUtility(IRegistry).forInterface(IThemeSettings, False)
-        self.active = (settings.enabled and self.name == getCurrentTheme())
+        policy = theming_policy(self.request)
+        settings = policy.getSettings()
+        self.active = (settings.enabled
+                       and self.name == policy.getCurrentTheme())
 
         self.rulesFileName = RULE_FILENAME
 
@@ -230,8 +231,8 @@ def getFrame(self):
             self.request.response.setHeader('X-Theme-Disabled', '1')
             themeInfo = getThemeFromResourceDirectory(self.context)
 
-            registry = getUtility(IRegistry)
-            settings = registry.forInterface(IThemeSettings, False)
+            policy = theming_policy(self.request)
+            settings = policy.getSettings()
 
             context = self.context
             try:
diff --git a/src/plone/app/theming/configure.zcml b/src/plone/app/theming/configure.zcml
index 4a6bbd8..28e1d7a 100644
--- a/src/plone/app/theming/configure.zcml
+++ b/src/plone/app/theming/configure.zcml
@@ -59,7 +59,21 @@
     <subscriber
         for=".interfaces.IThemeSettings
               plone.registry.interfaces.IRecordModifiedEvent"
-        handler=".transform.invalidateCache"
+        handler=".policy.invalidateCache"
+        />
+
+    <!-- policy adapter
+         You can plug in a custom adapter by registering it for your own layer
+         eg for="your.product.interfaces.IThemeSwitcher".  -->
+    <adapter
+        factory=".policy.ThemingPolicy"
+        for="zope.publisher.interfaces.IRequest"
+        />
+    <!-- fallback default policy adapter
+         Do not override this, it is used by applyTheme -->
+    <adapter
+        factory=".policy.ThemingPolicy"
+        for="plone.app.theming.interfaces.INoRequest"
         />
 
     <!-- Set X-Theme-Enabled header in the request if theming is enabled -->
diff --git a/src/plone/app/theming/interfaces.py b/src/plone/app/theming/interfaces.py
index 9cfb1f0..ae8e1ec 100644
--- a/src/plone/app/theming/interfaces.py
+++ b/src/plone/app/theming/interfaces.py
@@ -231,3 +231,39 @@ def onRequest(request, theme, settings, dependenciesSettings):
 
 class IThemeAppliedEvent(Interface):
     theme = Attribute('theme that is getting applied')
+
+
+class INoRequest(Interface):
+    """Fallback to enable querying for the policy adapter
+    even in the absence of a proper IRequest."""
+
+
+class IThemingPolicy(Interface):
+    """An adapter on request that provides access to the current
+    theme and theme settings.
+    """
+
+    def getSettings():
+        """Settings for current theme."""
+
+    def getCurrentTheme():
+        """The name of the current theme."""
+
+    def isThemeEnabled():
+        """Whether theming is enabled."""
+
+    def getCache(theme=None):
+        """Managing the cache is a policy decision."""
+
+    def getCacheKey(theme=None):
+        """Managing the cache is a policy decision."""
+
+    def invalidateCache():
+        """When our settings are changed, invalidate the cache on all zeo clients.
+        """
+
+    def get_theme():
+        """Returns the current theme object, cached."""
+
+    def set_theme(themeName, themeObj):
+        """Update the theme cache."""
diff --git a/src/plone/app/theming/plugins/hooks.py b/src/plone/app/theming/plugins/hooks.py
index 8fa461f..93b0c6b 100644
--- a/src/plone/app/theming/plugins/hooks.py
+++ b/src/plone/app/theming/plugins/hooks.py
@@ -2,8 +2,7 @@
 from plone.app.theming.interfaces import THEME_RESOURCE_NAME
 from plone.app.theming.plugins.utils import getPluginSettings
 from plone.app.theming.plugins.utils import getPlugins
-from plone.app.theming.utils import getCurrentTheme
-from plone.app.theming.utils import isThemeEnabled
+from plone.app.theming.utils import theming_policy
 from plone.resource.utils import iterDirectoriesOfType
 from plone.resource.utils import queryResourceDirectory
 
@@ -29,11 +28,12 @@ def onRequest(object, event):
     """
 
     request = event.request
+    policy = theming_policy(request)
 
-    if not isThemeEnabled(request):
+    if not policy.isThemeEnabled():
         return
 
-    theme = getCurrentTheme()
+    theme = policy.getCurrentTheme()
     if theme is None:
         return
 
diff --git a/src/plone/app/theming/policy.py b/src/plone/app/theming/policy.py
new file mode 100644
index 0000000..900e773
--- /dev/null
+++ b/src/plone/app/theming/policy.py
@@ -0,0 +1,191 @@
+# -*- coding: utf-8 -*-
+import Globals
+from logging import getLogger
+import threading
+import time
+
+from plone.registry.interfaces import IRegistry
+from zope.component import queryUtility
+from zope.component.hooks import getSite
+from zope.interface import implementer
+from zope.publisher.interfaces import IRequest
+
+from plone.app.theming.interfaces import IThemingPolicy
+from plone.app.theming.interfaces import IThemeSettings
+from plone.app.theming import utils
+
+log = getLogger(__name__)
+_local_cache = threading.local()
+
+
+def invalidateCache(settings, event):
+    """Event handler for registry change"""
+    utils.theming_policy().invalidateCache()
+
+
+@implementer(IThemingPolicy)
+class ThemingPolicy(object):
+
+    def __init__(self, request):
+        """Adapt IRequest.
+        Do not call this class directly, always use a
+        utils.theming_policy(request) adapter lookup.
+
+        This enables overriding of the IThemingPolicy adapter
+        via ZCML by integrators.
+
+        When used as INoRequest adapter, returns the default policy.
+        """
+        if IRequest.providedBy(request):
+            self.request = request
+        else:
+            self.request = None
+
+    def getSettings(self):
+        """Settings for current theme."""
+        registry = queryUtility(IRegistry)
+        if registry is None:
+            return None
+        try:
+            settings = registry.forInterface(IThemeSettings, False)
+        except KeyError:
+            return None
+        return settings
+
+    def getCurrentTheme(self):
+        """The name of the current theme."""
+        settings = self.getSettings()
+        if not settings.rules:
+            return None
+        if settings.currentTheme:
+            return settings.currentTheme
+
+        # BBB: If currentTheme isn't set, look for a theme with a rules file
+        # matching that of the current theme
+        for theme in utils.getAvailableThemes():
+            if theme.rules == settings.rules:
+                return theme.__name__
+
+        return None
+
+    def isThemeEnabled(self, settings=None):
+        """Whether theming is enabled."""
+
+        # Resolve DevelopmentMode late (i.e. not on import time) since it may
+        # be set during import or test setup time
+        DevelopmentMode = Globals.DevelopmentMode
+
+        # Disable theming if the response sets a header
+        if self.request.response.getHeader('X-Theme-Disabled'):
+            return False
+
+        # Check for diazo.off request parameter
+        true_vals = ('1', 'y', 'yes', 't', 'true')
+        if (DevelopmentMode and self.request.get(
+                'diazo.off', '').lower() in true_vals):
+            return False
+
+        if not settings:
+            settings = self.getSettings()
+        if not settings.enabled or not settings.rules:
+            return False
+
+        server_url = self.request.get('SERVER_URL')
+        proto, host = server_url.split('://', 1)
+        host = host.lower()
+        serverPort = self.request.get('SERVER_PORT')
+
+        for hostname in settings.hostnameBlacklist or ():
+            if host == hostname or host == ':'.join((hostname, serverPort)):
+                return False
+
+        return True
+
+    def getCache(self, theme=None):
+        """Managing the cache is a policy decision."""
+        caches = self.getCacheStorage()
+        key = self.getCacheKey(theme)
+        cache = caches.get(key)
+        if cache is None:
+            log.info("initializing local cache on thread %s for %s",
+                     threading.current_thread().ident, key)
+            cache = caches[key] = ThemeCache()
+        return cache
+
+    def getCacheKey(self, theme=None):
+        if not theme:
+            theme = self.getCurrentTheme()
+        key = "%s::%s" % (getSite().absolute_url(), theme)
+        return key
+
+    def getCacheStorage(self):
+        if not hasattr(_local_cache, 'themedata'):
+            self._reset_local_cache()
+        if self._get_shared_invalidation() > _local_cache.themedata['mtime']:
+            log.info("shared invalidation requires local cache reset on %s",
+                     threading.current_thread().ident)
+            self._reset_local_cache()
+        return _local_cache.themedata
+
+    def invalidateCache(self):
+        """When our settings are changed, invalidate the cache on all zeo clients
+        """
+        log.info("invalidating cache across all threads and processes")
+        self._reset_local_cache()
+        self._set_shared_invalidation()
+
+    def _reset_local_cache(self):
+        """
+        Invalidate only the local thread cache
+        Removes actual theme data, leaving only mtime
+        """
+        _local_cache.themedata = {'mtime': time.time()}
+        log.info("local cache invalidated on thread %s",
+                 threading.current_thread().ident)
+
+    def _set_shared_invalidation(self):
+        """Signal to other threads and processes they should invalidate their
+        theme caches."""
+        registry = queryUtility(IRegistry)
+        setattr(registry, '_theme_cache_mtime', time.time())
+        registry._p_changed = True
+        log.info("shared cache invalidation marker updated")
+
+    def _get_shared_invalidation(self):
+        registry = queryUtility(IRegistry)
+        return getattr(registry, '_theme_cache_mtime', 0)
+
+    def get_theme(self):
+        """Managing the theme cache is a plone.app.theming policy
+        decision. Moved out out Products.CMFPlone."""
+        cache = self.getCache()
+        themeObj = cache.themeObj
+        if not themeObj:
+            theme = self.getCurrentTheme()
+            themeObj = utils.getTheme(theme)
+            self.set_theme(theme, themeObj)
+        return themeObj
+
+    def set_theme(self, themeName, themeObj):
+        """Update the theme cache"""
+        cache = self.getCache(themeName)
+        cache.updateTheme(themeObj)
+
+
+class ThemeCache(object):
+    """Simple cache for the transform and theme
+    """
+
+    def __init__(self):
+        self.transform = None
+        self.expressions = None
+        self.themeObj = None
+
+    def updateTransform(self, transform):
+        self.transform = transform
+
+    def updateExpressions(self, expressions):
+        self.expressions = expressions
+
+    def updateTheme(self, themeObj):
+        self.themeObj = themeObj
diff --git a/src/plone/app/theming/tests/test_policy.py b/src/plone/app/theming/tests/test_policy.py
new file mode 100644
index 0000000..258f5c4
--- /dev/null
+++ b/src/plone/app/theming/tests/test_policy.py
@@ -0,0 +1,131 @@
+# -*- coding: utf-8 -*-
+import time
+import multiprocessing
+import threading
+import transaction
+import unittest2 as unittest
+
+from plone.registry.interfaces import IRegistry
+from zope.component import queryUtility
+
+from plone.app.theming.testing import THEMING_FUNCTIONAL_TESTING
+from plone.app.theming.utils import theming_policy
+
+
+class TestFunctional(unittest.TestCase):
+
+    layer = THEMING_FUNCTIONAL_TESTING
+
+    def tearDown(self):
+        request = self.layer['request']
+        policy = theming_policy(request)
+        # static class attribute is cached across test runs
+        policy.invalidateCache()
+
+    def test_getSettings(self):
+        request = self.layer['request']
+        policy = theming_policy(request)
+        settings = policy.getSettings()
+        self.assertEqual(settings.currentTheme,
+                         u'barceloneta')
+        self.assertEqual(settings.rules,
+                         u'/++theme++barceloneta/rules.xml')
+
+    def test_getCurrentTheme(self):
+        request = self.layer['request']
+        policy = theming_policy(request)
+        self.assertEqual(policy.getCurrentTheme(),
+                         u'barceloneta')
+
+    def test_isThemeEnabled(self):
+        request = self.layer['request']
+        policy = theming_policy(request)
+        self.assertTrue(policy.isThemeEnabled())
+
+    def test_isThemeEnabled_blacklist(self):
+        request = self.layer['request']
+        request.set('BASE1', 'http://nohost/path/to/site')
+        policy = theming_policy(request)
+        settings = policy.getSettings()
+        # Should pay no attention to BASE1 and only use SERVER_URL
+        settings.hostnameBlacklist.append('nohost')
+        self.assertFalse(policy.isThemeEnabled())
+
+    def test_getCache(self):
+        request = self.layer['request']
+        policy = theming_policy(request)
+        cache = policy.getCache()
+        self.assertEqual(cache.themeObj, None)
+
+    def test_getCacheKey(self):
+        request = self.layer['request']
+        policy = theming_policy(request)
+        self.assertEqual(policy.getCacheKey(),
+                         u'http://nohost/plone::barceloneta')
+
+    def test_getCacheStorage(self):
+        request = self.layer['request']
+        policy = theming_policy(request)
+        self.assertEqual(policy.getCacheStorage().keys(), ['mtime'])
+        cache = policy.getCache()
+        storage = policy.getCacheStorage()
+        self.assertEqual(
+            [(k, v) for (k, v) in storage.items() if k != 'mtime'],
+            [(u'http://nohost/plone::barceloneta', cache)])
+
+    def test_caching(self):
+        """roundtrip"""
+        request = self.layer['request']
+        policy = theming_policy(request)
+        theme = policy.get_theme()
+        cache = policy.getCache()
+        storage = policy.getCacheStorage()
+        self.assertEqual(
+            [(k, v) for (k, v) in storage.items() if k != 'mtime'],
+            [(u'http://nohost/plone::barceloneta', cache)])
+        self.assertEqual(cache.themeObj, theme)
+        policy.set_theme(u'barceloneta', 'faketheme')
+        self.assertEqual(policy.get_theme(), 'faketheme')
+        policy.invalidateCache()
+        self.assertEqual(policy.getCacheStorage().keys(), ['mtime'])
+        theme2 = policy.get_theme()
+        # different objects but both are barceloneta
+        self.assertEqual(theme.title, theme2.title)
+
+    def test_invalidateCache_locally(self):
+        """Poor man's IPC - verify within same thread"""
+        request = self.layer['request']
+        policy = theming_policy(request)
+        cache = policy.getCache()
+        storage = policy.getCacheStorage()
+        self.assertEqual(
+            [(k, v) for (k, v) in storage.items() if k != 'mtime'],
+            [(u'http://nohost/plone::barceloneta', cache)])
+        shared_mtime_1 = policy._get_shared_invalidation()
+        policy.invalidateCache()
+        shared_mtime_2 = policy._get_shared_invalidation()
+        self.assertTrue(shared_mtime_2 > shared_mtime_1)
+
+    def test_invalidateCache_threaded(self):
+        """Poor man's IPC - verify in other thread"""
+        request = self.layer['request']
+        policy = theming_policy(request)
+        cache = policy.getCache()
+        storage = policy.getCacheStorage()
+        self.assertEqual(
+            [(k, v) for (k, v) in storage.items() if k != 'mtime'],
+            [(u'http://nohost/plone::barceloneta', cache)])
+        shared_mtime_1 = policy._get_shared_invalidation()
+
+        def invalidate(registry):
+            setattr(registry, '_theme_cache_mtime', time.time())
+            registry._p_modified = True
+            transaction.commit()
+
+        registry = queryUtility(IRegistry)
+        t = threading.Thread(target=invalidate, args=(registry, ))
+        t.start()
+        t.join(5.0)
+
+        shared_mtime_2 = policy._get_shared_invalidation()
+        self.assertTrue(shared_mtime_2 > shared_mtime_1)
diff --git a/src/plone/app/theming/transform.py b/src/plone/app/theming/transform.py
index 5ac54a6..9e214df 100644
--- a/src/plone/app/theming/transform.py
+++ b/src/plone/app/theming/transform.py
@@ -1,19 +1,15 @@
 # -*- coding: utf-8 -*-
 from lxml import etree
-from plone.app.theming.interfaces import IThemeSettings
 from plone.app.theming.interfaces import IThemingLayer
 from plone.app.theming.utils import compileThemeTransform
 from plone.app.theming.utils import findContext
 from plone.app.theming.utils import getParser
-from plone.app.theming.utils import isThemeEnabled
 from plone.app.theming.utils import prepareThemeParameters
+from plone.app.theming.utils import theming_policy
 from plone.app.theming.zmi import patch_zmi
-from plone.registry.interfaces import IRegistry
 from plone.transformchain.interfaces import ITransform
 from repoze.xmliter.utils import getHTMLSerializer
 from zope.component import adapter
-from zope.component import queryUtility
-from zope.component.hooks import getSite
 from zope.interface import Interface
 from zope.interface import implementer
 import Globals
@@ -25,46 +21,6 @@
 LOGGER = logging.getLogger('plone.app.theming')
 
 
-class _Cache(object):
-    """Simple cache for the transform
-    """
-
-    def __init__(self):
-        self.transform = None
-        self.expressions = None
-
-    def updateTransform(self, transform):
-        self.transform = transform
-
-    def updateExpressions(self, expressions):
-        self.expressions = expressions
-
-
-def getCache(settings):
-    # We need a persistent object to hang a _v_ attribute off for caching.
-
-    registry = settings.__registry__
-    caches = getattr(registry, '_v_plone_app_theming_caches', None)
-    if caches is None:
-        caches = registry._v_plone_app_theming_caches = {}
-
-    key = getSite().absolute_url()
-
-    cache = caches.get(key)
-    if cache is None:
-        cache = caches[key] = _Cache()
-    return cache
-
-
-def invalidateCache(settings, event):
-    """When our settings are changed, invalidate the cache on all zeo clients
-    """
-    registry = settings.__registry__
-    registry._p_changed = True
-    if hasattr(registry, '_v_plone_app_theming_caches'):
-        del registry._v_plone_app_theming_caches
-
-
 @implementer(ITransform)
 @adapter(Interface, IThemingLayer)
 class ThemeTransform(object):
@@ -79,19 +35,19 @@ def __init__(self, published, request):
         self.request = request
 
     def setupTransform(self, runtrace=False):
-        request = self.request
         DevelopmentMode = Globals.DevelopmentMode
+        policy = theming_policy(self.request)
 
         # Obtain settings. Do nothing if not found
-        settings = self.getSettings()
+        settings = policy.getSettings()
 
         if settings is None:
             return None
 
-        if not isThemeEnabled(request, settings):
+        if not policy.isThemeEnabled():
             return None
 
-        cache = getCache(settings)
+        cache = policy.getCache()
 
         # Apply theme
         transform = None
@@ -121,16 +77,7 @@ def setupTransform(self, runtrace=False):
         return transform
 
     def getSettings(self):
-        registry = queryUtility(IRegistry)
-        if registry is None:
-            return None
-
-        try:
-            settings = registry.forInterface(IThemeSettings, False)
-        except KeyError:
-            return None
-
-        return settings
+        return theming_policy(self.request).getSettings()
 
     def parseTree(self, result):
         contentType = self.request.response.getHeader('Content-Type')
@@ -157,10 +104,11 @@ def transformIterable(self, result, encoding):
         """Apply the transform if required
         """
         # Obtain settings. Do nothing if not found
-        settings = self.getSettings()
+        policy = theming_policy(self.request)
+        settings = policy.getSettings()
         if settings is None:
             return None
-        if not isThemeEnabled(self.request, settings):
+        if not policy.isThemeEnabled():
             return None
         result = self.parseTree(result)
         if result is None:
@@ -187,7 +135,7 @@ def transformIterable(self, result, encoding):
 
             cache = None
             if not DevelopmentMode:
-                cache = getCache(settings)
+                cache = policy.getCache()
 
             parameterExpressions = settings.parameterExpressions or {}
             params = prepareThemeParameters(
diff --git a/src/plone/app/theming/traversal.py b/src/plone/app/theming/traversal.py
index beb73b6..4e1329d 100644
--- a/src/plone/app/theming/traversal.py
+++ b/src/plone/app/theming/traversal.py
@@ -1,11 +1,9 @@
 # -*- coding: utf-8 -*-
-from plone.app.theming.interfaces import IThemeSettings
 from plone.app.theming.interfaces import THEME_RESOURCE_NAME
-from plone.registry.interfaces import IRegistry
+from plone.app.theming.utils import theming_policy
 from plone.resource.traversal import ResourceTraverser
 from plone.resource.utils import queryResourceDirectory
 from zExceptions import NotFound
-from zope.component import getUtility
 import urllib
 
 
@@ -22,9 +20,7 @@ def __init__(self, context, request=None):
         self.context = context
 
     def current_theme(self):
-        registry = getUtility(IRegistry)
-        settings = registry.forInterface(IThemeSettings)
-        return settings.currentTheme
+        return theming_policy(self.request).getCurrentTheme()
 
     def traverse(self, name, remaining):
         if name == '':
diff --git a/src/plone/app/theming/utils.py b/src/plone/app/theming/utils.py
index 9fe505d..0e40ec0 100644
--- a/src/plone/app/theming/utils.py
+++ b/src/plone/app/theming/utils.py
@@ -8,8 +8,8 @@
 from diazo.compiler import compile_theme
 from diazo.compiler import quote_param
 from lxml import etree
-from plone.app.theming.events import ThemeAppliedEvent
-from plone.app.theming.interfaces import IThemeSettings
+from plone.app.theming.interfaces import IThemingPolicy
+from plone.app.theming.interfaces import INoRequest
 from plone.app.theming.interfaces import MANIFEST_FORMAT
 from plone.app.theming.interfaces import RULE_FILENAME
 from plone.app.theming.interfaces import THEME_RESOURCE_NAME
@@ -17,7 +17,6 @@
 from plone.app.theming.plugins.utils import getPlugins
 from plone.app.theming.theme import Theme
 from plone.i18n.normalizer.interfaces import IURLNormalizer
-from plone.registry.interfaces import IRegistry
 from plone.resource.interfaces import IResourceDirectory
 from plone.resource.manifest import MANIFEST_FILENAME
 from plone.resource.manifest import extractManifestFromZipFile
@@ -31,16 +30,30 @@
 from urlparse import urlsplit
 from zope.component import getUtility
 from zope.component import queryMultiAdapter
-from zope.component import queryUtility
-from zope.event import notify
 from zope.globalrequest import getRequest
-import Globals
+from zope.interface import implementer
 import logging
 import pkg_resources
 
 LOGGER = logging.getLogger('plone.app.theming')
 
 
+@implementer(INoRequest)
+class NoRequest(object):
+    """Fallback to enable querying for the policy adapter
+    even in the absence of a proper IRequest."""
+
+
+def theming_policy(request=None):
+    """Primary policy accessor, uses pluggable ZCA lookup.
+    Resolves into a IThemingPolicy adapter."""
+    if not request:
+        request = getRequest()
+    if not request:
+        request = NoRequest()  # the adapter knows how to handle this
+    return IThemingPolicy(request)
+
+
 class NetworkResolver(etree.Resolver):
     """Resolver for network urls
     """
@@ -392,70 +405,26 @@ def getZODBThemes():
 def getCurrentTheme():
     """Get the name of the currently enabled theme
     """
-    settings = getUtility(IRegistry).forInterface(IThemeSettings, False)
-    if not settings.rules:
-        return None
-
-    if settings.currentTheme:
-        return settings.currentTheme
-
-    # BBB: If currentTheme isn't set, look for a theme with a rules file
-    # matching that of the current theme
-    for theme in getAvailableThemes():
-        if theme.rules == settings.rules:
-            return theme.__name__
-
-    return None
+    return theming_policy().getCurrentTheme()
 
 
 def isThemeEnabled(request, settings=None):
     """Determine if a theme is enabled for the given request
     """
-
-    # Resolve DevelopmentMode late (i.e. not on import time) since it may
-    # be set during import or test setup time
-    DevelopmentMode = Globals.DevelopmentMode
-
-    # Disable theming if the response sets a header
-    if request.response.getHeader('X-Theme-Disabled'):
-        return False
-
-    # Check for diazo.off request parameter
-    true_vals = ('1', 'y', 'yes', 't', 'true')
-    if (DevelopmentMode and request.get('diazo.off', '').lower() in true_vals):
-        return False
-
-    if settings is None:
-        registry = queryUtility(IRegistry)
-        if registry is None:
-            return False
-        settings = registry.forInterface(IThemeSettings, False)
-
-    if not settings.enabled or not settings.rules:
-        return False
-
-    server_url = request.get('SERVER_URL')
-    proto, host = server_url.split('://', 1)
-    host = host.lower()
-    serverPort = request.get('SERVER_PORT')
-
-    for hostname in settings.hostnameBlacklist or ():
-        if host == hostname or host == ':'.join((hostname, serverPort)):
-            return False
-
-    return True
+    return theming_policy(request).isThemeEnabled(settings)
 
 
 def applyTheme(theme):
     """Apply an ITheme
     """
-
-    settings = getUtility(IRegistry).forInterface(IThemeSettings, False)
+    # on write, force using default policy
+    policy = IThemingPolicy(NoRequest())
+    settings = policy.getSettings()
 
     plugins = None
     themeDirectory = None
     pluginSettings = None
-    currentTheme = getCurrentTheme()
+    currentTheme = policy.getCurrentTheme()
 
     if currentTheme is not None:
         themeDirectory = queryResourceDirectory(
@@ -510,7 +479,7 @@ def applyTheme(theme):
             for name, plugin in plugins:
                 plugin.onEnabled(currentTheme, pluginSettings[name],
                                  pluginSettings)
-        notify(ThemeAppliedEvent(theme))
+        policy.set_theme(currentTheme, theme)
 
 
 def createThemeFromTemplate(title, description, baseOn='template'):


