Repository: plone.app.collection
Branch: refs/heads/master
Date: 2015-02-12T00:35:11Z
Author: Matthew Wilkes (MatthewWilkes) <git@matthewwilkes.name>
Commit: https://github.com/plone/plone.app.collection/commit/403cd5ec3c728532e56f3f52c8bbcb4fcecee592

Add marshaller that understands queries and round trips them correctly

Conflicts:
	plone/app/collection/tests/test_collection.py

Files changed:
A plone/app/collection/marshaller.py
M plone/app/collection/collection.py
M plone/app/collection/tests/test_collection.py

diff --git a/plone/app/collection/collection.py b/plone/app/collection/collection.py
index ed110bf..5504a4e 100644
--- a/plone/app/collection/collection.py
+++ b/plone/app/collection/collection.py
@@ -20,7 +20,7 @@
 from plone.app.collection import PloneMessageFactory as _
 from plone.app.collection.config import ATCT_TOOLNAME, PROJECTNAME
 from plone.app.collection.interfaces import ICollection
-
+from plone.app.collection.marshaller import CollectionRFC822Marshaller
 
 CollectionSchema = document.ATDocumentSchema.copy() + atapi.Schema((
 
@@ -86,6 +86,9 @@
         ),
 ))
 
+# Use the extended marshaller that understands queries
+CollectionSchema.registerLayer("marshall", CollectionRFC822Marshaller())
+
 CollectionSchema.moveField('query', after='description')
 if 'presentation' in CollectionSchema:
     CollectionSchema['presentation'].widget.visible = False
diff --git a/plone/app/collection/marshaller.py b/plone/app/collection/marshaller.py
new file mode 100644
index 0000000..acab0ad
--- /dev/null
+++ b/plone/app/collection/marshaller.py
@@ -0,0 +1,68 @@
+from types import ListType, TupleType
+
+from zope.contenttype import guess_content_type
+
+from AccessControl import ClassSecurityInfo
+from App.class_init import InitializeClass
+from Products.Archetypes.interfaces.base import IBaseUnit
+from Products.Archetypes.utils import mapply
+from Products.Archetypes.Marshall import RFC822Marshaller, parseRFC822, formatRFC822Headers
+
+
+class CollectionRFC822Marshaller(RFC822Marshaller):
+
+    security = ClassSecurityInfo()
+    security.declareObjectPrivate()
+    security.setDefaultAccess('deny')
+
+    def demarshall(self, instance, data, **kwargs):
+        # We don't want to pass file forward.
+        if 'file' in kwargs:
+            if not data:
+                # TODO Yuck! Shouldn't read the whole file, never.
+                # OTOH, if you care about large files, you should be
+                # using the PrimaryFieldMarshaller or something
+                # similar.
+                data = kwargs['file'].read()
+            del kwargs['file']
+        headers, body = parseRFC822(data)
+        
+        query = {}
+        for k, v in headers.items():
+            if not k.startswith("query"):
+                continue
+            else:
+                index = int(k[5])
+                sub_key = k.split("_")[1]
+                query_part = query.get(index, {})
+                query_part[sub_key] = v
+                query[index] = query_part
+                del headers[k]
+        query = [facet[1] for facet in sorted(query.items())]
+        
+        header = formatRFC822Headers(headers.items())
+        data = '%s\n\n%s' % (header, body)
+        
+        try:
+            return RFC822Marshaller.demarshall(self, instance, data, **kwargs)
+        finally:
+            instance.query = query
+
+    def marshall(self, instance, **kwargs):
+        content_type, length, data = RFC822Marshaller.marshall(self, instance, **kwargs)
+        headers, body = parseRFC822(data)
+        
+        headers = headers.items()
+        for i, query in enumerate(instance.query):
+            for key, value in query.items():
+                if isinstance(value, list):
+                    value = "\n".join(value)
+                header_key = 'query%d_%s' % (i, key)
+                headers.append((header_key, value))
+        
+        header = formatRFC822Headers(headers)
+        data = '%s\n\n%s' % (header, body)
+        length = len(data)
+        return (content_type, length, data)
+
+InitializeClass(CollectionRFC822Marshaller)
\ No newline at end of file
diff --git a/plone/app/collection/tests/test_collection.py b/plone/app/collection/tests/test_collection.py
index f1611e7..9599d3e 100644
--- a/plone/app/collection/tests/test_collection.py
+++ b/plone/app/collection/tests/test_collection.py
@@ -7,6 +7,7 @@
 from plone.app.testing import setRoles
 from plone.testing.z2 import Browser
 from transaction import commit
+from Products.Archetypes.Marshall import parseRFC822
 
 import unittest2 as unittest
 
@@ -235,3 +236,94 @@ def test_selectedViewFields(self):
     def test_syndication_enabled_by_default(self):
         syn = getToolByName(self.portal, 'portal_syndication')
         self.assertTrue(syn.isSyndicationAllowed(self.collection))
+
+
+class TestMarshalling(unittest.TestCase):
+
+    layer = PLONEAPPCOLLECTION_INTEGRATION_TESTING
+
+    def test_simple_query_included_in_marshall_results(self):
+        portal = self.layer['portal']
+        login(portal, 'admin')
+        query = [{
+            'i': 'portal_type',
+            'o': 'plone.app.querystring.operation.string.is',
+            'v': 'News Item',
+        }]
+        portal.invokeFactory("Collection",
+                             "collection",
+                             query=query,
+                             title="New Collection")
+        collection = portal['collection']
+        rfc822 = collection.manage_FTPget()
+        data = parseRFC822(rfc822)
+        self.assertIn('query0_i', data[0])
+        self.assertIn('query0_o', data[0])
+        self.assertIn('query0_v', data[0])
+        
+        self.assertEqual(data[0]['query0_i'], query[0]['i'])
+        self.assertEqual(data[0]['query0_o'], query[0]['o'])
+        self.assertEqual(data[0]['query0_v'], query[0]['v'])
+    
+    def test_multiple_query_items_included_in_marshall_results(self):
+        portal = self.layer['portal']
+        login(portal, 'admin')
+        query = [{
+            'i': 'portal_type',
+            'o': 'plone.app.querystring.operation.string.is',
+            'v': 'News Item',
+        },{ 'i': 'Title',
+            'o': 'plone.app.querystring.operation.string.is',
+            'v': 'Test News Item',
+        }]
+        
+        portal.invokeFactory("Collection",
+                             "collection",
+                             query=query,
+                             title="New Collection")
+        collection = portal['collection']
+        rfc822 = collection.manage_FTPget()
+        data = parseRFC822(rfc822)
+        
+        self.assertIn('query0_i', data[0])
+        self.assertIn('query0_o', data[0])
+        self.assertIn('query0_v', data[0])
+        self.assertIn('query1_i', data[0])
+        self.assertIn('query1_o', data[0])
+        self.assertIn('query1_v', data[0])
+        
+        self.assertEqual(data[0]['query0_i'], query[0]['i'])
+        self.assertEqual(data[0]['query0_o'], query[0]['o'])
+        self.assertEqual(data[0]['query0_v'], query[0]['v'])
+        self.assertEqual(data[0]['query1_i'], query[1]['i'])
+        self.assertEqual(data[0]['query1_o'], query[1]['o'])
+        self.assertEqual(data[0]['query1_v'], query[1]['v'])
+    
+    def test_query_gets_set_on_PUT(self):
+        portal = self.layer['portal']
+        login(portal, 'admin')
+        query = [{
+            'i': 'portal_type',
+            'o': 'plone.app.querystring.operation.string.is',
+            'v': 'News Item',
+        }]
+        
+        expected_query = [{
+            'i': 'portal_type',
+            'o': 'plone.app.querystring.operation.string.is',
+            'v': 'LOREM IPSUM DOLOR',
+        }]
+        
+        portal.invokeFactory("Collection",
+                             "collection",
+                             query=query,
+                             title="New Collection")
+        collection = portal['collection']
+        rfc822 = collection.manage_FTPget()
+        # Modify the response to put in a sentinal, to check it's been updated
+        rfc822 = rfc822.replace(query[0]['v'], expected_query[0]['v'])
+        
+        portal.REQUEST.set("BODY", rfc822)
+        collection.PUT(portal.REQUEST, None)
+        self.assertEqual(collection.query, expected_query)
+    


Repository: plone.app.collection
Branch: refs/heads/master
Date: 2015-02-12T00:39:40Z
Author: Matthew Wilkes (MatthewWilkes) <git@matthewwilkes.name>
Commit: https://github.com/plone/plone.app.collection/commit/30d66ce177cbb7e3170e1cf3e4e7a2c3c98fdc4c

Changelog

Conflicts:
	CHANGES.rst

Files changed:
M CHANGES.rst

diff --git a/CHANGES.rst b/CHANGES.rst
index 169f9c9..734edfa 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,7 +4,8 @@ Changelog
 1.1.3 (unreleased)
 ------------------
 
-- Nothing changed yet.
+- Support for import and export of collections using FTP, DAV and GenericSetup
+  [matthewwilkes]
 
 
 1.1.2 (2014-10-23)


