Repository: plone.app.portlets


Branch: refs/heads/master
Date: 2015-09-22T09:43:57+02:00
Author: Patrick Gerken (do3cc) <do3cc@patrick-gerken.de>
Commit: https://github.com/plone/plone.app.portlets/commit/6e8f590ded025afe2ccb88ed2e3a3b6dcc20c7ae

feat(logging): Log more error cases with rss feeds

Files changed:
M CHANGES.rst
M plone/app/portlets/portlets/rss.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 25c7fc3..dbf2063 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -111,7 +111,10 @@ Changelog
   [thet]
 
 - Use plone_layout for getIcon.
-  [pbauer]
+- Log exceptions while parsing rss feeds. Get logged as info since
+  this often caused by factor out of control of site owners and
+  because the problem is handled in the UI
+  [do3cc]
 
 
 3.0.2 (2014-10-23)
diff --git a/plone/app/portlets/portlets/rss.py b/plone/app/portlets/portlets/rss.py
index 485cbb6..514fb5c 100644
--- a/plone/app/portlets/portlets/rss.py
+++ b/plone/app/portlets/portlets/rss.py
@@ -162,6 +162,8 @@ def _retrieveFeed(self):
                                        ACCEPTED_FEEDPARSER_EXCEPTIONS)):
                 self._loaded = True  # we tried at least but have a failed load
                 self._failed = True
+                logger.info('failed to update RSS feed %s', 
+                            d.get('bozo_exception', None))
                 return False
             try:
                 self._title = d.feed.title


Repository: plone.app.portlets


Branch: refs/heads/master
Date: 2015-09-22T09:44:43+02:00
Author: Patrick Gerken (do3cc) <do3cc@patrick-gerken.de>
Commit: https://github.com/plone/plone.app.portlets/commit/7746069c62b6c3ae8446a6e7ee6887ff936c6a97

Add caching

Files changed:
M CHANGES.rst
M plone/app/portlets/portlets/rss.py

diff --git a/CHANGES.rst b/CHANGES.rst
index dbf2063..9c2b1f5 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,6 +4,19 @@ Changelog
 3.1.2 (unreleased)
 ------------------
 
+- Log exceptions while parsing rss feeds. Get logged as info since
+  this often caused by factor out of control of site owners and
+  because the problem is handled in the UI
+  [do3cc]
+
+- Remove hard coded 10 minute delay if retrieving a feed failed once.
+  Either you don't need your feeds ultra fast, then you can create
+  a longer time, or you need them fast and don't want this hidden delayq
+  [do3cc]
+
+- Add caching functionality from feedparser.
+  [do3cc]
+
 - Use ``is_default_page`` instead of ``check_default_page_via_view``. 
   [fulv]
 
@@ -70,7 +83,7 @@ Changelog
 
 
 3.0.6 (2015-06-05)
-------------------
+-----------------
 
 - Convert manage-portlets.js into a pattern and make improvements on
   using the manage portlets infrastructure
@@ -111,11 +124,7 @@ Changelog
   [thet]
 
 - Use plone_layout for getIcon.
-- Log exceptions while parsing rss feeds. Get logged as info since
-  this often caused by factor out of control of site owners and
-  because the problem is handled in the UI
-  [do3cc]
-
+  [pbauer]
 
 3.0.2 (2014-10-23)
 ------------------
diff --git a/plone/app/portlets/portlets/rss.py b/plone/app/portlets/portlets/rss.py
index 514fb5c..f65aeca 100644
--- a/plone/app/portlets/portlets/rss.py
+++ b/plone/app/portlets/portlets/rss.py
@@ -68,9 +68,6 @@ class RSSFeed(object):
     """an RSS feed"""
     implements(IFeed)
 
-    # TODO: discuss whether we want an increasing update time here, probably not though
-    FAILURE_DELAY = 10  # time in minutes after which we retry to load it after a failure
-
     def __init__(self, url, timeout):
         self.url = url
         self.timeout = timeout
@@ -82,6 +79,8 @@ def __init__(self, url, timeout):
         self._failed = False    # does it fail at the last update?
         self._last_update_time_in_minutes = 0  # when was the feed last updated?
         self._last_update_time = None  # time as DateTime or Nonw
+        self._etag = None
+        self._last_modified = None
 
     @property
     def last_update_time_in_minutes(self):
@@ -119,7 +118,7 @@ def update(self):
         try:
             # check for failure and retry
             if self.update_failed:
-                if (self.last_update_time_in_minutes + self.FAILURE_DELAY) < now:
+                if (self.last_update_time_in_minutes) < now:
                     return self._retrieveFeed()
                 else:
                     return False
@@ -156,7 +155,12 @@ def _retrieveFeed(self):
         if url != '':
             self._last_update_time_in_minutes = time.time() / 60
             self._last_update_time = DateTime()
-            d = feedparser.parse(url)
+            kwargs = {}
+            if self._last_modified:
+                kwargs['modified'] = self._last_modified
+            if self._etag:
+                kwargs['etag'] = self._etag
+            d = feedparser.parse(url, **kwargs)
             if (getattr(d, 'bozo', 0) == 1
                     and not isinstance(d.get('bozo_exception'),
                                        ACCEPTED_FEEDPARSER_EXCEPTIONS)):
@@ -165,22 +169,31 @@ def _retrieveFeed(self):
                 logger.info('failed to update RSS feed %s', 
                             d.get('bozo_exception', None))
                 return False
-            try:
-                self._title = d.feed.title
-            except AttributeError:
-                self._title = ""
-            self._items = []
-            try:
-                self._siteurl = d.feed.link
-            except AttributeError:
-                self._siteurl = ""
-            for item in d['items']:
+            
+            #  If the response was 304, nothing changed!
+            #  Don't change anything...
+            if d.status != 304:
+                self._etag = getattr(d, 'etag', None)
+                self._modified = getattr(d, 'modified', None)
+
+                try:
+                    self._title = d.feed.title
+                except AttributeError:
+                    self._title = ""
                 try:
-                    itemdict = self._buildItemDict(item)
+                    self._siteurl = d.feed.link
                 except AttributeError:
-                    continue
+                    self._siteurl = ""
+            
+                self._items = []
+                for item in d['items']:
+                    try:
+                        itemdict = self._buildItemDict(item)
+                    except AttributeError:
+                        continue
+  
+                    self._items.append(itemdict)
 
-                self._items.append(itemdict)
             self._loaded = True
             self._failed = False
             return True


Repository: plone.app.portlets


Branch: refs/heads/master
Date: 2015-09-22T09:44:43+02:00
Author: Patrick Gerken (do3cc) <patrick.gerken@zumtobelgroup.com>
Commit: https://github.com/plone/plone.app.portlets/commit/18c14a9d9c5bcc49741bd6c6e863160392bc3c02

Fix rebase mistakes

Files changed:
M CHANGES.rst

diff --git a/CHANGES.rst b/CHANGES.rst
index 9c2b1f5..5c8c632 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -83,7 +83,7 @@ Changelog
 
 
 3.0.6 (2015-06-05)
------------------
+------------------
 
 - Convert manage-portlets.js into a pattern and make improvements on
   using the manage portlets infrastructure
@@ -126,6 +126,7 @@ Changelog
 - Use plone_layout for getIcon.
   [pbauer]
 
+
 3.0.2 (2014-10-23)
 ------------------
 
@@ -1351,3 +1352,4 @@ Changelog
 
 - Initial implementation.
   [optilude]
+


Repository: plone.app.portlets


Branch: refs/heads/master
Date: 2015-09-23T10:57:50+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.app.portlets/commit/a7d00a2ca3299b9cd6f2781b6d1bd70b9edfcc54

Merge pull request #44 from do3cc/caching

Use caching headers while getting rss, remove unconfigurable additional delay on errors

Files changed:
M CHANGES.rst
M plone/app/portlets/portlets/rss.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 25c7fc3..5c8c632 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,6 +4,19 @@ Changelog
 3.1.2 (unreleased)
 ------------------
 
+- Log exceptions while parsing rss feeds. Get logged as info since
+  this often caused by factor out of control of site owners and
+  because the problem is handled in the UI
+  [do3cc]
+
+- Remove hard coded 10 minute delay if retrieving a feed failed once.
+  Either you don't need your feeds ultra fast, then you can create
+  a longer time, or you need them fast and don't want this hidden delayq
+  [do3cc]
+
+- Add caching functionality from feedparser.
+  [do3cc]
+
 - Use ``is_default_page`` instead of ``check_default_page_via_view``. 
   [fulv]
 
@@ -1339,3 +1352,4 @@ Changelog
 
 - Initial implementation.
   [optilude]
+
diff --git a/plone/app/portlets/portlets/rss.py b/plone/app/portlets/portlets/rss.py
index 485cbb6..f65aeca 100644
--- a/plone/app/portlets/portlets/rss.py
+++ b/plone/app/portlets/portlets/rss.py
@@ -68,9 +68,6 @@ class RSSFeed(object):
     """an RSS feed"""
     implements(IFeed)
 
-    # TODO: discuss whether we want an increasing update time here, probably not though
-    FAILURE_DELAY = 10  # time in minutes after which we retry to load it after a failure
-
     def __init__(self, url, timeout):
         self.url = url
         self.timeout = timeout
@@ -82,6 +79,8 @@ def __init__(self, url, timeout):
         self._failed = False    # does it fail at the last update?
         self._last_update_time_in_minutes = 0  # when was the feed last updated?
         self._last_update_time = None  # time as DateTime or Nonw
+        self._etag = None
+        self._last_modified = None
 
     @property
     def last_update_time_in_minutes(self):
@@ -119,7 +118,7 @@ def update(self):
         try:
             # check for failure and retry
             if self.update_failed:
-                if (self.last_update_time_in_minutes + self.FAILURE_DELAY) < now:
+                if (self.last_update_time_in_minutes) < now:
                     return self._retrieveFeed()
                 else:
                     return False
@@ -156,29 +155,45 @@ def _retrieveFeed(self):
         if url != '':
             self._last_update_time_in_minutes = time.time() / 60
             self._last_update_time = DateTime()
-            d = feedparser.parse(url)
+            kwargs = {}
+            if self._last_modified:
+                kwargs['modified'] = self._last_modified
+            if self._etag:
+                kwargs['etag'] = self._etag
+            d = feedparser.parse(url, **kwargs)
             if (getattr(d, 'bozo', 0) == 1
                     and not isinstance(d.get('bozo_exception'),
                                        ACCEPTED_FEEDPARSER_EXCEPTIONS)):
                 self._loaded = True  # we tried at least but have a failed load
                 self._failed = True
+                logger.info('failed to update RSS feed %s', 
+                            d.get('bozo_exception', None))
                 return False
-            try:
-                self._title = d.feed.title
-            except AttributeError:
-                self._title = ""
-            self._items = []
-            try:
-                self._siteurl = d.feed.link
-            except AttributeError:
-                self._siteurl = ""
-            for item in d['items']:
+            
+            #  If the response was 304, nothing changed!
+            #  Don't change anything...
+            if d.status != 304:
+                self._etag = getattr(d, 'etag', None)
+                self._modified = getattr(d, 'modified', None)
+
+                try:
+                    self._title = d.feed.title
+                except AttributeError:
+                    self._title = ""
                 try:
-                    itemdict = self._buildItemDict(item)
+                    self._siteurl = d.feed.link
                 except AttributeError:
-                    continue
+                    self._siteurl = ""
+            
+                self._items = []
+                for item in d['items']:
+                    try:
+                        itemdict = self._buildItemDict(item)
+                    except AttributeError:
+                        continue
+  
+                    self._items.append(itemdict)
 
-                self._items.append(itemdict)
             self._loaded = True
             self._failed = False
             return True


