Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2015-07-29T00:47:20+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.CMFPlone/commit/cc6a04bcde06f77b813347def9aedad0f5e3a256

move Plone specific getDefaultPage code+view from plone.app.layout over to Products.CMFPlone. This avoids a circular dependency. Also its not really layout only related code.

Files changed:
A Products/CMFPlone/browser/defaultpage.py
A Products/CMFPlone/defaultpage.py
A Products/CMFPlone/interfaces/defaultpage.py
A Products/CMFPlone/tests/test_defaultpage.py
M CHANGES.rst
M Products/CMFPlone/browser/configure.zcml
M Products/CMFPlone/utils.py

diff --git a/CHANGES.rst b/CHANGES.rst
index b289b53..cf04549 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -8,6 +8,11 @@ Changelog
 5.0b4 (unreleased)
 ----------------
 
+- move Plone specific ``getDefaultPage`` (magic) code from plone.app.layout
+  over to Products.CMFPlone. This avoids a circular dependency. Also its
+  not really layout only related code.
+  [jensens]
+
 - Fix add-ons to be installed using CMFQuickInstaller (restore support
   for Extensions/Install.py)
   [datakurre]
diff --git a/Products/CMFPlone/browser/configure.zcml b/Products/CMFPlone/browser/configure.zcml
index 0189231..ca3de1a 100644
--- a/Products/CMFPlone/browser/configure.zcml
+++ b/Products/CMFPlone/browser/configure.zcml
@@ -197,4 +197,14 @@
     permission="zope2.View"
     attribute="checkDocument"
     />
+
+    <!-- Default Page View -->
+    <browser:page
+      for="Products.CMFCore.interfaces.IFolderish"
+      name="default_page"
+      class=".defaultpage.DefaultPage"
+      permission="zope.Public"
+      allowed_interface="Products.CMFPlone.interfaces.defaultpage.IDefaultPage"
+      />
+
 </configure>
diff --git a/Products/CMFPlone/browser/defaultpage.py b/Products/CMFPlone/browser/defaultpage.py
new file mode 100644
index 0000000..c998711
--- /dev/null
+++ b/Products/CMFPlone/browser/defaultpage.py
@@ -0,0 +1,17 @@
+# -*- coding: utf-8 -*-
+from Acquisition import aq_inner
+from Products.CMFPlone.interfaces.defaultpage import IDefaultPage
+from Products.CMFPlone.defaultpage import get_default_page
+from Products.CMFPlone.defaultpage import is_default_page
+from Products.Five.browser import BrowserView
+from zope.interface import implementer
+
+
+@implementer(IDefaultPage)
+class DefaultPage(BrowserView):
+
+    def isDefaultPage(self, obj):
+        return is_default_page(aq_inner(self.context), obj)
+
+    def getDefaultPage(self):
+        return get_default_page(aq_inner(self.context))
diff --git a/Products/CMFPlone/defaultpage.py b/Products/CMFPlone/defaultpage.py
new file mode 100644
index 0000000..1917054
--- /dev/null
+++ b/Products/CMFPlone/defaultpage.py
@@ -0,0 +1,108 @@
+# -*- coding: utf-8 -*-
+from Acquisition import aq_base
+from Products.BTreeFolder2.BTreeFolder2 import BTreeFolder2Base
+from Products.CMFCore.interfaces import IFolderish
+from Products.CMFCore.interfaces import ISiteRoot
+from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault
+from Products.CMFDynamicViewFTI.interfaces import IDynamicViewTypeInformation
+from zope.component import queryAdapter
+from zope.component import queryUtility
+
+
+def get_default_page(context):
+    """Given a folderish item, find out if it has a default-page using
+    the following lookup rules:
+
+        1. A content object called 'index_html' wins
+        2. Else check for IBrowserDefault, either if the container implements
+           it or if an adapter exists. In both cases fetch its FTI and either
+           take it if it implements IDynamicViewTypeInformation or adapt it to
+           IDynamicViewTypeInformation. call getDefaultPage on the implementer
+           and take value if given.
+        3. Else, look up the attribute default_page on the object, without
+           acquisition in place
+        3.1 look for a content in the container with the id, no acquisition!
+        3.2 look for a content at portal, with acquisition
+        4. Else, look up the property default_page in site_properties for
+           magic ids and test these
+
+    The id of the first matching item is then used to lookup a translation
+    and if found, its id is returned. If no default page is set, None is
+    returned. If a non-folderish item is passed in, return None always.
+    """
+    # met precondition?
+    if not IFolderish.providedBy(context):
+        return
+
+    # The ids where we look for default - must support __contains__
+    ids = set()
+
+    # For BTreeFolders we just use the __contains__ otherwise build a set
+    if isinstance(aq_base(context), BTreeFolder2Base):
+        ids = context
+    elif hasattr(aq_base(context), 'objectIds'):
+        ids = set(context.objectIds())
+
+    # 1. test for contentish index_html
+    if 'index_html' in ids:
+        return 'index_html'
+
+    # 2. Test for IBrowserDefault
+    if IBrowserDefault.providedBy(context):
+        browserDefault = context
+    else:
+        browserDefault = queryAdapter(context, IBrowserDefault)
+
+    if browserDefault is not None:
+        fti = context.getTypeInfo()
+        if fti is not None:
+            if IDynamicViewTypeInformation.providedBy(fti):
+                dynamic_fti = fti
+            else:
+                dynamic_fti = queryAdapter(fti, IDynamicViewTypeInformation)
+            if dynamic_fti is not None:
+                page = dynamic_fti.getDefaultPage(context, check_exists=True)
+                if page is not None:
+                    return page
+
+    # 3.1 Test for default_page attribute in folder, no acquisition
+    pages = getattr(aq_base(context), 'default_page', [])
+    if isinstance(pages, basestring):
+        pages = [pages]
+    for page in pages:
+        if page and page in ids:
+            return page
+
+    portal = queryUtility(ISiteRoot)
+    # Might happen during portal creation
+    if portal is None:
+        return
+
+    # 3.2 Test for default page in portal, acquire
+    for page in pages:
+        if portal.unrestrictedTraverse(page, None):
+            return page
+
+    # 4. Test for default sitewide default_page setting
+    pp = getattr(portal, 'portal_properties', None)
+    if pp is not None:
+        site_properties = getattr(pp, 'site_properties', None)
+        if site_properties is not None:
+            for page in site_properties.getProperty('default_page', []):
+                if page in ids:
+                    return page
+
+
+def is_default_page(container, obj):
+    """Finds out if the given obj is the default page in its parent folder.
+
+    Only considers explicitly contained objects, either set as index_html,
+    with the default_page property, or using IBrowserDefault.
+    """
+    parent_default_page = get_default_page(container)
+    precondition = (
+        parent_default_page is not None
+        and '/' not in parent_default_page
+        and hasattr(aq_base(obj), 'getId')
+    )
+    return precondition and (parent_default_page == obj.getId())
diff --git a/Products/CMFPlone/interfaces/defaultpage.py b/Products/CMFPlone/interfaces/defaultpage.py
new file mode 100644
index 0000000..0aa7d79
--- /dev/null
+++ b/Products/CMFPlone/interfaces/defaultpage.py
@@ -0,0 +1,17 @@
+# -*- coding: utf-8 -*-
+from zope.interface import Interface
+
+
+class IDefaultPage(Interface):
+    """Interface for a view that can determine if its context is the
+    default page or not.
+    """
+
+    def isDefaultPage(obj):
+        """Finds out if the given obj is the default page for the
+        adapted object.
+        """
+
+    def getDefaultPage():
+        """Returns the id of the default page for the adapted object.
+        """
diff --git a/Products/CMFPlone/tests/test_defaultpage.py b/Products/CMFPlone/tests/test_defaultpage.py
new file mode 100644
index 0000000..0075003
--- /dev/null
+++ b/Products/CMFPlone/tests/test_defaultpage.py
@@ -0,0 +1,118 @@
+# -*- coding: utf-8 -*-
+from plone.app.testing import setRoles
+from plone.app.testing import TEST_USER_ID
+from Products.CMFPlone.testing import PRODUCTS_CMFPLONE_INTEGRATION_TESTING
+import unittest
+
+
+class DefaultPageTestCase(unittest.TestCase):
+
+    layer = PRODUCTS_CMFPLONE_INTEGRATION_TESTING
+
+    def setUp(self):
+        self.portal = self.layer['portal']
+        setRoles(self.portal, TEST_USER_ID, ['Manager'])
+        self.portal.invokeFactory('Folder', 'folder', title=u"Test Folder")
+        self.folder = self.portal.folder
+
+    def test_get_default_page_step_1(self):
+        # A content object called 'index_html' wins
+        self.folder.invokeFactory('Document', 'd1', title=u"Doc 1")
+        self.folder.setDefaultPage('d1')
+        self.folder.invokeFactory('Document', 'index_html', title=u"Doc 2")
+
+        from Products.CMFPlone.defaultpage import get_default_page
+        self.assertEqual('index_html', get_default_page(self.folder))
+
+    def test_get_default_page_step_2(self):
+        # Else check for IBrowserDefault, either if the container implements
+        # it or if an adapter exists. In both cases fetch its FTI and either
+        # take it if it implements IDynamicViewTypeInformation or adapt it to
+        # IDynamicViewTypeInformation. call get_default_page on the implementer
+        # and take value if given.
+
+        # first check some preconditions
+        #
+        # 1) a folder provides IBrowserDefault
+        from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault
+        self.assertTrue(IBrowserDefault.providedBy(self.folder))
+
+        # 2) a folder also provides an fti that implements
+        #    IDynamicViewTypeInformation
+        from Products.CMFDynamicViewFTI.interfaces import IDynamicViewTypeInformation  # noqa
+        fti = self.folder.getTypeInfo()
+        self.assertTrue(IDynamicViewTypeInformation.providedBy(fti))
+
+        # so if we set a document as defaultpage
+        self.folder.invokeFactory('Document', 'd1', title=u"Doc 1")
+        self.folder.setDefaultPage('d1')
+
+        # 3) fti should return it
+        self.assertEqual(
+            'd1',
+            fti.get_default_page(self.folder, check_exists=True)
+        )
+
+        # now test since we're sure everythings set up correctly
+        from Products.CMFPlone.defaultpage import get_default_page
+        self.assertEqual('d1', get_default_page(self.folder))
+
+        # missing here:
+        # - test adapter instead of direct implements in precondition 1
+        # - test adapter instead of direct implements in precondition 2
+
+    def test_get_default_page_step_3_1(self):
+        # 3. Else, look up the attribute default_page on the object, without
+        #    acquisition in place
+        # 3.1 look for a content in the container with the id, no acquisition!
+        self.folder.invokeFactory('Document', 'd1', title=u"Doc 1")
+        from Products.CMFPlone.defaultpage import get_default_page
+
+        # set doc d1 must work
+        self.folder.default_page = 'd1'
+        self.assertEqual('d1', get_default_page(self.folder))
+
+        # set doc d2 must fail and return None
+        self.folder.default_page = 'd2'
+        self.assertIsNone(get_default_page(self.folder))
+
+        # list of possible values is allowed
+        self.folder.default_page = ['d2', 'd1']
+        self.assertEqual('d1', get_default_page(self.folder))
+
+        # list of impossible values return None
+        self.folder.default_page = ['d2', 'd3']
+        self.assertIsNone(get_default_page(self.folder))
+
+        # acquisition check, must not work
+        self.folder.invokeFactory('Folder', 'f1', title=u"Sub Folder 1")
+        self.folder.f1.invokeFactory('Document', 'd2', title=u"Document 2")
+        self.folder.default_page = 'd2'
+        self.assertIsNone(get_default_page(self.folder.f1))
+
+    def test_get_default_page_step_3_2(self):
+        # 3. Else, look up the attribute default_page on the object, without
+        #    acquisition in place
+        # 3.2 look for a content at portal, with acquisition
+        self.portal.invokeFactory('Document', 'd1', title=u"Doc 1")
+        self.folder.default_page = 'd1'
+        from Products.CMFPlone.defaultpage import get_default_page
+
+        # now it must acquire from portal
+        self.assertEqual('d1', get_default_page(self.folder))
+
+        # fetch from i.e. portal_skins by acquisition
+        # robots.txt is in portal_skins/plone_templates and so available
+        # by acquisition
+        self.folder.default_page = 'robots.txt'
+        self.assertEqual('robots.txt', get_default_page(self.folder))
+
+    def test_get_default_page_step_4(self):
+        # 4. Else, look up the property default_page in site_properties for
+        #   magic ids and test these
+        sp = self.portal.portal_properties.site_properties
+        sp.manage_changeProperties(default_page=('d1',))
+        self.folder.invokeFactory('Document', 'd1', title=u"Doc 1")
+
+        from Products.CMFPlone.defaultpage import get_default_page
+        self.assertEqual('d1', get_default_page(self.folder))
diff --git a/Products/CMFPlone/utils.py b/Products/CMFPlone/utils.py
index 6fd2869..1b9c0a7 100644
--- a/Products/CMFPlone/utils.py
+++ b/Products/CMFPlone/utils.py
@@ -1,18 +1,25 @@
 # -*- coding: utf-8 -*-
-
-import re
-import json
-
-from types import ClassType
+from AccessControl import getSecurityManager
+from AccessControl import ModuleSecurityInfo
+from AccessControl import Unauthorized
+from Acquisition import aq_base
+from Acquisition import aq_get
+from Acquisition import aq_inner
+from Acquisition import aq_parent
+from App.Common import package_home
+from App.ImageFile import ImageFile
+from DateTime import DateTime
+from DateTime.interfaces import DateTimeError
 from os.path import join, abspath, split
-
-import pkg_resources
 from plone.i18n.normalizer.interfaces import IIDNormalizer
 from plone.registry.interfaces import IRegistry
+from Products.CMFCore.permissions import ManageUsers
+from Products.CMFCore.utils import getToolByName
+from Products.CMFCore.utils import ToolInit as CMFCoreToolInit
+from Products.CMFPlone import PloneMessageFactory as _
+from types import ClassType
 from webdav.interfaces import IWriteLock
-
-import zope.interface
-from zope.interface import implementedBy
+from zope import schema
 from zope.component import getMultiAdapter
 from zope.component import getUtility
 from zope.component import queryMultiAdapter
@@ -20,24 +27,15 @@
 from zope.component.hooks import getSite
 from zope.deprecation import deprecated
 from zope.i18n import translate
+from zope.interface import implementedBy
 from zope.publisher.interfaces.browser import IBrowserRequest
-from zope import schema
 
+import json
 import OFS
-from AccessControl import getSecurityManager, Unauthorized
-from AccessControl import ModuleSecurityInfo
-from Acquisition import aq_get
-from Acquisition import aq_base, aq_inner, aq_parent
-from App.Common import package_home
-from App.ImageFile import ImageFile
-from DateTime import DateTime
-from DateTime.interfaces import DateTimeError
-from Products.CMFCore.permissions import ManageUsers
-from Products.CMFCore.utils import ToolInit as CMFCoreToolInit
-from Products.CMFCore.utils import getToolByName
-from Products.CMFPlone import PloneMessageFactory as _
-
+import pkg_resources
+import re
 import transaction
+import zope.interface
 
 security = ModuleSecurityInfo()
 security.declarePrivate('deprecated')
@@ -97,8 +95,7 @@ def _getDefaultPageView(obj, request):
     """
     view = queryMultiAdapter((obj, request), name='default_page')
     if view is None:
-        # XXX: import here to avoid a circular dependency
-        from plone.app.layout.navigation.defaultpage import DefaultPage
+        from Products.CMFPlone.browser.defaultpage import DefaultPage
         view = DefaultPage(obj, request)
     return view
 
@@ -268,7 +265,7 @@ def next(self):
         return result
 
 
-security.declarePrivate('ToolInit')
+@security.private
 class ToolInit(CMFCoreToolInit):
 
     def getProductContext(self, context):
@@ -392,7 +389,7 @@ def versionTupleFromString(v_str):
         >>> versionTupleFromString('foo') is None
         True
         """
-    regex_str = "(^\d+)[.]?(\d*)[.]?(\d*)[- ]?(alpha|beta|candidate|final|a|b|rc)?(\d*)"
+    regex_str = "(^\d+)[.]?(\d*)[.]?(\d*)[- ]?(alpha|beta|candidate|final|a|b|rc)?(\d*)"  # noqa
     v_regex = re.compile(regex_str)
     match = v_regex.match(v_str)
     if match is None:
@@ -742,4 +739,4 @@ def getSiteLogo(site=None):
         return '{}/@@site-logo/{}'.format(
             site_url, filename)
     else:
-        return '%s/logo.png' % site_url
\ No newline at end of file
+        return '%s/logo.png' % site_url


Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2015-07-29T01:11:56+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.CMFPlone/commit/cf15b43baad43a06b4efdf5033fd8b8c950befbe

must apply to all zope objects in order to work, so take this basic interface.

Files changed:
M Products/CMFPlone/browser/configure.zcml

diff --git a/Products/CMFPlone/browser/configure.zcml b/Products/CMFPlone/browser/configure.zcml
index ca3de1a..a841477 100644
--- a/Products/CMFPlone/browser/configure.zcml
+++ b/Products/CMFPlone/browser/configure.zcml
@@ -200,7 +200,7 @@
 
     <!-- Default Page View -->
     <browser:page
-      for="Products.CMFCore.interfaces.IFolderish"
+      for="OFS.interfaces.IZopeObject"
       name="default_page"
       class=".defaultpage.DefaultPage"
       permission="zope.Public"


Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2015-07-29T01:45:14+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.CMFPlone/commit/12d1c5517e727c35fe6801a73c9f76d5eea980b2

to much renaming, revert where not applies

Files changed:
M Products/CMFPlone/tests/test_defaultpage.py

diff --git a/Products/CMFPlone/tests/test_defaultpage.py b/Products/CMFPlone/tests/test_defaultpage.py
index 0075003..daab269 100644
--- a/Products/CMFPlone/tests/test_defaultpage.py
+++ b/Products/CMFPlone/tests/test_defaultpage.py
@@ -50,7 +50,7 @@ def test_get_default_page_step_2(self):
         # 3) fti should return it
         self.assertEqual(
             'd1',
-            fti.get_default_page(self.folder, check_exists=True)
+            fti.getDefaultPage(self.folder, check_exists=True)
         )
 
         # now test since we're sure everythings set up correctly


Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2015-07-29T02:17:39+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/Products.CMFPlone/commit/509bc971e6157b59580f4c48185a63883bd6deee

move defaultpage stuff to its place, also place deprecated import placeholders at old places.

Files changed:
M Products/CMFPlone/PloneTool.py
M Products/CMFPlone/defaultpage.py
M Products/CMFPlone/utils.py

diff --git a/Products/CMFPlone/PloneTool.py b/Products/CMFPlone/PloneTool.py
index 17fd9f5..eeec833 100644
--- a/Products/CMFPlone/PloneTool.py
+++ b/Products/CMFPlone/PloneTool.py
@@ -1,59 +1,58 @@
-from email.Utils import getaddresses
-import re
-import sys
-from types import UnicodeType, StringType
-import urlparse
-import transaction
-
-from plone.registry.interfaces import IRegistry
-
-from zope.component import queryAdapter
-from zope.component import getUtility
-
-from zope.deprecation import deprecate
-from zope.interface import implements
-from zope.event import notify
-from zope.lifecycleevent import ObjectModifiedEvent
-
-from AccessControl import ClassSecurityInfo, Unauthorized
+# -*- coding: utf-8 -*-
+from AccessControl import ClassSecurityInfo
 from AccessControl import getSecurityManager
+from AccessControl import Unauthorized
+from AccessControl.requestmethod import postonly
 from Acquisition import aq_base
 from Acquisition import aq_inner
 from Acquisition import aq_parent
+from App.class_init import InitializeClass
 from ComputedAttribute import ComputedAttribute
 from DateTime import DateTime
-from App.class_init import InitializeClass
-from OFS.SimpleItem import SimpleItem
+from email.Utils import getaddresses
 from OFS.ObjectManager import bad_id
-from ZODB.POSException import ConflictError
-
-from Products.CMFCore.utils import UniqueObject
+from OFS.SimpleItem import SimpleItem
+from plone.registry.interfaces import IRegistry
+from Products.CMFCore.interfaces import IDublinCore
+from Products.CMFCore.interfaces import IMutableDublinCore
+from Products.CMFCore.permissions import AccessContentsInformation
+from Products.CMFCore.permissions import ManagePortal
+from Products.CMFCore.permissions import ManageUsers
+from Products.CMFCore.permissions import ModifyPortalContent
+from Products.CMFCore.permissions import View
 from Products.CMFCore.utils import getToolByName
-from Products.CMFCore import permissions
-from Products.CMFCore.permissions import AccessContentsInformation, \
-                        ManagePortal, ManageUsers, ModifyPortalContent, View
-from Products.CMFCore.interfaces import IDublinCore, IMutableDublinCore
+from Products.CMFCore.utils import UniqueObject
 from Products.CMFCore.WorkflowCore import WorkflowException
-from Products.CMFPlone.DublinCore import DefaultDublinCoreImpl
 from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault
-from Products.CMFPlone.interfaces import ISearchSchema
-from Products.CMFPlone.interfaces import ISiteSchema
+from Products.CMFPlone import utils
+from Products.CMFPlone.defaultpage import check_default_page_via_view
+from Products.CMFPlone.defaultpage import get_default_page_via_view
 from Products.CMFPlone.events import ReorderedEvent
-from Products.CMFPlone.interfaces import IPloneTool
 from Products.CMFPlone.interfaces import INonStructuralFolder
+from Products.CMFPlone.interfaces import IPloneTool
+from Products.CMFPlone.interfaces import ISearchSchema
 from Products.CMFPlone.interfaces import ISecuritySchema
+from Products.CMFPlone.interfaces import ISiteSchema
 from Products.CMFPlone.PloneBaseTool import PloneBaseTool
 from Products.CMFPlone.PloneFolder import ReplaceableWrapper
-from Products.CMFPlone import utils
+from Products.CMFPlone.utils import base_hasattr
 from Products.CMFPlone.utils import log
 from Products.CMFPlone.utils import log_exc
-from Products.CMFPlone.utils import transaction_note
-from Products.CMFPlone.utils import base_hasattr
 from Products.CMFPlone.utils import safe_hasattr
+from Products.CMFPlone.utils import transaction_note
 from Products.statusmessages.interfaces import IStatusMessage
-from AccessControl.requestmethod import postonly
-from plone.app.linkintegrity.exceptions \
-    import LinkIntegrityNotificationException
+from types import UnicodeType
+from ZODB.POSException import ConflictError
+from zope.component import getUtility
+from zope.component import queryAdapter
+from zope.deprecation import deprecate
+from zope.event import notify
+from zope.interface import implementer
+from zope.lifecycleevent import ObjectModifiedEvent
+import re
+import sys
+import transaction
+import urlparse
 
 
 _marker = utils._marker
@@ -64,7 +63,7 @@
 BAD_CHARS = bad_id.__self__.findall
 
 # max 63 chars per label in domains, see RFC1035
-EMAIL_RE = re.compile(r"^(\w&.%#$&'\*+-/=?^_`{}|~]+!)*[\w&.%#$&'\*+-/=?^_`{}|~]+@(([0-9a-z]([0-9a-z-]*[0-9a-z])?\.)+[a-z]{2,63}|([0-9]{1,3}\.){3}[0-9]{1,3})$", re.IGNORECASE)
+EMAIL_RE = re.compile(r"^(\w&.%#$&'\*+-/=?^_`{}|~]+!)*[\w&.%#$&'\*+-/=?^_`{}|~]+@(([0-9a-z]([0-9a-z-]*[0-9a-z])?\.)+[a-z]{2,63}|([0-9]{1,3}\.){3}[0-9]{1,3})$", re.IGNORECASE)  # noqa
 # used to find double new line (in any variant)
 EMAIL_CUTOFF_RE = re.compile(r".*[\n\r][\n\r]")
 
@@ -84,10 +83,11 @@
     'Format'           : 'DC.format',
     'Language'         : 'DC.language',
     'Rights'           : 'DC.rights',
-    }
+}
 METADATA_DC_AUTHORFIELDS = ('Creator', 'Contributors', 'Publisher')
 
 
+@implementer(IPloneTool)
 class PloneTool(PloneBaseTool, UniqueObject, SimpleItem):
     """Various utility methods."""
 
@@ -99,9 +99,7 @@ class PloneTool(PloneBaseTool, UniqueObject, SimpleItem):
     # Prefix for forms fields!?
     field_prefix = 'field_'
 
-    implements(IPloneTool)
-
-    security.declareProtected(ManageUsers, 'setMemberProperties')
+    @security.protected(ManageUsers)
     def setMemberProperties(self, member, REQUEST=None, **properties):
         pas = getToolByName(self, 'acl_users')
         if safe_hasattr(member, 'getId'):
@@ -109,7 +107,7 @@ def setMemberProperties(self, member, REQUEST=None, **properties):
         user = pas.getUserById(member)
         user.setProperties(**properties)
 
-    security.declarePublic('getSiteEncoding')
+    @security.public
     @deprecate(('`getSiteEncoding` is deprecated. Plone only supports UTF-8 '
                 'currently. This method always returns "utf-8"'))
     def getSiteEncoding(self):
@@ -122,7 +120,7 @@ def getSiteEncoding(self):
         """
         return 'utf-8'
 
-    security.declarePublic('portal_utf8')
+    @security.public
     def portal_utf8(self, str, errors='strict'):
         """ Transforms an string in portal encoding to utf8.
 
@@ -135,7 +133,7 @@ def portal_utf8(self, str, errors='strict'):
         """
         return utils.portal_utf8(self, str, errors)
 
-    security.declarePublic('utf8_portal')
+    @security.public
     def utf8_portal(self, str, errors='strict'):
         """ Transforms an utf8 string to portal encoding.
 
@@ -148,7 +146,7 @@ def utf8_portal(self, str, errors='strict'):
         """
         return utils.utf8_portal(self, str, errors)
 
-    security.declarePrivate('getMailHost')
+    @security.private
     def getMailHost(self):
         """ Gets the MailHost.
 
@@ -159,7 +157,7 @@ def getMailHost(self):
         """
         return getattr(aq_parent(self), 'MailHost')
 
-    security.declarePublic('validateSingleNormalizedEmailAddress')
+    @security.public
     def validateSingleNormalizedEmailAddress(self, address):
         """Lower-level function to validate a single normalized email address,
         see validateEmailAddress.
@@ -168,7 +166,7 @@ def validateSingleNormalizedEmailAddress(self, address):
             return False
 
         sub = EMAIL_CUTOFF_RE.match(address)
-        if sub != None:
+        if sub is not None:
             # Address contains two newlines (possible spammer relay attack)
             return False
 
@@ -178,14 +176,14 @@ def validateSingleNormalizedEmailAddress(self, address):
             return True
         return False
 
-    security.declarePublic('validateSingleEmailAddress')
+    @security.public
     def validateSingleEmailAddress(self, address):
         """Validate a single email address, see also validateEmailAddresses."""
         if not isinstance(address, basestring):
             return False
 
         sub = EMAIL_CUTOFF_RE.match(address)
-        if sub != None:
+        if sub is not None:
             # Address contains two newlines (spammer attack using
             # "address\n\nSpam message")
             return False
@@ -200,7 +198,7 @@ def validateSingleEmailAddress(self, address):
                 return False
         return True
 
-    security.declarePublic('validateEmailAddresses')
+    @security.public
     def validateEmailAddresses(self, addresses):
         """Validate a list of possibly several email addresses, see also
         validateSingleEmailAddress.
@@ -209,7 +207,7 @@ def validateEmailAddresses(self, addresses):
             return False
 
         sub = EMAIL_CUTOFF_RE.match(addresses)
-        if sub != None:
+        if sub is not None:
             # Addresses contains two newlines (spammer attack using
             # "To: list\n\nSpam message")
             return False
@@ -220,7 +218,7 @@ def validateEmailAddresses(self, addresses):
                 return False
         return True
 
-    security.declarePublic('editMetadata')
+    @security.public
     def editMetadata(self, obj, allowDiscussion=None, title=None,
                      subject=None, description=None, contributors=None,
                      effective_date=None, expiration_date=None, format=None,
@@ -297,9 +295,10 @@ def _renameObject(self, obj, id):
             parent.manage_renameObject(obj.getId(), id)
 
     def _makeTransactionNote(self, obj, msg=''):
-        #TODO Why not aq_parent()?
-        relative_path = '/'.join(getToolByName(self, 'portal_url') \
-                                    .getRelativeContentPath(obj)[:-1])
+        # TODO Why not aq_parent()?
+        relative_path = '/'.join(
+            getToolByName(self, 'portal_url').getRelativeContentPath(obj)[:-1]
+        )
         if not msg:
             msg = relative_path + '/' + obj.title_or_id() \
                     + ' has been modified.'
@@ -311,7 +310,7 @@ def _makeTransactionNote(self, obj, msg=''):
         if not transaction.get().description:
             transaction_note(msg)
 
-    security.declarePublic('contentEdit')
+    @security.public
     def contentEdit(self, obj, **kwargs):
         """Encapsulates how the editing of content occurs."""
         try:
@@ -323,7 +322,7 @@ def contentEdit(self, obj, **kwargs):
             self._renameObject(obj, id=kwargs['id'].strip())
         self._makeTransactionNote(obj)
 
-    security.declarePublic('availableMIMETypes')
+    @security.public
     def availableMIMETypes(self):
         """Returns a map of mimetypes.
 
@@ -332,7 +331,7 @@ def availableMIMETypes(self):
         mtr = getToolByName(self, 'mimetypes_registry')
         return mtr.list_mimetypes()
 
-    security.declareProtected(View, 'getWorkflowChainFor')
+    @security.protected(View)
     def getWorkflowChainFor(self, object):
         """Proxy the request for the chain to the workflow tool, as
         this method is private there.
@@ -347,7 +346,7 @@ def getWorkflowChainFor(self, object):
             pass
         return wfs
 
-    security.declareProtected(View, 'getIconFor')
+    @security.protected(View)
     def getIconFor(self, category, id, default=_marker, context=None):
         """Get an icon for an action, from its icon_expr.
         """
@@ -373,7 +372,7 @@ def getIconFor(self, category, id, default=_marker, context=None):
 
         return icon
 
-    security.declareProtected(View, 'getReviewStateTitleFor')
+    @security.protected(View)
     def getReviewStateTitleFor(self, obj):
         """Utility method that gets the workflow state title for the
         object's review_state.
@@ -399,7 +398,7 @@ def getReviewStateTitleFor(self, obj):
                     return w.states[objstate].title or objstate
         return None
 
-    security.declareProtected(ManagePortal, 'changeOwnershipOf')
+    @security.protected(ManagePortal)
     def changeOwnershipOf(self, object, userid, recursive=0, REQUEST=None):
         """Changes the ownership of an object."""
         membership = getToolByName(self, 'portal_membership')
@@ -439,15 +438,17 @@ def fixOwnerRole(object, user_id):
             catalog_tool = getToolByName(self, 'portal_catalog')
             purl = getToolByName(self, 'portal_url')
             _path = purl.getRelativeContentURL(object)
-            subobjects = [b.getObject() for b in
-                         catalog_tool(path={'query': _path, 'level': 1})]
+            subobjects = [
+                b.getObject()
+                for b in catalog_tool(path={'query': _path, 'level': 1})
+            ]
             for obj in subobjects:
                 fixOwnerRole(obj, user.getId())
                 if base_hasattr(obj, 'reindexObject'):
                     obj.reindexObject()
     changeOwnershipOf = postonly(changeOwnershipOf)
 
-    security.declarePublic('urlparse')
+    @security.public
     def urlparse(self, url):
         """Returns the pieces of url in a six-part tuple.
 
@@ -465,7 +466,7 @@ def urlparse(self, url):
         """
         return tuple(urlparse.urlparse(url))
 
-    security.declarePublic('urlunparse')
+    @security.public
     def urlunparse(self, url_tuple):
         """Puts a url back together again, in the manner that
         urlparse breaks it.
@@ -475,7 +476,8 @@ def urlunparse(self, url_tuple):
 
         >>> ptool = self.portal.plone_utils
 
-        >>> ptool.urlunparse(('http', 'plone.org', '/support', '', '', 'users'))
+        >>> ptool.urlunparse(
+        ...     ('http', 'plone.org', '/support', '', '', 'users'))
         'http://plone.org/support#users'
         """
         return urlparse.urlunparse(url_tuple)
@@ -488,7 +490,7 @@ def exceptionString(self):
         s = sys.exc_info()[:2]
         if s[0] == None:
             return None
-        if type(s[0]) == type(''):
+        if isinstance(s[0], basestring):
             return s[0]
         return str(s[1])
 
@@ -499,7 +501,7 @@ def logException(self):
         """
         log_exc()
 
-    security.declarePublic('createSitemap')
+    @security.public
     def createSitemap(self, context, request=None):
         """Returns a sitemap navtree structure.
         """
@@ -512,11 +514,11 @@ def _addToNavTreeResult(self, result, data):
         """
         return utils.addToNavTreeResult(result, data)
 
-    security.declareProtected(AccessContentsInformation, 'typesToList')
+    @security.protected(AccessContentsInformation)
     def typesToList(self):
         return utils.typesToList(self)
 
-    security.declarePublic('createNavTree')
+    @security.public
     def createNavTree(self, context, sitemap=None, request=None):
         """Returns a structure that can be used by navigation_tree_slot.
         """
@@ -524,7 +526,7 @@ def createNavTree(self, context, sitemap=None, request=None):
             request = self.REQUEST
         return utils.createNavTree(context, request)
 
-    security.declarePublic('createBreadCrumbs')
+    @security.public
     def createBreadCrumbs(self, context, request=None):
         """Returns a structure for the portal breadcumbs.
         """
@@ -532,7 +534,7 @@ def createBreadCrumbs(self, context, request=None):
             request = self.REQUEST
         return utils.createBreadCrumbs(context, request)
 
-    security.declarePublic('good_id')
+    @security.public
     def good_id(self, id):
         """Exposes ObjectManager's bad_id test to skin scripts."""
         m = bad_id(id)
@@ -540,12 +542,12 @@ def good_id(self, id):
             return 0
         return 1
 
-    security.declarePublic('bad_chars')
+    @security.public
     def bad_chars(self, id):
         """Returns a list of the Bad characters."""
         return BAD_CHARS(id)
 
-    security.declarePublic('getInheritedLocalRoles')
+    @security.public
     def getInheritedLocalRoles(self, context):
         """Returns a tuple with the acquired local roles."""
         portal = getToolByName(context, 'portal_url').getPortalObject()
@@ -564,7 +566,7 @@ def getInheritedLocalRoles(self, context):
                         if user2 == user:
                             # Check which roles must be added to roles2
                             for role in roles:
-                                if not role in roles2:
+                                if role not in roles2:
                                     roles2.append(role)
                             found = 1
                             break
@@ -599,45 +601,30 @@ def getInheritedLocalRoles(self, context):
     #       : lookup rules for old-style content types
     #
 
-    security.declarePublic('isDefaultPage')
+    @security.public
     def isDefaultPage(self, obj, request=None):
         """Finds out if the given obj is the default page in its parent folder.
-
-        Only considers explicitly contained objects, either set as index_html,
-        with the default_page property, or using IBrowserDefault.
+        Uses the lookup rules of Plone.  Lookup happens over a view, for which
+        in theory a different implementation may exist.
         """
         if request is None:
             request = self.REQUEST
-        return utils.isDefaultPage(obj, request)
+        return check_default_page_via_view(obj, request)
 
-    security.declarePublic('getDefaultPage')
+    @security.public
     def getDefaultPage(self, obj, request=None):
         """Given a folderish item, find out if it has a default-page using
-        the following lookup rules:
-
-            1. A content object called 'index_html' wins
-            2. If the folder implements IBrowserDefault, query this
-            3. Else, look up the property default_page on the object
-                - Note that in this case, the returned id may *not* be of an
-                  object in the folder, since it could be acquired from a
-                  parent folder or skin layer
-            4. Else, look up the property default_page in site_properties for
-                magic ids and test these
-
-        The id of the first matching item is then used to lookup a translation
-        and if found, its id is returned. If no default page is set, None is
-        returned. If a non-folderish item is passed in, return None always.
+        the lookup rules of Plone (see Products.CMFPlone/defaultpage.py).
+        Lookup happens over a view, for which in theory a different
+        implementation may be used.
         """
         if request is None:
             if hasattr(self, 'REQUEST'):
                 request = self.REQUEST
         if request:
-            return utils.getDefaultPage(obj, request)
-        else:
-            # In case its executed from an event that does not have request
-            return None
+            return get_default_page_via_view(obj, request)
 
-    security.declarePublic('addPortalMessage')
+    @security.public
     def addPortalMessage(self, message, type='info', request=None):
         """\
         Call this once or more to add messages to be displayed at the
@@ -670,13 +657,13 @@ def addPortalMessage(self, message, type='info', request=None):
         long as they are processed before the portal_message macro is
         called by the main template. Example:
 
-          <tal:block tal:define="temp python:context.plone_utils.addPortalMessage('A random info message')" />
+          <tal:block tal:define="temp python:context.plone_utils.addPortalMessage('A random info message')" />  # noqa
         """
         if request is None:
             request = self.REQUEST
         IStatusMessage(request).add(message, type=type)
 
-    security.declarePublic('showPortalMessages')
+    @security.public
     def showPortalMessages(self, request=None):
         """\
         Return portal status messages that will be displayed when the
@@ -690,7 +677,7 @@ def showPortalMessages(self, request=None):
             request = self.REQUEST
         return IStatusMessage(request).show()
 
-    security.declarePublic('browserDefault')
+    @security.public
     def browserDefault(self, obj):
         """Sets default so we can return whatever we want instead of index_html.
 
@@ -702,7 +689,7 @@ def browserDefault(self, obj):
         a template or other object to be acquired and displayed on the object.
         The path is determined as follows:
 
-        0. If we're coming from WebDAV, make sure we don't return a contained
+        0. If we're c oming from WebDAV, make sure we don't return a contained
             object "default page" ever
         1. If there is an index_html attribute (either a contained object or
             an explicit attribute) on the object, return that as the
@@ -773,8 +760,10 @@ def browserDefault(self, obj):
                     return obj, [defaultPage]
                 # Avoid infinite recursion in the case that the page id == the
                 # object id
-                elif defaultPage != obj.getId() and \
-                     defaultPage != '/'.join(obj.getPhysicalPath()):
+                elif (
+                    defaultPage != obj.getId()
+                    and defaultPage != '/'.join(obj.getPhysicalPath())
+                ):
                     # For the default_page property, we may get things in the
                     # skin layers or with an explicit path - split this path
                     # to comply with the __browser_default__() spec
@@ -808,7 +797,9 @@ def browserDefault(self, obj):
                 # XXX: This isn't quite right since it assumes the action
                 # starts with ${object_url}.  Should we raise an error if
                 # it doesn't?
-                act = obj.getTypeInfo().getActionInfo('folder/folderlisting')['url'].split('/')[-1]
+                act = obj.getTypeInfo().getActionInfo(
+                    'folder/folderlisting'
+                )['url'].split('/')[-1]
                 return obj, [act]
             except ValueError:
                 pass
@@ -821,7 +812,9 @@ def browserDefault(self, obj):
                 # XXX: This isn't quite right since it assumes the action
                 # starts with ${object_url}.  Should we raise an error if
                 # it doesn't?
-                act = obj.getTypeInfo().getActionInfo('object/view')['url'].split('/')[-1]
+                act = obj.getTypeInfo().getActionInfo(
+                    'object/view'
+                )['url'].split('/')[-1]
                 return obj, [act]
             except ValueError:
                 pass
@@ -831,10 +824,11 @@ def browserDefault(self, obj):
         #
 
         raise AttributeError(
-                "Failed to get a default page or view_action for %s"
-                    % (obj.absolute_url(),))
+            "Failed to get a default page or view_action for %s"
+            % (obj.absolute_url(),)
+        )
 
-    security.declarePublic('isStructuralFolder')
+    @security.public
     def isStructuralFolder(self, obj):
         """Checks if a given object is a "structural folder".
 
@@ -847,14 +841,12 @@ def isStructuralFolder(self, obj):
         >>> ptool.isStructuralFolder(self.folder)
         True
         """
-        if not obj.isPrincipiaFolderish:
-            return False
-        elif INonStructuralFolder.providedBy(obj):
-            return False
-        else:
-            return True
+        return (
+            obj.isPrincipiaFolderish
+            and not INonStructuralFolder.providedBy(obj)
+        )
 
-    security.declarePublic('acquireLocalRoles')
+    @security.public
     def acquireLocalRoles(self, obj, status=1, REQUEST=None):
         """If status is 1, allow acquisition of local roles (regular
         behaviour).
@@ -878,7 +870,7 @@ def acquireLocalRoles(self, obj, status=1, REQUEST=None):
         obj.reindexObjectSecurity()
     acquireLocalRoles = postonly(acquireLocalRoles)
 
-    security.declarePublic('isLocalRoleAcquired')
+    @security.public
     def isLocalRoleAcquired(self, obj):
         """Returns local role acquisition blocking status.
 
@@ -888,7 +880,7 @@ def isLocalRoleAcquired(self, obj):
             return False
         return True
 
-    security.declarePublic('getOwnerName')
+    @security.public
     def getOwnerName(self, obj):
         """ Returns the userid of the owner of an object.
 
@@ -903,7 +895,7 @@ def getOwnerName(self, obj):
             raise Unauthorized
         return obj.getOwner().getId()
 
-    security.declarePublic('normalizeString')
+    @security.public
     def normalizeString(self, text):
         """Normalizes a title to an id.
 
@@ -960,7 +952,7 @@ def normalizeString(self, text):
         """
         return utils.normalizeString(text, context=self)
 
-    security.declarePublic('listMetaTags')
+    @security.public
     def listMetaTags(self, context):
         """Lists meta tags helper.
 
@@ -1073,7 +1065,7 @@ def listMetaTags(self, context):
 
         return result
 
-    security.declarePublic('getUserFriendlyTypes')
+    @security.public
     def getUserFriendlyTypes(self, typesList=None):
         """Get a list of types which are considered "user friendly" for search
         and selection purposes.
@@ -1100,18 +1092,18 @@ def getUserFriendlyTypes(self, typesList=None):
         friendlyTypes = set(types) - set(blacklistedTypes)
         return list(friendlyTypes)
 
-    security.declarePublic('reindexOnReorder')
+    @security.public
     def reindexOnReorder(self, parent):
         """ reindexing of "gopip" isn't needed any longer,
         but some extensions might need the info anyway :("""
         notify(ReorderedEvent(parent))
 
-    security.declarePublic('isIDAutoGenerated')
+    @security.public
     def isIDAutoGenerated(self, id):
         """Determine if an id is autogenerated"""
         return utils.isIDAutoGenerated(self, id)
 
-    security.declarePublic('getEmptyTitle')
+    @security.public
     def getEmptyTitle(self, translated=True):
         """ Returns string to be used for objects with no title or id.
 
@@ -1122,7 +1114,7 @@ def getEmptyTitle(self, translated=True):
         """
         return utils.getEmptyTitle(self, translated)
 
-    security.declarePublic('pretty_title_or_id')
+    @security.public
     def pretty_title_or_id(self, obj, empty_value=_marker):
         """Return the best possible title or id of an item, regardless
         of whether obj is a catalog brain or an object, but returning an
@@ -1130,7 +1122,7 @@ def pretty_title_or_id(self, obj, empty_value=_marker):
         """
         return utils.pretty_title_or_id(self, obj, empty_value=empty_value)
 
-    security.declarePublic('getMethodAliases')
+    @security.public
     def getMethodAliases(self, typeInfo):
         """Given an FTI, return the dict of method aliases defined on that
         FTI. If there are no method aliases (i.e. this FTI doesn't support it),
@@ -1145,7 +1137,7 @@ def getMethodAliases(self, typeInfo):
     # This is public because we don't know what permissions the user
     # has on the objects to be deleted.  The restrictedTraverse and
     # manage_delObjects calls should handle permission checks for us.
-    security.declarePublic('deleteObjectsByPaths')
+    @security.public
     def deleteObjectsByPaths(self, paths, handle_errors=True, REQUEST=None):
         failure = {}
         success = []
@@ -1176,7 +1168,7 @@ def deleteObjectsByPaths(self, paths, handle_errors=True, REQUEST=None):
         return success, failure
     deleteObjectsByPaths = postonly(deleteObjectsByPaths)
 
-    security.declarePublic('transitionObjectsByPaths')
+    @security.public
     def transitionObjectsByPaths(self, workflow_action, paths, comment='',
                                  expiration_date=None, effective_date=None,
                                  include_children=False, handle_errors=True,
@@ -1213,7 +1205,7 @@ def transitionObjectsByPaths(self, workflow_action, paths, comment='',
         return failure
     transitionObjectsByPaths = postonly(transitionObjectsByPaths)
 
-    security.declarePublic('renameObjectsByPaths')
+    @security.public
     def renameObjectsByPaths(self, paths, new_ids, new_titles,
                              handle_errors=True, REQUEST=None):
         failure = {}
@@ -1233,7 +1225,9 @@ def renameObjectsByPaths(self, paths, new_ids, new_titles,
                 change_title = new_title and title != new_title
                 changed = False
                 if change_title:
-                    getSecurityManager().validate(obj, obj, 'setTitle', obj.setTitle)
+                    getSecurityManager().validate(
+                        obj, obj, 'setTitle', obj.setTitle
+                    )
                     obj.setTitle(new_title)
                     notify(ObjectModifiedEvent(obj))
                     changed = True
diff --git a/Products/CMFPlone/defaultpage.py b/Products/CMFPlone/defaultpage.py
index 1917054..365a8d2 100644
--- a/Products/CMFPlone/defaultpage.py
+++ b/Products/CMFPlone/defaultpage.py
@@ -1,5 +1,7 @@
 # -*- coding: utf-8 -*-
 from Acquisition import aq_base
+from Acquisition import aq_parent
+from Acquisition import aq_inner
 from Products.BTreeFolder2.BTreeFolder2 import BTreeFolder2Base
 from Products.CMFCore.interfaces import IFolderish
 from Products.CMFCore.interfaces import ISiteRoot
@@ -7,6 +9,7 @@
 from Products.CMFDynamicViewFTI.interfaces import IDynamicViewTypeInformation
 from zope.component import queryAdapter
 from zope.component import queryUtility
+from zope.component import queryMultiAdapter
 
 
 def get_default_page(context):
@@ -106,3 +109,33 @@ def is_default_page(container, obj):
         and hasattr(aq_base(obj), 'getId')
     )
     return precondition and (parent_default_page == obj.getId())
+
+
+def _getDefaultPageView(obj, request):
+    """This is a nasty hack because the view lookup fails when it occurs too
+       early in the publishing process because the request isn't marked with
+       the default skin.  Explicitly marking the request appears to cause
+       connection errors, so we just instantiate the view manually.
+    """
+    view = queryMultiAdapter((obj, request), name='default_page')
+    if view is None:
+        # mask circular import
+        from Products.CMFPlone.browser.defaultpage import DefaultPage
+        view = DefaultPage(obj, request)
+    return view
+
+
+def check_default_page_via_view(obj, request):
+    container = aq_parent(aq_inner(obj))
+    if container is None:
+        return False
+    view = _getDefaultPageView(container, request)
+    return view.isDefaultPage(obj)
+
+
+def get_default_page_via_view(obj, request):
+    # Short circuit if we are not looking at a Folder
+    if not obj.isPrincipiaFolderish:
+        return None
+    view = _getDefaultPageView(obj, request)
+    return view.getDefaultPage()
diff --git a/Products/CMFPlone/utils.py b/Products/CMFPlone/utils.py
index 1b9c0a7..a9cbcbf 100644
--- a/Products/CMFPlone/utils.py
+++ b/Products/CMFPlone/utils.py
@@ -22,9 +22,9 @@
 from zope import schema
 from zope.component import getMultiAdapter
 from zope.component import getUtility
-from zope.component import queryMultiAdapter
 from zope.component import queryUtility
 from zope.component.hooks import getSite
+from zope.deferredimport import deprecated as deprecated_import
 from zope.deprecation import deprecated
 from zope.i18n import translate
 from zope.interface import implementedBy
@@ -37,6 +37,12 @@
 import transaction
 import zope.interface
 
+deprecated_import(
+    "Import from Products.CMFPlone.defaultpage instead",
+    isDefaultPage='Products.CMFPlone.defaultpage:check_default_page_via_view',
+    getDefaultPage='Products.CMFPlone.defaultpage:get_default_page_via_view',
+)
+
 security = ModuleSecurityInfo()
 security.declarePrivate('deprecated')
 security.declarePrivate('abspath')
@@ -87,35 +93,6 @@ def createSiteMap(context, request, sitemap=False):
     return view.siteMap()
 
 
-def _getDefaultPageView(obj, request):
-    """This is a nasty hack because the view lookup fails when it occurs too
-       early in the publishing process because the request isn't marked with
-       the default skin.  Explicitly marking the request appears to cause
-       connection errors, so we just instantiate the view manually.
-    """
-    view = queryMultiAdapter((obj, request), name='default_page')
-    if view is None:
-        from Products.CMFPlone.browser.defaultpage import DefaultPage
-        view = DefaultPage(obj, request)
-    return view
-
-
-def isDefaultPage(obj, request):
-    container = parent(obj)
-    if container is None:
-        return False
-    view = _getDefaultPageView(container, request)
-    return view.isDefaultPage(obj)
-
-
-def getDefaultPage(obj, request):
-    # Short circuit if we are not looking at a Folder
-    if not obj.isPrincipiaFolderish:
-        return None
-    view = _getDefaultPageView(obj, request)
-    return view.getDefaultPage()
-
-
 def isIDAutoGenerated(context, id):
     # In 2.1 non-autogenerated is the common case, caught exceptions are
     # expensive, so let's make a cheap check first


Repository: Products.CMFPlone


Branch: refs/heads/master
Date: 2015-07-29T17:15:55+02:00
Author: agitator (agitator) <hpeter@agitator.com>
Commit: https://github.com/plone/Products.CMFPlone/commit/97e4e0eeaec0f3e177e8b756195f51abd9725203

Merge pull request #758 from plone/jensens-defaultpage-move

move Plone specific getDefaultPage code+view from plone.app.layout ov…

Files changed:
A Products/CMFPlone/browser/defaultpage.py
A Products/CMFPlone/defaultpage.py
A Products/CMFPlone/interfaces/defaultpage.py
A Products/CMFPlone/tests/test_defaultpage.py
M CHANGES.rst
M Products/CMFPlone/PloneTool.py
M Products/CMFPlone/browser/configure.zcml
M Products/CMFPlone/utils.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 9bbae63..c25e0c1 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -8,6 +8,11 @@ Changelog
 5.0b4 (unreleased)
 ------------------
 
+- move Plone specific ``getDefaultPage`` (magic) code from plone.app.layout
+  over to Products.CMFPlone. This avoids a circular dependency. Also its
+  not really layout only related code.
+  [jensens]
+
 - Fix add-ons to be installed using CMFQuickInstaller (restore support
   for Extensions/Install.py)
   [datakurre]
diff --git a/Products/CMFPlone/PloneTool.py b/Products/CMFPlone/PloneTool.py
index 17fd9f5..eeec833 100644
--- a/Products/CMFPlone/PloneTool.py
+++ b/Products/CMFPlone/PloneTool.py
@@ -1,59 +1,58 @@
-from email.Utils import getaddresses
-import re
-import sys
-from types import UnicodeType, StringType
-import urlparse
-import transaction
-
-from plone.registry.interfaces import IRegistry
-
-from zope.component import queryAdapter
-from zope.component import getUtility
-
-from zope.deprecation import deprecate
-from zope.interface import implements
-from zope.event import notify
-from zope.lifecycleevent import ObjectModifiedEvent
-
-from AccessControl import ClassSecurityInfo, Unauthorized
+# -*- coding: utf-8 -*-
+from AccessControl import ClassSecurityInfo
 from AccessControl import getSecurityManager
+from AccessControl import Unauthorized
+from AccessControl.requestmethod import postonly
 from Acquisition import aq_base
 from Acquisition import aq_inner
 from Acquisition import aq_parent
+from App.class_init import InitializeClass
 from ComputedAttribute import ComputedAttribute
 from DateTime import DateTime
-from App.class_init import InitializeClass
-from OFS.SimpleItem import SimpleItem
+from email.Utils import getaddresses
 from OFS.ObjectManager import bad_id
-from ZODB.POSException import ConflictError
-
-from Products.CMFCore.utils import UniqueObject
+from OFS.SimpleItem import SimpleItem
+from plone.registry.interfaces import IRegistry
+from Products.CMFCore.interfaces import IDublinCore
+from Products.CMFCore.interfaces import IMutableDublinCore
+from Products.CMFCore.permissions import AccessContentsInformation
+from Products.CMFCore.permissions import ManagePortal
+from Products.CMFCore.permissions import ManageUsers
+from Products.CMFCore.permissions import ModifyPortalContent
+from Products.CMFCore.permissions import View
 from Products.CMFCore.utils import getToolByName
-from Products.CMFCore import permissions
-from Products.CMFCore.permissions import AccessContentsInformation, \
-                        ManagePortal, ManageUsers, ModifyPortalContent, View
-from Products.CMFCore.interfaces import IDublinCore, IMutableDublinCore
+from Products.CMFCore.utils import UniqueObject
 from Products.CMFCore.WorkflowCore import WorkflowException
-from Products.CMFPlone.DublinCore import DefaultDublinCoreImpl
 from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault
-from Products.CMFPlone.interfaces import ISearchSchema
-from Products.CMFPlone.interfaces import ISiteSchema
+from Products.CMFPlone import utils
+from Products.CMFPlone.defaultpage import check_default_page_via_view
+from Products.CMFPlone.defaultpage import get_default_page_via_view
 from Products.CMFPlone.events import ReorderedEvent
-from Products.CMFPlone.interfaces import IPloneTool
 from Products.CMFPlone.interfaces import INonStructuralFolder
+from Products.CMFPlone.interfaces import IPloneTool
+from Products.CMFPlone.interfaces import ISearchSchema
 from Products.CMFPlone.interfaces import ISecuritySchema
+from Products.CMFPlone.interfaces import ISiteSchema
 from Products.CMFPlone.PloneBaseTool import PloneBaseTool
 from Products.CMFPlone.PloneFolder import ReplaceableWrapper
-from Products.CMFPlone import utils
+from Products.CMFPlone.utils import base_hasattr
 from Products.CMFPlone.utils import log
 from Products.CMFPlone.utils import log_exc
-from Products.CMFPlone.utils import transaction_note
-from Products.CMFPlone.utils import base_hasattr
 from Products.CMFPlone.utils import safe_hasattr
+from Products.CMFPlone.utils import transaction_note
 from Products.statusmessages.interfaces import IStatusMessage
-from AccessControl.requestmethod import postonly
-from plone.app.linkintegrity.exceptions \
-    import LinkIntegrityNotificationException
+from types import UnicodeType
+from ZODB.POSException import ConflictError
+from zope.component import getUtility
+from zope.component import queryAdapter
+from zope.deprecation import deprecate
+from zope.event import notify
+from zope.interface import implementer
+from zope.lifecycleevent import ObjectModifiedEvent
+import re
+import sys
+import transaction
+import urlparse
 
 
 _marker = utils._marker
@@ -64,7 +63,7 @@
 BAD_CHARS = bad_id.__self__.findall
 
 # max 63 chars per label in domains, see RFC1035
-EMAIL_RE = re.compile(r"^(\w&.%#$&'\*+-/=?^_`{}|~]+!)*[\w&.%#$&'\*+-/=?^_`{}|~]+@(([0-9a-z]([0-9a-z-]*[0-9a-z])?\.)+[a-z]{2,63}|([0-9]{1,3}\.){3}[0-9]{1,3})$", re.IGNORECASE)
+EMAIL_RE = re.compile(r"^(\w&.%#$&'\*+-/=?^_`{}|~]+!)*[\w&.%#$&'\*+-/=?^_`{}|~]+@(([0-9a-z]([0-9a-z-]*[0-9a-z])?\.)+[a-z]{2,63}|([0-9]{1,3}\.){3}[0-9]{1,3})$", re.IGNORECASE)  # noqa
 # used to find double new line (in any variant)
 EMAIL_CUTOFF_RE = re.compile(r".*[\n\r][\n\r]")
 
@@ -84,10 +83,11 @@
     'Format'           : 'DC.format',
     'Language'         : 'DC.language',
     'Rights'           : 'DC.rights',
-    }
+}
 METADATA_DC_AUTHORFIELDS = ('Creator', 'Contributors', 'Publisher')
 
 
+@implementer(IPloneTool)
 class PloneTool(PloneBaseTool, UniqueObject, SimpleItem):
     """Various utility methods."""
 
@@ -99,9 +99,7 @@ class PloneTool(PloneBaseTool, UniqueObject, SimpleItem):
     # Prefix for forms fields!?
     field_prefix = 'field_'
 
-    implements(IPloneTool)
-
-    security.declareProtected(ManageUsers, 'setMemberProperties')
+    @security.protected(ManageUsers)
     def setMemberProperties(self, member, REQUEST=None, **properties):
         pas = getToolByName(self, 'acl_users')
         if safe_hasattr(member, 'getId'):
@@ -109,7 +107,7 @@ def setMemberProperties(self, member, REQUEST=None, **properties):
         user = pas.getUserById(member)
         user.setProperties(**properties)
 
-    security.declarePublic('getSiteEncoding')
+    @security.public
     @deprecate(('`getSiteEncoding` is deprecated. Plone only supports UTF-8 '
                 'currently. This method always returns "utf-8"'))
     def getSiteEncoding(self):
@@ -122,7 +120,7 @@ def getSiteEncoding(self):
         """
         return 'utf-8'
 
-    security.declarePublic('portal_utf8')
+    @security.public
     def portal_utf8(self, str, errors='strict'):
         """ Transforms an string in portal encoding to utf8.
 
@@ -135,7 +133,7 @@ def portal_utf8(self, str, errors='strict'):
         """
         return utils.portal_utf8(self, str, errors)
 
-    security.declarePublic('utf8_portal')
+    @security.public
     def utf8_portal(self, str, errors='strict'):
         """ Transforms an utf8 string to portal encoding.
 
@@ -148,7 +146,7 @@ def utf8_portal(self, str, errors='strict'):
         """
         return utils.utf8_portal(self, str, errors)
 
-    security.declarePrivate('getMailHost')
+    @security.private
     def getMailHost(self):
         """ Gets the MailHost.
 
@@ -159,7 +157,7 @@ def getMailHost(self):
         """
         return getattr(aq_parent(self), 'MailHost')
 
-    security.declarePublic('validateSingleNormalizedEmailAddress')
+    @security.public
     def validateSingleNormalizedEmailAddress(self, address):
         """Lower-level function to validate a single normalized email address,
         see validateEmailAddress.
@@ -168,7 +166,7 @@ def validateSingleNormalizedEmailAddress(self, address):
             return False
 
         sub = EMAIL_CUTOFF_RE.match(address)
-        if sub != None:
+        if sub is not None:
             # Address contains two newlines (possible spammer relay attack)
             return False
 
@@ -178,14 +176,14 @@ def validateSingleNormalizedEmailAddress(self, address):
             return True
         return False
 
-    security.declarePublic('validateSingleEmailAddress')
+    @security.public
     def validateSingleEmailAddress(self, address):
         """Validate a single email address, see also validateEmailAddresses."""
         if not isinstance(address, basestring):
             return False
 
         sub = EMAIL_CUTOFF_RE.match(address)
-        if sub != None:
+        if sub is not None:
             # Address contains two newlines (spammer attack using
             # "address\n\nSpam message")
             return False
@@ -200,7 +198,7 @@ def validateSingleEmailAddress(self, address):
                 return False
         return True
 
-    security.declarePublic('validateEmailAddresses')
+    @security.public
     def validateEmailAddresses(self, addresses):
         """Validate a list of possibly several email addresses, see also
         validateSingleEmailAddress.
@@ -209,7 +207,7 @@ def validateEmailAddresses(self, addresses):
             return False
 
         sub = EMAIL_CUTOFF_RE.match(addresses)
-        if sub != None:
+        if sub is not None:
             # Addresses contains two newlines (spammer attack using
             # "To: list\n\nSpam message")
             return False
@@ -220,7 +218,7 @@ def validateEmailAddresses(self, addresses):
                 return False
         return True
 
-    security.declarePublic('editMetadata')
+    @security.public
     def editMetadata(self, obj, allowDiscussion=None, title=None,
                      subject=None, description=None, contributors=None,
                      effective_date=None, expiration_date=None, format=None,
@@ -297,9 +295,10 @@ def _renameObject(self, obj, id):
             parent.manage_renameObject(obj.getId(), id)
 
     def _makeTransactionNote(self, obj, msg=''):
-        #TODO Why not aq_parent()?
-        relative_path = '/'.join(getToolByName(self, 'portal_url') \
-                                    .getRelativeContentPath(obj)[:-1])
+        # TODO Why not aq_parent()?
+        relative_path = '/'.join(
+            getToolByName(self, 'portal_url').getRelativeContentPath(obj)[:-1]
+        )
         if not msg:
             msg = relative_path + '/' + obj.title_or_id() \
                     + ' has been modified.'
@@ -311,7 +310,7 @@ def _makeTransactionNote(self, obj, msg=''):
         if not transaction.get().description:
             transaction_note(msg)
 
-    security.declarePublic('contentEdit')
+    @security.public
     def contentEdit(self, obj, **kwargs):
         """Encapsulates how the editing of content occurs."""
         try:
@@ -323,7 +322,7 @@ def contentEdit(self, obj, **kwargs):
             self._renameObject(obj, id=kwargs['id'].strip())
         self._makeTransactionNote(obj)
 
-    security.declarePublic('availableMIMETypes')
+    @security.public
     def availableMIMETypes(self):
         """Returns a map of mimetypes.
 
@@ -332,7 +331,7 @@ def availableMIMETypes(self):
         mtr = getToolByName(self, 'mimetypes_registry')
         return mtr.list_mimetypes()
 
-    security.declareProtected(View, 'getWorkflowChainFor')
+    @security.protected(View)
     def getWorkflowChainFor(self, object):
         """Proxy the request for the chain to the workflow tool, as
         this method is private there.
@@ -347,7 +346,7 @@ def getWorkflowChainFor(self, object):
             pass
         return wfs
 
-    security.declareProtected(View, 'getIconFor')
+    @security.protected(View)
     def getIconFor(self, category, id, default=_marker, context=None):
         """Get an icon for an action, from its icon_expr.
         """
@@ -373,7 +372,7 @@ def getIconFor(self, category, id, default=_marker, context=None):
 
         return icon
 
-    security.declareProtected(View, 'getReviewStateTitleFor')
+    @security.protected(View)
     def getReviewStateTitleFor(self, obj):
         """Utility method that gets the workflow state title for the
         object's review_state.
@@ -399,7 +398,7 @@ def getReviewStateTitleFor(self, obj):
                     return w.states[objstate].title or objstate
         return None
 
-    security.declareProtected(ManagePortal, 'changeOwnershipOf')
+    @security.protected(ManagePortal)
     def changeOwnershipOf(self, object, userid, recursive=0, REQUEST=None):
         """Changes the ownership of an object."""
         membership = getToolByName(self, 'portal_membership')
@@ -439,15 +438,17 @@ def fixOwnerRole(object, user_id):
             catalog_tool = getToolByName(self, 'portal_catalog')
             purl = getToolByName(self, 'portal_url')
             _path = purl.getRelativeContentURL(object)
-            subobjects = [b.getObject() for b in
-                         catalog_tool(path={'query': _path, 'level': 1})]
+            subobjects = [
+                b.getObject()
+                for b in catalog_tool(path={'query': _path, 'level': 1})
+            ]
             for obj in subobjects:
                 fixOwnerRole(obj, user.getId())
                 if base_hasattr(obj, 'reindexObject'):
                     obj.reindexObject()
     changeOwnershipOf = postonly(changeOwnershipOf)
 
-    security.declarePublic('urlparse')
+    @security.public
     def urlparse(self, url):
         """Returns the pieces of url in a six-part tuple.
 
@@ -465,7 +466,7 @@ def urlparse(self, url):
         """
         return tuple(urlparse.urlparse(url))
 
-    security.declarePublic('urlunparse')
+    @security.public
     def urlunparse(self, url_tuple):
         """Puts a url back together again, in the manner that
         urlparse breaks it.
@@ -475,7 +476,8 @@ def urlunparse(self, url_tuple):
 
         >>> ptool = self.portal.plone_utils
 
-        >>> ptool.urlunparse(('http', 'plone.org', '/support', '', '', 'users'))
+        >>> ptool.urlunparse(
+        ...     ('http', 'plone.org', '/support', '', '', 'users'))
         'http://plone.org/support#users'
         """
         return urlparse.urlunparse(url_tuple)
@@ -488,7 +490,7 @@ def exceptionString(self):
         s = sys.exc_info()[:2]
         if s[0] == None:
             return None
-        if type(s[0]) == type(''):
+        if isinstance(s[0], basestring):
             return s[0]
         return str(s[1])
 
@@ -499,7 +501,7 @@ def logException(self):
         """
         log_exc()
 
-    security.declarePublic('createSitemap')
+    @security.public
     def createSitemap(self, context, request=None):
         """Returns a sitemap navtree structure.
         """
@@ -512,11 +514,11 @@ def _addToNavTreeResult(self, result, data):
         """
         return utils.addToNavTreeResult(result, data)
 
-    security.declareProtected(AccessContentsInformation, 'typesToList')
+    @security.protected(AccessContentsInformation)
     def typesToList(self):
         return utils.typesToList(self)
 
-    security.declarePublic('createNavTree')
+    @security.public
     def createNavTree(self, context, sitemap=None, request=None):
         """Returns a structure that can be used by navigation_tree_slot.
         """
@@ -524,7 +526,7 @@ def createNavTree(self, context, sitemap=None, request=None):
             request = self.REQUEST
         return utils.createNavTree(context, request)
 
-    security.declarePublic('createBreadCrumbs')
+    @security.public
     def createBreadCrumbs(self, context, request=None):
         """Returns a structure for the portal breadcumbs.
         """
@@ -532,7 +534,7 @@ def createBreadCrumbs(self, context, request=None):
             request = self.REQUEST
         return utils.createBreadCrumbs(context, request)
 
-    security.declarePublic('good_id')
+    @security.public
     def good_id(self, id):
         """Exposes ObjectManager's bad_id test to skin scripts."""
         m = bad_id(id)
@@ -540,12 +542,12 @@ def good_id(self, id):
             return 0
         return 1
 
-    security.declarePublic('bad_chars')
+    @security.public
     def bad_chars(self, id):
         """Returns a list of the Bad characters."""
         return BAD_CHARS(id)
 
-    security.declarePublic('getInheritedLocalRoles')
+    @security.public
     def getInheritedLocalRoles(self, context):
         """Returns a tuple with the acquired local roles."""
         portal = getToolByName(context, 'portal_url').getPortalObject()
@@ -564,7 +566,7 @@ def getInheritedLocalRoles(self, context):
                         if user2 == user:
                             # Check which roles must be added to roles2
                             for role in roles:
-                                if not role in roles2:
+                                if role not in roles2:
                                     roles2.append(role)
                             found = 1
                             break
@@ -599,45 +601,30 @@ def getInheritedLocalRoles(self, context):
     #       : lookup rules for old-style content types
     #
 
-    security.declarePublic('isDefaultPage')
+    @security.public
     def isDefaultPage(self, obj, request=None):
         """Finds out if the given obj is the default page in its parent folder.
-
-        Only considers explicitly contained objects, either set as index_html,
-        with the default_page property, or using IBrowserDefault.
+        Uses the lookup rules of Plone.  Lookup happens over a view, for which
+        in theory a different implementation may exist.
         """
         if request is None:
             request = self.REQUEST
-        return utils.isDefaultPage(obj, request)
+        return check_default_page_via_view(obj, request)
 
-    security.declarePublic('getDefaultPage')
+    @security.public
     def getDefaultPage(self, obj, request=None):
         """Given a folderish item, find out if it has a default-page using
-        the following lookup rules:
-
-            1. A content object called 'index_html' wins
-            2. If the folder implements IBrowserDefault, query this
-            3. Else, look up the property default_page on the object
-                - Note that in this case, the returned id may *not* be of an
-                  object in the folder, since it could be acquired from a
-                  parent folder or skin layer
-            4. Else, look up the property default_page in site_properties for
-                magic ids and test these
-
-        The id of the first matching item is then used to lookup a translation
-        and if found, its id is returned. If no default page is set, None is
-        returned. If a non-folderish item is passed in, return None always.
+        the lookup rules of Plone (see Products.CMFPlone/defaultpage.py).
+        Lookup happens over a view, for which in theory a different
+        implementation may be used.
         """
         if request is None:
             if hasattr(self, 'REQUEST'):
                 request = self.REQUEST
         if request:
-            return utils.getDefaultPage(obj, request)
-        else:
-            # In case its executed from an event that does not have request
-            return None
+            return get_default_page_via_view(obj, request)
 
-    security.declarePublic('addPortalMessage')
+    @security.public
     def addPortalMessage(self, message, type='info', request=None):
         """\
         Call this once or more to add messages to be displayed at the
@@ -670,13 +657,13 @@ def addPortalMessage(self, message, type='info', request=None):
         long as they are processed before the portal_message macro is
         called by the main template. Example:
 
-          <tal:block tal:define="temp python:context.plone_utils.addPortalMessage('A random info message')" />
+          <tal:block tal:define="temp python:context.plone_utils.addPortalMessage('A random info message')" />  # noqa
         """
         if request is None:
             request = self.REQUEST
         IStatusMessage(request).add(message, type=type)
 
-    security.declarePublic('showPortalMessages')
+    @security.public
     def showPortalMessages(self, request=None):
         """\
         Return portal status messages that will be displayed when the
@@ -690,7 +677,7 @@ def showPortalMessages(self, request=None):
             request = self.REQUEST
         return IStatusMessage(request).show()
 
-    security.declarePublic('browserDefault')
+    @security.public
     def browserDefault(self, obj):
         """Sets default so we can return whatever we want instead of index_html.
 
@@ -702,7 +689,7 @@ def browserDefault(self, obj):
         a template or other object to be acquired and displayed on the object.
         The path is determined as follows:
 
-        0. If we're coming from WebDAV, make sure we don't return a contained
+        0. If we're c oming from WebDAV, make sure we don't return a contained
             object "default page" ever
         1. If there is an index_html attribute (either a contained object or
             an explicit attribute) on the object, return that as the
@@ -773,8 +760,10 @@ def browserDefault(self, obj):
                     return obj, [defaultPage]
                 # Avoid infinite recursion in the case that the page id == the
                 # object id
-                elif defaultPage != obj.getId() and \
-                     defaultPage != '/'.join(obj.getPhysicalPath()):
+                elif (
+                    defaultPage != obj.getId()
+                    and defaultPage != '/'.join(obj.getPhysicalPath())
+                ):
                     # For the default_page property, we may get things in the
                     # skin layers or with an explicit path - split this path
                     # to comply with the __browser_default__() spec
@@ -808,7 +797,9 @@ def browserDefault(self, obj):
                 # XXX: This isn't quite right since it assumes the action
                 # starts with ${object_url}.  Should we raise an error if
                 # it doesn't?
-                act = obj.getTypeInfo().getActionInfo('folder/folderlisting')['url'].split('/')[-1]
+                act = obj.getTypeInfo().getActionInfo(
+                    'folder/folderlisting'
+                )['url'].split('/')[-1]
                 return obj, [act]
             except ValueError:
                 pass
@@ -821,7 +812,9 @@ def browserDefault(self, obj):
                 # XXX: This isn't quite right since it assumes the action
                 # starts with ${object_url}.  Should we raise an error if
                 # it doesn't?
-                act = obj.getTypeInfo().getActionInfo('object/view')['url'].split('/')[-1]
+                act = obj.getTypeInfo().getActionInfo(
+                    'object/view'
+                )['url'].split('/')[-1]
                 return obj, [act]
             except ValueError:
                 pass
@@ -831,10 +824,11 @@ def browserDefault(self, obj):
         #
 
         raise AttributeError(
-                "Failed to get a default page or view_action for %s"
-                    % (obj.absolute_url(),))
+            "Failed to get a default page or view_action for %s"
+            % (obj.absolute_url(),)
+        )
 
-    security.declarePublic('isStructuralFolder')
+    @security.public
     def isStructuralFolder(self, obj):
         """Checks if a given object is a "structural folder".
 
@@ -847,14 +841,12 @@ def isStructuralFolder(self, obj):
         >>> ptool.isStructuralFolder(self.folder)
         True
         """
-        if not obj.isPrincipiaFolderish:
-            return False
-        elif INonStructuralFolder.providedBy(obj):
-            return False
-        else:
-            return True
+        return (
+            obj.isPrincipiaFolderish
+            and not INonStructuralFolder.providedBy(obj)
+        )
 
-    security.declarePublic('acquireLocalRoles')
+    @security.public
     def acquireLocalRoles(self, obj, status=1, REQUEST=None):
         """If status is 1, allow acquisition of local roles (regular
         behaviour).
@@ -878,7 +870,7 @@ def acquireLocalRoles(self, obj, status=1, REQUEST=None):
         obj.reindexObjectSecurity()
     acquireLocalRoles = postonly(acquireLocalRoles)
 
-    security.declarePublic('isLocalRoleAcquired')
+    @security.public
     def isLocalRoleAcquired(self, obj):
         """Returns local role acquisition blocking status.
 
@@ -888,7 +880,7 @@ def isLocalRoleAcquired(self, obj):
             return False
         return True
 
-    security.declarePublic('getOwnerName')
+    @security.public
     def getOwnerName(self, obj):
         """ Returns the userid of the owner of an object.
 
@@ -903,7 +895,7 @@ def getOwnerName(self, obj):
             raise Unauthorized
         return obj.getOwner().getId()
 
-    security.declarePublic('normalizeString')
+    @security.public
     def normalizeString(self, text):
         """Normalizes a title to an id.
 
@@ -960,7 +952,7 @@ def normalizeString(self, text):
         """
         return utils.normalizeString(text, context=self)
 
-    security.declarePublic('listMetaTags')
+    @security.public
     def listMetaTags(self, context):
         """Lists meta tags helper.
 
@@ -1073,7 +1065,7 @@ def listMetaTags(self, context):
 
         return result
 
-    security.declarePublic('getUserFriendlyTypes')
+    @security.public
     def getUserFriendlyTypes(self, typesList=None):
         """Get a list of types which are considered "user friendly" for search
         and selection purposes.
@@ -1100,18 +1092,18 @@ def getUserFriendlyTypes(self, typesList=None):
         friendlyTypes = set(types) - set(blacklistedTypes)
         return list(friendlyTypes)
 
-    security.declarePublic('reindexOnReorder')
+    @security.public
     def reindexOnReorder(self, parent):
         """ reindexing of "gopip" isn't needed any longer,
         but some extensions might need the info anyway :("""
         notify(ReorderedEvent(parent))
 
-    security.declarePublic('isIDAutoGenerated')
+    @security.public
     def isIDAutoGenerated(self, id):
         """Determine if an id is autogenerated"""
         return utils.isIDAutoGenerated(self, id)
 
-    security.declarePublic('getEmptyTitle')
+    @security.public
     def getEmptyTitle(self, translated=True):
         """ Returns string to be used for objects with no title or id.
 
@@ -1122,7 +1114,7 @@ def getEmptyTitle(self, translated=True):
         """
         return utils.getEmptyTitle(self, translated)
 
-    security.declarePublic('pretty_title_or_id')
+    @security.public
     def pretty_title_or_id(self, obj, empty_value=_marker):
         """Return the best possible title or id of an item, regardless
         of whether obj is a catalog brain or an object, but returning an
@@ -1130,7 +1122,7 @@ def pretty_title_or_id(self, obj, empty_value=_marker):
         """
         return utils.pretty_title_or_id(self, obj, empty_value=empty_value)
 
-    security.declarePublic('getMethodAliases')
+    @security.public
     def getMethodAliases(self, typeInfo):
         """Given an FTI, return the dict of method aliases defined on that
         FTI. If there are no method aliases (i.e. this FTI doesn't support it),
@@ -1145,7 +1137,7 @@ def getMethodAliases(self, typeInfo):
     # This is public because we don't know what permissions the user
     # has on the objects to be deleted.  The restrictedTraverse and
     # manage_delObjects calls should handle permission checks for us.
-    security.declarePublic('deleteObjectsByPaths')
+    @security.public
     def deleteObjectsByPaths(self, paths, handle_errors=True, REQUEST=None):
         failure = {}
         success = []
@@ -1176,7 +1168,7 @@ def deleteObjectsByPaths(self, paths, handle_errors=True, REQUEST=None):
         return success, failure
     deleteObjectsByPaths = postonly(deleteObjectsByPaths)
 
-    security.declarePublic('transitionObjectsByPaths')
+    @security.public
     def transitionObjectsByPaths(self, workflow_action, paths, comment='',
                                  expiration_date=None, effective_date=None,
                                  include_children=False, handle_errors=True,
@@ -1213,7 +1205,7 @@ def transitionObjectsByPaths(self, workflow_action, paths, comment='',
         return failure
     transitionObjectsByPaths = postonly(transitionObjectsByPaths)
 
-    security.declarePublic('renameObjectsByPaths')
+    @security.public
     def renameObjectsByPaths(self, paths, new_ids, new_titles,
                              handle_errors=True, REQUEST=None):
         failure = {}
@@ -1233,7 +1225,9 @@ def renameObjectsByPaths(self, paths, new_ids, new_titles,
                 change_title = new_title and title != new_title
                 changed = False
                 if change_title:
-                    getSecurityManager().validate(obj, obj, 'setTitle', obj.setTitle)
+                    getSecurityManager().validate(
+                        obj, obj, 'setTitle', obj.setTitle
+                    )
                     obj.setTitle(new_title)
                     notify(ObjectModifiedEvent(obj))
                     changed = True
diff --git a/Products/CMFPlone/browser/configure.zcml b/Products/CMFPlone/browser/configure.zcml
index 0189231..a841477 100644
--- a/Products/CMFPlone/browser/configure.zcml
+++ b/Products/CMFPlone/browser/configure.zcml
@@ -197,4 +197,14 @@
     permission="zope2.View"
     attribute="checkDocument"
     />
+
+    <!-- Default Page View -->
+    <browser:page
+      for="OFS.interfaces.IZopeObject"
+      name="default_page"
+      class=".defaultpage.DefaultPage"
+      permission="zope.Public"
+      allowed_interface="Products.CMFPlone.interfaces.defaultpage.IDefaultPage"
+      />
+
 </configure>
diff --git a/Products/CMFPlone/browser/defaultpage.py b/Products/CMFPlone/browser/defaultpage.py
new file mode 100644
index 0000000..c998711
--- /dev/null
+++ b/Products/CMFPlone/browser/defaultpage.py
@@ -0,0 +1,17 @@
+# -*- coding: utf-8 -*-
+from Acquisition import aq_inner
+from Products.CMFPlone.interfaces.defaultpage import IDefaultPage
+from Products.CMFPlone.defaultpage import get_default_page
+from Products.CMFPlone.defaultpage import is_default_page
+from Products.Five.browser import BrowserView
+from zope.interface import implementer
+
+
+@implementer(IDefaultPage)
+class DefaultPage(BrowserView):
+
+    def isDefaultPage(self, obj):
+        return is_default_page(aq_inner(self.context), obj)
+
+    def getDefaultPage(self):
+        return get_default_page(aq_inner(self.context))
diff --git a/Products/CMFPlone/defaultpage.py b/Products/CMFPlone/defaultpage.py
new file mode 100644
index 0000000..365a8d2
--- /dev/null
+++ b/Products/CMFPlone/defaultpage.py
@@ -0,0 +1,141 @@
+# -*- coding: utf-8 -*-
+from Acquisition import aq_base
+from Acquisition import aq_parent
+from Acquisition import aq_inner
+from Products.BTreeFolder2.BTreeFolder2 import BTreeFolder2Base
+from Products.CMFCore.interfaces import IFolderish
+from Products.CMFCore.interfaces import ISiteRoot
+from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault
+from Products.CMFDynamicViewFTI.interfaces import IDynamicViewTypeInformation
+from zope.component import queryAdapter
+from zope.component import queryUtility
+from zope.component import queryMultiAdapter
+
+
+def get_default_page(context):
+    """Given a folderish item, find out if it has a default-page using
+    the following lookup rules:
+
+        1. A content object called 'index_html' wins
+        2. Else check for IBrowserDefault, either if the container implements
+           it or if an adapter exists. In both cases fetch its FTI and either
+           take it if it implements IDynamicViewTypeInformation or adapt it to
+           IDynamicViewTypeInformation. call getDefaultPage on the implementer
+           and take value if given.
+        3. Else, look up the attribute default_page on the object, without
+           acquisition in place
+        3.1 look for a content in the container with the id, no acquisition!
+        3.2 look for a content at portal, with acquisition
+        4. Else, look up the property default_page in site_properties for
+           magic ids and test these
+
+    The id of the first matching item is then used to lookup a translation
+    and if found, its id is returned. If no default page is set, None is
+    returned. If a non-folderish item is passed in, return None always.
+    """
+    # met precondition?
+    if not IFolderish.providedBy(context):
+        return
+
+    # The ids where we look for default - must support __contains__
+    ids = set()
+
+    # For BTreeFolders we just use the __contains__ otherwise build a set
+    if isinstance(aq_base(context), BTreeFolder2Base):
+        ids = context
+    elif hasattr(aq_base(context), 'objectIds'):
+        ids = set(context.objectIds())
+
+    # 1. test for contentish index_html
+    if 'index_html' in ids:
+        return 'index_html'
+
+    # 2. Test for IBrowserDefault
+    if IBrowserDefault.providedBy(context):
+        browserDefault = context
+    else:
+        browserDefault = queryAdapter(context, IBrowserDefault)
+
+    if browserDefault is not None:
+        fti = context.getTypeInfo()
+        if fti is not None:
+            if IDynamicViewTypeInformation.providedBy(fti):
+                dynamic_fti = fti
+            else:
+                dynamic_fti = queryAdapter(fti, IDynamicViewTypeInformation)
+            if dynamic_fti is not None:
+                page = dynamic_fti.getDefaultPage(context, check_exists=True)
+                if page is not None:
+                    return page
+
+    # 3.1 Test for default_page attribute in folder, no acquisition
+    pages = getattr(aq_base(context), 'default_page', [])
+    if isinstance(pages, basestring):
+        pages = [pages]
+    for page in pages:
+        if page and page in ids:
+            return page
+
+    portal = queryUtility(ISiteRoot)
+    # Might happen during portal creation
+    if portal is None:
+        return
+
+    # 3.2 Test for default page in portal, acquire
+    for page in pages:
+        if portal.unrestrictedTraverse(page, None):
+            return page
+
+    # 4. Test for default sitewide default_page setting
+    pp = getattr(portal, 'portal_properties', None)
+    if pp is not None:
+        site_properties = getattr(pp, 'site_properties', None)
+        if site_properties is not None:
+            for page in site_properties.getProperty('default_page', []):
+                if page in ids:
+                    return page
+
+
+def is_default_page(container, obj):
+    """Finds out if the given obj is the default page in its parent folder.
+
+    Only considers explicitly contained objects, either set as index_html,
+    with the default_page property, or using IBrowserDefault.
+    """
+    parent_default_page = get_default_page(container)
+    precondition = (
+        parent_default_page is not None
+        and '/' not in parent_default_page
+        and hasattr(aq_base(obj), 'getId')
+    )
+    return precondition and (parent_default_page == obj.getId())
+
+
+def _getDefaultPageView(obj, request):
+    """This is a nasty hack because the view lookup fails when it occurs too
+       early in the publishing process because the request isn't marked with
+       the default skin.  Explicitly marking the request appears to cause
+       connection errors, so we just instantiate the view manually.
+    """
+    view = queryMultiAdapter((obj, request), name='default_page')
+    if view is None:
+        # mask circular import
+        from Products.CMFPlone.browser.defaultpage import DefaultPage
+        view = DefaultPage(obj, request)
+    return view
+
+
+def check_default_page_via_view(obj, request):
+    container = aq_parent(aq_inner(obj))
+    if container is None:
+        return False
+    view = _getDefaultPageView(container, request)
+    return view.isDefaultPage(obj)
+
+
+def get_default_page_via_view(obj, request):
+    # Short circuit if we are not looking at a Folder
+    if not obj.isPrincipiaFolderish:
+        return None
+    view = _getDefaultPageView(obj, request)
+    return view.getDefaultPage()
diff --git a/Products/CMFPlone/interfaces/defaultpage.py b/Products/CMFPlone/interfaces/defaultpage.py
new file mode 100644
index 0000000..0aa7d79
--- /dev/null
+++ b/Products/CMFPlone/interfaces/defaultpage.py
@@ -0,0 +1,17 @@
+# -*- coding: utf-8 -*-
+from zope.interface import Interface
+
+
+class IDefaultPage(Interface):
+    """Interface for a view that can determine if its context is the
+    default page or not.
+    """
+
+    def isDefaultPage(obj):
+        """Finds out if the given obj is the default page for the
+        adapted object.
+        """
+
+    def getDefaultPage():
+        """Returns the id of the default page for the adapted object.
+        """
diff --git a/Products/CMFPlone/tests/test_defaultpage.py b/Products/CMFPlone/tests/test_defaultpage.py
new file mode 100644
index 0000000..daab269
--- /dev/null
+++ b/Products/CMFPlone/tests/test_defaultpage.py
@@ -0,0 +1,118 @@
+# -*- coding: utf-8 -*-
+from plone.app.testing import setRoles
+from plone.app.testing import TEST_USER_ID
+from Products.CMFPlone.testing import PRODUCTS_CMFPLONE_INTEGRATION_TESTING
+import unittest
+
+
+class DefaultPageTestCase(unittest.TestCase):
+
+    layer = PRODUCTS_CMFPLONE_INTEGRATION_TESTING
+
+    def setUp(self):
+        self.portal = self.layer['portal']
+        setRoles(self.portal, TEST_USER_ID, ['Manager'])
+        self.portal.invokeFactory('Folder', 'folder', title=u"Test Folder")
+        self.folder = self.portal.folder
+
+    def test_get_default_page_step_1(self):
+        # A content object called 'index_html' wins
+        self.folder.invokeFactory('Document', 'd1', title=u"Doc 1")
+        self.folder.setDefaultPage('d1')
+        self.folder.invokeFactory('Document', 'index_html', title=u"Doc 2")
+
+        from Products.CMFPlone.defaultpage import get_default_page
+        self.assertEqual('index_html', get_default_page(self.folder))
+
+    def test_get_default_page_step_2(self):
+        # Else check for IBrowserDefault, either if the container implements
+        # it or if an adapter exists. In both cases fetch its FTI and either
+        # take it if it implements IDynamicViewTypeInformation or adapt it to
+        # IDynamicViewTypeInformation. call get_default_page on the implementer
+        # and take value if given.
+
+        # first check some preconditions
+        #
+        # 1) a folder provides IBrowserDefault
+        from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault
+        self.assertTrue(IBrowserDefault.providedBy(self.folder))
+
+        # 2) a folder also provides an fti that implements
+        #    IDynamicViewTypeInformation
+        from Products.CMFDynamicViewFTI.interfaces import IDynamicViewTypeInformation  # noqa
+        fti = self.folder.getTypeInfo()
+        self.assertTrue(IDynamicViewTypeInformation.providedBy(fti))
+
+        # so if we set a document as defaultpage
+        self.folder.invokeFactory('Document', 'd1', title=u"Doc 1")
+        self.folder.setDefaultPage('d1')
+
+        # 3) fti should return it
+        self.assertEqual(
+            'd1',
+            fti.getDefaultPage(self.folder, check_exists=True)
+        )
+
+        # now test since we're sure everythings set up correctly
+        from Products.CMFPlone.defaultpage import get_default_page
+        self.assertEqual('d1', get_default_page(self.folder))
+
+        # missing here:
+        # - test adapter instead of direct implements in precondition 1
+        # - test adapter instead of direct implements in precondition 2
+
+    def test_get_default_page_step_3_1(self):
+        # 3. Else, look up the attribute default_page on the object, without
+        #    acquisition in place
+        # 3.1 look for a content in the container with the id, no acquisition!
+        self.folder.invokeFactory('Document', 'd1', title=u"Doc 1")
+        from Products.CMFPlone.defaultpage import get_default_page
+
+        # set doc d1 must work
+        self.folder.default_page = 'd1'
+        self.assertEqual('d1', get_default_page(self.folder))
+
+        # set doc d2 must fail and return None
+        self.folder.default_page = 'd2'
+        self.assertIsNone(get_default_page(self.folder))
+
+        # list of possible values is allowed
+        self.folder.default_page = ['d2', 'd1']
+        self.assertEqual('d1', get_default_page(self.folder))
+
+        # list of impossible values return None
+        self.folder.default_page = ['d2', 'd3']
+        self.assertIsNone(get_default_page(self.folder))
+
+        # acquisition check, must not work
+        self.folder.invokeFactory('Folder', 'f1', title=u"Sub Folder 1")
+        self.folder.f1.invokeFactory('Document', 'd2', title=u"Document 2")
+        self.folder.default_page = 'd2'
+        self.assertIsNone(get_default_page(self.folder.f1))
+
+    def test_get_default_page_step_3_2(self):
+        # 3. Else, look up the attribute default_page on the object, without
+        #    acquisition in place
+        # 3.2 look for a content at portal, with acquisition
+        self.portal.invokeFactory('Document', 'd1', title=u"Doc 1")
+        self.folder.default_page = 'd1'
+        from Products.CMFPlone.defaultpage import get_default_page
+
+        # now it must acquire from portal
+        self.assertEqual('d1', get_default_page(self.folder))
+
+        # fetch from i.e. portal_skins by acquisition
+        # robots.txt is in portal_skins/plone_templates and so available
+        # by acquisition
+        self.folder.default_page = 'robots.txt'
+        self.assertEqual('robots.txt', get_default_page(self.folder))
+
+    def test_get_default_page_step_4(self):
+        # 4. Else, look up the property default_page in site_properties for
+        #   magic ids and test these
+        sp = self.portal.portal_properties.site_properties
+        sp.manage_changeProperties(default_page=('d1',))
+        self.folder.invokeFactory('Document', 'd1', title=u"Doc 1")
+
+        from Products.CMFPlone.defaultpage import get_default_page
+        self.assertEqual('d1', get_default_page(self.folder))
diff --git a/Products/CMFPlone/utils.py b/Products/CMFPlone/utils.py
index 6fd2869..a9cbcbf 100644
--- a/Products/CMFPlone/utils.py
+++ b/Products/CMFPlone/utils.py
@@ -1,43 +1,47 @@
 # -*- coding: utf-8 -*-
-
-import re
-import json
-
-from types import ClassType
+from AccessControl import getSecurityManager
+from AccessControl import ModuleSecurityInfo
+from AccessControl import Unauthorized
+from Acquisition import aq_base
+from Acquisition import aq_get
+from Acquisition import aq_inner
+from Acquisition import aq_parent
+from App.Common import package_home
+from App.ImageFile import ImageFile
+from DateTime import DateTime
+from DateTime.interfaces import DateTimeError
 from os.path import join, abspath, split
-
-import pkg_resources
 from plone.i18n.normalizer.interfaces import IIDNormalizer
 from plone.registry.interfaces import IRegistry
+from Products.CMFCore.permissions import ManageUsers
+from Products.CMFCore.utils import getToolByName
+from Products.CMFCore.utils import ToolInit as CMFCoreToolInit
+from Products.CMFPlone import PloneMessageFactory as _
+from types import ClassType
 from webdav.interfaces import IWriteLock
-
-import zope.interface
-from zope.interface import implementedBy
+from zope import schema
 from zope.component import getMultiAdapter
 from zope.component import getUtility
-from zope.component import queryMultiAdapter
 from zope.component import queryUtility
 from zope.component.hooks import getSite
+from zope.deferredimport import deprecated as deprecated_import
 from zope.deprecation import deprecated
 from zope.i18n import translate
+from zope.interface import implementedBy
 from zope.publisher.interfaces.browser import IBrowserRequest
-from zope import schema
 
+import json
 import OFS
-from AccessControl import getSecurityManager, Unauthorized
-from AccessControl import ModuleSecurityInfo
-from Acquisition import aq_get
-from Acquisition import aq_base, aq_inner, aq_parent
-from App.Common import package_home
-from App.ImageFile import ImageFile
-from DateTime import DateTime
-from DateTime.interfaces import DateTimeError
-from Products.CMFCore.permissions import ManageUsers
-from Products.CMFCore.utils import ToolInit as CMFCoreToolInit
-from Products.CMFCore.utils import getToolByName
-from Products.CMFPlone import PloneMessageFactory as _
-
+import pkg_resources
+import re
 import transaction
+import zope.interface
+
+deprecated_import(
+    "Import from Products.CMFPlone.defaultpage instead",
+    isDefaultPage='Products.CMFPlone.defaultpage:check_default_page_via_view',
+    getDefaultPage='Products.CMFPlone.defaultpage:get_default_page_via_view',
+)
 
 security = ModuleSecurityInfo()
 security.declarePrivate('deprecated')
@@ -89,36 +93,6 @@ def createSiteMap(context, request, sitemap=False):
     return view.siteMap()
 
 
-def _getDefaultPageView(obj, request):
-    """This is a nasty hack because the view lookup fails when it occurs too
-       early in the publishing process because the request isn't marked with
-       the default skin.  Explicitly marking the request appears to cause
-       connection errors, so we just instantiate the view manually.
-    """
-    view = queryMultiAdapter((obj, request), name='default_page')
-    if view is None:
-        # XXX: import here to avoid a circular dependency
-        from plone.app.layout.navigation.defaultpage import DefaultPage
-        view = DefaultPage(obj, request)
-    return view
-
-
-def isDefaultPage(obj, request):
-    container = parent(obj)
-    if container is None:
-        return False
-    view = _getDefaultPageView(container, request)
-    return view.isDefaultPage(obj)
-
-
-def getDefaultPage(obj, request):
-    # Short circuit if we are not looking at a Folder
-    if not obj.isPrincipiaFolderish:
-        return None
-    view = _getDefaultPageView(obj, request)
-    return view.getDefaultPage()
-
-
 def isIDAutoGenerated(context, id):
     # In 2.1 non-autogenerated is the common case, caught exceptions are
     # expensive, so let's make a cheap check first
@@ -268,7 +242,7 @@ def next(self):
         return result
 
 
-security.declarePrivate('ToolInit')
+@security.private
 class ToolInit(CMFCoreToolInit):
 
     def getProductContext(self, context):
@@ -392,7 +366,7 @@ def versionTupleFromString(v_str):
         >>> versionTupleFromString('foo') is None
         True
         """
-    regex_str = "(^\d+)[.]?(\d*)[.]?(\d*)[- ]?(alpha|beta|candidate|final|a|b|rc)?(\d*)"
+    regex_str = "(^\d+)[.]?(\d*)[.]?(\d*)[- ]?(alpha|beta|candidate|final|a|b|rc)?(\d*)"  # noqa
     v_regex = re.compile(regex_str)
     match = v_regex.match(v_str)
     if match is None:
@@ -742,4 +716,4 @@ def getSiteLogo(site=None):
         return '{}/@@site-logo/{}'.format(
             site_url, filename)
     else:
-        return '%s/logo.png' % site_url
\ No newline at end of file
+        return '%s/logo.png' % site_url


