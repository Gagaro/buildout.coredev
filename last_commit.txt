Repository: plone.app.contentlisting


Branch: refs/heads/master
Date: 2015-06-18T14:17:51+02:00
Author: Johannes Raggam (thet) <raggam-nl@adm.at>
Commit: https://github.com/plone/plone.app.contentlisting/commit/d377e3eecfecf40eb6722af0cacbc5d86f068ca7

Introduce ``@@contentlisting`` with Collection support

Introduce ``@@contentlisting`` view, which is also supports Collections from
plone.app.contenttypes including filtering of results.
Deprecate ``@@folderListing``, which is kept for BBB compatibility.

Files changed:
M CHANGES.rst
M docs/README.rst
M plone/app/contentlisting/browser.py
M plone/app/contentlisting/configure.zcml
M plone/app/contentlisting/tests/integration.rst
M plone/app/contentlisting/tests/test_integration_unit.py

diff --git a/CHANGES.rst b/CHANGES.rst
index efd4a6a..f087b88 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -1,10 +1,13 @@
 Changelog
 =========
 
-1.1.4 (unreleased)
-------------------
+1.2 (unreleased)
+----------------
 
-- Nothing changed yet.
+- Introduce ``@@contentlisting`` view, which is also supports Collections from
+  plone.app.contenttypes including filtering of results.
+  Deprecate ``@@folderListing``, which is kept for BBB compatibility.
+  [thet]
 
 
 1.1.3 (2015-05-05)
diff --git a/docs/README.rst b/docs/README.rst
index c04adf1..19af613 100644
--- a/docs/README.rst
+++ b/docs/README.rst
@@ -22,27 +22,38 @@ Making or getting a contentListing
 The typical way to get a contentlisting is to call one of two built-in views:
 
 
-Listing the contents of a folder
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Listing the contents of a Folder or Collection
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
-In Page templates getting the contents of a folder is as simple as this::
+In Page templates getting the contents of a folder or the results of a
+collection is as simple as this::
 
-  context/@@folderListing
+    context/@@contentlisting
 
 Every template-writer's dream ;)
 
+.. note::
+
+    In previous versions there was only support to list the contents of a
+    folder with ``context/@@folderListing``. There was no collection support.
+    The ``@@folderListing`` view is kept for compatibility, but we encourage
+    you to use the ``@@contentlisting`` instead.
+    
+
+
 A real example of listing the titles of the content objects of a folder::
 
   <ul>
-    <li tal:repeat="item context/@@folderListing" tal:content="item/Title"/>
+    <li tal:repeat="item context/@@contentlisting" tal:content="item/Title"/>
   </ul>
 
-The context in which it is called defines which folder is listed.
+The context in which it is called defines which folder is listed or which
+collection results are queried.
 
 You can also use Python expressions to be able to pass parameters, like which
 content type or review state you want to use::
 
-  <li tal:repeat="item python:context.restrictedTraverse('@@folderListing')(portal_type='Document')">
+  <li tal:repeat="item python:context.restrictedTraverse('@@contentlisting')(portal_type='Document')">
 
 Batching can be done like this::
 
@@ -50,7 +61,7 @@ Batching can be done like this::
       Batch python:modules['Products.CMFPlone'].Batch;
       b_size python:int(request.get('b_size', 20));
       b_start python:int(request.get('b_start', 0));
-      results python:context.restrictedTraverse('@@folderListing')(batch=True, b_size=b_size, b_start=b_start);
+      results python:context.restrictedTraverse('@@contentlisting')(batch=True, b_size=b_size, b_start=b_start);
       batch python:Batch(results, b_size, b_start);">
     <li tal:repeat="item results"
         tal:content="item/Title" />
@@ -58,15 +69,19 @@ Batching can be done like this::
   </ul>
 
 Note that you iterate directly over the results that you get from
-``@@folderListing``.  The definition of ``batch`` is only used in the
+``@@contentlisting``.  The definition of ``batch`` is only used in the
 ``batch_macros`` call.
 
 In Python a ContentListing of a particular folder's contents can be fetched
 by using::
 
-    >>> path.to.your.folder.restrictedTraverse('@@folderListing')()
+    >>> path.to.your.folder.restrictedTraverse('@@contentlisting')()
+
+Exactly the same for collections::
+
+    >>> path.to.your.collection.restrictedTraverse('@@contentlisting')()
 
-The folderListing view called above implements all the logic the old
+The contentlisting view called above implements all the logic the old
 getFolderContents script in Plone used to do. The old script has been left in
 place to not break compatibility for customizations and add-ons that might
 depend on its particular return values.
diff --git a/plone/app/contentlisting/browser.py b/plone/app/contentlisting/browser.py
index 87d78b5..500a902 100644
--- a/plone/app/contentlisting/browser.py
+++ b/plone/app/contentlisting/browser.py
@@ -26,3 +26,22 @@ def __call__(self, batch=False, b_size=20, b_start=0, orphan=0, **kw):
         catalog = getToolByName(self.context, 'portal_catalog')
         results = catalog(query)
         return IContentListing(results)
+
+
+class ContentListingCollection(BrowserView):
+
+    def __call__(self, batch=False, b_size=20, b_start=0, **kw):
+
+        if 'orphan' in kw:
+            # At the moment, orphan keyword is not supported by
+            # plone.app.contenttypes Collection behavior, nor by
+            # plone.app.querystring's querybuilder.
+            del kw['orphan']
+
+        res = self.context.results(
+            batch=batch,
+            b_size=b_size,
+            b_start=b_start,
+            custom_query=kw
+        )
+        return res
diff --git a/plone/app/contentlisting/configure.zcml b/plone/app/contentlisting/configure.zcml
index d655460..e4b4a1e 100644
--- a/plone/app/contentlisting/configure.zcml
+++ b/plone/app/contentlisting/configure.zcml
@@ -1,5 +1,6 @@
 <configure xmlns="http://namespaces.zope.org/zope"
-           xmlns:browser="http://namespaces.zope.org/browser">
+           xmlns:browser="http://namespaces.zope.org/browser"
+           xmlns:zcml="http://namespaces.zope.org/zcml">
 
   <adapter
       factory=".contentlisting.ContentListing"
@@ -42,6 +43,22 @@
       />
 
   <browser:page
+      name="contentlisting"
+      class=".browser.FolderListing"
+      permission="zope2.View"
+      for="Products.CMFCore.interfaces.IFolderish"
+      />
+
+  <browser:page
+      name="contentlisting"
+      class=".browser.ContentListingCollection"
+      permission="zope2.View"
+      for="plone.app.contenttypes.behaviors.collection.ISyndicatableCollection"
+      zcml:condition="installed plone.app.contenttypes"
+      />
+
+  <!-- BBB -->
+  <browser:page
       name="folderListing"
       class=".browser.FolderListing"
       permission="zope2.View"
diff --git a/plone/app/contentlisting/tests/integration.rst b/plone/app/contentlisting/tests/integration.rst
index 80ebd82..d52e2bd 100644
--- a/plone/app/contentlisting/tests/integration.rst
+++ b/plone/app/contentlisting/tests/integration.rst
@@ -2,7 +2,7 @@ Basic usage
 ===========
 
 The idea behind plone.app.contentlisting is to have a unified way of listing
-Plone content whenever needed, whether in folderlistings, collections,
+Plone content whenever needed, whether in contentlistings, collections,
 portlets or search results.
 
 It should be simple to use for new developers and integrators. The core concept
@@ -64,36 +64,36 @@ This item's origin is no longer a Brain, but the real object
 For user and integrator convenience we also include a couple of handy
 browser views to get to these listings.
 
-    >>> folderlisting = self.portal.restrictedTraverse('@@folderListing')()
-    >>> print(folderlisting)
+    >>> contentlisting = self.portal.restrictedTraverse('@@contentlisting')()
+    >>> print(contentlisting)
     <plone.app.contentlisting.contentlisting.ContentListing object ...
 
-    >>> len(folderlisting)
+    >>> len(contentlisting)
     3
 
-We can even slice the new folderlisting
+We can even slice the new contentlisting
 
-    >>> len (folderlisting[2:4])
+    >>> len (contentlisting[2:4])
     1
 
-    >>> len(self.portal.restrictedTraverse('news/@@folderListing')())
+    >>> len(self.portal.restrictedTraverse('news/@@contentlisting')())
     1
 
 And we can use batching in it:
 
-    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@folderListing')()]
+    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@contentlisting')()]
     ['http://nohost/plone/test-folder', 'http://nohost/plone/front-page', 'http://nohost/plone/news']
-    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@folderListing')(batch=True, b_size=1)]
+    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@contentlisting')(batch=True, b_size=1)]
     ['http://nohost/plone/test-folder']
-    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@folderListing')(batch=True, b_start=1, b_size=1)]
+    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@contentlisting')(batch=True, b_start=1, b_size=1)]
     ['http://nohost/plone/front-page']
-    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@folderListing')(batch=True, b_start=2, b_size=1)]
+    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@contentlisting')(batch=True, b_start=2, b_size=1)]
     ['http://nohost/plone/news']
-    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@folderListing')(batch=True, b_start=1, b_size=2)]
+    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@contentlisting')(batch=True, b_start=1, b_size=2)]
     ['http://nohost/plone/front-page', 'http://nohost/plone/news']
 
 We can use filtering by catalog indexes:
-    >>> len(self.portal.restrictedTraverse('@@folderListing')(portal_type='Document'))
+    >>> len(self.portal.restrictedTraverse('@@contentlisting')(portal_type='Document'))
     1
 
 
@@ -102,10 +102,10 @@ Append View Action
 
 Some types may require '/view' appended to their URLs. Currently these don't
 
-    >>> frontpage = self.portal.restrictedTraverse('@@folderListing')(id='front-page')[0]
+    >>> frontpage = self.portal.restrictedTraverse('@@contentlisting')(id='front-page')[0]
     >>> frontpage.appendViewAction()
     ''
-    >>> news = self.portal.restrictedTraverse('@@folderListing')(id='news')[0]
+    >>> news = self.portal.restrictedTraverse('@@contentlisting')(id='news')[0]
     >>> news.appendViewAction()
     ''
     >>> realfrontpage = IContentListingObject(self.portal['front-page'])
@@ -139,11 +139,11 @@ Visibility in Navigation
 
 Items by default are visible in navigation
 
-    >>> frontpage = self.portal.restrictedTraverse('@@folderListing')(id='front-page')[0]
+    >>> frontpage = self.portal.restrictedTraverse('@@contentlisting')(id='front-page')[0]
     >>> frontpage.isVisibleInNav()
     True
 
-    >>> news = self.portal.restrictedTraverse('@@folderListing')(id='news')[0]
+    >>> news = self.portal.restrictedTraverse('@@contentlisting')(id='news')[0]
     >>> news.isVisibleInNav()
     True
 
@@ -181,7 +181,7 @@ way is the exclude_from_nav property being true
 
 This will be indexed, so an object isn't necessary to check this
 
-    >>> frontpage = self.portal.restrictedTraverse('@@folderListing')(id='front-page')[0]
+    >>> frontpage = self.portal.restrictedTraverse('@@contentlisting')(id='front-page')[0]
     >>> frontpage.isVisibleInNav()
     False
     >>> print(frontpage.getDataOrigin())
@@ -200,7 +200,7 @@ We can also turn it off again.
     >>> frontpage_object.exclude_from_nav = False
     >>> frontpage_object.reindexObject()
 
-    >>> frontpage = self.portal.restrictedTraverse('@@folderListing')(id='front-page')[0]
+    >>> frontpage = self.portal.restrictedTraverse('@@contentlisting')(id='front-page')[0]
     >>> frontpage.isVisibleInNav()
     True
 
diff --git a/plone/app/contentlisting/tests/test_integration_unit.py b/plone/app/contentlisting/tests/test_integration_unit.py
index 5a6bc32..2e44c73 100644
--- a/plone/app/contentlisting/tests/test_integration_unit.py
+++ b/plone/app/contentlisting/tests/test_integration_unit.py
@@ -2,6 +2,9 @@
 from ..interfaces import IContentListingObject
 from .base import ContentlistingFunctionalTestCase
 from Products.CMFCore.utils import getToolByName
+from plone.app.testing import TEST_USER_ID
+from plone.app.testing import setRoles
+from plone.batching.interfaces import IBatch
 from zope.interface.verify import verifyObject
 
 
@@ -135,7 +138,7 @@ def test_appendViewAction(self):
         self.assertEqual(self.item.appendViewAction(), '')
         self.folder.invokeFactory(
             'Image', 'myimage', title='My Image', description='blah')
-        self.item = self.folder.restrictedTraverse('@@folderListing')()[1]
+        self.item = self.folder.restrictedTraverse('@@contentlisting')()[1]
         self.assertEqual(self.item.appendViewAction(), '/view')
 
     def test_item_ContentTypeClass(self):
@@ -149,7 +152,7 @@ def test_containment(self):
         # we can test containment for normal content objects against
         # contentlistings
         self.assertTrue(self.folder.mypage in
-                        self.folder.restrictedTraverse('@@folderListing')())
+                        self.folder.restrictedTraverse('@@contentlisting')())
 
 
 class TestIndividualRealContentItems(ContentlistingFunctionalTestCase):
@@ -238,49 +241,134 @@ class TestFolderContents(ContentlistingFunctionalTestCase):
     """
 
     def test_empty_folder_contents(self):
-        folderlisting = self.folder.restrictedTraverse('@@folderListing')()
-        self.assertEqual(len(folderlisting), 0)
-        self.assertEqual(folderlisting.actual_result_count, 0)
+        contentlisting = self.folder.restrictedTraverse('@@contentlisting')()
+        self.assertEqual(len(contentlisting), 0)
+        self.assertEqual(contentlisting.actual_result_count, 0)
 
     def test_item_in_folder_contents(self):
         # adding a new page, adds to the length of folder contents
         self.folder.invokeFactory('Document', 'mypage')
-        folderlisting = self.folder.restrictedTraverse('@@folderListing')()
-        self.assertEqual(len(folderlisting), 1)
-        self.assertEqual(folderlisting.actual_result_count, 1)
+        contentlisting = self.folder.restrictedTraverse('@@contentlisting')()
+        self.assertEqual(len(contentlisting), 1)
+        self.assertEqual(contentlisting.actual_result_count, 1)
 
     def test_folder_contents(self):
         # call the generic folder contents browserview. Check that it makes
         # the results a contentlisting, regardless of batching
         self.folder.invokeFactory('Document', 'mypage')
-        folderlisting = self.folder.restrictedTraverse('@@folderListing')()
-        self.assertTrue(verifyObject(IContentListing, folderlisting))
+        contentlisting = self.folder.restrictedTraverse('@@contentlisting')()
+        self.assertTrue(verifyObject(IContentListing, contentlisting))
 
     def test_batching_folder_contents(self):
         # call the generic folder contents browserview. Check that it makes
         # the results a contentlisting, regardless of batching
         self.folder.invokeFactory('Document', 'mypage')
-        folderlisting = self.folder.restrictedTraverse('@@folderListing')(
+        contentlisting = self.folder.restrictedTraverse('@@contentlisting')(
             batch=True, b_size=1)
-        self.assertTrue(verifyObject(IContentListing, folderlisting))
-        self.assertEqual(len(folderlisting), 1)
+        self.assertTrue(verifyObject(IContentListing, contentlisting))
+        self.assertEqual(len(contentlisting), 1)
 
     def test_batching_folder_contents_2(self):
         # call the generic folder contents browserview. Check that it makes
         # the results a contentlisting, regardless of batching
         new_id = self.folder.invokeFactory('Document', 'mypage')
         new_id2 = self.folder.invokeFactory('Document', 'mypage2')
-        folderlisting = self.folder.restrictedTraverse('@@folderListing')(
+        contentlisting = self.folder.restrictedTraverse('@@contentlisting')(
+            batch=True, b_size=1)
+        self.assertTrue(contentlisting[0].getId() == new_id)
+        self.assertEqual(len(contentlisting), 1)
+        self.assertEqual(contentlisting.actual_result_count, 2)
+
+        contentlisting = self.folder.restrictedTraverse('@@contentlisting')(
+            batch=True, b_size=1, b_start=1)
+        self.assertEqual(contentlisting[0].getId(), new_id2)
+        self.assertEqual(len(contentlisting), 1)
+        self.assertEqual(contentlisting.actual_result_count, 2)
+
+
+class TestCollectionResults(ContentlistingFunctionalTestCase):
+    """Test, if the @@contentlisting view also works for Collections.
+    """
+
+    def setUp(self):
+        super(TestCollectionResults, self).setUp()
+        setRoles(self.portal, TEST_USER_ID, ['Manager'])
+        self.portal.invokeFactory('Collection', 'collection', title=u'Col')
+        collection = self.portal.collection
+        collection.query = [
+            {'i': 'portal_type',
+             'o': 'plone.app.querystring.operation.selection.is',
+             'v': ['Event', 'Event']
+             },
+        ]
+        collection.reindexObject()
+        self.col = collection
+
+    def test_collection_results_is_contentlisting(self):
+        # call the generic contentlisting view. Check that it makes results
+        # a contentlisting, regardless of batching
+        self.folder.invokeFactory('Event', 'myevent')
+        contentlisting = self.col.restrictedTraverse('@@contentlisting')()
+
+        self.assertTrue(verifyObject(IContentListing, contentlisting))
+
+    def test_filtering_collection_results_to_empty(self):
+        contentlisting = self.col.restrictedTraverse('@@contentlisting')(
+            portal_type='NotExistent'
+        )
+
+        self.assertEqual(len(contentlisting), 0)
+        self.assertEqual(contentlisting.actual_result_count, 0)
+
+    def test_filtering_collection_results_to_news_items(self):
+        self.folder.invokeFactory('Link', 'mylink')
+        contentlisting = self.col.restrictedTraverse('@@contentlisting')(
+            portal_type='Link'
+        )
+
+        self.assertEqual(len(contentlisting), 1)
+        self.assertEqual(contentlisting.actual_result_count, 1)
+        self.assertEqual(contentlisting[0].portal_type, 'Link')
+
+    def test_item_in_collection_results(self):
+        self.folder.invokeFactory('Event', 'myevent')
+        contentlisting = self.col.restrictedTraverse('@@contentlisting')()
+
+        self.assertEqual(len(contentlisting), 1)
+        self.assertEqual(contentlisting.actual_result_count, 1)
+
+    def test_batching_collection_results(self):
+        # call the contentlisting view. Check that it makes
+        # the results a contentlisting, regardless of batching
+        self.folder.invokeFactory('Event', 'myevent')
+        contentlisting = self.col.restrictedTraverse('@@contentlisting')(
             batch=True, b_size=1)
-        self.assertTrue(folderlisting[0].getId() == new_id)
-        self.assertEqual(len(folderlisting), 1)
-        self.assertEqual(folderlisting.actual_result_count, 2)
 
-        folderlisting = self.folder.restrictedTraverse('@@folderListing')(
+        # In case of Collections, the result is a plone.batching object
+        self.assertTrue(IBatch.providedBy(contentlisting))
+        self.assertTrue(verifyObject(IContentListingObject, contentlisting[0]))
+        self.assertEqual(len(contentlisting), 1)
+
+    def test_batching_collection_results_2(self):
+        # call the contentlisting view. Check that it makes
+        # the results a contentlisting, regardless of batching
+        new_id = self.folder.invokeFactory('Event', 'myevent')
+        new_id2 = self.folder.invokeFactory('Event', 'myevent2')
+        contentlisting = self.col.restrictedTraverse('@@contentlisting')(
+            batch=True, b_size=1)
+
+        self.assertTrue(contentlisting[0].getId() == new_id)
+        self.assertEqual(contentlisting.items_on_page, 1)
+        self.assertEqual(len(contentlisting), 2)
+        self.assertEqual(contentlisting.has_next, True)
+
+        contentlisting = self.col.restrictedTraverse('@@contentlisting')(
             batch=True, b_size=1, b_start=1)
-        self.assertEqual(folderlisting[0].getId(), new_id2)
-        self.assertEqual(len(folderlisting), 1)
-        self.assertEqual(folderlisting.actual_result_count, 2)
+
+        self.assertEqual(contentlisting[0].getId(), new_id2)
+        self.assertEqual(contentlisting.items_on_page, 1)
+        self.assertEqual(len(contentlisting), 2)
+        self.assertEqual(contentlisting.has_next, False)
 
 
 def test_suite():
@@ -290,4 +378,5 @@ def test_suite():
     suite.addTest(unittest.makeSuite(TestIndividualCatalogContentItems))
     suite.addTest(unittest.makeSuite(TestIndividualRealContentItems))
     suite.addTest(unittest.makeSuite(TestFolderContents))
+    suite.addTest(unittest.makeSuite(TestCollectionResults))
     return suite


Repository: plone.app.contentlisting


Branch: refs/heads/master
Date: 2015-06-18T14:17:51+02:00
Author: Johannes Raggam (thet) <raggam-nl@adm.at>
Commit: https://github.com/plone/plone.app.contentlisting/commit/b74a0087f6d3e97ecb65cfa6e08e30e35fdf9cb1

more praise

Files changed:
M CHANGES.rst

diff --git a/CHANGES.rst b/CHANGES.rst
index f087b88..02149c2 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -5,7 +5,8 @@ Changelog
 ----------------
 
 - Introduce ``@@contentlisting`` view, which is also supports Collections from
-  plone.app.contenttypes including filtering of results.
+  plone.app.contenttypes including filtering of results. This gives us a
+  unified interface for listing content from Folders or Collections.
   Deprecate ``@@folderListing``, which is kept for BBB compatibility.
   [thet]
 


