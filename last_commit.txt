Repository: Products.CMFPlone
Branch: refs/heads/4.3.x
Date: 2015-03-13T10:23:41+01:00
Author: Timo Stollenwerk (tisto) <tisto@plone.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/6da2a42bfa0e33af695ab8774eaa7f29f6d03010

Revert "Revert "fix for https://dev.plone.org/ticket/13603""

This reverts commit d29f3f4808575620c5fe5216487a17616735f1d4.

Files changed:
M Products/CMFPlone/skins/plone_scripts/object_delete.cpy

diff --git a/Products/CMFPlone/skins/plone_scripts/object_delete.cpy b/Products/CMFPlone/skins/plone_scripts/object_delete.cpy
index b5e4673..0399472 100644
--- a/Products/CMFPlone/skins/plone_scripts/object_delete.cpy
+++ b/Products/CMFPlone/skins/plone_scripts/object_delete.cpy
@@ -18,7 +18,9 @@ REQUEST = context.REQUEST
 if REQUEST.get('REQUEST_METHOD', 'GET').upper() == 'GET':
     raise Unauthorized('This method can not be accessed using a GET request')
 
-parent = context.aq_inner.aq_parent
+parent_path = '/'.join(REQUEST.physicalPathFromURL(REQUEST.URL2))
+parent = context.restrictedTraverse(parent_path)
+
 title = safe_unicode(context.title_or_id())
 
 try:
@@ -35,6 +37,15 @@ else:
     authenticator = context.restrictedTraverse('@@authenticator', None)
     if not authenticator.verify():
         raise Forbidden
+
+    id = context.getId()
+    item = parent.get(id, parent)
+    if item == parent:
+        message = _(u'${title} does not exist and cannot be deleted.',
+                    mapping={u'title': title})
+        context.plone_utils.addPortalMessage(message, type='error')
+        return state.set(status='failure')
+
     parent.manage_delObjects(context.getId())
     message = _(u'${title} has been deleted.',
                 mapping={u'title': title})


Repository: Products.CMFPlone
Branch: refs/heads/4.3.x
Date: 2015-03-13T10:30:32+01:00
Author: Timo Stollenwerk (tisto) <tisto@plone.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/48ef550217d620484873e5a9fbc09676138d97b2

Revert "Revert "add tests for https://dev.plone.org/ticket/13603""

This reverts commit 38b8474d6c3b51e390aa6b3e20663a8eafe9d6e9.

Files changed:
M Products/CMFPlone/tests/test_ploneutils.py
M docs/CHANGES.rst

diff --git a/Products/CMFPlone/tests/test_ploneutils.py b/Products/CMFPlone/tests/test_ploneutils.py
index 461c71b..a4cb95f 100644
--- a/Products/CMFPlone/tests/test_ploneutils.py
+++ b/Products/CMFPlone/tests/test_ploneutils.py
@@ -1,6 +1,9 @@
 import unittest
+import re
 
 from Products.CMFPlone.testing import PRODUCTS_CMFPLONE_INTEGRATION_TESTING
+from plone.app.testing import setRoles
+from plone.app.testing import TEST_USER_ID
 
 
 class TestPloneTool(unittest.TestCase):
@@ -26,19 +29,83 @@ def test_deleteObjectsByPaths_relative_path_raises(self):
             handle_errors=False
         )
 
-    def test_deleteObjectsByPaths_wrongly_acquired_object(self):
+    def test_delete_wrongly_acquired_object_through_deleteObjectsByPaths(self):
         '''
-        Do not delete wrongly acquired object.
+        Do not delete wrongly acquired object through folder_contents
         See https://dev.plone.org/ticket/13603
+
         '''
-        self.portal.invokeFactory('Folder', 'a_page')
+        # prepare content
+        self.portal.invokeFactory('Document', 'a_page')
         self.assertTrue('a_page' in self.portal.objectIds())
-        a_page_folder = self.portal['a_page']
-        a_page_folder.invokeFactory('Document', 'a_page')
-        self.assertTrue('a_page' in a_page_folder.objectIds())
-        a_page = a_page_folder['a_page']
-        path = a_page.absolute_url_path()
+        self.portal.invokeFactory('Folder', 'a_folder')
+        a_folder = self.portal['a_folder']
+        a_folder.invokeFactory('Document', 'a_page')
+        self.assertTrue('a_page' in a_folder.objectIds())
+        a_page_in_folder = a_folder['a_page']
+        path = a_page_in_folder.absolute_url_path()
+
+        # first request to delete
         self.plone_utils.deleteObjectsByPaths([path])
-        self.assertFalse('a_page' in a_page_folder.objectIds())
+        self.assertFalse('a_page' in a_folder.objectIds())
+        self.assertTrue('a_page' in self.portal.objectIds())
+
+        # second request to delete
         self.plone_utils.deleteObjectsByPaths([path])
+        self.assertTrue(
+            'a_page' in self.portal.objectIds(),
+            'acquired content should not be deleted.'
+        )
+
+    def _get_authenticator(self):
+        url = '/plone/login_password'
+        login = self.portal.restrictedTraverse(url)
+        res = login()
+        m = re.search('name="_authenticator" value="([^"]*)"', res)
+        if m:
+            return m.group(1)
+        return ''
+
+    def test_delete_wrongly_acquired_object_through_object_delete(self):
+        '''
+        Do not delete wrongly acquired object through Actions Delete.
+        See https://dev.plone.org/ticket/13603
+        '''
+        setRoles(self.portal, TEST_USER_ID, ['Member', 'Manager'])
+
+        # prepare content
+        self.portal.invokeFactory('Document', 'a_page')
         self.assertTrue('a_page' in self.portal.objectIds())
+        self.portal.invokeFactory('Folder', 'a_folder')
+        a_folder = self.portal['a_folder']
+        a_folder.invokeFactory('Document', 'a_page')
+        self.assertTrue('a_page' in a_folder.objectIds())
+        a_page_in_folder = a_folder['a_page']
+
+        # prepare fake request
+        physical_path = list(a_page_in_folder.getPhysicalPath())
+        physical_path.append('object_delete')
+        url = '/'.join(physical_path)
+        request = self.layer['request']
+        request.set('URL', url)
+        url2 = '/'.join(physical_path[:-2])
+        request.set('URL2', url2)
+        request.environ['REQUEST_METHOD'] = 'POST'
+        csrf_token = self._get_authenticator()
+        request.form.update({
+            '_authenticator': csrf_token,
+        })
+
+        # simulate call to object_delete
+        object_delete = self.portal.restrictedTraverse(url)
+        object_delete()
+        self.assertFalse('a_page' in a_folder.objectIds())
+        self.assertTrue('a_page' in self.portal.objectIds())
+
+        # simulate second call to object_delete
+        object_delete = self.portal.restrictedTraverse(url)
+        object_delete()
+        self.assertTrue(
+            'a_page' in self.portal.objectIds(),
+            'acquired content should not be deleted.'
+        )
diff --git a/docs/CHANGES.rst b/docs/CHANGES.rst
index 7cdc1fc..8ff990e 100644
--- a/docs/CHANGES.rst
+++ b/docs/CHANGES.rst
@@ -8,6 +8,11 @@ Changelog
 4.3.5 (unreleased)
 ------------------
 
+- Fix: If a user "deletes" the same item twice (ex.: having two different tabs 
+  open and not realising it's already been deleted) any higher level item with 
+  the same short name will be deleted without trace. 
+  [gotcha]
+
 - Extended ulocalized_time for target_language
   [agitator]
 


Repository: Products.CMFPlone
Branch: refs/heads/4.3.x
Date: 2015-03-13T11:39:31+01:00
Author: Godefroid Chapelle (gotcha) <gotcha@bubblenet.be>
Commit: https://github.com/plone/Products.CMFPlone/commit/6b3be300ff37a7776f367a450358b28f65d984aa

proper request setup

Files changed:
M Products/CMFPlone/tests/testContentTypeScripts.py

diff --git a/Products/CMFPlone/tests/testContentTypeScripts.py b/Products/CMFPlone/tests/testContentTypeScripts.py
index d57ad7f..7fcc780 100644
--- a/Products/CMFPlone/tests/testContentTypeScripts.py
+++ b/Products/CMFPlone/tests/testContentTypeScripts.py
@@ -152,9 +152,21 @@ def testObjectDeleteFailsOnGET(self):
 
     def testObjectDelete(self):
         self.folder.invokeFactory('Document', id='doc')
+
+        # prepare fake request with URL and URL2 properly setup
+        physical_path = list(self.folder.doc.getPhysicalPath())
+        physical_path.append('object_delete')
+        url = '/'.join(physical_path)
+        self.request.set('URL', url)
+        url2 = '/'.join(physical_path[:-2])
+        self.request.set('URL2', url2)
         self.setupAuthenticator()
         self.setRequestMethod('POST')
-        self.folder.doc.object_delete()
+
+        # simulate call to object_delete
+        object_delete = self.portal.restrictedTraverse(url)
+        object_delete()
+
         self.assertFalse('doc' in self.folder)
 
 


Repository: Products.CMFPlone
Branch: refs/heads/4.3.x
Date: 2015-03-13T14:42:34+01:00
Author: Timo Stollenwerk (tisto) <tisto@plone.org>
Commit: https://github.com/plone/Products.CMFPlone/commit/939e47d2ae9bbcb60649f6337aee227f12a88e20

Merge pull request #397 from plone/delete-by-acquisition-2

Revert "Revert "fix for https://dev.plone.org/ticket/13603""

Files changed:
M Products/CMFPlone/skins/plone_scripts/object_delete.cpy
M Products/CMFPlone/tests/testContentTypeScripts.py
M Products/CMFPlone/tests/test_ploneutils.py
M docs/CHANGES.rst

diff --git a/Products/CMFPlone/skins/plone_scripts/object_delete.cpy b/Products/CMFPlone/skins/plone_scripts/object_delete.cpy
index b5e4673..0399472 100644
--- a/Products/CMFPlone/skins/plone_scripts/object_delete.cpy
+++ b/Products/CMFPlone/skins/plone_scripts/object_delete.cpy
@@ -18,7 +18,9 @@ REQUEST = context.REQUEST
 if REQUEST.get('REQUEST_METHOD', 'GET').upper() == 'GET':
     raise Unauthorized('This method can not be accessed using a GET request')
 
-parent = context.aq_inner.aq_parent
+parent_path = '/'.join(REQUEST.physicalPathFromURL(REQUEST.URL2))
+parent = context.restrictedTraverse(parent_path)
+
 title = safe_unicode(context.title_or_id())
 
 try:
@@ -35,6 +37,15 @@ else:
     authenticator = context.restrictedTraverse('@@authenticator', None)
     if not authenticator.verify():
         raise Forbidden
+
+    id = context.getId()
+    item = parent.get(id, parent)
+    if item == parent:
+        message = _(u'${title} does not exist and cannot be deleted.',
+                    mapping={u'title': title})
+        context.plone_utils.addPortalMessage(message, type='error')
+        return state.set(status='failure')
+
     parent.manage_delObjects(context.getId())
     message = _(u'${title} has been deleted.',
                 mapping={u'title': title})
diff --git a/Products/CMFPlone/tests/testContentTypeScripts.py b/Products/CMFPlone/tests/testContentTypeScripts.py
index d57ad7f..7fcc780 100644
--- a/Products/CMFPlone/tests/testContentTypeScripts.py
+++ b/Products/CMFPlone/tests/testContentTypeScripts.py
@@ -152,9 +152,21 @@ def testObjectDeleteFailsOnGET(self):
 
     def testObjectDelete(self):
         self.folder.invokeFactory('Document', id='doc')
+
+        # prepare fake request with URL and URL2 properly setup
+        physical_path = list(self.folder.doc.getPhysicalPath())
+        physical_path.append('object_delete')
+        url = '/'.join(physical_path)
+        self.request.set('URL', url)
+        url2 = '/'.join(physical_path[:-2])
+        self.request.set('URL2', url2)
         self.setupAuthenticator()
         self.setRequestMethod('POST')
-        self.folder.doc.object_delete()
+
+        # simulate call to object_delete
+        object_delete = self.portal.restrictedTraverse(url)
+        object_delete()
+
         self.assertFalse('doc' in self.folder)
 
 
diff --git a/Products/CMFPlone/tests/test_ploneutils.py b/Products/CMFPlone/tests/test_ploneutils.py
index 461c71b..a4cb95f 100644
--- a/Products/CMFPlone/tests/test_ploneutils.py
+++ b/Products/CMFPlone/tests/test_ploneutils.py
@@ -1,6 +1,9 @@
 import unittest
+import re
 
 from Products.CMFPlone.testing import PRODUCTS_CMFPLONE_INTEGRATION_TESTING
+from plone.app.testing import setRoles
+from plone.app.testing import TEST_USER_ID
 
 
 class TestPloneTool(unittest.TestCase):
@@ -26,19 +29,83 @@ def test_deleteObjectsByPaths_relative_path_raises(self):
             handle_errors=False
         )
 
-    def test_deleteObjectsByPaths_wrongly_acquired_object(self):
+    def test_delete_wrongly_acquired_object_through_deleteObjectsByPaths(self):
         '''
-        Do not delete wrongly acquired object.
+        Do not delete wrongly acquired object through folder_contents
         See https://dev.plone.org/ticket/13603
+
         '''
-        self.portal.invokeFactory('Folder', 'a_page')
+        # prepare content
+        self.portal.invokeFactory('Document', 'a_page')
         self.assertTrue('a_page' in self.portal.objectIds())
-        a_page_folder = self.portal['a_page']
-        a_page_folder.invokeFactory('Document', 'a_page')
-        self.assertTrue('a_page' in a_page_folder.objectIds())
-        a_page = a_page_folder['a_page']
-        path = a_page.absolute_url_path()
+        self.portal.invokeFactory('Folder', 'a_folder')
+        a_folder = self.portal['a_folder']
+        a_folder.invokeFactory('Document', 'a_page')
+        self.assertTrue('a_page' in a_folder.objectIds())
+        a_page_in_folder = a_folder['a_page']
+        path = a_page_in_folder.absolute_url_path()
+
+        # first request to delete
         self.plone_utils.deleteObjectsByPaths([path])
-        self.assertFalse('a_page' in a_page_folder.objectIds())
+        self.assertFalse('a_page' in a_folder.objectIds())
+        self.assertTrue('a_page' in self.portal.objectIds())
+
+        # second request to delete
         self.plone_utils.deleteObjectsByPaths([path])
+        self.assertTrue(
+            'a_page' in self.portal.objectIds(),
+            'acquired content should not be deleted.'
+        )
+
+    def _get_authenticator(self):
+        url = '/plone/login_password'
+        login = self.portal.restrictedTraverse(url)
+        res = login()
+        m = re.search('name="_authenticator" value="([^"]*)"', res)
+        if m:
+            return m.group(1)
+        return ''
+
+    def test_delete_wrongly_acquired_object_through_object_delete(self):
+        '''
+        Do not delete wrongly acquired object through Actions Delete.
+        See https://dev.plone.org/ticket/13603
+        '''
+        setRoles(self.portal, TEST_USER_ID, ['Member', 'Manager'])
+
+        # prepare content
+        self.portal.invokeFactory('Document', 'a_page')
         self.assertTrue('a_page' in self.portal.objectIds())
+        self.portal.invokeFactory('Folder', 'a_folder')
+        a_folder = self.portal['a_folder']
+        a_folder.invokeFactory('Document', 'a_page')
+        self.assertTrue('a_page' in a_folder.objectIds())
+        a_page_in_folder = a_folder['a_page']
+
+        # prepare fake request
+        physical_path = list(a_page_in_folder.getPhysicalPath())
+        physical_path.append('object_delete')
+        url = '/'.join(physical_path)
+        request = self.layer['request']
+        request.set('URL', url)
+        url2 = '/'.join(physical_path[:-2])
+        request.set('URL2', url2)
+        request.environ['REQUEST_METHOD'] = 'POST'
+        csrf_token = self._get_authenticator()
+        request.form.update({
+            '_authenticator': csrf_token,
+        })
+
+        # simulate call to object_delete
+        object_delete = self.portal.restrictedTraverse(url)
+        object_delete()
+        self.assertFalse('a_page' in a_folder.objectIds())
+        self.assertTrue('a_page' in self.portal.objectIds())
+
+        # simulate second call to object_delete
+        object_delete = self.portal.restrictedTraverse(url)
+        object_delete()
+        self.assertTrue(
+            'a_page' in self.portal.objectIds(),
+            'acquired content should not be deleted.'
+        )
diff --git a/docs/CHANGES.rst b/docs/CHANGES.rst
index 7cdc1fc..8ff990e 100644
--- a/docs/CHANGES.rst
+++ b/docs/CHANGES.rst
@@ -8,6 +8,11 @@ Changelog
 4.3.5 (unreleased)
 ------------------
 
+- Fix: If a user "deletes" the same item twice (ex.: having two different tabs 
+  open and not realising it's already been deleted) any higher level item with 
+  the same short name will be deleted without trace. 
+  [gotcha]
+
 - Extended ulocalized_time for target_language
   [agitator]
 


