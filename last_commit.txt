Repository: plone.locking


Branch: refs/heads/master
Date: 2015-07-19T08:48:15-05:00
Author: vangheem (vangheem) <vangheem@gmail.com>
Commit: https://github.com/plone/plone.locking/commit/e23cd15326a87cd224b7d62a0efd781246ab6cb2

mark objects as safe to write

Files changed:
M CHANGES.rst
M plone/locking/lockable.py

diff --git a/CHANGES.rst b/CHANGES.rst
index d8a5a0c..b4f1bfb 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,7 +4,8 @@ Changelog
 2.0.8 (unreleased)
 ------------------
 
-- Nothing changed yet.
+- Fix write on read CSRF issues with latest plone.protect
+  [vangheem]
 
 
 2.0.7 (2015-06-05)
diff --git a/plone/locking/lockable.py b/plone/locking/lockable.py
index 4b2376d..20babf5 100644
--- a/plone/locking/lockable.py
+++ b/plone/locking/lockable.py
@@ -15,6 +15,13 @@
 from plone.locking.interfaces import STEALABLE_LOCK
 from plone.locking.interfaces import ILockSettings
 
+try:
+    from plone.protect.auto import safeWrite
+except ImportError:
+    def safeWrite(*args):
+        pass
+
+
 ANNOTATION_KEY = 'plone.locking'
 
 
@@ -44,9 +51,12 @@ def lock(self, lock_type=STEALABLE_LOCK, children=False):
             depth = children and 'infinity' or 0
             lock = LockItem(user, depth=depth, timeout=lock_type.timeout * 60L)
             token = lock.getLockToken()
+            self.context._v_safe_write = True
             self.context.wl_setLock(token, lock)
 
-            self._locks()[lock_type.__name__] = dict(type=lock_type, token=token)
+            locks = self._locks()
+            locks[lock_type.__name__] = dict(type=lock_type, token=token)
+            safeWrite(self.context)
 
     def refresh_lock(self, lock_type=STEALABLE_LOCK):
         if not self.locked():
@@ -123,7 +133,9 @@ def lock_info(self):
             isReadOnly = jar.isReadOnly()
         else:
             isReadOnly = False
-        for lock in self.context.wl_lockValues(not isReadOnly):
+        lock_mapping = self.context.wl_lockmapping(not isReadOnly)
+        safeWrite(lock_mapping)
+        for lock in lock_mapping.values():
             if not lock.isValid():
                 continue  # Skip invalid/expired locks
             token = lock.getLockToken()
@@ -145,6 +157,7 @@ def _locks(self, create=True):
 
         annotations = IAnnotations(self.context)
         locks = annotations.get(ANNOTATION_KEY, None)
+        safeWrite(annotations.obj.__annotations__)
         if locks is None and create:
             locks = annotations.setdefault(ANNOTATION_KEY, PersistentDict())
         if locks is not None:


Repository: plone.locking


Branch: refs/heads/master
Date: 2015-07-19T13:14:38-05:00
Author: vangheem (vangheem) <vangheem@gmail.com>
Commit: https://github.com/plone/plone.locking/commit/e9508d41d432dbbb44f2e55d03d95b24e1be41d0

annotations would have attr set always

Files changed:
M plone/locking/lockable.py

diff --git a/plone/locking/lockable.py b/plone/locking/lockable.py
index 20babf5..bb51d59 100644
--- a/plone/locking/lockable.py
+++ b/plone/locking/lockable.py
@@ -157,9 +157,14 @@ def _locks(self, create=True):
 
         annotations = IAnnotations(self.context)
         locks = annotations.get(ANNOTATION_KEY, None)
-        safeWrite(annotations.obj.__annotations__)
         if locks is None and create:
             locks = annotations.setdefault(ANNOTATION_KEY, PersistentDict())
+
+        try:
+            safeWrite(annotations.obj.__annotations__)
+        except AttributeError:
+            pass
+
         if locks is not None:
             self.__locks = locks
             return self.__locks


Repository: plone.locking


Branch: refs/heads/master
Date: 2015-07-19T18:30:38-05:00
Author: Nathan Van Gheem (vangheem) <vangheem@gmail.com>
Commit: https://github.com/plone/plone.locking/commit/ab8e007f9a67458f4268291566eba6528e785173

Merge pull request #6 from plone/csrf-fixes

mark objects as safe to write

Files changed:
M CHANGES.rst
M plone/locking/lockable.py

diff --git a/CHANGES.rst b/CHANGES.rst
index d8a5a0c..b4f1bfb 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,7 +4,8 @@ Changelog
 2.0.8 (unreleased)
 ------------------
 
-- Nothing changed yet.
+- Fix write on read CSRF issues with latest plone.protect
+  [vangheem]
 
 
 2.0.7 (2015-06-05)
diff --git a/plone/locking/lockable.py b/plone/locking/lockable.py
index 4b2376d..bb51d59 100644
--- a/plone/locking/lockable.py
+++ b/plone/locking/lockable.py
@@ -15,6 +15,13 @@
 from plone.locking.interfaces import STEALABLE_LOCK
 from plone.locking.interfaces import ILockSettings
 
+try:
+    from plone.protect.auto import safeWrite
+except ImportError:
+    def safeWrite(*args):
+        pass
+
+
 ANNOTATION_KEY = 'plone.locking'
 
 
@@ -44,9 +51,12 @@ def lock(self, lock_type=STEALABLE_LOCK, children=False):
             depth = children and 'infinity' or 0
             lock = LockItem(user, depth=depth, timeout=lock_type.timeout * 60L)
             token = lock.getLockToken()
+            self.context._v_safe_write = True
             self.context.wl_setLock(token, lock)
 
-            self._locks()[lock_type.__name__] = dict(type=lock_type, token=token)
+            locks = self._locks()
+            locks[lock_type.__name__] = dict(type=lock_type, token=token)
+            safeWrite(self.context)
 
     def refresh_lock(self, lock_type=STEALABLE_LOCK):
         if not self.locked():
@@ -123,7 +133,9 @@ def lock_info(self):
             isReadOnly = jar.isReadOnly()
         else:
             isReadOnly = False
-        for lock in self.context.wl_lockValues(not isReadOnly):
+        lock_mapping = self.context.wl_lockmapping(not isReadOnly)
+        safeWrite(lock_mapping)
+        for lock in lock_mapping.values():
             if not lock.isValid():
                 continue  # Skip invalid/expired locks
             token = lock.getLockToken()
@@ -147,6 +159,12 @@ def _locks(self, create=True):
         locks = annotations.get(ANNOTATION_KEY, None)
         if locks is None and create:
             locks = annotations.setdefault(ANNOTATION_KEY, PersistentDict())
+
+        try:
+            safeWrite(annotations.obj.__annotations__)
+        except AttributeError:
+            pass
+
         if locks is not None:
             self.__locks = locks
             return self.__locks


