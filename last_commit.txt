Repository: plone.app.contentlisting
Branch: refs/heads/master
Date: 2015-04-28T11:46:23+02:00
Author: Johannes Raggam (thet) <raggam-nl@adm.at>
Commit: https://github.com/plone/plone.app.contentlisting/commit/1930cc69b6b8f35452b3b17958180d354b52cd1a

pep8

Files changed:
A CHANGES.rst
A plone/app/contentlisting/tests/integration.rst
M plone/app/contentlisting/__init__.py
M plone/app/contentlisting/catalog.py
M plone/app/contentlisting/contentlisting.py
M plone/app/contentlisting/interfaces.py
M plone/app/contentlisting/realobject.py
M plone/app/contentlisting/tests/base.py
M plone/app/contentlisting/tests/test_integration_doctest.py
M plone/app/contentlisting/tests/test_integration_unit.py
M setup.py
D CHANGES.txt
D plone/app/contentlisting/tests/integration.txt

diff --git a/CHANGES.rst b/CHANGES.rst
new file mode 100644
index 0000000..bdc6639
--- /dev/null
+++ b/CHANGES.rst
@@ -0,0 +1,114 @@
+Changelog
+=========
+
+1.1.2 (unreleased)
+------------------
+
+- Pep8.
+  [thet]
+
+
+1.1.1 (2015-03-13)
+------------------
+
+- Add remaining, implemented but missing IContentListing interface methods.
+  [thet]
+
+- forward getURL's relative kw for contentlistings (plone4 compat)
+  [kiorky]
+
+
+1.1.0 (2014-04-16)
+------------------
+
+- Use proper styleguide for headings.
+  [polyester]
+
+- Move README to /docs folder.
+  [polyester]
+
+- Replace deprecated test assert statements.
+  [tisto]
+
+- Removing language tests and fixing icon tests to get the correct images.
+  [bloodbare]
+
+- Use PLONE_APP_CONTENTTYPES fixture for Plone 5.
+  [tisto]
+
+
+1.0.5 (2013-08-13)
+------------------
+
+- Add missing getDataOrigin method to interfaces.
+  [timo]
+
+
+1.0.4 (2013-01-01)
+------------------
+
+- Nothing changed.
+
+
+1.0.3 (2012-10-29)
+------------------
+
+- Whoever heard I liked batching was wrong. The Catalog results are
+  already batched, so don't batch them again.
+  [lentinj]
+
+
+1.0.2 (2012-10-15)
+------------------
+
+- Nothing changed.
+
+
+1.0.1 (2012-04-15)
+------------------
+
+- Change ContentTypeClass to return contenttype-{portal_type} to match
+  what the rest of Plone expects. This fixes sprite based icons for
+  pages/documents.
+  [gaudenz]
+
+
+1.0 - 2011-07-19
+----------------
+
+- Removed `searchResults` view and related code. Search is handled inside
+  `plone.app.search`.
+  [hannosch]
+
+- Renamed `uniqueIdentifier` method to `uuid` for shorter and more consistent
+  naming with `plone.uuid`.
+  [hannosch]
+
+
+0.1b2 - 2011-04-15
+------------------
+
+- Unit tests for appendViewAction, compare against portal_type rather than Type.
+  [lentinj]
+
+- Handle RealContentListingObject objects in isVisibleFromNav,
+  appendViewAction. Remove memoise, isn't going to cache anything for a useful
+  amount of time.
+  [lentinj]
+
+
+0.1b1 - 2011-04-15
+------------------
+
+- Add an isVisibleFromNav method, based on http://siarp.de/node/201, use
+  memoise to cache lookup of portal_properties
+  [lentinj]
+
+- Add MANIFEST.in.
+  [WouterVH]
+
+
+0.1a1 - 2011-03-02
+------------------
+
+- Initial release
diff --git a/CHANGES.txt b/CHANGES.txt
deleted file mode 100644
index ddefde4..0000000
--- a/CHANGES.txt
+++ /dev/null
@@ -1,113 +0,0 @@
-Changelog
-=========
-
-1.1.2 (unreleased)
-------------------
-
-- Nothing changed yet.
-
-
-1.1.1 (2015-03-13)
-------------------
-
-- Add remaining, implemented but missing IContentListing interface methods.
-  [thet]
-
-- forward getURL's relative kw for contentlistings (plone4 compat)
-  [kiorky]
-
-
-1.1.0 (2014-04-16)
-------------------
-
-- Use proper styleguide for headings.
-  [polyester]
-
-- Move README to /docs folder.
-  [polyester]
-
-- Replace deprecated test assert statements.
-  [tisto]
-
-- Removing language tests and fixing icon tests to get the correct images.
-  [bloodbare]
-
-- Use PLONE_APP_CONTENTTYPES fixture for Plone 5.
-  [tisto]
-
-
-1.0.5 (2013-08-13)
-------------------
-
-- Add missing getDataOrigin method to interfaces.
-  [timo]
-
-
-1.0.4 (2013-01-01)
-------------------
-
-- Nothing changed.
-
-
-1.0.3 (2012-10-29)
-------------------
-
-- Whoever heard I liked batching was wrong. The Catalog results are
-  already batched, so don't batch them again.
-  [lentinj]
-
-
-1.0.2 (2012-10-15)
-------------------
-
-- Nothing changed.
-
-
-1.0.1 (2012-04-15)
-------------------
-
-- Change ContentTypeClass to return contenttype-{portal_type} to match
-  what the rest of Plone expects. This fixes sprite based icons for
-  pages/documents.
-  [gaudenz]
-
-
-1.0 - 2011-07-19
-----------------
-
-- Removed `searchResults` view and related code. Search is handled inside
-  `plone.app.search`.
-  [hannosch]
-
-- Renamed `uniqueIdentifier` method to `uuid` for shorter and more consistent
-  naming with `plone.uuid`.
-  [hannosch]
-
-
-0.1b2 - 2011-04-15
-------------------
-
-- Unit tests for appendViewAction, compare against portal_type rather than Type.
-  [lentinj]
-
-- Handle RealContentListingObject objects in isVisibleFromNav,
-  appendViewAction. Remove memoise, isn't going to cache anything for a useful
-  amount of time.
-  [lentinj]
-
-
-0.1b1 - 2011-04-15
-------------------
-
-- Add an isVisibleFromNav method, based on http://siarp.de/node/201, use
-  memoise to cache lookup of portal_properties
-  [lentinj]
-
-- Add MANIFEST.in.
-  [WouterVH]
-
-
-0.1a1 - 2011-03-02
-------------------
-
-- Initial release
diff --git a/plone/app/contentlisting/__init__.py b/plone/app/contentlisting/__init__.py
index 792d600..e69de29 100644
--- a/plone/app/contentlisting/__init__.py
+++ b/plone/app/contentlisting/__init__.py
@@ -1 +0,0 @@
-#
diff --git a/plone/app/contentlisting/catalog.py b/plone/app/contentlisting/catalog.py
index df1bd31..ebb8659 100644
--- a/plone/app/contentlisting/catalog.py
+++ b/plone/app/contentlisting/catalog.py
@@ -1,19 +1,19 @@
+from .contentlisting import BaseContentListingObject
+from .interfaces import IContentListingObject
 from Acquisition import aq_base
 from Acquisition import aq_get
+from Products.CMFCore.utils import getToolByName
 from plone.app.layout.icons.interfaces import IContentIcon
 from plone.uuid.interfaces import IUUID
-from Products.CMFCore.utils import getToolByName
-from zope.component import queryMultiAdapter
 from zope import interface
-
-from .contentlisting import BaseContentListingObject
-from .interfaces import IContentListingObject
+from zope.component import queryMultiAdapter
 
 
 class CatalogContentListingObject(BaseContentListingObject):
-    """A Catalog-results based content object representation
-       Whenever sequences of catalog brains are turned into contentlistings,
-       This is the type of objects they are adapted to.
+    """A Catalog-results based content object representation.
+
+    Whenever sequences of catalog brains are turned into contentlistings,
+    This is the type of objects they are adapted to.
     """
 
     interface.implements(IContentListingObject)
@@ -24,16 +24,18 @@ def __init__(self, brain):
         self.request = aq_get(brain, 'REQUEST')
 
     def __repr__(self):
-        return "<plone.app.contentlisting.catalog." + \
-               "CatalogContentListingObject instance at %s>" % (
-            self.getPath(), )
+        return "<plone.app.contentlisting.catalog."\
+            "CatalogContentListingObject instance at {0}>".format(
+                self.getPath()
+            )
 
     __str__ = __repr__
 
     def __getattr__(self, name):
-        """We'll override getattr so that we can defer name lookups
-        to the real underlying objects without knowing the names of
-        all attributes """
+        """We'll override getattr so that we can defer name lookups to the real
+        underlying objects without knowing the names of all attributes.
+        """
+
         if name.startswith('_'):
             raise AttributeError(name)
         if hasattr(aq_base(self._brain), name):
@@ -44,10 +46,10 @@ def __getattr__(self, name):
             raise AttributeError(name)
 
     def getDataOrigin(self):
-        """ The origin of the data for the object.
+        """The origin of the data for the object.
 
         Sometimes we just need to know if we are looking at a brain or
-        the real object
+        the real object.
         """
         if self._cached_realobject is not None:
             return self._cached_realobject
@@ -55,7 +57,7 @@ def getDataOrigin(self):
             return self._brain
 
     def getObject(self):
-        """get the real, underlying object
+        """Get the real, underlying object.
 
         This is performance intensive compared to just getting the
         catalog brain, so we don't do it until we need to.  We may
@@ -86,8 +88,10 @@ def uuid(self):
         return self.getPath()
 
     def getIcon(self):
-        return queryMultiAdapter((self._brain, self.request, self._brain),
-                                 interface=IContentIcon)()
+        return queryMultiAdapter(
+            (self._brain, self.request, self._brain),
+            interface=IContentIcon
+        )()
 
     def getSize(self):
         return self._brain.getObjSize
@@ -98,15 +102,12 @@ def review_state(self):
     # All the dublin core elements. Most of them should be in the
     # brain for easy access
     def Title(self):
-        """title"""
         return self._brain.Title
 
     def Description(self):
-        """description"""
         return self._brain.Description
 
     def CroppedDescription(self):
-        """cropped description"""
         # TODO: Let's port Plones description cropping here instead of
         # implementing it all in the templates.
         return self.Description()
@@ -118,7 +119,6 @@ def PortalType(self):
         return self._brain.portal_type
 
     def listCreators(self):
-        """ """
         return self._brain.listCreators
 
     def getUserData(self, username):
@@ -131,18 +131,20 @@ def getUserData(self, username):
             membershiptool = getToolByName(self._brain, 'portal_membership')
             userdata = membershiptool.getMemberInfo(self._brain.Creator)
             if not userdata:
-                userdata = {'username': username,
-                'description': '',
-                'language': '',
-                # TODO string:${navigation_root_url}/author/${item_creator}
-                'home_page': '/HOMEPAGEURL',
-                'location': '',
-                'fullname': username}
+                userdata = {
+                    'username': username,
+                    'description': '',
+                    'language': '',
+                    # TODO
+                    # string:${navigation_root_url}/author/${item_creator}
+                    'home_page': '/HOMEPAGEURL',
+                    'location': '',
+                    'fullname': username
+                }
             self.request.usercache[username] = userdata
         return userdata
 
     def Creator(self):
-        """ """
         username = self._brain.Creator
         return username
 
@@ -183,7 +185,7 @@ def Identifier(self):
         return self.getURL()
 
     def Language(self):
-        """the language of the content"""
+        """The language of the content"""
         if hasattr(aq_base(self._brain), 'Language'):
             return self._brain.Language
         else:
diff --git a/plone/app/contentlisting/contentlisting.py b/plone/app/contentlisting/contentlisting.py
index 6d550ee..fca29b4 100644
--- a/plone/app/contentlisting/contentlisting.py
+++ b/plone/app/contentlisting/contentlisting.py
@@ -1,13 +1,13 @@
-from plone.i18n.normalizer.interfaces import IIDNormalizer
+from .interfaces import IContentListing
+from .interfaces import IContentListingObject
 from Products.CMFCore.utils import getToolByName
-from zope.component import queryUtility
+from plone.i18n.normalizer.interfaces import IIDNormalizer
 from zope import interface
-
-from .interfaces import IContentListing, IContentListingObject
+from zope.component import queryUtility
 
 
 class ContentListing(object):
-    """ An IContentListing implementation based on sequences of objects"""
+    """An IContentListing implementation based on sequences of objects."""
     interface.implements(IContentListing)
 
     def __init__(self, sequence):
@@ -19,8 +19,8 @@ def __getitem__(self, index):
         return IContentListingObject(self._basesequence[index])
 
     def __len__(self):
-        """ length of the resultset is equal to the length of the underlying
-            sequence
+        """Length of the resultset is equal to the length of the underlying
+        sequence.
         """
         return len(self._basesequence)
 
@@ -30,8 +30,9 @@ def actual_result_count(self):
         return getattr(bs, 'actual_result_count', len(bs))
 
     def __iter__(self):
-        """ let the sequence be iterable and whenever we look at an object,
-            it should be a ContentListingObject"""
+        """Let the sequence be iterable and whenever we look at an object, it
+        should be a ContentListingObject.
+        """
         for obj in self._basesequence:
             yield IContentListingObject(obj)
 
@@ -88,8 +89,9 @@ def __getslice__(self, i, j):
 
 
 class BaseContentListingObject(object):
-    """A baseclass for the different types of contentlistingobjects
-        To avoid duplication of the stuff that is not implementation-specific
+    """A baseclass for the different types of contentlistingobjects.
+
+    To avoid duplication of the stuff that is not implementation-specific.
     """
 
     def __eq__(self, other):
@@ -104,13 +106,15 @@ def ContentTypeClass(self):
             self.PortalType())
 
     def ReviewStateClass(self):
-        """A normalised review state string for CSS styling use in listings."""
+        """A normalised review state string for CSS styling use in listings.
+        """
         return "state-" + queryUtility(IIDNormalizer).normalize(
             self.review_state())
 
     def appendViewAction(self):
-        """decide whether to produce a string /view to append to links
-        in results listings"""
+        """Decide whether to produce a string /view to append to links in
+        results listings.
+        """
         try:
             ttool = getToolByName(self.getDataOrigin(), 'portal_properties')
             types = ttool.site_properties.typesUseViewActionInListings
@@ -121,11 +125,18 @@ def appendViewAction(self):
         return ''
 
     def isVisibleInNav(self):
-        """true iff this item should be visible in navigation trees"""
-        if hasattr(self,'exclude_from_nav') and (self.exclude_from_nav() if callable(self.exclude_from_nav) else self.exclude_from_nav):
+        """True, if this item should be visible in navigation trees.
+        """
+        if hasattr(self, 'exclude_from_nav') and (
+                self.exclude_from_nav()
+                if callable(self.exclude_from_nav)
+                else self.exclude_from_nav
+        ):
             return False
-        portal_properties = getToolByName(self.getDataOrigin(), 'portal_properties')
+        portal_properties = getToolByName(self.getDataOrigin(), 'portal_properties')  # noqa
         navtree_properties = getattr(portal_properties, 'navtree_properties')
-        if self.portal_type in list(navtree_properties.metaTypesNotToList): return False
-        if self.id in list(navtree_properties.idsNotToList): return False
+        if self.portal_type in list(navtree_properties.metaTypesNotToList):
+            return False
+        if self.id in list(navtree_properties.idsNotToList):
+            return False
         return True
diff --git a/plone/app/contentlisting/interfaces.py b/plone/app/contentlisting/interfaces.py
index 3acefb6..6646985 100644
--- a/plone/app/contentlisting/interfaces.py
+++ b/plone/app/contentlisting/interfaces.py
@@ -3,88 +3,88 @@
 
 
 class IContentListing(IReadSequence):
-    """Sequence of IContentListingObjects"""
+    """Sequence of IContentListingObjects."""
 
 
 class IContentListingObject(IDublinCore):
-    """Unified representation of content objects in listings"""
+    """Unified representation of content objects in listings."""
 
     def getDataOrigin():
         """The origin of the data for the object."""
 
     def getObject():
-        """get the real object (may be expensive)"""
+        """get the real object (may be expensive)."""
 
     def getId():
-        """get the object id in its container"""
+        """get the object id in its container."""
 
     def getPath():
-        """Path to the object, relative to the portal root"""
+        """Path to the object, relative to the portal root."""
 
     def getURL(relative=False):
-        """Full url to the object, including the portal root"""
+        """Full url to the object, including the portal root."""
 
     def uuid():
-        """Unique content identifier"""
+        """Unique content identifier."""
 
     def getIcon():
-        """icon for the object"""
+        """icon for the object."""
 
     def getSize():
-        """size in bytes"""
+        """size in bytes."""
 
     def review_state():
-        """Workflow review state"""
+        """Workflow review state."""
 
     def Title():
-        """Title"""
+        """Title."""
 
     def Description():
-        """Description"""
+        """Description."""
 
     def CroppedDescription():
-        """A cropped description"""
+        """A cropped description."""
 
     def Type():
-        """Type"""
+        """Type title."""
 
     def PortalType():
-        """Portal Type of the opject"""
+        """Content type id of the object."""
 
     def listCreators():
-        """List creators of the object"""
+        """List creators of the object."""
 
     def getUserData(username):
-        """Get some data of a given user"""
+        """Get some data of a given user."""
 
     def Creator():
-        """Creator of the object"""
+        """Creator of the object."""
 
     def Author():
-        """Author of the object"""
+        """Author of the object."""
 
     def Subject():
-        """Subject(s) of the object"""
+        """Subject(s) of the object."""
 
     def Date():
-        """Date of the object"""
+        """Date of the object."""
 
     def CreationDate():
-        """Creation date of the object"""
+        """Creation date of the object."""
 
     def EffectiveDate():
-        """Date, when content will be shown in listings"""
+        """Date, when content will be shown in listings."""
 
     def ExpirationDate():
-        """Date, when content will be removed from listings"""
+        """Date, when content will be removed from listings."""
 
     def ModificationDate():
-        """Date, when object was last modified"""
+        """Date, when object was last modified."""
 
     def Language():
-        """Language of the object"""
+        """Language of the object."""
 
     def ContentTypeClass():
-        """The contenttype suitable as a css class name,
-           matching plone conventions
+        """The contenttype suitable as a css class name, matching Plone
+        conventions.
         """
diff --git a/plone/app/contentlisting/realobject.py b/plone/app/contentlisting/realobject.py
index 04ea29f..4781f88 100644
--- a/plone/app/contentlisting/realobject.py
+++ b/plone/app/contentlisting/realobject.py
@@ -1,17 +1,17 @@
+from .contentlisting import BaseContentListingObject
+from .interfaces import IContentListingObject
 from Acquisition import aq_base
 from Acquisition import aq_get
+from Products.CMFCore.utils import getToolByName
 from plone.app.layout.icons.interfaces import IContentIcon
 from plone.uuid.interfaces import IUUID
-from Products.CMFCore.utils import getToolByName
-from zope.component import queryMultiAdapter
 from zope import interface
-
-from .contentlisting import BaseContentListingObject
-from .interfaces import IContentListingObject
+from zope.component import queryMultiAdapter
 
 
 class RealContentListingObject(BaseContentListingObject):
-    """A content object representation wrapping a real content object"""
+    """A content object representation wrapping a real content object.
+    """
 
     interface.implements(IContentListingObject)
 
@@ -20,9 +20,10 @@ def __init__(self, obj):
         self.request = aq_get(obj, 'REQUEST')
 
     def __repr__(self):
-        return "<plone.app.contentlisting.realobject." + \
-               "RealContentListingObject instance at %s>" % (
-            self.getPath(), )
+        return "<plone.app.contentlisting.realobject."\
+            "RealContentListingObject instance at {0}>".format(
+                self.getPath()
+            )
 
     __str__ = __repr__
 
@@ -77,7 +78,7 @@ def review_state(self):
         return wftool.getInfoFor(obj, 'review_state')
 
     def Type(self):
-        """Dublin Core element - Object type"""
+        """Dublin Core element - Object type."""
         obj = self.getObject()
         typestool = getToolByName(obj, 'portal_types')
         ti = typestool.getTypeInfo(obj)
diff --git a/plone/app/contentlisting/tests/base.py b/plone/app/contentlisting/tests/base.py
index 882a50e..8457012 100644
--- a/plone/app/contentlisting/tests/base.py
+++ b/plone/app/contentlisting/tests/base.py
@@ -1,13 +1,12 @@
-import unittest2 as unittest
-
+from Products.CMFCore.utils import getToolByName
+from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FIXTURE
 from plone.app.testing import FunctionalTesting
 from plone.app.testing import IntegrationTesting
 from plone.app.testing import PloneSandboxLayer
-from plone.app.contenttypes.testing import PLONE_APP_CONTENTTYPES_FIXTURE
-from plone.app.testing import setRoles
 from plone.app.testing import TEST_USER_ID
-from Products.CMFCore.utils import getToolByName
+from plone.app.testing import setRoles
 from zope.configuration import xmlconfig
+import unittest2 as unittest
 
 
 class ContentListingLayer(PloneSandboxLayer):
@@ -25,9 +24,13 @@ def setUpZope(self, app, configurationContext):
 
 CONTENTLISTING_FIXTURE = ContentListingLayer()
 CONTENTLISTING_INTEGRATION_TESTING = IntegrationTesting(
-    bases=(CONTENTLISTING_FIXTURE, ), name="ContentListing:Integration")
+    bases=(CONTENTLISTING_FIXTURE, ),
+    name="ContentListing:Integration"
+)
 CONTENTLISTING_FUNCTIONAL_TESTING = FunctionalTesting(
-    bases=(CONTENTLISTING_FIXTURE, ), name="ContentListing:Functional")
+    bases=(CONTENTLISTING_FIXTURE, ),
+    name="ContentListing:Functional"
+)
 
 
 class ContentlistingTestCase(unittest.TestCase):
diff --git a/plone/app/contentlisting/tests/integration.rst b/plone/app/contentlisting/tests/integration.rst
new file mode 100644
index 0000000..1c3a734
--- /dev/null
+++ b/plone/app/contentlisting/tests/integration.rst
@@ -0,0 +1,244 @@
+Basic usage
+===========
+
+The idea behind plone.app.contentlisting is to have a unified way of listing
+Plone content whenever needed, whether in folderlistings, collections,
+portlets or search results.
+
+It should be simple to use for new developers and integrators. The core concept
+is to take a list of something (in this case a catalog result set) and turn it
+into an IContentListing so that the user always knows what to expect.
+
+    >>> from zope import interface
+    >>> from plone.app.contentlisting.interfaces import IContentListing, IContentListingObject
+    >>> from Products.CMFCore.utils import getToolByName
+
+We simply adapt a sequence of something content-like. In this case (and most
+common cases) the sequence will be a catalog search result set.
+
+    >>> catalog = getToolByName(self.portal, 'portal_catalog')
+    >>> results = catalog.searchResults(dict(is_default_page=False))
+    >>> contentlist = IContentListing(results)
+    >>> print(contentlist)
+    <plone.app.contentlisting.contentlisting.ContentListing object ...>
+
+We get a ContentListing. That is the catalog based implementation of
+IContentListing. In other cases you might get a different implementations,
+but they should all conform to the rules of the interface.
+
+The contentListing is a normal iterator that we can loop over. Each entry is
+a CatalogContentListingObject
+
+    >>> listitem = contentlist[2]
+    >>> print(listitem)
+    <plone.app.contentlisting.catalog.CatalogContentListingObject instance ...>
+
+The listitem provides all the methods of the IContentListingObject interface
+
+    >>> print(listitem.review_state())
+    published
+
+It can report what its source of data is
+
+    >>> print(listitem.getDataOrigin())
+    <Products.ZCatalog.Catalog.mybrains object at...>
+
+and if we access attributes on it that are not in the interface or in the
+brain, it will transparently fetch the real object and cache it to get
+properties from that instead.
+
+After accessing an attribute of the object that was neither in the
+IContentListingObject or on the catalog brain, we can now see that the
+real object has been silently fetched in the background. getDataOrigin now
+returns the object.
+
+    >>> dummy= listitem.absolute_url()
+    >>> print(listitem.getDataOrigin())
+    <Folder at news>
+
+This item's origin is no longer a Brain, but the real object
+
+    >>> listitem.review_state()
+    'published'
+
+For user and integrator convenience we also include a couple of handy
+browser views to get to these listings.
+
+    >>> folderlisting = self.portal.restrictedTraverse('@@folderListing')()
+    >>> print(folderlisting)
+    <plone.app.contentlisting.contentlisting.ContentListing object ...
+
+    >>> len(folderlisting)
+    3
+
+We can even slice the new folderlisting
+
+    >>> len (folderlisting[2:4])
+    1
+
+    >>> len(self.portal.restrictedTraverse('news/@@folderListing')())
+    1
+
+And we can use batching in it:
+
+    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@folderListing')()]
+    ['http://nohost/plone/test-folder', 'http://nohost/plone/front-page', 'http://nohost/plone/news']
+    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@folderListing')(batch=True, b_size=1)]
+    ['http://nohost/plone/test-folder']
+    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@folderListing')(batch=True, b_start=1, b_size=1)]
+    ['http://nohost/plone/front-page']
+    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@folderListing')(batch=True, b_start=2, b_size=1)]
+    ['http://nohost/plone/news']
+    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@folderListing')(batch=True, b_start=1, b_size=2)]
+    ['http://nohost/plone/front-page', 'http://nohost/plone/news']
+
+We can use filtering by catalog indexes:
+    >>> len(self.portal.restrictedTraverse('@@folderListing')(portal_type='Document'))
+    1
+
+
+Append View Action
+==================
+
+Some types may require '/view' appended to their URLs. Currently these don't
+
+    >>> frontpage = self.portal.restrictedTraverse('@@folderListing')(id='front-page')[0]
+    >>> frontpage.appendViewAction()
+    ''
+    >>> news = self.portal.restrictedTraverse('@@folderListing')(id='news')[0]
+    >>> news.appendViewAction()
+    ''
+    >>> realfrontpage = IContentListingObject(self.portal['front-page'])
+    >>> realfrontpage.appendViewAction()
+    ''
+
+By altering portal_properties, we can make this true for Documents
+
+    >>> ttool = getToolByName(self.portal, 'portal_properties')
+    >>> ttool.site_properties.typesUseViewActionInListings = [frontpage.portal_type]
+    >>> frontpage.appendViewAction()
+    '/view'
+    >>> news.appendViewAction()
+    ''
+    >>> realfrontpage.appendViewAction()
+    '/view'
+
+And turn it off again
+
+    >>> ttool.site_properties.typesUseViewActionInListings = []
+    >>> frontpage.appendViewAction()
+    ''
+    >>> news.appendViewAction()
+    ''
+    >>> realfrontpage.appendViewAction()
+    ''
+
+
+Visibility in Navigation
+========================
+
+Items by default are visible in navigation
+
+    >>> frontpage = self.portal.restrictedTraverse('@@folderListing')(id='front-page')[0]
+    >>> frontpage.isVisibleInNav()
+    True
+
+    >>> news = self.portal.restrictedTraverse('@@folderListing')(id='news')[0]
+    >>> news.isVisibleInNav()
+    True
+
+Just to check, these will be catalog objects using a brain internally
+
+    >>> frontpage.__class__
+    <class 'plone.app.contentlisting.catalog.CatalogContentListingObject'>
+    >>> print(frontpage.getDataOrigin())
+    <Products.ZCatalog.Catalog.mybrains object at...>
+    >>> frontpage.isVisibleInNav()
+    True
+
+A catalog object with a real object works
+
+    >>> dummy= listitem.absolute_url()
+    >>> print(listitem.getDataOrigin())
+    <Folder at news>
+    >>> frontpage.isVisibleInNav()
+    True
+
+Getting a realobject-based listing also works
+
+    >>> realfrontpage = IContentListingObject(self.portal['front-page'])
+    >>> realfrontpage.__class__
+    <class 'plone.app.contentlisting.realobject.RealContentListingObject'>
+    >>> realfrontpage.isVisibleInNav()
+    True
+
+There are several ways something can be hidden from navigation, the most direct
+way is the exclude_from_nav property being true
+
+    >>> frontpage_object = frontpage.getObject()
+    >>> frontpage_object.exclude_from_nav = True
+    >>> frontpage_object.reindexObject()
+
+This will be indexed, so an object isn't necessary to check this
+
+    >>> frontpage = self.portal.restrictedTraverse('@@folderListing')(id='front-page')[0]
+    >>> frontpage.isVisibleInNav()
+    False
+    >>> print(frontpage.getDataOrigin())
+    <Products.ZCatalog.Catalog.mybrains object at...>
+
+But a real object still works.
+
+    >>> realfrontpage = IContentListingObject(self.portal['front-page'])
+    >>> realfrontpage.__class__
+    <class 'plone.app.contentlisting.realobject.RealContentListingObject'>
+    >>> realfrontpage.isVisibleInNav()
+    False
+
+We can also turn it off again.
+
+    >>> frontpage_object.exclude_from_nav = False
+    >>> frontpage_object.reindexObject()
+
+    >>> frontpage = self.portal.restrictedTraverse('@@folderListing')(id='front-page')[0]
+    >>> frontpage.isVisibleInNav()
+    True
+
+    >>> realfrontpage = IContentListingObject(self.portal['front-page'])
+    >>> realfrontpage.isVisibleInNav()
+    True
+
+We can also exclude anything of a particular type using metaTypesNotToList
+
+    >>> navtree_properties = getattr(getToolByName(self.portal, 'portal_properties'), 'navtree_properties')
+    >>> navtree_properties.metaTypesNotToList = [frontpage.portal_type]
+    >>> frontpage.isVisibleInNav()
+    False
+    >>> realfrontpage.isVisibleInNav()
+    False
+    >>> news.isVisibleInNav()
+    True
+    >>> navtree_properties.metaTypesNotToList = []
+    >>> frontpage.isVisibleInNav()
+    True
+    >>> realfrontpage.isVisibleInNav()
+    True
+    >>> news.isVisibleInNav()
+    True
+
+Finally, particular ids can be excluded from listings
+
+    >>> navtree_properties.idsNotToList = [news.id]
+    >>> frontpage.isVisibleInNav()
+    True
+    >>> realfrontpage.isVisibleInNav()
+    True
+    >>> news.isVisibleInNav()
+    False
+    >>> navtree_properties.idsNotToList = []
+    >>> frontpage.isVisibleInNav()
+    True
+    >>> realfrontpage.isVisibleInNav()
+    True
+    >>> news.isVisibleInNav()
+    True
diff --git a/plone/app/contentlisting/tests/integration.txt b/plone/app/contentlisting/tests/integration.txt
deleted file mode 100644
index 0cce5c3..0000000
--- a/plone/app/contentlisting/tests/integration.txt
+++ /dev/null
@@ -1,245 +0,0 @@
-===========
-Basic usage
-===========
-
-The idea behind plone.app.contentlisting is to have a unified way of listing
-Plone content whenever needed, whether in folderlistings, collections,
-portlets or search results.
-
-It should be simple to use for new developers and integrators. The core concept
-is to take a list of something (in this case a catalog result set) and turn it
-into an IContentListing so that the user always knows what to expect.
-
-    >>> from zope import interface
-    >>> from plone.app.contentlisting.interfaces import IContentListing, IContentListingObject
-    >>> from Products.CMFCore.utils import getToolByName
-
-We simply adapt a sequence of something content-like. In this case (and most
-common cases) the sequence will be a catalog search result set.
-
-    >>> catalog = getToolByName(self.portal, 'portal_catalog')
-    >>> results = catalog.searchResults(dict(is_default_page=False))
-    >>> contentlist = IContentListing(results)
-    >>> print(contentlist)
-    <plone.app.contentlisting.contentlisting.ContentListing object ...>
-
-We get a ContentListing. That is the catalog based implementation of
-IContentListing. In other cases you might get a different implementations,
-but they should all conform to the rules of the interface.
-
-The contentListing is a normal iterator that we can loop over. Each entry is
-a CatalogContentListingObject
-
-    >>> listitem = contentlist[2]
-    >>> print(listitem)
-    <plone.app.contentlisting.catalog.CatalogContentListingObject instance ...>
-
-The listitem provides all the methods of the IContentListingObject interface
-
-    >>> print(listitem.review_state())
-    published
-
-It can report what its source of data is
-
-    >>> print(listitem.getDataOrigin())
-    <Products.ZCatalog.Catalog.mybrains object at...>
-
-and if we access attributes on it that are not in the interface or in the
-brain, it will transparently fetch the real object and cache it to get
-properties from that instead.
-
-After accessing an attribute of the object that was neither in the
-IContentListingObject or on the catalog brain, we can now see that the
-real object has been silently fetched in the background. getDataOrigin now
-returns the object.
-
-    >>> dummy= listitem.absolute_url()
-    >>> print(listitem.getDataOrigin())
-    <Folder at news>
-
-This item's origin is no longer a Brain, but the real object
-
-    >>> listitem.review_state()
-    'published'
-
-For user and integrator convenience we also include a couple of handy
-browser views to get to these listings.
-
-    >>> folderlisting = self.portal.restrictedTraverse('@@folderListing')()
-    >>> print(folderlisting)
-    <plone.app.contentlisting.contentlisting.ContentListing object ...
-
-    >>> len(folderlisting)
-    3
-
-We can even slice the new folderlisting
-
-    >>> len (folderlisting[2:4])
-    1
-
-    >>> len(self.portal.restrictedTraverse('news/@@folderListing')())
-    1
-
-And we can use batching in it:
-
-    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@folderListing')()]
-    ['http://nohost/plone/test-folder', 'http://nohost/plone/front-page', 'http://nohost/plone/news']
-    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@folderListing')(batch=True, b_size=1)]
-    ['http://nohost/plone/test-folder']
-    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@folderListing')(batch=True, b_start=1, b_size=1)]
-    ['http://nohost/plone/front-page']
-    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@folderListing')(batch=True, b_start=2, b_size=1)]
-    ['http://nohost/plone/news']
-    >>> [i.getURL() for i in self.portal.restrictedTraverse('@@folderListing')(batch=True, b_start=1, b_size=2)]
-    ['http://nohost/plone/front-page', 'http://nohost/plone/news']
-
-We can use filtering by catalog indexes:
-    >>> len(self.portal.restrictedTraverse('@@folderListing')(portal_type='Document'))
-    1
-
-==================
-Append View Action
-==================
-
-Some types may require '/view' appended to their URLs. Currently these don't
-
-    >>> frontpage = self.portal.restrictedTraverse('@@folderListing')(id='front-page')[0]
-    >>> frontpage.appendViewAction()
-    ''
-    >>> news = self.portal.restrictedTraverse('@@folderListing')(id='news')[0]
-    >>> news.appendViewAction()
-    ''
-    >>> realfrontpage = IContentListingObject(self.portal['front-page'])
-    >>> realfrontpage.appendViewAction()
-    ''
-
-By altering portal_properties, we can make this true for Documents
-
-    >>> ttool = getToolByName(self.portal, 'portal_properties')
-    >>> ttool.site_properties.typesUseViewActionInListings = [frontpage.portal_type]
-    >>> frontpage.appendViewAction()
-    '/view'
-    >>> news.appendViewAction()
-    ''
-    >>> realfrontpage.appendViewAction()
-    '/view'
-
-And turn it off again
-
-    >>> ttool.site_properties.typesUseViewActionInListings = []
-    >>> frontpage.appendViewAction()
-    ''
-    >>> news.appendViewAction()
-    ''
-    >>> realfrontpage.appendViewAction()
-    ''
-
-========================
-Visibility in Navigation
-========================
-
-Items by default are visible in navigation
-
-    >>> frontpage = self.portal.restrictedTraverse('@@folderListing')(id='front-page')[0]
-    >>> frontpage.isVisibleInNav()
-    True
-
-    >>> news = self.portal.restrictedTraverse('@@folderListing')(id='news')[0]
-    >>> news.isVisibleInNav()
-    True
-
-Just to check, these will be catalog objects using a brain internally
-
-    >>> frontpage.__class__
-    <class 'plone.app.contentlisting.catalog.CatalogContentListingObject'>
-    >>> print(frontpage.getDataOrigin())
-    <Products.ZCatalog.Catalog.mybrains object at...>
-    >>> frontpage.isVisibleInNav()
-    True
-
-A catalog object with a real object works
-
-    >>> dummy= listitem.absolute_url()
-    >>> print(listitem.getDataOrigin())
-    <Folder at news>
-    >>> frontpage.isVisibleInNav()
-    True
-
-Getting a realobject-based listing also works
-
-    >>> realfrontpage = IContentListingObject(self.portal['front-page'])
-    >>> realfrontpage.__class__
-    <class 'plone.app.contentlisting.realobject.RealContentListingObject'>
-    >>> realfrontpage.isVisibleInNav()
-    True
-
-There are several ways something can be hidden from navigation, the most direct
-way is the exclude_from_nav property being true
-
-    >>> frontpage_object = frontpage.getObject()
-    >>> frontpage_object.exclude_from_nav = True
-    >>> frontpage_object.reindexObject()
-
-This will be indexed, so an object isn't necessary to check this
-
-    >>> frontpage = self.portal.restrictedTraverse('@@folderListing')(id='front-page')[0]
-    >>> frontpage.isVisibleInNav()
-    False
-    >>> print(frontpage.getDataOrigin())
-    <Products.ZCatalog.Catalog.mybrains object at...>
-
-But a real object still works.
-
-    >>> realfrontpage = IContentListingObject(self.portal['front-page'])
-    >>> realfrontpage.__class__
-    <class 'plone.app.contentlisting.realobject.RealContentListingObject'>
-    >>> realfrontpage.isVisibleInNav()
-    False
-
-We can also turn it off again.
-
-    >>> frontpage_object.exclude_from_nav = False
-    >>> frontpage_object.reindexObject()
-
-    >>> frontpage = self.portal.restrictedTraverse('@@folderListing')(id='front-page')[0]
-    >>> frontpage.isVisibleInNav()
-    True
-
-    >>> realfrontpage = IContentListingObject(self.portal['front-page'])
-    >>> realfrontpage.isVisibleInNav()
-    True
-
-We can also exclude anything of a particular type using metaTypesNotToList
-
-    >>> navtree_properties = getattr(getToolByName(self.portal, 'portal_properties'), 'navtree_properties')
-    >>> navtree_properties.metaTypesNotToList = [frontpage.portal_type]
-    >>> frontpage.isVisibleInNav()
-    False
-    >>> realfrontpage.isVisibleInNav()
-    False
-    >>> news.isVisibleInNav()
-    True
-    >>> navtree_properties.metaTypesNotToList = []
-    >>> frontpage.isVisibleInNav()
-    True
-    >>> realfrontpage.isVisibleInNav()
-    True
-    >>> news.isVisibleInNav()
-    True
-
-Finally, particular ids can be excluded from listings
-
-    >>> navtree_properties.idsNotToList = [news.id]
-    >>> frontpage.isVisibleInNav()
-    True
-    >>> realfrontpage.isVisibleInNav()
-    True
-    >>> news.isVisibleInNav()
-    False
-    >>> navtree_properties.idsNotToList = []
-    >>> frontpage.isVisibleInNav()
-    True
-    >>> realfrontpage.isVisibleInNav()
-    True
-    >>> news.isVisibleInNav()
-    True
diff --git a/plone/app/contentlisting/tests/test_integration_doctest.py b/plone/app/contentlisting/tests/test_integration_doctest.py
index 284ebc2..cfbd1af 100644
--- a/plone/app/contentlisting/tests/test_integration_doctest.py
+++ b/plone/app/contentlisting/tests/test_integration_doctest.py
@@ -1,15 +1,13 @@
+from .base import ContentlistingFunctionalTestCase
+from Testing import ZopeTestCase as ztc
 import doctest
 import unittest
 
-from Testing import ZopeTestCase as ztc
-
-from .base import ContentlistingFunctionalTestCase
-
 
 def test_suite():
     return unittest.TestSuite([
         ztc.ZopeDocFileSuite(
-            'tests/integration.txt', package='plone.app.contentlisting',
+            'tests/integration.rst', package='plone.app.contentlisting',
             test_class=ContentlistingFunctionalTestCase,
             optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS),
-        ])
+    ])
diff --git a/plone/app/contentlisting/tests/test_integration_unit.py b/plone/app/contentlisting/tests/test_integration_unit.py
index 991a991..5a6bc32 100644
--- a/plone/app/contentlisting/tests/test_integration_unit.py
+++ b/plone/app/contentlisting/tests/test_integration_unit.py
@@ -1,9 +1,8 @@
-from Products.CMFCore.utils import getToolByName
-from zope.interface.verify import verifyObject
-
-from .base import ContentlistingFunctionalTestCase
 from ..interfaces import IContentListing
 from ..interfaces import IContentListingObject
+from .base import ContentlistingFunctionalTestCase
+from Products.CMFCore.utils import getToolByName
+from zope.interface.verify import verifyObject
 
 
 class TestSetup(ContentlistingFunctionalTestCase):
@@ -56,12 +55,16 @@ def setUp(self):
         self.realitem = self.folder.mypage
 
     def test_printing_item(self):
-        self.assertEqual(repr(self.item),
+        self.assertEqual(
+            repr(self.item),
             '<plone.app.contentlisting.catalog.CatalogContentListingObject '
-            'instance at /plone/test-folder/mypage>')
-        self.assertEqual(str(self.item),
+            'instance at /plone/test-folder/mypage>'
+        )
+        self.assertEqual(
+            str(self.item),
             '<plone.app.contentlisting.catalog.CatalogContentListingObject '
-            'instance at /plone/test-folder/mypage>')
+            'instance at /plone/test-folder/mypage>'
+        )
 
     def test_special_getattr_with_underscore(self):
         # looking up attributes starting with _ should always raise
@@ -72,15 +75,19 @@ def test_special_getattr_from_brain(self):
         # Asking for an attribute not in the contentlistingobject, should
         # defer lookup to the brain
         self.assertEqual(self.item.is_folderish, False)
-        self.assertTrue(repr(self.item.getDataOrigin())[:35],
-            '<Products.ZCatalog.Catalog.mybrains')
+        self.assertTrue(
+            repr(self.item.getDataOrigin())[:35],
+            '<Products.ZCatalog.Catalog.mybrains'
+        )
 
     def test_special_getattr_from_object(self):
         # Asking for an attribute not in the contentlistingobject, should
         # defer lookup to the brain"""
         self.assertEqual(self.item.absolute_url(), '')
-        self.assertEqual(repr(self.item.getDataOrigin()),
-            '<Document at /plone/test-folder/mypage>')
+        self.assertEqual(
+            repr(self.item.getDataOrigin()),
+            '<Document at /plone/test-folder/mypage>'
+        )
 
     def test_item_Title(self):
         self.assertEqual(self.item.Title(), 'My Page')
@@ -94,8 +101,10 @@ def test_item_Creator(self):
         self.assertEqual(self.item.Creator(), 'test_user_1_')
 
     def test_item_getURL(self):
-        self.assertEqual(self.item.getURL(),
-            'http://nohost/plone/test-folder/mypage')
+        self.assertEqual(
+            self.item.getURL(),
+            'http://nohost/plone/test-folder/mypage'
+        )
         self.assertEqual(self.item.getURL(), self.realitem.absolute_url())
 
     def test_item_getIcon(self):
@@ -104,7 +113,8 @@ def test_item_getIcon(self):
         self.folder.invokeFactory(
             'Image', 'myimage', title='My Image', description='blah')
         self.item = self.folder.restrictedTraverse('@@folderListing')()[1]
-        self.assertEqual(self.item.getIcon(),
+        self.assertEqual(
+            self.item.getIcon(),
             u'<img width="16" height="16" src="http://nohost/plone/png.png" '
             u'alt="Image" />')
 
@@ -152,12 +162,16 @@ def setUp(self):
         self.realitem = self.folder.mypage
 
     def test_printing_item(self):
-        self.assertEqual(repr(self.item),
+        self.assertEqual(
+            repr(self.item),
             '<plone.app.contentlisting.realobject.RealContentListingObject '
-            'instance at /plone/test-folder/mypage>')
-        self.assertEqual(str(self.item),
+            'instance at /plone/test-folder/mypage>'
+        )
+        self.assertEqual(
+            str(self.item),
             '<plone.app.contentlisting.realobject.RealContentListingObject '
-            'instance at /plone/test-folder/mypage>')
+            'instance at /plone/test-folder/mypage>'
+        )
 
     def test_special_getattr_with_underscore(self):
         # looking up attributes starting with _ should always raise
@@ -169,7 +183,7 @@ def test_special_getattr_from_object(self):
         # defer lookup to the brain
         self.assertEqual(self.item.absolute_url(), '')
         self.assertEqual(repr(self.item.getDataOrigin()),
-            '<Document at /plone/test-folder/mypage>')
+                         '<Document at /plone/test-folder/mypage>')
 
     def test_item_Title(self):
         self.assertEqual(self.item.Title(), 'My Page')
@@ -184,7 +198,7 @@ def test_item_Creator(self):
 
     def test_item_getURL(self):
         self.assertEqual(self.item.getURL(),
-            'http://nohost/plone/test-folder/mypage')
+                         'http://nohost/plone/test-folder/mypage')
         self.assertEqual(self.item.getURL(), self.realitem.absolute_url())
 
     def test_item_getIcon(self):
@@ -193,9 +207,11 @@ def test_item_getIcon(self):
         self.folder.invokeFactory(
             'Image', 'myimage', title='My Image', description='blah')
         self.item = IContentListingObject(self.folder.myimage)
-        self.assertEqual(self.item.getIcon(),
-            u'<img width="16" height="16" src="http://nohost/plone/error_icon.png" '
-            u'alt="My Image" />')
+        self.assertEqual(
+            self.item.getIcon(),
+            u'<img width="16" height="16" src="http://nohost/plone/error_icon.png" '  # noqa
+            u'alt="My Image" />'
+        )
 
     def test_item_reviewState(self):
         wftool = getToolByName(self.realitem, "portal_workflow")
diff --git a/setup.py b/setup.py
index b2f6d4a..3632c0d 100644
--- a/setup.py
+++ b/setup.py
@@ -1,45 +1,47 @@
 from setuptools import setup, find_packages
-
 import os
 
+
 def read(*rnames):
     return open(os.path.join(os.path.dirname(__file__), *rnames)).read()
 
 version = '1.1.2.dev0'
 
-long_description = \
-    read('docs', 'README.rst') + '\n\n' + \
-    read('CHANGES.txt')
+long_description = '{0}\n\n{1}'.format(
+    read('docs', 'README.rst'),
+    read('CHANGES.rst')
+)
 
-setup(name='plone.app.contentlisting',
-      version=version,
-      description="Listing of content for the Plone CMS",
-      long_description=long_description,
-      classifiers=[
+setup(
+    name='plone.app.contentlisting',
+    version=version,
+    description="Listing of content for the Plone CMS",
+    long_description=long_description,
+    classifiers=[
         "Framework :: Plone",
         "Programming Language :: Python",
-        ],
-      keywords='',
-      author='Plone Foundation',
-      author_email='plone-developers@lists.sourceforge.net',
-      url='http://pypi.python.org/pypi/plone.app.contentlisting',
-      license='GPL version 2',
-      packages=find_packages(exclude=['ez_setup']),
-      namespace_packages=['plone', 'plone.app'],
-      include_package_data=True,
-      zip_safe=False,
-      install_requires=[
-          'setuptools',
-          'plone.uuid',
-      ],
-      extras_require={
+    ],
+    keywords='',
+    author='Plone Foundation',
+    author_email='plone-developers@lists.sourceforge.net',
+    url='http://pypi.python.org/pypi/plone.app.contentlisting',
+    license='GPL version 2',
+    packages=find_packages(exclude=['ez_setup']),
+    namespace_packages=['plone', 'plone.app'],
+    include_package_data=True,
+    zip_safe=False,
+    install_requires=[
+        'setuptools',
+        'plone.uuid',
+    ],
+    extras_require={
         'test': [
             'plone.app.contenttypes',
             'plone.app.testing',
         ],
-      },
-      entry_points='''
-      [z3c.autoinclude.plugin]
-      target = plone
-      ''',
-      )
+    },
+    entry_points="""
+    [z3c.autoinclude.plugin]
+    target = plone
+    """,
+)


