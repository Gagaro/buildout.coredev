Repository: plone.directives.form
Branch: refs/heads/master
Date: 2015-05-04T16:29:58+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.directives.form/commit/f565a625a64e1bbee35de77a49a30b2cdf665927

txt to rst.

Move docs/HISTORY to CHANGES

Files changed:
A CHANGES.rst
A README.rst
M setup.py
D README.txt
D docs/HISTORY.txt

diff --git a/CHANGES.rst b/CHANGES.rst
new file mode 100644
index 0000000..2669d19
--- /dev/null
+++ b/CHANGES.rst
@@ -0,0 +1,117 @@
+Changelog
+=========
+
+2.0.1 (unreleased)
+------------------
+
+- Nothing changed yet.
+
+
+2.0 (2012-08-30)
+----------------
+
+* Update to work with grokcore.view >= 2.2. This generally means that this
+  package is no longer compatible with Plone < 4.3.
+  [davisagli]
+
+* Change i18n domain to plone.dexterity to reuse the translations. plone.dexterity
+  already has all the strings needed.
+  [gaudenz]
+
+* Fixes documentation mistake of documented ``form.wrapped()`` directive
+  which is in fact ``form.wrap()``
+  [romanofski]
+
+* A number of schema directives were moved to other packages and reimplemented
+  to not depend on grok.  The ``Schema`` class and the ``model``, ``fieldset``,
+  and ``primary`` directives were moved to ``plone.supermodel.model``. The
+  ``omitted``, ``no_omit``, ``mode``, ``widget``, ``order_before``,
+  ``order_after``, ``read_permission``, and ``write_permission`` directives were
+  moved to ``plone.autoform.directives``.
+
+  For now the directives are still available under their old names in this
+  package, but they are deprecated and may be removed at some point.
+
+  Some minor related changes:
+
+  * Tagged values are now stored on schemas as soon as they are defined, rather
+    than when the schemas are grokked. Additional actions required by the
+    directives, if any, are performed at the end of ZCML configuration.
+  * Due to a bug in zope.interface, ``plone.supermodel.model.Schema`` must be
+    the `first` base class of any schema to which the directives should apply.
+    Also, unfortunately it is no longer possible to give an error if the schema
+    directives are called on an interface that is not a ``Schema``.
+
+  [davisagli]
+
+1.0 - 2011-05-20
+----------------
+
+* No changes.
+
+1.0b7 - 2010-04-20
+------------------
+
+* Allow arbitrary extra parameters for the fieldset directive. This is useful
+  for extensions that want to tweak fieldset behaviour or rendering.
+  [wichert]
+
+* Add ``no_omit`` directive, so that fields that have been omitted can be
+  re-included again on for a more specific form interface.
+  [davisagli]
+
+* Accept a form interface as an optional positional argument for the ``mode``
+  and ``omitted`` directives, and store it in the tagged values using the new
+  format expected by plone.autoform.
+  [davisagli]
+
+* Add ``@form.error_message()`` decorator for registering custom error
+  messages for errors and/or fields.
+  [optilude]
+
+* Add ``@form.validator()`` decorator to register a simple field validator.
+  See README.txt for details.
+  [optilude]
+
+* Support unwrapped forms (in Zope 2.12). The default is to wrap in Zope <
+  2.12, and not to wrap in Zope >= 2.12. A new ``form.wrapped()`` directive
+  can be used to force wrapping or non-wrapping (by passing ``False`` as an
+  argument).
+  [optilude]
+
+* Warn more forcefully when using form directives on interfaces not deriving
+  from ``Schema``, or using schema hints that refer to field names that cannot
+  be found.
+  [optilude]
+
+1.0b6 - 2009-10-08
+------------------
+
+* Add support for the ``primary()`` directive, which is used to set the
+  primary field for marshalling. See the ``plone.rfc822`` for details.
+  [optilude]
+
+1.0b5 - 2009-07-21
+------------------
+
+* Updated to new five.grok release.
+  [optilude]
+
+1.0b3 - 2009-07-12
+------------------
+
+* Made adjustments for changes in plone.supermodel's API.
+  [optilude]
+
+1.0b2 - 2009-06-15
+------------------
+
+* Make sure that we don't lose the function when using the
+  @form.default_value() decorator and the other value decorators.
+  [optilude]
+
+1.0b1 - 2009-04-17
+------------------
+
+* Initial release
+
diff --git a/README.rst b/README.rst
new file mode 100644
index 0000000..b1e47d1
--- /dev/null
+++ b/README.rst
@@ -0,0 +1,437 @@
+=====================
+plone.directives.form
+=====================
+
+This package provides optional, Grok-like directives for configuring
+forms, as defined by the `z3c.form`_ library, using XML schemata as defined by
+`plone.supermodel`_ and/or using widget form layout as defined by
+`plone.autoform`_. It depends on `five.grok`_, which in turn depends on the
+various re-usable grokcore.* packages, but not Grok itself.
+
+.. contents:: Contents
+
+Installation
+------------
+
+To use this package you must first install it, either by depending on it
+in your own ``setup.py`` (under the ``install_requires`` list), or by adding
+it directly to your buildout.
+
+This will pull in a number of dependencies. You probably want to pin those
+down to known-good versions by using a known-good version set. See the
+installation instructions of `five.grok`_ for a starting point.
+
+You must also load the relevant configuration from ``meta.zcml`` and
+``configure.zcml``. For example, you could use statements like the following
+in your ``configure.zcml``::
+
+    <include package="plone.directives.form" file="meta.zcml" />
+    <include package="plone.directives.form" />
+
+or if you declare dependencies in setup.py using install_requires::
+
+    <includeDependencies package="." />
+
+Schemata loaded from XML
+------------------------
+
+``plone.directives.form`` used to contain a directive for loading an XML-based
+schema model into a Python interface.  This directive has moved to ``plone.supermodel``, as ``plone.supermodel.model.load``.
+
+Form widget hints
+-----------------
+
+``plone.directives.form`` used to contain a number of directives for generating
+a form from a schema, using hints stored in tagged values on that schema to
+control the form's layout and field widgets. These directives have now moved
+to other packages to avoid a dependency of Dexterity on grok.
+
+The ``fieldset`` and ``primary`` directives are now in
+``plone.supermodel.model``.
+
+The ``omitted``, ``no_omit``, ``mode``, ``widget``, ``order_before``,
+``order_after``, ``read_permission``, and ``write_permission`` directives are
+now in ``plone.autoform.directives``.
+
+Value adapters
+--------------
+
+z3c.form has the concept of a "value adapter", a component that can provide
+a value for an attribute (usually of widgets and buttons) at runtime. This
+package comes with some helpful decorators to register value adapters for
+computed values. For example::
+
+    from plone.directives import form
+    from zope import schema
+
+    class IMySchema(form.Schema):
+
+        title = schema.TextLine(title=u"Title")
+
+    @form.default_value(field=IMySchema['title'])
+    def default_title(data):
+        return data.context.suggested_title
+
+The decorator takes one or more discriminators. The available discriminators
+for ``default_value`` are:
+
+context
+  The type of context (e.g. an interface)
+
+request
+  The type of request (e.g. a layer marker interface). You can
+  use 'layer' as an alias for 'request', but note that the data passed
+  to the function will have a 'request' attribute only.
+
+view
+    The type of form (e.g. a form instance or interface). You can
+    use 'form' as an alias for 'view', but note that the data passed to
+    the function will have 'view' attribute only.
+
+field
+    The field instance (or a field interface).
+
+widget
+    The widget type (e.g. an interface).
+
+You must specify either ``field`` or ``widget``. The object passed to the
+decorated function has an attribute for each discriminator.
+
+There are two more decorators:
+
+widget_label
+  Provide a dynamic label for a widget. Takes the same discriminators as the
+  ``default_value`` decorator.
+
+button_label -- Provide a dynamic label for a button. Takes parameters
+  content (alias context), request (alias layer), form (alias view),
+  manager and button.
+
+Please note the rather unfortunate differences in naming between the button
+descriptors (content vs. context, form vs. view) and the widget ones. The
+descriptor will accept the same names, but the data object passed to the
+function will only contain the names as defined in z3c.form, so be careful.
+
+Validators
+----------
+
+By default, z3c.form uses fields' native validation, as implemented by the
+``IField.validate()`` method, as well as field constraints (functions passed
+as the ``constraint`` parameter to fields) and schema invariants (using the
+``@zope.interface.invariant`` decorator in a schema interface). In addition,
+you can define your own widget validators (for an individual field of the
+form) and widget manager validators (which cover the entire form). This is
+useful if you do not want to define a validator on the schema, e.g. because
+the schema is also used elsewhere, or if you want to create a more generic
+validator that is applied to any fields that match its discriminators.
+
+This package provides a grokked decorator which you can use to define a simple
+widget validator, called ``@form.validator()``::
+
+    from plone.directives import form
+    from zope import schema
+
+    class IMySchema(form.Schema):
+
+        title = schema.TextLine(title=u"Title")
+
+    @form.validator(field=IMySchema['title'])
+    def validateTitle(value):
+        if value == value.upper():
+            raise schema.ValidationError(u"Please don't shout")
+
+The validator should return nothing if the field is valid, or raise an
+``zope.schema.ValidationError`` exception with an error message.
+
+The ``@form.validator()`` decorator can take various keyword arguments that
+determine when the validator is invoked. These are:
+
+context
+  The type of context (e.g. an interface)
+
+request
+  The type of request (e.g. a layer marker interface).
+
+view
+    The type of form (e.g. a form instance or interface).
+
+field
+    The field instance (or a field interface).
+
+widget
+    The widget type (e.g. an interface).
+
+Note that this validator function does not give access to the full context
+of the standard validator, such as the field, widget, context or request.
+If you need that, you can create a standard validator adapter, e.g. using
+``grok.Adapter``. See the `z3c.form`_ documentation for details.
+
+Also note that the standard field validator will be called before the custom
+validator is invoked. If you need to override the validator wholesale, you
+can again do so with a custom adapter.
+
+Error messages
+--------------
+
+When using custom validators, it is easy to supply a tailored error message.
+However, the error messages that arise from the default field validation
+mechanism (e.g. when a required field is omitted) are by necessity more
+generic. Sometimes, it may be necessary to override these messages to make
+them more user friendly.
+
+To customise an error message, you can use the ``@form.error_message`` grokked
+decorator. For example::
+
+    from plone.directives import form
+    from zope import schema
+
+    from zope.schema.interfaces import TooShort
+
+    class IMySchema(form.Schema):
+
+        title = schema.TextLine(title=u"Title", min_length=2)
+
+    @form.error_message(error=TooShort, field=IMySchema['title'])
+    def titleTooShort(value):
+        return u"The title '%s' is too short" % value
+
+The decorated function will be called when constructing an error message for
+the given field. It should return a unicode string or translatable message.
+The value passed is the value that failed validation.
+
+The ``@form.error_message`` validator takes keyword arguments that determine
+when the message is used. It is possible to register a generic error message
+for a given type of error that applies to all fields, or, as shown above,
+a message specific to an individual field and error. The latter is more
+common. In general, you should be careful if you omit either or both of the
+``error`` and ``field`` discriminators.
+
+error
+    An exception class that represents the error. All errors inherit from
+    ``zope.interface.Invalid``, and most error also inherit from
+    ``zope.schema.interfaces.ValidationError``. See below for a list of
+    common exception types.
+request
+    The current request. Use this to tie the error to a specific browser
+    layer interface.
+widget
+    The widget that was used. May be either a widget interface or a specific
+    widget class.
+field
+    The field that was used, normally given as a field instance obtained from
+    an interface, as illustrated above.
+form
+    The current form, either as a class or an interface. This is useful if
+    the same interface is used in more than one form, but you only want the
+    error to be shown in one form.
+content
+    The content item that is acting as the context for the form. May be given
+    as either an interface or a class.
+
+None of these parameters is required, but you would normally supply at least
+``error``. In most cases, you should also supply the ``field``, as shown
+above.
+
+The most common validation error exception types are defined in
+``zope.schema``, and can be imported from ``zope.schema.interfaces``:
+
+* ``RequiredMissing``, used when a required field is submitted without a value
+* ``WrongType``, used when a field is passed a value of an invalid type
+* ``TooBig`` and ``TooSmall``, used when a value is outside the ``min`` and/or
+  ``max`` range specified for ordered fields (e.g. numeric or date fields)
+* ``TooLong`` and ``TooShort``, used when a value is outside the
+  ``min_length`` and/or ``max_length`` range specified for length-aware fields
+  (e.g. text or sequence fields)
+* ``InvalidValue``, used when a value is invalid, e.g. a non-ASCII character
+  passed to an ASCII field
+* ``ConstraintNotSatisfied``, used when a ``constraint`` method returns
+  ``False``
+* ``WrongContainedType``, used if an object of an invalid type is added
+  to a sequence (i.e. the type does not conform to the field's
+  ``value_type``)
+* ``NotUnique``, used if a uniqueness constraint is violated
+* ``InvalidURI``, used for ``URI`` fields if the value is not a valid URI
+* ``InvalidId``, used for ``Id`` fields if the value is not a valid id
+* ``InvalidDottedName``, used for ``DottedName`` fields if the value is not
+  a valid dotted name
+
+Form base classes
+-----------------
+
+If you need to create your own forms, this package provides a number of
+convenient base classes that will be grokked much like a ``grok.View``.
+
+In Zope 2.10, the grokkers take care of wrapping the form in a
+`plone.z3cform`_ FormWrapper as well. In Zope 2.12 and later, there is no
+wrapper by default. If you want one (e.g. if you are using a custom template
+and you need it to work in both Zope 2.10 and 2.12), you can use the
+``form.wrap()`` directive in the form class.
+
+The base classes can all be imported from ``plone.directives.form``, e.g::
+
+    from five import grok
+    from plone.directives import form, button
+    from z3c.form import field
+
+    class MyForm(form.Form):
+        grok.context(ISomeContext)
+        grok.require('zope2.View')
+
+        fields = field.Fields(IMyFormSchema)
+
+        @button.buttonAndHandler(u'Submit')
+        def handleApply(self, action):
+            data, errors = self.extractData()
+            ...
+
+The allowed directives are:
+
+* ``grok.context()``, to specify the context of form view. If not given, the
+  grokker will look for a module-level context, much like the standard
+  ``grok.View``.
+* ``grok.require()``, to specify a permission. The default is ``zope2.View``
+  for standard forms, ``cmf.ModifyPortalContent`` for edit forms, and
+  ``cmf.AddPortalContent`` for add forms.
+* ``grok.layer()`` to specify a browser layer
+* ``grok.name()`` to set a different name. By default your form will be
+  available as view @@yourformclassnamelowercase, but you can use
+  ``grok.name()`` to set name explicitly.
+* ``form.wrap()`` to wrap the form in a layout wrapper view. You can pass
+  an argument of ``True`` or ``False`` to enable or disable wrapping. If no
+  argument is given, it defaults to ``True``. If omitted, the global default
+  is used, which is to wrap in Zope 2.11 or earlier, and to not wrap in Zope
+  2.12 or later
+
+More complex example how to use Grok directives with a form::
+
+        from plone.directives import form
+        from Products.CMFCore.interfaces import ISiteRoot
+
+        class CompanyCreationForm(form.SchemaForm):
+            """ A sample form how to "create companies".
+
+            """
+
+            # Which plone.directives.form.Schema subclass is used to define
+            # fields for this form (not shown on this example)
+            schema = ICompanyCreationFormSchema
+
+            # Permission required to view/submit the form
+            grok.require("cmf.ManagePortal")
+
+            # The form does not care about the context object
+            # and  should not try to extract field value
+            # defaults out of it
+            ignoreContext = True
+
+            # This form is available at the site root only
+            grok.context(ISiteRoot)
+
+            # The form will be available in Plone site root only
+            # Use http://yourhost/@@create_company URL to access this form
+            grok.name("create_company")
+
+
+
+
+Each of the form base classes has a "schema" equivalent, which can be
+initialised with a ``schema`` attribute instead of the ``fields`` attribute.
+These forms use `plone.autoform`_'s ``AutoExtensibleForm`` as a base class,
+allowing schema hints as shown above to be processed::
+
+    from plone.directives import form
+    from z3c.form import field
+
+    class MyForm(form.SchemaForm):
+        grok.context(ISomeContext)
+        grok.require('zope2.View')
+
+        schema = IMySchema
+
+        @button.buttonAndHandler(u'Submit')
+        def handleApply(self, action):
+            data, errors = self.extractData()
+            ...
+
+Note that the ``schema`` can be omitted if you are using ``SchemaForm`` or
+``SchemaEditForm`` and you have given an interface as the argument to
+``grok.context()``. In this case, the context interface will be used as the
+default schema.
+
+The available form base classes are:
+
+Form
+    A simple page form, basically a grokked version of ``z3c.form.form.Form``.
+
+SchemaForm
+    A page form that uses `plone.autoform`_. You must set the ``schema`` class
+    variable (or implement it as a property) to a schema interface form which
+    the form will be built. Form widget hints will be taken into account.
+
+AddForm
+    A simple add form with "Add" and "Cancel" buttons. You must implement
+    the ``create()`` and ``add()`` methods. See the `z3c.form`_ documentation
+    for more details.
+
+SchemaAddForm
+    An add form using `plone.autoform`_. Again, you must set the ``schema``
+    class variable.
+
+EditForm
+    A simple edit form with "Save" and "Cancel" buttons. See the `z3c.form`_
+    documentation for more details.
+
+SchemaEditForm
+    An edit form using `plone.autoform`_. Again, you must set the ``schema``
+    class variable.
+
+DisplayForm
+    A view with an automatically associated template (like ``grok.View``),
+    that is initialised with display widgets. See `plone.autoform`_'s
+    ``WidgetsView`` for more details.
+
+All of the grokked form base classes above support associating a custom
+template with the form. This uses the same semantics as ``grok.View``. See
+`grokcore.view`_ for details, but briefly:
+
+* If you want to completely customise rendering, you can override the
+  ``render()`` method.
+* If you want to use a page template to render a form called ``MyForm`` in
+  the module ``my.package.forms``, create a directory inside ``my.package``
+  called ``forms_templates`` (the prefix should match the module name),
+  and place a file there called ``myform.pt``.
+* If you do neither, the default form template will be used, as is the
+  standard behaviour in z3c.form.
+
+Note that the automatically associated form template can use ``grok.View``
+methods, such as ``view.url()`` and ``view.redirect()``, which are defined
+in the grokked form base classes.
+
+Also note that you can use the view ``@@ploneform-macros`` from
+`plone.app.z3cform`_ if you want to use some of the standard form markup.
+For example, the ``titlelessform`` macro will render the ``<form >`` element
+and all fieldsets and fields::
+
+    <metal:block use-macro="context/@@ploneform-macros/titlelessform" />
+
+Troubleshooting
+---------------
+
+Forms are not found
+=====================
+
+When you try to access your form on the site, you'll get page not found (NotFound exception).
+
+* Make sure that you typed your form name correctly and it matches ``grok.name()``
+  or lowercased class name
+
+* Make sure you have <include package="plone.directives.form" file="meta.zcml" />
+  or similar in configure.zcml of your add-on product
+
+.. _five.grok: http://pypi.python.org/pypi/five.grok
+.. _z3c.form: http://pypi.python.org/pypi/z3c.form
+.. _plone.z3cform: http://pypi.python.org/pypi/plone.z3cform
+.. _plone.app.z3cform: http://pypi.python.org/pypi/plone.app.z3cform
+.. _plone.supermodel: http://pypi.python.org/pypi/plone.supermodel
+.. _plone.autoform: http://pypi.python.org/pypi/plone.autoform
+.. _grokcore.view: http://pypi.python.org/pypi/grokcore.view
diff --git a/README.txt b/README.txt
deleted file mode 100644
index b1e47d1..0000000
--- a/README.txt
+++ /dev/null
@@ -1,437 +0,0 @@
-=====================
-plone.directives.form
-=====================
-
-This package provides optional, Grok-like directives for configuring
-forms, as defined by the `z3c.form`_ library, using XML schemata as defined by
-`plone.supermodel`_ and/or using widget form layout as defined by
-`plone.autoform`_. It depends on `five.grok`_, which in turn depends on the
-various re-usable grokcore.* packages, but not Grok itself.
-
-.. contents:: Contents
-
-Installation
-------------
-
-To use this package you must first install it, either by depending on it
-in your own ``setup.py`` (under the ``install_requires`` list), or by adding
-it directly to your buildout.
-
-This will pull in a number of dependencies. You probably want to pin those
-down to known-good versions by using a known-good version set. See the
-installation instructions of `five.grok`_ for a starting point.
-
-You must also load the relevant configuration from ``meta.zcml`` and
-``configure.zcml``. For example, you could use statements like the following
-in your ``configure.zcml``::
-
-    <include package="plone.directives.form" file="meta.zcml" />
-    <include package="plone.directives.form" />
-
-or if you declare dependencies in setup.py using install_requires::
-
-    <includeDependencies package="." />
-
-Schemata loaded from XML
-------------------------
-
-``plone.directives.form`` used to contain a directive for loading an XML-based
-schema model into a Python interface.  This directive has moved to ``plone.supermodel``, as ``plone.supermodel.model.load``.
-
-Form widget hints
------------------
-
-``plone.directives.form`` used to contain a number of directives for generating
-a form from a schema, using hints stored in tagged values on that schema to
-control the form's layout and field widgets. These directives have now moved
-to other packages to avoid a dependency of Dexterity on grok.
-
-The ``fieldset`` and ``primary`` directives are now in
-``plone.supermodel.model``.
-
-The ``omitted``, ``no_omit``, ``mode``, ``widget``, ``order_before``,
-``order_after``, ``read_permission``, and ``write_permission`` directives are
-now in ``plone.autoform.directives``.
-
-Value adapters
---------------
-
-z3c.form has the concept of a "value adapter", a component that can provide
-a value for an attribute (usually of widgets and buttons) at runtime. This
-package comes with some helpful decorators to register value adapters for
-computed values. For example::
-
-    from plone.directives import form
-    from zope import schema
-
-    class IMySchema(form.Schema):
-
-        title = schema.TextLine(title=u"Title")
-
-    @form.default_value(field=IMySchema['title'])
-    def default_title(data):
-        return data.context.suggested_title
-
-The decorator takes one or more discriminators. The available discriminators
-for ``default_value`` are:
-
-context
-  The type of context (e.g. an interface)
-
-request
-  The type of request (e.g. a layer marker interface). You can
-  use 'layer' as an alias for 'request', but note that the data passed
-  to the function will have a 'request' attribute only.
-
-view
-    The type of form (e.g. a form instance or interface). You can
-    use 'form' as an alias for 'view', but note that the data passed to
-    the function will have 'view' attribute only.
-
-field
-    The field instance (or a field interface).
-
-widget
-    The widget type (e.g. an interface).
-
-You must specify either ``field`` or ``widget``. The object passed to the
-decorated function has an attribute for each discriminator.
-
-There are two more decorators:
-
-widget_label
-  Provide a dynamic label for a widget. Takes the same discriminators as the
-  ``default_value`` decorator.
-
-button_label -- Provide a dynamic label for a button. Takes parameters
-  content (alias context), request (alias layer), form (alias view),
-  manager and button.
-
-Please note the rather unfortunate differences in naming between the button
-descriptors (content vs. context, form vs. view) and the widget ones. The
-descriptor will accept the same names, but the data object passed to the
-function will only contain the names as defined in z3c.form, so be careful.
-
-Validators
-----------
-
-By default, z3c.form uses fields' native validation, as implemented by the
-``IField.validate()`` method, as well as field constraints (functions passed
-as the ``constraint`` parameter to fields) and schema invariants (using the
-``@zope.interface.invariant`` decorator in a schema interface). In addition,
-you can define your own widget validators (for an individual field of the
-form) and widget manager validators (which cover the entire form). This is
-useful if you do not want to define a validator on the schema, e.g. because
-the schema is also used elsewhere, or if you want to create a more generic
-validator that is applied to any fields that match its discriminators.
-
-This package provides a grokked decorator which you can use to define a simple
-widget validator, called ``@form.validator()``::
-
-    from plone.directives import form
-    from zope import schema
-
-    class IMySchema(form.Schema):
-
-        title = schema.TextLine(title=u"Title")
-
-    @form.validator(field=IMySchema['title'])
-    def validateTitle(value):
-        if value == value.upper():
-            raise schema.ValidationError(u"Please don't shout")
-
-The validator should return nothing if the field is valid, or raise an
-``zope.schema.ValidationError`` exception with an error message.
-
-The ``@form.validator()`` decorator can take various keyword arguments that
-determine when the validator is invoked. These are:
-
-context
-  The type of context (e.g. an interface)
-
-request
-  The type of request (e.g. a layer marker interface).
-
-view
-    The type of form (e.g. a form instance or interface).
-
-field
-    The field instance (or a field interface).
-
-widget
-    The widget type (e.g. an interface).
-
-Note that this validator function does not give access to the full context
-of the standard validator, such as the field, widget, context or request.
-If you need that, you can create a standard validator adapter, e.g. using
-``grok.Adapter``. See the `z3c.form`_ documentation for details.
-
-Also note that the standard field validator will be called before the custom
-validator is invoked. If you need to override the validator wholesale, you
-can again do so with a custom adapter.
-
-Error messages
---------------
-
-When using custom validators, it is easy to supply a tailored error message.
-However, the error messages that arise from the default field validation
-mechanism (e.g. when a required field is omitted) are by necessity more
-generic. Sometimes, it may be necessary to override these messages to make
-them more user friendly.
-
-To customise an error message, you can use the ``@form.error_message`` grokked
-decorator. For example::
-
-    from plone.directives import form
-    from zope import schema
-
-    from zope.schema.interfaces import TooShort
-
-    class IMySchema(form.Schema):
-
-        title = schema.TextLine(title=u"Title", min_length=2)
-
-    @form.error_message(error=TooShort, field=IMySchema['title'])
-    def titleTooShort(value):
-        return u"The title '%s' is too short" % value
-
-The decorated function will be called when constructing an error message for
-the given field. It should return a unicode string or translatable message.
-The value passed is the value that failed validation.
-
-The ``@form.error_message`` validator takes keyword arguments that determine
-when the message is used. It is possible to register a generic error message
-for a given type of error that applies to all fields, or, as shown above,
-a message specific to an individual field and error. The latter is more
-common. In general, you should be careful if you omit either or both of the
-``error`` and ``field`` discriminators.
-
-error
-    An exception class that represents the error. All errors inherit from
-    ``zope.interface.Invalid``, and most error also inherit from
-    ``zope.schema.interfaces.ValidationError``. See below for a list of
-    common exception types.
-request
-    The current request. Use this to tie the error to a specific browser
-    layer interface.
-widget
-    The widget that was used. May be either a widget interface or a specific
-    widget class.
-field
-    The field that was used, normally given as a field instance obtained from
-    an interface, as illustrated above.
-form
-    The current form, either as a class or an interface. This is useful if
-    the same interface is used in more than one form, but you only want the
-    error to be shown in one form.
-content
-    The content item that is acting as the context for the form. May be given
-    as either an interface or a class.
-
-None of these parameters is required, but you would normally supply at least
-``error``. In most cases, you should also supply the ``field``, as shown
-above.
-
-The most common validation error exception types are defined in
-``zope.schema``, and can be imported from ``zope.schema.interfaces``:
-
-* ``RequiredMissing``, used when a required field is submitted without a value
-* ``WrongType``, used when a field is passed a value of an invalid type
-* ``TooBig`` and ``TooSmall``, used when a value is outside the ``min`` and/or
-  ``max`` range specified for ordered fields (e.g. numeric or date fields)
-* ``TooLong`` and ``TooShort``, used when a value is outside the
-  ``min_length`` and/or ``max_length`` range specified for length-aware fields
-  (e.g. text or sequence fields)
-* ``InvalidValue``, used when a value is invalid, e.g. a non-ASCII character
-  passed to an ASCII field
-* ``ConstraintNotSatisfied``, used when a ``constraint`` method returns
-  ``False``
-* ``WrongContainedType``, used if an object of an invalid type is added
-  to a sequence (i.e. the type does not conform to the field's
-  ``value_type``)
-* ``NotUnique``, used if a uniqueness constraint is violated
-* ``InvalidURI``, used for ``URI`` fields if the value is not a valid URI
-* ``InvalidId``, used for ``Id`` fields if the value is not a valid id
-* ``InvalidDottedName``, used for ``DottedName`` fields if the value is not
-  a valid dotted name
-
-Form base classes
------------------
-
-If you need to create your own forms, this package provides a number of
-convenient base classes that will be grokked much like a ``grok.View``.
-
-In Zope 2.10, the grokkers take care of wrapping the form in a
-`plone.z3cform`_ FormWrapper as well. In Zope 2.12 and later, there is no
-wrapper by default. If you want one (e.g. if you are using a custom template
-and you need it to work in both Zope 2.10 and 2.12), you can use the
-``form.wrap()`` directive in the form class.
-
-The base classes can all be imported from ``plone.directives.form``, e.g::
-
-    from five import grok
-    from plone.directives import form, button
-    from z3c.form import field
-
-    class MyForm(form.Form):
-        grok.context(ISomeContext)
-        grok.require('zope2.View')
-
-        fields = field.Fields(IMyFormSchema)
-
-        @button.buttonAndHandler(u'Submit')
-        def handleApply(self, action):
-            data, errors = self.extractData()
-            ...
-
-The allowed directives are:
-
-* ``grok.context()``, to specify the context of form view. If not given, the
-  grokker will look for a module-level context, much like the standard
-  ``grok.View``.
-* ``grok.require()``, to specify a permission. The default is ``zope2.View``
-  for standard forms, ``cmf.ModifyPortalContent`` for edit forms, and
-  ``cmf.AddPortalContent`` for add forms.
-* ``grok.layer()`` to specify a browser layer
-* ``grok.name()`` to set a different name. By default your form will be
-  available as view @@yourformclassnamelowercase, but you can use
-  ``grok.name()`` to set name explicitly.
-* ``form.wrap()`` to wrap the form in a layout wrapper view. You can pass
-  an argument of ``True`` or ``False`` to enable or disable wrapping. If no
-  argument is given, it defaults to ``True``. If omitted, the global default
-  is used, which is to wrap in Zope 2.11 or earlier, and to not wrap in Zope
-  2.12 or later
-
-More complex example how to use Grok directives with a form::
-
-        from plone.directives import form
-        from Products.CMFCore.interfaces import ISiteRoot
-
-        class CompanyCreationForm(form.SchemaForm):
-            """ A sample form how to "create companies".
-
-            """
-
-            # Which plone.directives.form.Schema subclass is used to define
-            # fields for this form (not shown on this example)
-            schema = ICompanyCreationFormSchema
-
-            # Permission required to view/submit the form
-            grok.require("cmf.ManagePortal")
-
-            # The form does not care about the context object
-            # and  should not try to extract field value
-            # defaults out of it
-            ignoreContext = True
-
-            # This form is available at the site root only
-            grok.context(ISiteRoot)
-
-            # The form will be available in Plone site root only
-            # Use http://yourhost/@@create_company URL to access this form
-            grok.name("create_company")
-
-
-
-
-Each of the form base classes has a "schema" equivalent, which can be
-initialised with a ``schema`` attribute instead of the ``fields`` attribute.
-These forms use `plone.autoform`_'s ``AutoExtensibleForm`` as a base class,
-allowing schema hints as shown above to be processed::
-
-    from plone.directives import form
-    from z3c.form import field
-
-    class MyForm(form.SchemaForm):
-        grok.context(ISomeContext)
-        grok.require('zope2.View')
-
-        schema = IMySchema
-
-        @button.buttonAndHandler(u'Submit')
-        def handleApply(self, action):
-            data, errors = self.extractData()
-            ...
-
-Note that the ``schema`` can be omitted if you are using ``SchemaForm`` or
-``SchemaEditForm`` and you have given an interface as the argument to
-``grok.context()``. In this case, the context interface will be used as the
-default schema.
-
-The available form base classes are:
-
-Form
-    A simple page form, basically a grokked version of ``z3c.form.form.Form``.
-
-SchemaForm
-    A page form that uses `plone.autoform`_. You must set the ``schema`` class
-    variable (or implement it as a property) to a schema interface form which
-    the form will be built. Form widget hints will be taken into account.
-
-AddForm
-    A simple add form with "Add" and "Cancel" buttons. You must implement
-    the ``create()`` and ``add()`` methods. See the `z3c.form`_ documentation
-    for more details.
-
-SchemaAddForm
-    An add form using `plone.autoform`_. Again, you must set the ``schema``
-    class variable.
-
-EditForm
-    A simple edit form with "Save" and "Cancel" buttons. See the `z3c.form`_
-    documentation for more details.
-
-SchemaEditForm
-    An edit form using `plone.autoform`_. Again, you must set the ``schema``
-    class variable.
-
-DisplayForm
-    A view with an automatically associated template (like ``grok.View``),
-    that is initialised with display widgets. See `plone.autoform`_'s
-    ``WidgetsView`` for more details.
-
-All of the grokked form base classes above support associating a custom
-template with the form. This uses the same semantics as ``grok.View``. See
-`grokcore.view`_ for details, but briefly:
-
-* If you want to completely customise rendering, you can override the
-  ``render()`` method.
-* If you want to use a page template to render a form called ``MyForm`` in
-  the module ``my.package.forms``, create a directory inside ``my.package``
-  called ``forms_templates`` (the prefix should match the module name),
-  and place a file there called ``myform.pt``.
-* If you do neither, the default form template will be used, as is the
-  standard behaviour in z3c.form.
-
-Note that the automatically associated form template can use ``grok.View``
-methods, such as ``view.url()`` and ``view.redirect()``, which are defined
-in the grokked form base classes.
-
-Also note that you can use the view ``@@ploneform-macros`` from
-`plone.app.z3cform`_ if you want to use some of the standard form markup.
-For example, the ``titlelessform`` macro will render the ``<form >`` element
-and all fieldsets and fields::
-
-    <metal:block use-macro="context/@@ploneform-macros/titlelessform" />
-
-Troubleshooting
----------------
-
-Forms are not found
-=====================
-
-When you try to access your form on the site, you'll get page not found (NotFound exception).
-
-* Make sure that you typed your form name correctly and it matches ``grok.name()``
-  or lowercased class name
-
-* Make sure you have <include package="plone.directives.form" file="meta.zcml" />
-  or similar in configure.zcml of your add-on product
-
-.. _five.grok: http://pypi.python.org/pypi/five.grok
-.. _z3c.form: http://pypi.python.org/pypi/z3c.form
-.. _plone.z3cform: http://pypi.python.org/pypi/plone.z3cform
-.. _plone.app.z3cform: http://pypi.python.org/pypi/plone.app.z3cform
-.. _plone.supermodel: http://pypi.python.org/pypi/plone.supermodel
-.. _plone.autoform: http://pypi.python.org/pypi/plone.autoform
-.. _grokcore.view: http://pypi.python.org/pypi/grokcore.view
diff --git a/docs/HISTORY.txt b/docs/HISTORY.txt
deleted file mode 100644
index 2669d19..0000000
--- a/docs/HISTORY.txt
+++ /dev/null
@@ -1,117 +0,0 @@
-Changelog
-=========
-
-2.0.1 (unreleased)
-------------------
-
-- Nothing changed yet.
-
-
-2.0 (2012-08-30)
-----------------
-
-* Update to work with grokcore.view >= 2.2. This generally means that this
-  package is no longer compatible with Plone < 4.3.
-  [davisagli]
-
-* Change i18n domain to plone.dexterity to reuse the translations. plone.dexterity
-  already has all the strings needed.
-  [gaudenz]
-
-* Fixes documentation mistake of documented ``form.wrapped()`` directive
-  which is in fact ``form.wrap()``
-  [romanofski]
-
-* A number of schema directives were moved to other packages and reimplemented
-  to not depend on grok.  The ``Schema`` class and the ``model``, ``fieldset``,
-  and ``primary`` directives were moved to ``plone.supermodel.model``. The
-  ``omitted``, ``no_omit``, ``mode``, ``widget``, ``order_before``,
-  ``order_after``, ``read_permission``, and ``write_permission`` directives were
-  moved to ``plone.autoform.directives``.
-
-  For now the directives are still available under their old names in this
-  package, but they are deprecated and may be removed at some point.
-
-  Some minor related changes:
-
-  * Tagged values are now stored on schemas as soon as they are defined, rather
-    than when the schemas are grokked. Additional actions required by the
-    directives, if any, are performed at the end of ZCML configuration.
-  * Due to a bug in zope.interface, ``plone.supermodel.model.Schema`` must be
-    the `first` base class of any schema to which the directives should apply.
-    Also, unfortunately it is no longer possible to give an error if the schema
-    directives are called on an interface that is not a ``Schema``.
-
-  [davisagli]
-
-1.0 - 2011-05-20
-----------------
-
-* No changes.
-
-1.0b7 - 2010-04-20
-------------------
-
-* Allow arbitrary extra parameters for the fieldset directive. This is useful
-  for extensions that want to tweak fieldset behaviour or rendering.
-  [wichert]
-
-* Add ``no_omit`` directive, so that fields that have been omitted can be
-  re-included again on for a more specific form interface.
-  [davisagli]
-
-* Accept a form interface as an optional positional argument for the ``mode``
-  and ``omitted`` directives, and store it in the tagged values using the new
-  format expected by plone.autoform.
-  [davisagli]
-
-* Add ``@form.error_message()`` decorator for registering custom error
-  messages for errors and/or fields.
-  [optilude]
-
-* Add ``@form.validator()`` decorator to register a simple field validator.
-  See README.txt for details.
-  [optilude]
-
-* Support unwrapped forms (in Zope 2.12). The default is to wrap in Zope <
-  2.12, and not to wrap in Zope >= 2.12. A new ``form.wrapped()`` directive
-  can be used to force wrapping or non-wrapping (by passing ``False`` as an
-  argument).
-  [optilude]
-
-* Warn more forcefully when using form directives on interfaces not deriving
-  from ``Schema``, or using schema hints that refer to field names that cannot
-  be found.
-  [optilude]
-
-1.0b6 - 2009-10-08
-------------------
-
-* Add support for the ``primary()`` directive, which is used to set the
-  primary field for marshalling. See the ``plone.rfc822`` for details.
-  [optilude]
-
-1.0b5 - 2009-07-21
-------------------
-
-* Updated to new five.grok release.
-  [optilude]
-
-1.0b3 - 2009-07-12
-------------------
-
-* Made adjustments for changes in plone.supermodel's API.
-  [optilude]
-
-1.0b2 - 2009-06-15
-------------------
-
-* Make sure that we don't lose the function when using the
-  @form.default_value() decorator and the other value decorators.
-  [optilude]
-
-1.0b1 - 2009-04-17
-------------------
-
-* Initial release
-
diff --git a/setup.py b/setup.py
index bd8b3c7..ecf21a0 100644
--- a/setup.py
+++ b/setup.py
@@ -1,5 +1,4 @@
 from setuptools import setup, find_packages
-import os
 
 version = '2.0.1.dev0'
 
@@ -9,8 +8,8 @@
 setup(name='plone.directives.form',
       version=version,
       description="Grok-like directives configuring forms",
-      long_description=open("README.txt").read() + "\n" +
-                       open(os.path.join("docs", "HISTORY.txt")).read(),
+      long_description=(open("README.rst").read() + "\n" +
+                        open("CHANGES.rst").read()),
       # Get more strings from http://www.python.org/pypi?%3Aaction=list_classifiers
       classifiers=[
         "Framework :: Plone",


Repository: plone.directives.form
Branch: refs/heads/master
Date: 2015-05-04T16:30:46+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.directives.form/commit/0ac53bb014fac3deac5f4e9f7a474bf6958b73e5

cleanup setup.py a bit.

Properly link to PyPI.
Indent classifiers.

Files changed:
M setup.py

diff --git a/setup.py b/setup.py
index ecf21a0..a820415 100644
--- a/setup.py
+++ b/setup.py
@@ -10,12 +10,13 @@
       description="Grok-like directives configuring forms",
       long_description=(open("README.rst").read() + "\n" +
                         open("CHANGES.rst").read()),
-      # Get more strings from http://www.python.org/pypi?%3Aaction=list_classifiers
+      # Get more strings from
+      # https://pypi.python.org/pypi?%3Aaction=list_classifiers
       classifiers=[
-        "Framework :: Plone",
-        "Programming Language :: Python",
-        "Topic :: Software Development :: Libraries :: Python Modules",
-        ],
+          "Framework :: Plone",
+          "Programming Language :: Python",
+          "Topic :: Software Development :: Libraries :: Python Modules",
+          ],
       keywords='grok plone dexterity form content',
       author='Martin Aspeli',
       author_email='optilude@gmail.com',


Repository: plone.directives.form
Branch: refs/heads/master
Date: 2015-05-04T16:35:13+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.directives.form/commit/1fb2c1df6add60c7824da28d7880c2fd8214ce0e

pep8

Files changed:
M CHANGES.rst
M plone/directives/form/__init__.py
M plone/directives/form/error.py
M plone/directives/form/form.py
M plone/directives/form/meta.py
M plone/directives/form/schema.py
M plone/directives/form/tests/test_error.py
M plone/directives/form/tests/test_form.py
M plone/directives/form/tests/test_schema.py
M plone/directives/form/tests/test_validator.py
M plone/directives/form/tests/test_value.py
M plone/directives/form/validator.py
M plone/directives/form/value.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 2669d19..f0df8c7 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,7 +4,11 @@ Changelog
 2.0.1 (unreleased)
 ------------------
 
-- Nothing changed yet.
+- pep8.
+  [maurits]
+
+- Whitespaces cleanup.
+  [gforcada]
 
 
 2.0 (2012-08-30)
diff --git a/plone/directives/form/__init__.py b/plone/directives/form/__init__.py
index 87b769f..43e6cf5 100644
--- a/plone/directives/form/__init__.py
+++ b/plone/directives/form/__init__.py
@@ -10,11 +10,12 @@
 # >>> class IMyType(form.Schema)
 # ...     form.model('myschema.xml')
 
-zope.deferredimport.defineFrom('plone.supermodel.model',
+zope.deferredimport.defineFrom(
+    'plone.supermodel.model',
     'Schema', 'fieldset',
 )
 from plone.supermodel.model import load as model
-model # pyflakes
+model  # pyflakes
 try:
     from plone.supermodel.model import primary
 except ImportError:
@@ -46,10 +47,11 @@
 # form if the user has the 'cmf.ModifyPortalContent' permission; and 'field3'
 # will be marked as a primary field for marshaling purposes
 
-zope.deferredimport.defineFrom('plone.autoform.directives',
+zope.deferredimport.defineFrom(
+    'plone.autoform.directives',
     'omitted', 'no_omit', 'mode', 'widget', 'order_before', 'order_after',
     'read_permission', 'write_permission',
-    )
+)
 
 # Behavior interfaces can either be marked with or be adaptable to this
 # interface, in order to provide fields for the standard forms. For example:
@@ -69,7 +71,8 @@
 # where the behavior (that uses the standard Dexterity form support) is
 # enabled will have the appropriate form fields inserted.
 
-zope.deferredimport.defineFrom('plone.autoform.interfaces',
+zope.deferredimport.defineFrom(
+    'plone.autoform.interfaces',
     'IFormFieldProvider',
 )
 
@@ -83,10 +86,11 @@
 # ...     grok.context(IMyContext)
 # ...     grok.require('zope2.View')
 
-zope.deferredimport.defineFrom('plone.directives.form.form',
+zope.deferredimport.defineFrom(
+    'plone.directives.form.form',
     'Form', 'SchemaForm', 'AddForm', 'SchemaAddForm',
-        'EditForm', 'SchemaEditForm', 'DisplayForm',
-        'wrap',
+    'EditForm', 'SchemaEditForm', 'DisplayForm',
+    'wrap',
 )
 
 # z3c.form value adapters for computed values: default_value (for a widget),
@@ -98,7 +102,8 @@
 #
 # See docstrings in value.py for more.
 
-zope.deferredimport.defineFrom('plone.directives.form.value',
+zope.deferredimport.defineFrom(
+    'plone.directives.form.value',
     'default_value', 'widget_label', 'button_label',
 )
 
@@ -109,7 +114,8 @@
 # ...     if value == 42:
 # ...         raise Invalid(u"We don't like this number")
 
-zope.deferredimport.defineFrom('plone.directives.form.validator',
+zope.deferredimport.defineFrom(
+    'plone.directives.form.validator',
     'validator',
 )
 
@@ -119,6 +125,7 @@
 # ... def errorMessage(value):
 # ...     return u"The given value (%d) is too small" % value
 
-zope.deferredimport.defineFrom('plone.directives.form.error',
+zope.deferredimport.defineFrom(
+    'plone.directives.form.error',
     'error_message',
 )
diff --git a/plone/directives/form/error.py b/plone/directives/form/error.py
index ccc0fb3..82e0015 100644
--- a/plone/directives/form/error.py
+++ b/plone/directives/form/error.py
@@ -2,6 +2,7 @@
 
 from z3c.form.error import ComputedErrorViewMessage
 
+
 class error_message(object):
     """Decorator for functions which may return an error message.
 
diff --git a/plone/directives/form/form.py b/plone/directives/form/form.py
index b584704..69deca4 100644
--- a/plone/directives/form/form.py
+++ b/plone/directives/form/form.py
@@ -23,6 +23,7 @@
 
 # Form base classes
 
+
 class GrokkedForm(object):
     """Mixin class for all grokked forms, which provides grok.View-like
     semantics for template association, static resources, etc.
@@ -45,7 +46,7 @@ def __init__(self, context, request):
                 self.request,
                 zope.interface.Interface,
                 name=self.module_info.package_dotted_name
-                )
+            )
         else:
             self.static = None
 
@@ -121,20 +122,23 @@ def form(self):
 
 # Page forms
 
+
 class Form(GrokkedForm, z3c.form.form.Form):
     """A basic form.
     """
     martian.baseclass()
 
+
 class SchemaForm(plone.autoform.form.AutoExtensibleForm, Form):
     """A basic extensible form
     """
     martian.baseclass()
 
-    schema = None # Must be set by subclass
+    schema = None  # Must be set by subclass
 
 # Add forms
 
+
 class AddForm(GrokkedForm, z3c.form.form.AddForm):
     """A standard add form.
     """
@@ -170,11 +174,17 @@ def handleAdd(self, action):
         if obj is not None:
             # mark only as finished if we get the new object
             self._finishedAdd = True
-            IStatusMessage(self.request).addStatusMessage(_(u"Changes saved"), "info")
+            IStatusMessage(
+                self.request).addStatusMessage(
+                _(u"Changes saved"),
+                "info")
 
     @z3c.form.button.buttonAndHandler(_(u'Cancel'), name='cancel')
     def handleCancel(self, action):
-        IStatusMessage(self.request).addStatusMessage(_(u"Add New Item operation cancelled"), "info")
+        IStatusMessage(
+            self.request).addStatusMessage(
+            _(u"Add New Item operation cancelled"),
+            "info")
         self.request.response.redirect(self.nextURL())
 
     def updateActions(self):
@@ -182,15 +192,17 @@ def updateActions(self):
         self.actions["save"].addClass("context")
         self.actions["cancel"].addClass("standalone")
 
+
 class SchemaAddForm(plone.autoform.form.AutoExtensibleForm, AddForm):
     """An extensible add form.
     """
     martian.baseclass()
 
-    schema = None # Must be set by subclass
+    schema = None  # Must be set by subclass
 
 # Edit forms
 
+
 class EditForm(GrokkedForm, z3c.form.form.EditForm):
     """A standard edit form
     """
@@ -203,12 +215,18 @@ def handleApply(self, action):
             self.status = self.formErrorsMessage
             return
         self.applyChanges(data)
-        IStatusMessage(self.request).addStatusMessage(_(u"Changes saved"), "info")
+        IStatusMessage(
+            self.request).addStatusMessage(
+            _(u"Changes saved"),
+            "info")
         self.request.response.redirect(self.context.absolute_url())
 
     @z3c.form.button.buttonAndHandler(_(u'Cancel'), name='cancel')
     def handleCancel(self, action):
-        IStatusMessage(self.request).addStatusMessage(_(u"Edit cancelled"), "info")
+        IStatusMessage(
+            self.request).addStatusMessage(
+            _(u"Edit cancelled"),
+            "info")
         self.request.response.redirect(self.context.absolute_url())
 
     def updateActions(self):
@@ -216,15 +234,17 @@ def updateActions(self):
         self.actions["save"].addClass("context")
         self.actions["cancel"].addClass("standalone")
 
+
 class SchemaEditForm(plone.autoform.form.AutoExtensibleForm, EditForm):
     """An extensible edit form
     """
     martian.baseclass()
 
-    schema = None # Must be set by subclass
+    schema = None  # Must be set by subclass
 
 # Display forms
 
+
 class DisplayForm(plone.autoform.view.WidgetsView, five.grok.View):
     """A view that knows about field widgets, but otherwise has all the
     goodness of a grok.View, including automatic templates.
@@ -244,6 +264,7 @@ def render(self):
 
 # Directives
 
+
 class wrap(martian.Directive):
     """Directive used on a form class to determine if a form wrapper view
     should be used.
@@ -255,4 +276,4 @@ def factory(self, flag=True):
         return flag
 
 __all__ = ('Form', 'SchemaForm', 'AddForm', 'SchemaAddForm',
-            'EditForm', 'SchemaEditForm', 'DisplayForm', 'wrap',)
+           'EditForm', 'SchemaEditForm', 'DisplayForm', 'wrap',)
diff --git a/plone/directives/form/meta.py b/plone/directives/form/meta.py
index fbbde48..e476d99 100644
--- a/plone/directives/form/meta.py
+++ b/plone/directives/form/meta.py
@@ -15,15 +15,15 @@
 from zope.component.zcml import adapter as adapter_directive
 
 from plone.directives.form.form import (
-        GrokkedForm,
-        Form,
-        EditForm,
-        SchemaEditForm,
-        AddForm,
-        SchemaAddForm,
-        DisplayForm,
-        wrap,
-    )
+    GrokkedForm,
+    Form,
+    EditForm,
+    SchemaEditForm,
+    AddForm,
+    SchemaAddForm,
+    DisplayForm,
+    wrap,
+)
 
 
 # Whether or not we need to wrap the grokked form using the layout form
@@ -40,6 +40,7 @@
 
 # Form grokkers
 
+
 def default_view_name(factory, module=None, **data):
     return factory.__name__.lower()
 
@@ -64,14 +65,17 @@ class FormGrokker(martian.ClassGrokker):
     martian.directive(grokcore.component.context)
     martian.directive(grokcore.view.layer, default=IDefaultBrowserLayer)
     martian.directive(grokcore.component.name, get_default=default_view_name)
-    martian.directive(grokcore.security.require, name='permission', default=None)
+    martian.directive(
+        grokcore.security.require,
+        name='permission',
+        default=None)
     martian.directive(wrap, default=None)
 
     default_permissions = {
-        EditForm          : 'cmf.ModifyPortalContent',
-        SchemaEditForm    : 'cmf.ModifyPortalContent',
-        AddForm           : 'cmf.AddPortalContent',
-        SchemaAddForm     : 'cmf.AddPortalContent',
+        EditForm: 'cmf.ModifyPortalContent',
+        SchemaEditForm: 'cmf.ModifyPortalContent',
+        AddForm: 'cmf.AddPortalContent',
+        SchemaAddForm: 'cmf.AddPortalContent',
     }
 
     permission_fallback = 'zope2.View'
@@ -81,10 +85,13 @@ def grok(self, name, form, module_info, **kw):
         form.module_info = module_info
         return super(FormGrokker, self).grok(name, form, module_info, **kw)
 
-    def execute(self, form, config, context, layer, name, permission, wrap, **kw):
+    def execute(
+            self, form, config, context, layer, name, permission, wrap, **kw):
 
         if permission is None:
-            permission = self.default_permissions.get(form.__class__, self.permission_fallback)
+            permission = self.default_permissions.get(
+                form.__class__,
+                self.permission_fallback)
 
         if issubclass(form, AutoExtensibleForm):
             if getattr(form, 'schema', None) is None:
@@ -94,9 +101,9 @@ def execute(self, form, config, context, layer, name, permission, wrap, **kw):
                 else:
                     raise GrokImportError(
                         u"The schema form %s must have a 'schema' attribute "
-                          "defining a schema interface for the form. If you want "
-                          "to set up your fields manually, use a non-schema form "
-                          "base class instead." % (form.__name__))
+                        "defining a schema interface for the form. If you want "
+                        "to set up your fields manually, use a non-schema form "
+                        "base class instead." % (form.__name__))
 
         form.__view_name__ = name
 
@@ -111,13 +118,13 @@ def execute(self, form, config, context, layer, name, permission, wrap, **kw):
             factory = form
 
         page_directive(
-                config,
-                name=name,
-                permission=permission,
-                for_=context,
-                layer=layer,
-                class_=factory
-            )
+            config,
+            name=name,
+            permission=permission,
+            for_=context,
+            layer=layer,
+            class_=factory
+        )
 
         return True
 
@@ -150,13 +157,14 @@ def grok(self, name, module, module_info, config, **kw):
         adapters = module_info.getAnnotation('form.value_adapters', [])
         for factory, name in adapters:
             adapter_directive(config,
-                factory=(factory,),
-                name=name
-            )
+                              factory=(factory,),
+                              name=name
+                              )
         return True
 
 # Validator adapter grokker
 
+
 class ValidatorAdapterGrokker(martian.GlobalGrokker):
 
     def grok(self, name, module, module_info, config, **kw):
@@ -164,12 +172,13 @@ def grok(self, name, module, module_info, config, **kw):
         adapters = module_info.getAnnotation('form.validator_adapters', [])
         for factory in adapters:
             adapter_directive(config,
-                factory=(factory,),
-            )
+                              factory=(factory,),
+                              )
         return True
 
 # Error message adapter grokker
 
+
 class ErrorMessageAdapterGrokker(martian.GlobalGrokker):
 
     def grok(self, name, module, module_info, config, **kw):
@@ -177,7 +186,7 @@ def grok(self, name, module, module_info, config, **kw):
         adapters = module_info.getAnnotation('form.error_message_adapters', [])
         for factory in adapters:
             adapter_directive(config,
-                factory=(factory,),
-                name=u"message",
-            )
+                              factory=(factory,),
+                              name=u"message",
+                              )
         return True
diff --git a/plone/directives/form/schema.py b/plone/directives/form/schema.py
index e5dffbb..1fb4dca 100644
--- a/plone/directives/form/schema.py
+++ b/plone/directives/form/schema.py
@@ -14,12 +14,14 @@ def set(self, locals_, directive, value):
         tags.setdefault(directive.key, {}).update(value)
 
     def get(self, directive, component, default):
-        return component.queryTaggedValue(TEMP_KEY, {}).get(directive.key, default)
+        return component.queryTaggedValue(
+            TEMP_KEY, {}).get(directive.key, default)
 
     def setattr(self, context, directive, value):
         tags = context.queryTaggedValue(TEMP_KEY, {})
         tags.setdefault(directive.key, {}).update(value)
 
+
 class FormMetadataListStorage(object):
     """Store a list value in the TEMP_KEY tagged value, under the key in
     directive.key
@@ -30,7 +32,8 @@ def set(self, locals_, directive, value):
         tags.setdefault(directive.key, []).extend(value)
 
     def get(self, directive, component, default):
-        return component.queryTaggedValue(TEMP_KEY, {}).get(directive.key, default)
+        return component.queryTaggedValue(
+            TEMP_KEY, {}).get(directive.key, default)
 
     def setattr(self, context, directive, value):
         tags = context.queryTaggedValue(TEMP_KEY, {})
diff --git a/plone/directives/form/tests/test_error.py b/plone/directives/form/tests/test_error.py
index a624ff4..7635b95 100644
--- a/plone/directives/form/tests/test_error.py
+++ b/plone/directives/form/tests/test_error.py
@@ -16,41 +16,53 @@
 
 from plone.directives import form
 
+
 class IFolder(Interface):
     pass
 
+
 class IFolder2(Interface):
     pass
 
+
 class IDummySchema(Interface):
 
     field1 = schema.Int(title=u"Field one", min=10, required=True)
     field2 = schema.Int(title=u"Field two", min=10, required=False)
 
+
 class Folder(object):
     implements(IFolder)
 
+
 class Folder2(object):
     implements(IFolder2)
 
+
 class DummyForm(Form):
 
     ignoreContext = True
     fields = Fields(IDummySchema)
 
+
 class DummySecondaryForm(Form):
 
     ignoreContext = True
     fields = Fields(IDummySchema)
 
-@form.error_message(error=TooSmall, field=IDummySchema['field1'], form=DummySecondaryForm)
+
+@form.error_message(
+    error=TooSmall, field=IDummySchema['field1'], form=DummySecondaryForm)
 def field1ErrorSecondForm(value):
     return u"Field 1 error second form"
 
-@form.error_message(error=TooSmall, field=IDummySchema['field1'], content=IFolder2)
+
+@form.error_message(
+    error=TooSmall, field=IDummySchema['field1'], content=IFolder2)
 def field1ErrorContext(value):
     return u"Field 1 error context"
 
+
 @form.error_message(error=TooSmall, field=IDummySchema['field1'])
 def field1Error(value):
     return u"Field 1 error"
@@ -69,7 +81,11 @@ def tearDown(self):
 
     def test_error_message_no_error(self):
 
-        form = DummyForm(Folder(), TestRequest(form={'form.widgets.field1': u"10"}))
+        form = DummyForm(
+            Folder(),
+            TestRequest(
+                form={
+                    'form.widgets.field1': u"10"}))
         form.update()
 
         data, errors = form.extractData()
@@ -77,7 +93,11 @@ def test_error_message_no_error(self):
 
     def test_error_message_field_only(self):
 
-        form = DummyForm(Folder(), TestRequest(form={'form.widgets.field1': u"5"}))
+        form = DummyForm(
+            Folder(),
+            TestRequest(
+                form={
+                    'form.widgets.field1': u"5"}))
         form.update()
 
         data, errors = form.extractData()
@@ -86,7 +106,11 @@ def test_error_message_field_only(self):
 
     def test_error_message_field_view(self):
 
-        form = DummySecondaryForm(Folder(), TestRequest(form={'form.widgets.field1': u"5"}))
+        form = DummySecondaryForm(
+            Folder(),
+            TestRequest(
+                form={
+                    'form.widgets.field1': u"5"}))
         form.update()
 
         data, errors = form.extractData()
@@ -95,7 +119,11 @@ def test_error_message_field_view(self):
 
     def test_error_message_field_context(self):
 
-        form = DummyForm(Folder2(), TestRequest(form={'form.widgets.field1': u"5"}))
+        form = DummyForm(
+            Folder2(),
+            TestRequest(
+                form={
+                    'form.widgets.field1': u"5"}))
         form.update()
 
         data, errors = form.extractData()
@@ -105,5 +133,6 @@ def test_error_message_field_context(self):
     def test_method_not_changed(self):
         self.assertEquals(u"Field 1 error", field1Error(None))
 
+
 def test_suite():
     return unittest.defaultTestLoader.loadTestsFromName(__name__)
diff --git a/plone/directives/form/tests/test_form.py b/plone/directives/form/tests/test_form.py
index 2752a5e..9d22d07 100644
--- a/plone/directives/form/tests/test_form.py
+++ b/plone/directives/form/tests/test_form.py
@@ -20,21 +20,26 @@
 
 import plone.directives.form.meta
 
+
 class ILayer(Interface):
     pass
 
+
 class IDummy(Interface):
     pass
 
+
 class IDummy2(Interface):
     pass
 
+
 class Dummy(object):
     implements(IDummy)
 
     def absolute_url(self):
         return "http://dummy"
 
+
 class Request(TestRequest):
 
     # Zope 2 requests have this
@@ -43,7 +48,10 @@ def __setitem__(self, name, value):
 
 # ignore warnings about unassociated templates, since the way we do the tests
 # mean the association happens after the module is grokked
-warnings.filterwarnings("ignore", ".*unassociated template.*testformwithtemplate.*")
+warnings.filterwarnings(
+    "ignore",
+    ".*unassociated template.*testformwithtemplate.*")
+
 
 class TestFormDirectives(unittest.TestCase):
 
@@ -64,8 +72,12 @@ def setUp(self):
         grokcore.component.testing.grok('grokcore.view.templatereg')
 
         provideUtility(Permission('zope2.View'), name='zope2.View')
-        provideUtility(Permission('cmf.ModifyPortalContent'), name='cmf.ModifyPortalContent')
-        provideUtility(Permission('cmf.AddPortalContent'), name='cmf.AddPortalContent')
+        provideUtility(
+            Permission('cmf.ModifyPortalContent'),
+            name='cmf.ModifyPortalContent')
+        provideUtility(
+            Permission('cmf.AddPortalContent'),
+            name='cmf.AddPortalContent')
 
     def tearDown(self):
         zope.component.testing.tearDown()
@@ -332,7 +344,9 @@ class TestFormWithTemplate(form.Form):
 
         grokcore.component.testing.grok(__name__)
 
-        grokcore.component.testing.grok_component('TestFormWithTemplate', TestFormWithTemplate)
+        grokcore.component.testing.grok_component(
+            'TestFormWithTemplate',
+            TestFormWithTemplate)
 
         context = Dummy()
         request = Request()
@@ -340,7 +354,9 @@ class TestFormWithTemplate(form.Form):
         view = getMultiAdapter((context, request), name="testformwithtemplate")
 
         self.failUnless(issubclass(view.form, TestFormWithTemplate))
-        self.failUnless(grokcore.view.interfaces.ITemplate.providedBy(view.template))
+        self.failUnless(
+            grokcore.view.interfaces.ITemplate.providedBy(
+                view.template))
 
     def test_template_and_render(self):
 
@@ -353,8 +369,9 @@ def render(self):
         grokcore.component.testing.grok(__name__)
 
         self.assertRaises(ConfigurationExecutionError,
-            grokcore.component.testing.grok_component,
-            'TestFormWithTemplate', TestFormWithTemplate)
+                          grokcore.component.testing.grok_component,
+                          'TestFormWithTemplate', TestFormWithTemplate)
+
 
 def test_suite():
     return unittest.defaultTestLoader.loadTestsFromName(__name__)
diff --git a/plone/directives/form/tests/test_schema.py b/plone/directives/form/tests/test_schema.py
index 69b2193..0d4a6d0 100644
--- a/plone/directives/form/tests/test_schema.py
+++ b/plone/directives/form/tests/test_schema.py
@@ -19,9 +19,11 @@
 
 from plone.rfc822.interfaces import IPrimaryField
 
+
 class DummyWidget(object):
     pass
 
+
 class TestSchemaDirectives(unittest.TestCase):
 
     def setUp(self):
@@ -92,7 +94,7 @@ class IDummy(form.Schema):
             baz = zope.schema.TextLine(title=u"Baz")
 
         self.assertEquals({'foo': 'plone.directives.form.tests.test_schema.DummyWidget'},
-                  IDummy.queryTaggedValue(WIDGETS_KEY))
+                          IDummy.queryTaggedValue(WIDGETS_KEY))
 
     def test_multiple_invocations(self):
 
@@ -130,7 +132,7 @@ class IDummy(form.Schema):
         self.assertEquals([('baz', 'before', 'title'),
                            ('baz', 'after', 'qux'),
                            ('qux', 'after', 'bar'),
-                           ('foo', 'before', 'body'),],
+                           ('foo', 'before', 'body'), ],
                           IDummy.queryTaggedValue(ORDER_KEY))
         self.assertEquals({'foo': 'zope2.View', 'bar': 'zope2.View', 'baz': 'random.Permission'},
                           IDummy.queryTaggedValue(READ_PERMISSIONS_KEY))
@@ -192,7 +194,8 @@ class IBar(IFoo):
             form.order_after(foo='bar')
             bar = zope.schema.TextLine()
 
-        self.assertEquals([('foo', 'after', 'bar'),], IBar.queryTaggedValue(ORDER_KEY))
+        self.assertEquals(
+            [('foo', 'after', 'bar'), ], IBar.queryTaggedValue(ORDER_KEY))
 
     def test_schema_without_model_not_grokked(self):
 
@@ -202,10 +205,11 @@ class IFoo(Schema):
         self.assertEquals(None, IFoo.queryTaggedValue(FILENAME_KEY))
         self.assertEquals(None, IFoo.queryTaggedValue(SCHEMA_NAME_KEY))
 
+
 def test_suite():
     return unittest.TestSuite((
         unittest.makeSuite(TestSchemaDirectives),
         doctest.DocFileSuite('schema.txt',
-            setUp=zope.component.testing.setUp,
-            tearDown=zope.component.testing.tearDown),
-        ))
+                             setUp=zope.component.testing.setUp,
+                             tearDown=zope.component.testing.tearDown),
+    ))
diff --git a/plone/directives/form/tests/test_validator.py b/plone/directives/form/tests/test_validator.py
index 1c925e9..08d6f85 100644
--- a/plone/directives/form/tests/test_validator.py
+++ b/plone/directives/form/tests/test_validator.py
@@ -14,48 +14,59 @@
 
 from plone.directives import form
 
+
 class IFolder(Interface):
     pass
 
+
 class IFolder2(Interface):
     pass
 
+
 class IDummySchema(Interface):
 
     field1 = schema.TextLine(title=u"Field one", required=True)
     field2 = schema.TextLine(title=u"Field two", required=False)
 
+
 class Folder(object):
     implements(IFolder)
 
+
 class Folder2(object):
     implements(IFolder2)
 
+
 class DummyForm(Form):
 
     ignoreContext = True
     fields = Fields(IDummySchema)
 
+
 class DummySecondaryForm(Form):
 
     ignoreContext = True
     fields = Fields(IDummySchema)
 
+
 @form.validator(field=IDummySchema['field1'])
 def validate_field1(value):
     if value == 'fail':
         raise schema.ValidationError(u"Field 1, form 1")
 
+
 @form.validator(field=IDummySchema['field1'], view=DummySecondaryForm)
 def validate_field1_secondary(value):
     if value == 'fail':
         raise schema.ValidationError(u"Field 1, form 2")
 
+
 @form.validator(field=IDummySchema['field1'], context=IFolder2)
 def validate_field1_context(value):
     if value == 'fail':
         raise schema.ValidationError(u"Field 1, context")
 
+
 class TestValidatorDecorator(unittest.TestCase):
 
     def setUp(self):
@@ -78,7 +89,11 @@ def test_validator_calls_default(self):
 
     def test_validator_no_error(self):
 
-        form = DummyForm(Folder(), TestRequest(form={'form.widgets.field1': u"Value"}))
+        form = DummyForm(
+            Folder(),
+            TestRequest(
+                form={
+                    'form.widgets.field1': u"Value"}))
         form.update()
 
         data, errors = form.extractData()
@@ -86,7 +101,11 @@ def test_validator_no_error(self):
 
     def test_validator_field_only(self):
 
-        form = DummyForm(Folder(), TestRequest(form={'form.widgets.field1': u"fail"}))
+        form = DummyForm(
+            Folder(),
+            TestRequest(
+                form={
+                    'form.widgets.field1': u"fail"}))
         form.update()
 
         data, errors = form.extractData()
@@ -95,7 +114,11 @@ def test_validator_field_only(self):
 
     def test_validator_field_view(self):
 
-        form = DummySecondaryForm(Folder(), TestRequest(form={'form.widgets.field1': u"fail"}))
+        form = DummySecondaryForm(
+            Folder(),
+            TestRequest(
+                form={
+                    'form.widgets.field1': u"fail"}))
         form.update()
 
         data, errors = form.extractData()
@@ -104,7 +127,11 @@ def test_validator_field_view(self):
 
     def test_validator_field_context(self):
 
-        form = DummyForm(Folder2(), TestRequest(form={'form.widgets.field1': u"fail"}))
+        form = DummyForm(
+            Folder2(),
+            TestRequest(
+                form={
+                    'form.widgets.field1': u"fail"}))
         form.update()
 
         data, errors = form.extractData()
@@ -115,5 +142,6 @@ def test_method_not_changed(self):
         self.assertEquals(None, validate_field1(None))
         self.assertRaises(schema.ValidationError, validate_field1, 'fail')
 
+
 def test_suite():
     return unittest.defaultTestLoader.loadTestsFromName(__name__)
diff --git a/plone/directives/form/tests/test_value.py b/plone/directives/form/tests/test_value.py
index 6b0f93d..76a99d4 100644
--- a/plone/directives/form/tests/test_value.py
+++ b/plone/directives/form/tests/test_value.py
@@ -14,55 +14,69 @@
 
 from plone.directives import form
 
+
 class IFolder(Interface):
     pass
 
+
 class IDummySchema(Interface):
 
     field1 = schema.TextLine(title=u"Field one")
     field2 = schema.TextLine(title=u"Field two")
 
+
 class Folder(object):
     implements(IFolder)
 
+
 class Dummy(object):
     implements(IDummySchema)
 
     field1 = u"Field 1 default"
     field2 = u""
 
+
 class DummyEditForm(EditForm):
 
     fields = Fields(IDummySchema)
 
+
 class DummyAddForm(AddForm):
 
     fields = Fields(IDummySchema)
 
+
 class DummySecondaryAddForm(AddForm):
 
     fields = Fields(IDummySchema)
 
+
 @form.default_value(field=IDummySchema['field1'])
 def field1_default(data):
     return u"A dummy"
 
+
 @form.default_value(field=IDummySchema['field1'], form=DummySecondaryAddForm)
 def field1_default_secondary(data):
     return u"Another dummy"
 
+
 @form.widget_label(field=IDummySchema['field1'], context=IDummySchema)
 def field1_label(data):
     return u"A label"
 
+
 @form.button_label(button=EditForm.buttons['apply'])
 def apply_button_label(data):
     return u"Computed label"
 
-@form.button_label(button=DummySecondaryAddForm.buttons['add'], form=DummySecondaryAddForm)
+
+@form.button_label(
+    button=DummySecondaryAddForm.buttons['add'], form=DummySecondaryAddForm)
 def add_button_secondary(data):
     return u"Computed add button"
 
+
 class TestValueDecorators(unittest.TestCase):
 
     def setUp(self):
@@ -82,11 +96,15 @@ def test_default_value(self):
 
         edit_form = DummyEditForm(Dummy(), TestRequest())
         edit_form.update()
-        self.assertEquals(u"Field 1 default", edit_form.widgets['field1'].value)
+        self.assertEquals(
+            u"Field 1 default",
+            edit_form.widgets['field1'].value)
 
         secondary_add_form = DummySecondaryAddForm(Folder(), TestRequest())
         secondary_add_form.update()
-        self.assertEquals(u"Another dummy", secondary_add_form.widgets['field1'].value)
+        self.assertEquals(
+            u"Another dummy",
+            secondary_add_form.widgets['field1'].value)
 
     def test_widget_label(self):
 
@@ -108,7 +126,9 @@ def test_button_label(self):
 
         secondary_add_form = DummySecondaryAddForm(Folder(), TestRequest())
         secondary_add_form.update()
-        self.assertEquals(u"Computed add button", secondary_add_form.actions['add'].title)
+        self.assertEquals(
+            u"Computed add button",
+            secondary_add_form.actions['add'].title)
 
         edit_form = DummyEditForm(Dummy(), TestRequest())
         edit_form.update()
@@ -117,7 +137,8 @@ def test_button_label(self):
     def test_method_not_changed(self):
         self.assertEquals(u"Computed add button", add_button_secondary(None))
 
+
 def test_suite():
     return unittest.TestSuite((
         unittest.makeSuite(TestValueDecorators),
-        ))
\ No newline at end of file
+    ))
diff --git a/plone/directives/form/validator.py b/plone/directives/form/validator.py
index 6e9e56a..0ac2725 100644
--- a/plone/directives/form/validator.py
+++ b/plone/directives/form/validator.py
@@ -6,16 +6,25 @@
 from z3c.form.validator import SimpleFieldValidator
 from z3c.form.validator import WidgetValidatorDiscriminators
 
+
 class DecoratedValidator(SimpleFieldValidator):
 
     def __init__(self, fn, context, request, view, field, widget):
-        super(DecoratedValidator, self).__init__(context, request, view, field, widget)
+        super(
+            DecoratedValidator,
+            self).__init__(
+            context,
+            request,
+            view,
+            field,
+            widget)
         self.fn = fn
 
     def validate(self, value):
         super(DecoratedValidator, self).validate(value)
         self.fn(value)
 
+
 class validator(object):
     """Decorator for functions to be registered as validators
     """
@@ -27,7 +36,8 @@ def __call__(self, fn):
 
         @implementer(IValidator)
         def factory(context, request, view, field, widget):
-            return DecoratedValidator(fn, context, request, view, field, widget)
+            return DecoratedValidator(
+                fn, context, request, view, field, widget)
 
         WidgetValidatorDiscriminators(factory, **self.discriminators)
 
diff --git a/plone/directives/form/value.py b/plone/directives/form/value.py
index c32aa4a..2b4061d 100644
--- a/plone/directives/form/value.py
+++ b/plone/directives/form/value.py
@@ -3,6 +3,7 @@
 from z3c.form.widget import ComputedWidgetAttribute
 from z3c.form.button import ComputedButtonActionAttribute
 
+
 class _computed_value(object):
     """Decorator for things using z3c.form.value IValue creators.
     """
@@ -17,9 +18,16 @@ def __init__(self, name, **kw):
     def __call__(self, ob):
 
         try:
-            value_adapter = (self.factory(ob, **self.discriminators), self.name,)
+            value_adapter = (
+                self.factory(
+                    ob,
+                    **self.discriminators),
+                self.name,
+            )
         except ValueError, e:
-            raise ValueError(u"Error constructing value adapter for %s: %s" % (str(ob), str(e),))
+            raise ValueError(
+                u"Error constructing value adapter for %s: %s" %
+                (str(ob), str(e),))
 
         frame = sys._getframe(1)
         adapters = frame.f_locals.get('__form_value_adapters__', None)
@@ -29,6 +37,7 @@ def __call__(self, ob):
 
         return ob
 
+
 class default_value(_computed_value):
     """Decorator for functions providing a default field value when rendering
     a form::
@@ -44,28 +53,32 @@ def get_default(data):
 
     factory = ComputedWidgetAttribute
 
-    def __init__(self, context=None, request=None, view=None, field=None, widget=None, form=None, layer=None):
+    def __init__(self, context=None, request=None, view=None,
+                 field=None, widget=None, form=None, layer=None):
 
         if not field and not widget:
             raise TypeError(u"Either 'field' or 'widget' must be specified")
 
         if form and view:
-            raise TypeError(u"You cannot specify both 'view' and 'form' - one is an alias for the other")
+            raise TypeError(
+                u"You cannot specify both 'view' and 'form' - one is an alias for the other")
         elif form and not view:
             view = form
 
         if request and layer:
-            raise TypeError(u"You cannot specify both 'request' and 'layer' - one is an alias for the other")
+            raise TypeError(
+                u"You cannot specify both 'request' and 'layer' - one is an alias for the other")
         elif layer and not request:
             request = layer
 
         super(default_value, self).__init__('default',
-                context=context,
-                request=request,
-                view=view,
-                field=field,
-                widget=widget,
-            )
+                                            context=context,
+                                            request=request,
+                                            view=view,
+                                            field=field,
+                                            widget=widget,
+                                            )
+
 
 class widget_label(_computed_value):
     """Decorator for functions providing a computed widget label::
@@ -81,28 +94,32 @@ def get_widget(data):
 
     factory = ComputedWidgetAttribute
 
-    def __init__(self, context=None, request=None, view=None, field=None, widget=None, form=None, layer=None):
+    def __init__(self, context=None, request=None, view=None,
+                 field=None, widget=None, form=None, layer=None):
 
         if not field and not widget:
             raise TypeError(u"Either 'field' or 'widget' must be specified")
 
         if form and view:
-            raise TypeError(u"You cannot specify both 'view' and 'form' - one is an alias for the other")
+            raise TypeError(
+                u"You cannot specify both 'view' and 'form' - one is an alias for the other")
         elif form and not view:
             view = form
 
         if request and layer:
-            raise TypeError(u"You cannot specify both 'request' and 'layer' - one is an alias for the other")
+            raise TypeError(
+                u"You cannot specify both 'request' and 'layer' - one is an alias for the other")
         elif layer and not request:
             request = layer
 
         super(widget_label, self).__init__('label',
-                context=context,
-                request=request,
-                view=form,
-                field=field,
-                widget=widget,
-            )
+                                           context=context,
+                                           request=request,
+                                           view=form,
+                                           field=field,
+                                           widget=widget,
+                                           )
+
 
 class button_label(_computed_value):
     """Decorator for functions providing a computed button label::
@@ -118,29 +135,33 @@ def get_widget(data):
 
     factory = ComputedButtonActionAttribute
 
-    def __init__(self, content=None, request=None, form=None, manager=None, button=None, view=None, layer=None, context=None):
+    def __init__(self, content=None, request=None, form=None,
+                 manager=None, button=None, view=None, layer=None, context=None):
 
         if context and content:
-            raise TypeError(u"You cannot specify both 'content' and 'context' - one is an alias for the other")
+            raise TypeError(
+                u"You cannot specify both 'content' and 'context' - one is an alias for the other")
         elif context and not content:
             content = context
 
         if form and view:
-            raise TypeError(u"You cannot specify both 'view' and 'form' - one is an alias for the other")
+            raise TypeError(
+                u"You cannot specify both 'view' and 'form' - one is an alias for the other")
         elif view and not form:
             form = view
 
         if request and layer:
-            raise TypeError(u"You cannot specify both 'request' and 'layer' - one is an alias for the other")
+            raise TypeError(
+                u"You cannot specify both 'request' and 'layer' - one is an alias for the other")
         elif layer and not request:
             request = layer
 
         super(button_label, self).__init__('title',
-                content=content,
-                request=request,
-                form=form,
-                manager=manager,
-                button=button,
-            )
-
-__all__ = ('default_value', 'widget_label', 'button_label',)
\ No newline at end of file
+                                           content=content,
+                                           request=request,
+                                           form=form,
+                                           manager=manager,
+                                           button=button,
+                                           )
+
+__all__ = ('default_value', 'widget_label', 'button_label',)


Repository: plone.directives.form
Branch: refs/heads/master
Date: 2015-05-04T16:36:50+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.directives.form/commit/8a068d4a8b6eb0d11628f4207a06577fb75ff30a

Preparing release 2.0.1

[ci skip]

Files changed:
M CHANGES.rst
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index f0df8c7..c377ecf 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -1,7 +1,7 @@
 Changelog
 =========
 
-2.0.1 (unreleased)
+2.0.1 (2015-05-04)
 ------------------
 
 - pep8.
diff --git a/setup.py b/setup.py
index a820415..5ccbbb0 100644
--- a/setup.py
+++ b/setup.py
@@ -1,6 +1,6 @@
 from setuptools import setup, find_packages
 
-version = '2.0.1.dev0'
+version = '2.0.1'
 
 tests_require = []
 


Repository: plone.directives.form
Branch: refs/heads/master
Date: 2015-05-04T16:37:24+02:00
Author: Maurits van Rees (mauritsvanrees) <maurits@vanrees.org>
Commit: https://github.com/plone/plone.directives.form/commit/7b80423b9bf5161100730f18105dbfec3c11c853

Back to development: 2.0.2

[ci skip]

Files changed:
M CHANGES.rst
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index c377ecf..8897b0e 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -1,6 +1,12 @@
 Changelog
 =========
 
+2.0.2 (unreleased)
+------------------
+
+- Nothing changed yet.
+
+
 2.0.1 (2015-05-04)
 ------------------
 
diff --git a/setup.py b/setup.py
index 5ccbbb0..33dd710 100644
--- a/setup.py
+++ b/setup.py
@@ -1,6 +1,6 @@
 from setuptools import setup, find_packages
 
-version = '2.0.1'
+version = '2.0.2.dev0'
 
 tests_require = []
 


