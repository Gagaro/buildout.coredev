Repository: plone.app.controlpanel
Branch: refs/heads/master
Date: 2015-03-19T16:45:49+01:00
Author: Timo Stollenwerk (tisto) <tisto@plone.org>
Commit: https://github.com/plone/plone.app.controlpanel/commit/63799ca2f095a6fcfcd951b02fd7081b85d0aa26

Remove unused control panel code. Keep imports for bbb.

Files changed:
M plone/app/controlpanel/markup.py
M plone/app/controlpanel/search.py
M plone/app/controlpanel/security.py
M plone/app/controlpanel/site.py
M plone/app/controlpanel/types.py

diff --git a/plone/app/controlpanel/markup.py b/plone/app/controlpanel/markup.py
index 64a6eab..14a5394 100644
--- a/plone/app/controlpanel/markup.py
+++ b/plone/app/controlpanel/markup.py
@@ -1,134 +1,5 @@
-from plone.fieldsets.fieldsets import FormFieldsets
-
-from zope.interface import Interface
-from zope.interface import implements
-from zope.schema import Choice
-from zope.schema import Tuple
-
-from zope.schema.interfaces import IVocabularyFactory
-from zope.schema.vocabulary import SimpleVocabulary
-from zope.schema.vocabulary import SimpleTerm
-
-from Products.CMFCore.utils import getToolByName
-from Products.CMFPlone import PloneMessageFactory as _
-
-from plone.app.controlpanel.form import ControlPanelForm
-from plone.app.controlpanel.widgets import AllowedTypesWidget
-from plone.app.controlpanel.widgets import MultiCheckBoxVocabularyWidget
-
-from persistent import Persistent
-
-try:
-    from wicked.plone.registration import basic_type_regs as wicked_basic_type_regs
-except ImportError:
-    HAS_WICKED = False
-else:
-    HAS_WICKED = True
-
-WICKED_SETTING_KEY="plone.app.controlpanel.wicked"
-
-class WickedSettings(Persistent):
-    """Settings for Wicked markup
-    """
-    types_enabled = []
-    enable_mediawiki = False
-
-if HAS_WICKED:
-    wicked_type_regs = dict((factory.type, factory) for factory in \
-                            wicked_basic_type_regs)
-
-class WickedTypesVocabulary(object):
-    """Vocabulary factory for wickedized portal types.
-    """
-    implements(IVocabularyFactory)
-
-    def __call__(self, context):
-        context = getattr(context, 'context', context)
-        ttool = getToolByName(context, 'portal_types')
-        items = []
-        # Pretty insane code, but wicked uses different internal names for
-        # the types :(
-        for t in ttool.listContentTypes():
-            for reg in wicked_basic_type_regs:
-                if reg.type_id == t:
-                    items.append(SimpleTerm(reg.type, reg.type, ttool[t].Title()))
-        return SimpleVocabulary(items)
-
-WickedTypesVocabularyFactory = WickedTypesVocabulary()
-
-#
-# Markup types
-#
-
-class ITextMarkupSchema(Interface):
-
-    default_type = Choice(title=_(u'Default format'),
-        description=_(u"Select the default format of textfields for newly "
-                       "created content objects."),
-        default=u'text/html',
-        missing_value=set(),
-        vocabulary="plone.app.vocabularies.AllowableContentTypes",
-        required=True)
-
-    allowed_types = Tuple(title=_(u'Alternative formats'),
-        description=_(u"Select which formats are available for users as "
-                       "alternative to the default format. Note that if new "
-                       "formats are installed, they will be enabled for text "
-                       "fields by default unless explicitly turned off here "
-                       "or by the relevant installer."),
-        required=True,
-        missing_value=set(),
-        value_type=Choice(
-            vocabulary="plone.app.vocabularies.AllowableContentTypes"))
-
-#
-# Wicked behaviour
-#
-
-class IWikiMarkupSchema(Interface):
-
-    wiki_enabled_types = Tuple(title=_(u"Choose which types will have wiki "
-                                        "behavior."),
-                               description=_(u"Each type chosen will have a "
-                                             "wiki enabled primary text area. "
-                                             "At least one type must be chosen "
-                                             "to turn wiki behavior on."),
-                               required=False,
-                               missing_value=tuple(),
-                               value_type=Choice(vocabulary="plone.app.\
-controlpanel.WickedPortalTypes"))
-
-#
-# Combined schemata and fieldsets
-#
-
-if HAS_WICKED:
-    class IMarkupSchema(ITextMarkupSchema, IWikiMarkupSchema):
-        """Combined schema for the adapter lookup.
-        """
-else:
-    IMarkupSchema = ITextMarkupSchema
-
-
-textset = FormFieldsets(ITextMarkupSchema)
-textset.id = 'textmarkup'
-textset.label = _(u'Text markup')
-
-if HAS_WICKED:
-    wikiset = FormFieldsets(IWikiMarkupSchema)
-    wikiset.id = 'wiki'
-    wikiset.label = _(u'Wiki behavior')
-
-class MarkupControlPanel(ControlPanelForm):
-
-    if HAS_WICKED:
-        form_fields = FormFieldsets(textset, wikiset)
-        form_fields['wiki_enabled_types'].custom_widget = MultiCheckBoxVocabularyWidget
-    else:
-        form_fields = FormFieldsets(textset)
-    form_fields['allowed_types'].custom_widget = AllowedTypesWidget
-
-    label = _("Markup settings")
-    description = _("Lets you control what markup is available when editing "
-                    "content.")
-    form_name = _("Markup settings")
+# Control panels for Plone 5 have been moved to CMFPlone. We keep those imports
+# for backwards compatibility.
+from Products.CMFPlone.interfaces import IMailSchema  # noqa
+from Products.CMFPlone.controlpanel.markup import MarkupControlPanel  # noqa
+from Products.CMFPlone.controlpanel.bbb.markup import MarkupControlPanelAdapter  # noqa
diff --git a/plone/app/controlpanel/search.py b/plone/app/controlpanel/search.py
index 650823f..537ec35 100644
--- a/plone/app/controlpanel/search.py
+++ b/plone/app/controlpanel/search.py
@@ -1,63 +1,5 @@
-from plone.fieldsets.fieldsets import FormFieldsets
-from zope.interface import Interface
-from zope.schema import Bool
-from zope.schema import Choice
-from zope.schema import Tuple
-from zope.schema.vocabulary import SimpleTerm
-from zope.schema.vocabulary import SimpleVocabulary
-
-from Products.CMFPlone import PloneMessageFactory as _
-
-from form import ControlPanelForm
-from widgets import MultiCheckBoxThreeColumnWidget as MCBThreeColumnWidget
-
-
-anon_auth_items = (('anon', _(u'anonymous users')),
-                   ('auth', _(u'logged in users'),))
-
-anon_auth_terms = [SimpleTerm(item[0], title=item[1]) for item in
-                   anon_auth_items]
-
-AnonAuthVocabulary = SimpleVocabulary(anon_auth_terms)
-
-class IBaseSearchSchema(Interface):
-
-    enable_livesearch = Bool(
-        title=_(u'Enable LiveSearch'),
-        description=_(u"Enables the LiveSearch feature, which shows live "
-                       "results if the browser supports JavaScript."),
-        default=False,
-        required=True
-        )
-
-    types_not_searched = Tuple(
-        title=_(u"Define the types to be shown in the site and searched"),
-        description=_(u"Define the types that should be searched and be "
-                       "available in the user facing part of the site. "
-                       "Note that if new content types are installed, they "
-                       "will be enabled by default unless explicitly turned "
-                       "off here or by the relevant installer."),
-        required=True,
-        missing_value=tuple(),
-        value_type=Choice(
-            vocabulary="plone.app.vocabularies.ReallyUserFriendlyTypes")
-        )
-
-
-class ISearchSchema(IBaseSearchSchema):
-    ''' Base search form options '''
-
-
-searchset = FormFieldsets(IBaseSearchSchema)
-searchset.id = 'search'
-searchset.label = _("Search settings")
-
-class SearchControlPanel(ControlPanelForm):
-
-    form_fields = FormFieldsets(searchset)
-    form_fields['types_not_searched'].custom_widget = MCBThreeColumnWidget
-    form_fields['types_not_searched'].custom_widget.cssClass='label'
-
-    label = _("Search settings")
-    description = _("Search settings for this site.")
-    form_name = _("Search settings")
+# Control panels for Plone 5 have been moved to CMFPlone. We keep those imports
+# for backwards compatibility.
+from Products.CMFPlone.interfaces import ISearchSchema  # noqa
+from Products.CMFPlone.controlpanel.search import SearchControlPanel  # noqa
+from Products.CMFPlone.controlpanel.bbb.search import SearchControlPanelAdapter  # noqa
diff --git a/plone/app/controlpanel/security.py b/plone/app/controlpanel/security.py
index 338e2e1..f17d2f4 100644
--- a/plone/app/controlpanel/security.py
+++ b/plone/app/controlpanel/security.py
@@ -1,363 +1,5 @@
-import logging
-from collections import defaultdict
-from zope.interface import Interface
-from zope.component import adapts
-from zope.formlib.form import FormFields
-from zope.interface import implements
-from zope.schema import Bool
-from Acquisition import aq_inner
-
-from Products.CMFCore.utils import getToolByName
-from Products.CMFCore.ActionInformation import Action
-from Products.CMFDefault.formlib.schema import SchemaAdapterBase
-from Products.CMFPlone.utils import safe_hasattr
-from Products.CMFPlone import PloneMessageFactory as _
-from Products.CMFPlone.interfaces import IPloneSiteRoot
-from Products.Five import BrowserView
-
-from form import ControlPanelForm
-
-logger = logging.getLogger('plone.app.controlpanel')
-
-
-class ISecuritySchema(Interface):
-
-    enable_self_reg = Bool(
-        title=_(u'Enable self-registration'),
-        description=_(u"Allows users to register themselves on the site. If "
-                      "not selected, only site managers can add new users."),
-        default=False,
-        required=False)
-
-    enable_user_pwd_choice = Bool(
-        title=_(u'Let users select their own passwords'),
-        description=_(u"If not selected, a URL will be generated and "
-                      "e-mailed. Users are instructed to follow the link to "
-                      "reach a page where they can change their password and "
-                      "complete the registration process; this also verifies "
-                      "that they have entered a valid email address."),
-        default=False,
-        required=False)
-
-    enable_user_folders = Bool(
-        title=_(u'Enable User Folders'),
-        description=_(u"If selected, home folders where users can create "
-                      "content will be created when they log in."),
-        default=False,
-        required=False)
-
-    allow_anon_views_about = Bool(
-        title=_(u"Allow anyone to view 'about' information"),
-        description=_(u"If not selected only logged-in users will be able to "
-                      "view information about who created an item and when it "
-                      "was modified."),
-        default=False,
-        required=False)
-
-    use_email_as_login = Bool(
-        title=_(u'Use email address as login name'),
-        description = _(
-            u"Allows users to login with their email address instead "
-            u"of specifying a separate login name. This also updates "
-            u"the login name of existing users, which may take a "
-            u"while on large sites. The login name is saved as "
-            u"lower case, but to be userfriendly it does not matter "
-            u"which case you use to login. When duplicates are found, "
-            u"saving this form will fail. You can use the "
-            u"@@migrate-to-emaillogin page to show the duplicates."),
-        default=False,
-        required=False)
-
-    use_uuid_as_userid = Bool(
-        title=_(u'Use UUID user ids'),
-        description = _(
-            u"Use automatically generated UUIDs as user id for new users. "
-            u"When not turned on, the default is to use the same as the "
-            u"login name, or when using the email address as login name we "
-            u"generate a user id based on the fullname."),
-        default=False,
-        required=False)
-
-
-class SecurityControlPanelAdapter(SchemaAdapterBase):
-
-    adapts(IPloneSiteRoot)
-    implements(ISecuritySchema)
-
-    def __init__(self, context):
-        super(SecurityControlPanelAdapter, self).__init__(context)
-        pprop = getToolByName(context, 'portal_properties')
-        self.pmembership = getToolByName(context, 'portal_membership')
-        portal_url = getToolByName(context, 'portal_url')
-        self.portal = portal_url.getPortalObject()
-        self.context = pprop.site_properties
-
-    def get_enable_self_reg(self):
-        app_perms = self.portal.rolesOfPermission(permission='Add portal member')
-        for appperm in app_perms:
-            if appperm['name'] == 'Anonymous' and \
-               appperm['selected'] == 'SELECTED':
-                return True
-        return False
-
-    def set_enable_self_reg(self, value):
-        app_perms = self.portal.rolesOfPermission(permission='Add portal member')
-        reg_roles = []
-        for appperm in app_perms:
-            if appperm['selected'] == 'SELECTED':
-                reg_roles.append(appperm['name'])
-        if value == True and 'Anonymous' not in reg_roles:
-            reg_roles.append('Anonymous')
-        if value == False and 'Anonymous' in reg_roles:
-            reg_roles.remove('Anonymous')
-
-        self.portal.manage_permission('Add portal member', roles=reg_roles,
-                                      acquire=0)
-
-    enable_self_reg = property(get_enable_self_reg, set_enable_self_reg)
-
-
-    def get_enable_user_pwd_choice(self):
-        if self.portal.validate_email:
-            return False
-        else:
-            return True
-
-    def set_enable_user_pwd_choice(self, value):
-        if value == True:
-            self.portal.validate_email = False
-        else:
-            self.portal.validate_email = True
-
-    enable_user_pwd_choice = property(get_enable_user_pwd_choice,
-                                      set_enable_user_pwd_choice)
-
-
-    def get_enable_user_folders(self):
-        return self.pmembership.getMemberareaCreationFlag()
-
-    def set_enable_user_folders(self, value):
-        self.pmembership.memberareaCreationFlag = value
-        # support the 'my folder' user action #8417
-        portal_actions = getToolByName(self.portal, 'portal_actions', None)
-        if portal_actions is not None:
-            object_category = getattr(portal_actions, 'user', None)
-            if value and not safe_hasattr(object_category, 'mystuff'):
-                # add action
-                self.add_mystuff_action(object_category)
-            elif safe_hasattr(object_category, 'mystuff'):
-                a = getattr(object_category, 'mystuff')
-                a.visible = bool(value)    # show/hide action
-
-    enable_user_folders = property(get_enable_user_folders,
-                                   set_enable_user_folders)
-
-
-    def add_mystuff_action(self, object_category):
-        new_action = Action(
-            'mystuff',
-            title=_(u'My Folder'),
-            description='',
-            url_expr='string:${portal/portal_membership/getHomeUrl}',
-            available_expr='python:(member is not None) and \
-                            (portal.portal_membership.getHomeFolder() is not None) ',
-            permissions=('View',),
-            visible=True,
-            i18n_domain='plone')
-        object_category._setObject('mystuff', new_action)
-        # move action to top, at least before the logout action
-        object_category.moveObjectsToTop(('mystuff'))
-
-
-    def get_allow_anon_views_about(self):
-        return self.context.allowAnonymousViewAbout
-
-    def set_allow_anon_views_about(self, value):
-        self.context.allowAnonymousViewAbout = value
-
-    allow_anon_views_about = property(get_allow_anon_views_about,
-                                      set_allow_anon_views_about)
-
-    def get_use_email_as_login(self):
-        return self.context.getProperty('use_email_as_login')
-
-    def set_use_email_as_login(self, value):
-        context = aq_inner(self.context)
-        if context.getProperty('use_email_as_login') == value:
-            # no change
-            return
-        if value:
-            migrate_to_email_login(self.context)
-        else:
-            migrate_from_email_login(self.context)
-
-    use_email_as_login = property(get_use_email_as_login,
-                                  set_use_email_as_login)
-
-    def get_use_uuid_as_userid(self):
-        return self.context.getProperty('use_uuid_as_userid')
-
-    def set_use_uuid_as_userid(self, value):
-        self.context.manage_changeProperties(use_uuid_as_userid=value)
-
-    use_uuid_as_userid = property(get_use_uuid_as_userid,
-                                  set_use_uuid_as_userid)
-
-
-def migrate_to_email_login(context):
-    # Note that context could be the Plone Site or site_properties.
-    pas = getToolByName(context, 'acl_users')
-    pprop = getToolByName(context, 'portal_properties')
-    site_props = pprop.site_properties
-    site_props.manage_changeProperties(use_email_as_login=True)
-
-    # We want the login name to be lowercase here.  This is new in
-    # PAS.  Using 'manage_changeProperties' would change the login
-    # names immediately, but we want to do that explicitly ourselves
-    # and set the lowercase email address as login name, instead of
-    # the lower case user id.
-    #pas.manage_changeProperties(login_transform='lower')
-    pas.login_transform = 'lower'
-
-    # Update the users.
-    for user in pas.getUsers():
-        if user is None:
-            continue
-        user_id = user.getUserId()
-        email = user.getProperty('email', '')
-        if email:
-            login_name = pas.applyTransform(email)
-            pas.updateLoginName(user_id, login_name)
-        else:
-            logger.warn("User %s has no email address.", user_id)
-
-
-def migrate_from_email_login(context):
-    # Note that context could be the Plone Site or site_properties.
-    pas = getToolByName(context, 'acl_users')
-    pprop = getToolByName(context, 'portal_properties')
-    site_props = pprop.site_properties
-    site_props.manage_changeProperties(use_email_as_login=False)
-    # Whether the login name is lowercase or not does not really
-    # matter for this use case, but it may be better not to change
-    # it at this point.
-
-    # We do want to update the users.
-    for user in pas.getUsers():
-        if user is None:
-            continue
-        user_id = user.getUserId()
-        # If we keep the transform to lowercase, then we must apply it
-        # here as well, otherwise some users will not be able to
-        # login, as their user id may be mixed or upper case.
-        login_name = pas.applyTransform(user_id)
-        pas.updateLoginName(user_id, login_name)
-
-
-class SecurityControlPanel(ControlPanelForm):
-
-    form_fields = FormFields(ISecuritySchema)
-
-    label = _("Security settings")
-    description = _("Security settings for this site.")
-    form_name = _("Security settings")
-
-
-class EmailLogin(BrowserView):
-    """View to help in migrating to or from using email as login.
-
-    We used to change the login name of existing users here, but that
-    is now done by checking or unchecking the option in the security
-    control panel.  Here you can only search for duplicates.
-    """
-
-    duplicates = []
-
-    def __call__(self):
-        if self.request.form.get('check_email'):
-            self.duplicates = self.check_email()
-        elif self.request.form.get('check_userid'):
-            self.duplicates = self.check_userid()
-        return self.index()
-
-    @property
-    def _email_list(self):
-        context = aq_inner(self.context)
-        pas = getToolByName(context, 'acl_users')
-        emails = defaultdict(list)
-        orig_transform = pas.login_transform
-        try:
-            if not orig_transform:
-                # Temporarily set this to lower, as that will happen
-                # when turning emaillogin on.
-                pas.login_transform = 'lower'
-            for user in pas.getUsers():
-                if user is None:
-                    # Created in the ZMI?
-                    continue
-                email = user.getProperty('email', '')
-                if email:
-                    email = pas.applyTransform(email)
-                else:
-                    logger.warn("User %s has no email address.",
-                                user.getUserId())
-                    # Add the normal login name anyway.
-                    email = pas.applyTransform(user.getUserName())
-                emails[email].append(user.getUserId())
-        finally:
-            pas.login_transform = orig_transform
-            return emails
-
-    def check_email(self):
-        duplicates = []
-        for email, userids in self._email_list.items():
-            if len(userids) > 1:
-                logger.warn("Duplicate accounts for email address %s: %r",
-                            email, userids)
-                duplicates.append((email, userids))
-
-        return duplicates
-
-    @property
-    def _userid_list(self):
-        # user ids are unique, but their lowercase version might not
-        # be unique.
-        context = aq_inner(self.context)
-        pas = getToolByName(context, 'acl_users')
-        userids = defaultdict(list)
-        orig_transform = pas.login_transform
-        try:
-            if not orig_transform:
-                # Temporarily set this to lower, as that will happen
-                # when turning emaillogin on.
-                pas.login_transform = 'lower'
-            for user in pas.getUsers():
-                if user is None:
-                    continue
-                login_name = pas.applyTransform(user.getUserName())
-                userids[login_name].append(user.getUserId())
-        finally:
-            pas.login_transform = orig_transform
-            return userids
-
-    def check_userid(self):
-        duplicates = []
-        for login_name, userids in self._userid_list.items():
-            if len(userids) > 1:
-                logger.warn("Duplicate accounts for lower case user id "
-                            "%s: %r", login_name, userids)
-                duplicates.append((login_name, userids))
-
-        return duplicates
-
-    def switch_to_email(self):
-        # This is not used and is only here for backwards
-        # compatibility.  It avoids a test failure in
-        # Products.CMFPlone.
-        migrate_to_email_login(self.context)
-
-    def switch_to_userid(self):
-        # This is not used and is only here for backwards
-        # compatibility.  It avoids a test failure in
-        # Products.CMFPlone.
-        migrate_from_email_login(self.context)
+# Control panels for Plone 5 have been moved to CMFPlone. We keep those imports
+# for backwards compatibility.
+from Products.CMFPlone.interfaces import ISecuritySchema  # noqa
+from Products.CMFPlone.controlpanel.security import SecurityControlPanel  # noqa
+from Products.CMFPlone.controlpanel.bbb.security import SecurityControlPanelAdapter  # noqa
diff --git a/plone/app/controlpanel/site.py b/plone/app/controlpanel/site.py
index ffde62f..1c70bc3 100644
--- a/plone/app/controlpanel/site.py
+++ b/plone/app/controlpanel/site.py
@@ -1,141 +1,5 @@
-from zope.formlib.textwidgets import TextAreaWidget
-from zope.component import adapts
-from zope.formlib import form
-from zope.interface import Interface
-from zope.interface import implements
-from zope.schema import Bool
-from zope.schema import Text
-from zope.schema import TextLine
-from zope.schema import SourceText
-from zope.site.hooks import getSite
-
-from Products.CMFCore.utils import getToolByName
-from Products.CMFDefault.formlib.schema import ProxyFieldProperty
-from Products.CMFDefault.formlib.schema import SchemaAdapterBase
-from Products.CMFPlone import PloneMessageFactory as _
-from Products.CMFPlone.interfaces import IPloneSiteRoot
-from Products.CMFPlone.utils import safe_unicode
-
-from form import ControlPanelForm
-
-
-class ISiteSchema(Interface):
-
-    site_title = TextLine(title=_(u'Site title'),
-                          description=_(u"This shows up in the title bar of "
-                                        "browsers and in syndication feeds."),
-                          default=u'')
-
-    site_description = Text(title=_(u'Site description'),
-                           description=_(u"The site description is available "
-                               "in syndicated content and in search engines. "
-                               "Keep it brief."),
-                           default=u'',
-                           required=False)
-
-    exposeDCMetaTags = Bool(title=_(u"Expose Dublin Core metadata"),
-                        description=_(u"Exposes the Dublin Core properties as metatags."),
-                        default=False,
-                        required=False)
-
-    display_pub_date_in_byline = Bool(
-        title=_(u"Display publication date in 'about' information"),
-        description=_(u"Displays content publication date on site pages."),
-        default=False,
-        required=False)
-
-    enable_sitemap = Bool(title=_(u"Expose sitemap.xml.gz"),
-                          description=_(u"Exposes your content as a file "
-                              "according to the sitemaps.org standard. You "
-                              "can submit this to compliant search engines "
-                              "like Google, Yahoo and Microsoft. It allows "
-                              "these search engines to more intelligently "
-                              "crawl your site."),
-                          default=False,
-                          required=False)
-
-    webstats_js = SourceText(title=_(u'JavaScript for web statistics support'),
-                        description=_(u"For enabling web statistics support "
-                              "from external providers (for e.g. Google "
-                              "Analytics). Paste the code snippets provided. "
-                              "It will be included in the rendered HTML as "
-                              "entered near the end of the page."),
-                        default=u'',
-                        required=False)
-
-
-class SiteControlPanelAdapter(SchemaAdapterBase):
-
-    adapts(IPloneSiteRoot)
-    implements(ISiteSchema)
-
-    def __init__(self, context):
-        super(SiteControlPanelAdapter, self).__init__(context)
-        self.portal = getSite()
-        pprop = getToolByName(self.portal, 'portal_properties')
-        self.context = pprop.site_properties
-        self.encoding = pprop.site_properties.default_charset
-
-    def get_site_title(self):
-        title = getattr(self.portal, 'title', u'')
-        return safe_unicode(title)
-
-    def set_site_title(self, value):
-        self.portal.title = value.encode(self.encoding)
-
-    def get_site_description(self):
-        description = getattr(self.portal, 'description', u'')
-        return safe_unicode(description)
-
-    def set_site_description(self, value):
-        if value is not None:
-            self.portal.description = value.encode(self.encoding)
-        else:
-            self.portal.description = ''
-
-    def get_webstats_js(self):
-        description = getattr(self.context, 'webstats_js', u'')
-        return safe_unicode(description)
-
-    def set_webstats_js(self, value):
-        if value is not None:
-            self.context.webstats_js = value.encode(self.encoding)
-        else:
-            self.context.webstats_js = ''
-
-    site_title = property(get_site_title, set_site_title)
-    site_description = property(get_site_description, set_site_description)
-    webstats_js = property(get_webstats_js, set_webstats_js)
-
-    enable_sitemap = ProxyFieldProperty(ISiteSchema['enable_sitemap'])
-    exposeDCMetaTags = ProxyFieldProperty(ISiteSchema['exposeDCMetaTags'])
-
-    def get_display_pub_date_in_byline(self):
-        return getattr(self.context.site_properties,
-                       'displayPublicationDateInByline', False)
-
-    def set_display_pub_date_in_byline(self, value):
-        self.context.site_properties.displayPublicationDateInByline = value
-
-    display_pub_date_in_byline = property(get_display_pub_date_in_byline,
-        set_display_pub_date_in_byline)
-
-class MiniTextAreaWidget(TextAreaWidget):
-
-    height = 3
-
-
-class SmallTextAreaWidget(TextAreaWidget):
-
-    height = 5
-
-
-class SiteControlPanel(ControlPanelForm):
-
-    form_fields = form.FormFields(ISiteSchema)
-    form_fields['site_description'].custom_widget = MiniTextAreaWidget
-    form_fields['webstats_js'].custom_widget = SmallTextAreaWidget
-
-    label = _("Site settings")
-    description = _("Site-wide settings.")
-    form_name = _("Site settings")
+# Control panels for Plone 5 have been moved to CMFPlone. We keep those imports
+# for backwards compatibility.
+from Products.CMFPlone.interfaces import ISiteSchema  # noqa
+from Products.CMFPlone.controlpanel.site import SiteControlPanel  # noqa
+from Products.CMFPlone.controlpanel.bbb.site import SiteControlPanelAdapter  # noqa
diff --git a/plone/app/controlpanel/types.py b/plone/app/controlpanel/types.py
index 53a6338..b0ac6a0 100644
--- a/plone/app/controlpanel/types.py
+++ b/plone/app/controlpanel/types.py
@@ -1,431 +1,3 @@
-# NO LONGER USED - MOVED TO Products.CMFPlone.controlpanel.browser.types
-from plone.app.workflow.remap import remap_workflow
-from plone.memoize.instance import memoize
-
-from zope.component import getUtility
-
-from zope.event import notify
-
-from zope.i18n import translate
-from zope.schema.interfaces import IVocabularyFactory
-
-from Acquisition import aq_inner
-
-from Products.CMFCore.utils import getToolByName
-from Products.CMFPlone import PloneMessageFactory as _
-from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile
-
-from plone.app.controlpanel.events import ConfigurationChangedEvent
-
-from plone.app.controlpanel.form import ControlPanelView
-
-
-def format_title(text, request=None):
-    ''' Format ans translate workflow title '''
-    if type(text) == str:
-        text = text.decode('utf-8')
-    return translate(text, domain='plone', context=request)
-
-
-def format_description(text, request=None):
-    # We expect the workflow to be a text of '- ' divided bullet points.
-    if type(text) == str:
-        text = text.decode('utf-8')
-    text = translate(text.strip(), domain='plone', context=request)
-    return [s.strip() for s in text.split('- ') if s]
-
-
-# These are convenient / user friendly versioning policies.
-VERSION_POLICIES = [
-        dict(id="off",
-             policy=(),
-             title=_(u"versioning_off",
-                     default=u"No versioning")),
-
-        dict(id="manual",
-             policy=("version_on_revert",),
-             title=_(u"versioning_manual",
-                     default=u"Manual")),
-
-        dict(id="automatic",
-             policy=("at_edit_autoversion", "version_on_revert"),
-             title=_(u"versioning_automatic",
-                     default=u"Automatic")),
-        ]
-
-class TypesControlPanel(ControlPanelView):
-
-    # Actions
-
-    template = ViewPageTemplateFile('types.pt')
-
-    @property
-    @memoize
-    def type_id(self):
-        type_id = self.request.get('type_id', None)
-        if type_id is None:
-            type_id=''
-        return type_id
-
-    @property
-    @memoize
-    def fti(self):
-        type_id = self.type_id
-        portal_types = getToolByName(self.context, 'portal_types')
-        return getattr(portal_types, type_id)
-
-    def __call__(self):
-        """Perform the update and redirect if necessary, or render the page
-        """
-        postback = True
-        context = aq_inner(self.context)
-
-        form = self.request.form
-        submitted = form.get('form.submitted', False)
-        save_button = form.get('form.button.Save', None) is not None
-        cancel_button = form.get('form.button.Cancel', None) is not None
-        type_id = form.get('old_type_id', None)
-
-        if submitted and not cancel_button:
-            if type_id:
-                portal_types = getToolByName(self.context, 'portal_types')
-                portal_repository = getToolByName(self.context,
-                                                  'portal_repository')
-                portal_properties = getToolByName(self.context,
-                                                  'portal_properties')
-                site_properties = getattr(portal_properties, 'site_properties')
-
-                fti = getattr(portal_types, type_id)
-
-                # Set FTI properties
-
-                addable = form.get('addable', False)
-                allow_discussion = form.get('allow_discussion', False)
-
-                fti.manage_changeProperties(global_allow = bool(addable),
-                                            allow_discussion = bool(allow_discussion))
-
-                version_policy = form.get('versionpolicy', "off")
-                if version_policy!=self.current_versioning_policy():
-                    newpolicy=[p for p in VERSION_POLICIES if p["id"]==version_policy][0]
-
-
-                    versionable_types = list(portal_repository.getVersionableContentTypes())
-                    if not newpolicy["policy"]:
-                        if type_id in versionable_types:
-                            versionable_types.remove(type_id)
-                    else:
-                        if type_id not in versionable_types:
-                            versionable_types.append(type_id)
-
-                    for policy in portal_repository.listPolicies():
-                        policy_id = policy.getId()
-                        if policy_id in newpolicy["policy"]:
-                            portal_repository.addPolicyForContentType(type_id, policy_id)
-                        else:
-                            portal_repository.removePolicyFromContentType(type_id, policy_id)
-
-                    portal_repository.setVersionableContentTypes(versionable_types)
-
-                searchable = form.get('searchable', False)
-                blacklisted = list(site_properties.getProperty('types_not_searched'))
-                if searchable and type_id in blacklisted:
-                    blacklisted.remove(type_id)
-                elif not searchable and type_id not in blacklisted:
-                    blacklisted.append(type_id)
-                site_properties.manage_changeProperties(types_not_searched = \
-                                                        blacklisted)
-
-                if type_id=='Link':
-                    redirect_links = form.get('redirect_links', False)
-                    site_properties.manage_changeProperties(redirect_links = \
-                                                            redirect_links)
-
-            # Update workflow
-            if self.have_new_workflow() and \
-               form.get('form.workflow.submitted', False) and \
-               save_button:
-                if self.new_workflow_is_different():
-                    new_wf = self.new_workflow()
-                    if new_wf == '[none]':
-                        chain = ()
-                    elif new_wf == '(Default)':
-                        chain = new_wf
-                    else:
-                        chain = (new_wf,)
-                    state_map = dict([(s['old_state'], s['new_state']) for s in \
-                                      form.get('new_wfstates', [])])
-                    if state_map.has_key('[none]'):
-                        state_map[None] = state_map['[none]']
-                        del state_map['[none]']
-                    if type_id:
-                        type_ids=(type_id,)
-                    else:
-                        wt = getToolByName(self.context, 'portal_workflow')
-                        tt = getToolByName(self.context, 'portal_types')
-                        nondefault = [info[0] for info in wt.listChainOverrides()]
-                        type_ids = [type for type in tt.listContentTypes() if type not in nondefault]
-                        wt.setChainForPortalTypes(type_ids, wt.getDefaultChain())
-                        wt.setDefaultChain(','.join(chain))
-                        chain='(Default)'
-
-                    remap_workflow(context, type_ids=type_ids, chain=chain,
-                                   state_map=state_map)
-
-                    data = {'workflow': new_wf}
-                    notify(ConfigurationChangedEvent(self, data))
-
-                else:
-                    portal_workflow = getToolByName(context, 'portal_workflow')
-                    if self.new_workflow()=='(Default)':
-                        # The WorkflowTool API can not handle this sanely
-                        cbt=portal_workflow._chains_by_type
-                        if cbt.has_key(type_id):
-                            del cbt[type_id]
-                    else:
-                        portal_workflow.setChainForPortalTypes((type_id,),
-                                self.new_workflow())
-
-                self.request.response.redirect('%s/@@types-controlpanel?\
-type_id=%s' % (context.absolute_url() , type_id))
-                postback = False
-
-        elif cancel_button:
-            self.request.response.redirect(self.context.absolute_url() + \
-                                           '/plone_control_panel')
-            postback = False
-
-        if postback:
-            return self.template()
-
-    # View
-
-    def versioning_policies(self):
-        return VERSION_POLICIES
-
-    @memoize
-    def selectable_types(self):
-        vocab_factory = getUtility(IVocabularyFactory,
-                                   name="plone.app.vocabularies.ReallyUserFriendlyTypes")
-        types = []
-        for v in vocab_factory(self.context):
-            if v.title:
-                title = translate(v.title, context=self.request)
-            else:
-                title = translate(v.token, domain='plone', context=self.request)
-            types.append(dict(id=v.value, title=title) )
-        def _key(v):
-            return v['title']
-        types.sort(key=_key)
-        return types
-
-    def selected_type_title(self):
-        return self.fti.Title()
-
-    def selected_type_description(self):
-        return self.fti.Description()
-
-    def is_addable(self):
-        return self.fti.getProperty('global_allow', False)
-
-    def is_discussion_allowed(self):
-        return self.fti.getProperty('allow_discussion', False)
-
-    def current_versioning_policy(self):
-        portal_repository = getToolByName(self.context, 'portal_repository')
-        if self.type_id not in portal_repository.getVersionableContentTypes():
-            return "off"
-        policy = set(portal_repository.getPolicyMap().get(self.type_id, ()))
-        for info in VERSION_POLICIES:
-            if set(info["policy"]) == policy:
-                return info["id"]
-        return None
-
-    def is_searchable(self):
-        context = aq_inner(self.context)
-        portal_properties = getToolByName(context, 'portal_properties')
-        blacklisted = portal_properties.site_properties.types_not_searched
-        return (self.type_id not in blacklisted)
-
-    def is_redirect_links_enabled(self):
-        context = aq_inner(self.context)
-        portal_properties = getToolByName(context, 'portal_properties')
-        site_props = portal_properties.site_properties
-        return self.type_id == 'Link' and site_props.getProperty('redirect_links') or False
-
-    @memoize
-    def current_workflow(self):
-        context = aq_inner(self.context)
-        portal_workflow = getToolByName(context, 'portal_workflow')
-        default_workflow = self.default_workflow(False)
-        nondefault = [info[0] for info in portal_workflow.listChainOverrides()]
-        chain = portal_workflow.getChainForPortalType(self.type_id)
-        empty_workflow_dict = dict(id='[none]',
-                                   title=_(u"label_no_workflow"),
-                                   description= [_(u"description_no_workflow",
-                                   default=u"This type has no workflow. The visibilty "
-                                       u"of items of this type is determined by "
-                                       u"the folder they are in.")])
-
-        if self.type_id in nondefault:
-            if chain:
-                wf_id = chain[0]
-                wf = getattr(portal_workflow, wf_id)
-                title = format_title(wf.title, request=self.request)
-                return dict(id=wf.id, title=title,
-                            description=format_description(wf.description,
-                                                           self.request))
-            else:
-                return empty_workflow_dict
-
-        if default_workflow == '[none]':
-            return empty_workflow_dict
-
-        default_title = format_title(default_workflow.title,
-                                     request=self.request)
-        default_description = format_description(default_workflow.description,
-                                                 request=self.request)
-        return dict(id='(Default)',
-                    title=_(u"label_default_workflow_title",
-                        default=u"Default workflow (${title})",
-                        mapping=dict(title=default_title)),
-                    description=default_description)
-
-
-    def available_workflows(self):
-        vocab_factory = getUtility(IVocabularyFactory,
-                                   name="plone.app.vocabularies.Workflows")
-        workflows = []
-        for v in vocab_factory(self.context):
-            if v.title:
-                title = translate(v.title, context=self.request)
-            else:
-                title = translate(v.token, domain='plone', context=self.request)
-            workflows.append(dict(id=v.value, title=title) )
-        def _key(v):
-            return v['title']
-        workflows.sort(key=_key)
-
-        default_workflow = self.default_workflow(False)
-        if self.type_id and default_workflow != '[none]':
-            # Only offer a default workflow option on a real type
-            default_workflow = self.default_workflow(False)
-            default_title = translate(default_workflow.title,
-                                      domain='plone', context=self.request)
-            workflows.insert(0, dict(id='(Default)',
-                    title=_(u"label_default_workflow_title",
-                            default=u"Default workflow (${title})",
-                            mapping=dict(title=default_title)),
-                    description=format_description(default_workflow.description, self.request)))
-
-        return workflows
-
-    @memoize
-    def new_workflow(self):
-        current_workflow = self.current_workflow()['id']
-        if self.type_id=='':
-            # If we are looking at the default workflow we need to show
-            # the real workflow
-            current_workflow=self.real_workflow(current_workflow)
-        old_type_id = self.request.form.get('old_type_id', self.type_id)
-        if old_type_id != self.type_id:
-            return current_workflow
-        else:
-            return self.request.form.get('new_workflow', current_workflow)
-
-    @memoize
-    def have_new_workflow(self):
-        return self.current_workflow()['id'] != self.new_workflow()
-
-    @memoize
-    def default_workflow(self, id_only=True):
-        portal_workflow = getToolByName(self.context, 'portal_workflow')
-        default_chain = portal_workflow.getDefaultChain()
-        if not default_chain:
-            # There is no default workflow
-            return '[none]'
-        id = default_chain[0]
-        if id_only:
-            return id
-        else:
-            return portal_workflow.getWorkflowById(id)
-
-    @memoize
-    def real_workflow(self, wf):
-        if wf=='(Default)':
-            return self.default_workflow()
-        else:
-            return wf
-
-    @memoize
-    def new_workflow_is_different(self):
-        new_workflow = self.new_workflow()
-        current_workflow = self.current_workflow()['id']
-
-        return self.real_workflow(new_workflow)!=self.real_workflow(current_workflow)
-
-    @memoize
-    def new_workflow_is_none(self):
-        return self.new_workflow() == '[none]'
-
-    def new_workflow_description(self):
-        portal_workflow = getToolByName(self.context, 'portal_workflow')
-        new_workflow = self.new_workflow()
-
-        if self.new_workflow_is_different():
-            if self.new_workflow_is_none():
-                return [_(u"description_no_workflow",
-                    default=u"This type has no workflow. The visibilty of "
-                            u"items of this type is determined by the "
-                            u"folder they are in.")]
-            new_workflow = self.real_workflow(self.new_workflow())
-            wf = getattr(portal_workflow, new_workflow)
-            return format_description(wf.description, self.request)
-
-        return None
-
-
-    def new_workflow_available_states(self):
-        if self.new_workflow_is_different():
-            new_workflow = self.real_workflow(self.new_workflow())
-            portal_workflow = getToolByName(self.context, 'portal_workflow')
-            wf = getattr(portal_workflow, new_workflow)
-            states = []
-            for s in wf.states.objectValues():
-                title = translate(s.title, domain='plone', context=self.request)
-                states.append(dict(id=s.id, title=title))
-            return states
-        else:
-            return []
-
-    def suggested_state_map(self):
-        current_workflow = self.real_workflow(self.current_workflow()['id'])
-        new_workflow = self.real_workflow(self.new_workflow())
-
-        portal_workflow = getToolByName(self.context, 'portal_workflow')
-
-        if current_workflow == '[none]':
-            new_wf = getattr(portal_workflow, new_workflow)
-            default_state = new_wf.initial_state
-            return [dict(old_id = '[none]',
-                         old_title = _(u"No workflow"),
-                         suggested_id = default_state)]
-
-        elif self.new_workflow_is_different():
-            old_wf = getattr(portal_workflow, current_workflow)
-            new_wf = getattr(portal_workflow, new_workflow)
-
-            new_states = set([s.id for s in new_wf.states.objectValues()])
-            default_state = new_wf.initial_state
-
-            states = []
-            for old in old_wf.states.objectValues():
-                title = translate(old.title, domain='plone', context=self.request)
-                states.append(
-                    dict(old_id = old.id,
-                         old_title = title,
-                         suggested_id = (old.id in new_states and \
-                                         old.id or default_state)))
-            return states
-        else:
-            return []
+# Control panels for Plone 5 have been moved to CMFPlone. We keep those imports
+# for backwards compatibility.
+from Products.CMFPlone.controlpanel.types import TypesControlPanel  # noqa


