Repository: plone.registry


Branch: refs/heads/master
Date: 2015-10-08T10:50:47+02:00
Author: Jens W. Klein (jensens) <jk@kleinundpartner.at>
Commit: https://github.com/plone/plone.registry/commit/f2ec427fc7965f48b65b962df13ff07ae6c85951

Cleanup: Pep8, utf8 headers, whitespace fixes, readability, ReST-fixes, doc-style, etc.

Files changed:
M CHANGES.rst
M README.rst
M plone/__init__.py
M plone/registry/__init__.py
M plone/registry/events.py
M plone/registry/events.rst
M plone/registry/field.py
M plone/registry/field.rst
M plone/registry/fieldfactory.py
M plone/registry/fieldref.py
M plone/registry/record.py
M plone/registry/recordsproxy.py
M plone/registry/registry.py
M plone/registry/registry.rst
M plone/registry/tests.py
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 847f6d6..01968ab 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,7 +4,9 @@ Changelog
 1.0.3 (unreleased)
 ------------------
 
-- Nothing changed yet.
+- Cleanup: Pep8, utf8 headers, whitespace fixes, readability, ReST-fixes,
+  doc-style, etc.
+  [jensens]
 
 
 1.0.2 (2014-09-11)
diff --git a/README.rst b/README.rst
index 52870d5..2b77954 100644
--- a/README.rst
+++ b/README.rst
@@ -9,8 +9,5 @@ well as a ``field`` that describes the record in more detail. At a minimum, the
 field contains information about the type of value allowed, as well as a short
 title describing the record's purpose.
 
-See the following doctests for more details:
+.. contents:: Table of Contents
 
-* ``registry.rst``, which demonstrates how registries and records work
-* ``events.rst``, which shows the events that are fired from the registry
-* ``field.rst``, which describes the behaviour of persistent fields
diff --git a/plone/__init__.py b/plone/__init__.py
index f48ad10..68c04af 100644
--- a/plone/__init__.py
+++ b/plone/__init__.py
@@ -1,6 +1,2 @@
-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages
-try:
-    __import__('pkg_resources').declare_namespace(__name__)
-except ImportError:
-    from pkgutil import extend_path
-    __path__ = extend_path(__path__, __name__)
+# -*- coding: utf-8 -*-
+__import__('pkg_resources').declare_namespace(__name__)
diff --git a/plone/registry/__init__.py b/plone/registry/__init__.py
index 21fdd4a..347516c 100644
--- a/plone/registry/__init__.py
+++ b/plone/registry/__init__.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from plone.registry.registry import Registry
 from plone.registry.record import Record
-from plone.registry.fieldref import FieldRef
\ No newline at end of file
+from plone.registry.fieldref import FieldRef
diff --git a/plone/registry/events.py b/plone/registry/events.py
index ed9349b..a086c53 100644
--- a/plone/registry/events.py
+++ b/plone/registry/events.py
@@ -1,16 +1,17 @@
-from zope.interface import implements
-from zope.component import subscribers, adapter
-
-from plone.registry.interfaces import IRecordEvent
+# -*- coding: utf-8 -*-
+from plone.registry.interfaces import IInterfaceAwareRecord
 from plone.registry.interfaces import IRecordAddedEvent
-from plone.registry.interfaces import IRecordRemovedEvent
+from plone.registry.interfaces import IRecordEvent
 from plone.registry.interfaces import IRecordModifiedEvent
-from plone.registry.interfaces import IInterfaceAwareRecord
-
+from plone.registry.interfaces import IRecordRemovedEvent
 from plone.registry.recordsproxy import RecordsProxy
+from zope.component import adapter
+from zope.component import subscribers
+from zope.interface import implementer
+
 
+@implementer(IRecordEvent)
 class RecordEvent(object):
-    implements(IRecordEvent)
 
     def __init__(self, record):
         self.record = record
@@ -18,20 +19,26 @@ def __init__(self, record):
     def __repr__(self):
         return "<%s for %s>" % (self.__class__.__name__, self.record.__name__)
 
+
+@implementer(IRecordAddedEvent)
 class RecordAddedEvent(RecordEvent):
-    implements(IRecordAddedEvent)
+    """record added"""
 
+
+@implementer(IRecordRemovedEvent)
 class RecordRemovedEvent(RecordEvent):
-    implements(IRecordRemovedEvent)
+    """record removed"""
+
 
+@implementer(IRecordModifiedEvent)
 class RecordModifiedEvent(RecordEvent):
-    implements(IRecordModifiedEvent)
 
     def __init__(self, record, oldValue, newValue):
         super(RecordModifiedEvent, self).__init__(record)
         self.oldValue = oldValue
         self.newValue = newValue
 
+
 @adapter(IRecordEvent)
 def redispatchInterfaceAwareRecordEvents(event):
     """When an interface-aware record received a record event,
@@ -53,5 +60,5 @@ def redispatchInterfaceAwareRecordEvents(event):
     proxy = RecordsProxy(record.__parent__, schema)
 
     adapters = subscribers((proxy, event), None)
-    for adapter in adapters:
-        pass # getting them does the work
\ No newline at end of file
+    for ad in adapters:
+        pass  # getting them does the work
diff --git a/plone/registry/events.rst b/plone/registry/events.rst
index 452031a..a0df49c 100644
--- a/plone/registry/events.rst
+++ b/plone/registry/events.rst
@@ -4,21 +4,21 @@ Registry events
 
 The registry fires certain events. These are:
 
- * `plone.registry.interfaces.IRecordAddedEvent`, when a record has been
-    added to the registry.
+``plone.registry.interfaces.IRecordAddedEvent``
+    when a record has been added to the registry.
 
- * `plone.registry.interfaces.IRecordRemovedEvent`, when a record has been
-    removed from the registry.
+``plone.registry.interfaces.IRecordRemovedEvent``
+    when a record has been removed from the registry.
 
- * `plone.registry.interfaces.IRecordModifiedEvent`, when a record's value is
-    modified.
+``plone.registry.interfaces.IRecordModifiedEvent``,
+    when a record's value is modified.
 
-To test these events, we will create, modify and remove a few records:
+To test these events, we will create, modify and remove a few records::
 
     >>> from plone.registry import Registry, Record, field
     >>> registry = Registry()
 
-Adding a new record to the registry should fire IRecordAddedEvents:
+Adding a new record to the registry should fire ``IRecordAddedEvents``::
 
     >>> registry.records['plone.registry.tests.age'] = \
     ...     Record(field.Int(title=u"Age", min=0, default=18))
@@ -26,22 +26,21 @@ Adding a new record to the registry should fire IRecordAddedEvents:
     >>> registry.records['plone.registry.tests.cms'] = \
     ...     Record(field.TextLine(title=u"Preferred CMS"), value=u"Plone")
 
-When creating records from an interface, one event is fired for each field
-in the interface.
+When creating records from an interface, one event is fired for each field in the interface::
 
     >>> from plone.registry.tests import IMailSettings
     >>> registry.registerInterface(IMailSettings)
 
-Deleting a record should fire an IRecordRemovedEvent:
+Deleting a record should fire an ``IRecordRemovedEvent``::
 
     >>> del registry.records['plone.registry.tests.cms']
 
-Changing a record should fire an IRecordModifiedEvent:
+Changing a record should fire an ``IRecordModifiedEvent``::
 
     >>> registry['plone.registry.tests.age'] = 25
     >>> registry.records['plone.registry.tests.age'].value = 24
 
-Let's take a look at the events that were just fired:
+Let's take a look at the events that were just fired::
 
     >>> from plone.registry.interfaces import IRecordEvent
     >>> from zope.component.eventtesting import getEvents
@@ -54,8 +53,7 @@ Let's take a look at the events that were just fired:
      <RecordModifiedEvent for plone.registry.tests.age>,
      <RecordModifiedEvent for plone.registry.tests.age>]
 
-For the modified events, we can also check the value before and after the
-change.
+For the modified events, we can also check the value before and after the change::
 
     >>> from plone.registry.interfaces import IRecordModifiedEvent
     >>> [(repr(e), e.oldValue, e.newValue,) for e in getEvents(IRecordModifiedEvent)]
@@ -65,12 +63,13 @@ change.
 IObjectEvent-style redispatchers
 ================================
 
-There is a special event handler which takes care of re-dispatching registry
-events based on the schema interface prescribed by the record.
+There is a special event handler.
+It takes care of re-dispatching registry events based on the schema interface prescribed by the record.
 
-Let's re-set the event testing framework and register the re-dispatching event
-subscriber. Normally, this would happen automatically by including this
-package's ZCML.
+Let's re-set the event testing framework and register the re-dispatching event subscriber.
+Normally, this would happen automatically by including this package's ZCML.
+
+::
 
     >>> from zope.component.eventtesting import clearEvents
     >>> from zope.component import provideHandler
@@ -78,16 +77,14 @@ package's ZCML.
     >>> clearEvents()
     >>> provideHandler(redispatchInterfaceAwareRecordEvents)
 
-We'll then register a schema interface.
+We'll then register a schema interface::
 
     >>> from plone.registry.tests import IMailSettings
     >>> registry.registerInterface(IMailSettings)
 
-We could now register an event handler to print any record event occurring on
-an IMailSettings record. More specialised event handlers for e.g.
-IRecordModifiedEvent or IRecordRemovedEvent are of course also possible.
-Note that it is not possible to re-dispatch IRecordAddedEvents, so these are
-never caught.
+We could now register an event handler to print any record event occurring on an ``IMailSettings`` record.
+More specialised event handlers for e.g. ``IRecordModifiedEvent`` or ``IRecordRemovedEvent`` are of course also possible.
+Note that it is not possible to re-dispatch ``IRecordAddedEvents``, so these are never caught.
 
     >>> from zope.component import adapter
     >>> @adapter(IMailSettings, IRecordEvent)
@@ -95,23 +92,23 @@ never caught.
     ...     print "Got", event, "for", proxy
     >>> provideHandler(print_mail_settings_events)
 
-Let's now modify one of the records for this interface. The event handler
-should react immediately.
+Let's now modify one of the records for this interface.
+The event handler should react immediately::
 
     >>> registry['plone.registry.tests.IMailSettings.sender'] = u"Some sender"
     Got <RecordModifiedEvent for plone.registry.tests.IMailSettings.sender> for <RecordsProxy for plone.registry.tests.IMailSettings>
 
-Let's also modify a non-interface-aware record, for comparison's sake. Here,
-there is nothing printed.
+Let's also modify a non-interface-aware record, for comparison's sake.
+Here, there is nothing printed::
 
     >>> registry['plone.registry.tests.age'] = 3
 
-We can try a record-removed event as well:
+We can try a record-removed event as well::
 
     >>> del registry.records['plone.registry.tests.IMailSettings.sender']
     Got <RecordRemovedEvent for plone.registry.tests.IMailSettings.sender> for <RecordsProxy for plone.registry.tests.IMailSettings>
 
-The basic events that have been dispatched are:
+The basic events that have been dispatched are::
 
     >>> getEvents(IRecordEvent)
     [<RecordAddedEvent for plone.registry.tests.IMailSettings.sender>,
diff --git a/plone/registry/field.py b/plone/registry/field.py
index 0a27051..2150d31 100644
--- a/plone/registry/field.py
+++ b/plone/registry/field.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 """This module defines persistent versions of various fields.
 
 The idea is that when a record is created, we copy relevant field properties
@@ -5,30 +6,30 @@
 persistent field. Not all field types are supported, but the common types
 are.
 """
-
-import zope.interface
-
-import zope.schema
-import zope.schema._field
-import zope.schema.vocabulary
-import zope.schema.interfaces
-
 from persistent import Persistent
-
 from plone.registry.interfaces import IPersistentField
+from zope.interface import implementer
+from zope.schema.interfaces import IContextSourceBinder
+from zope.schema.vocabulary import SimpleVocabulary
+import zope.schema
+import zope.schema._field
 
 _missing_value_marker = object()
 
+
 def is_primitive(value):
     return value is None or \
-            isinstance(value, (int, long, bool, str, unicode, tuple, list,
-                                set, frozenset, dict, float))
+            isinstance(
+                value,
+                (int, long, bool, str, unicode, tuple,
+                 list, set, frozenset, dict, float)
+            )
+
 
 class DisallowedProperty(object):
     """A property that may not be set on an instance. It may still be set
     defined in a base class.
     """
-
     uses = []
 
     def __init__(self, name):
@@ -46,12 +47,15 @@ def __get__(self, inst, type_=None):
         raise AttributeError(self._name)
 
     def __set__(self, inst, value):
-        raise ValueError(u"Persistent fields does not support setting the `%s` property" % self._name)
+        raise ValueError(
+            u"Persistent fields does not support setting the `{0}` "
+            u"property".format(self._name)
+        )
+
 
 class StubbornProperty(object):
     """A property that stays stubbornly at a single, pre-defined value.
     """
-
     uses = []
 
     def __init__(self, name, value):
@@ -65,10 +69,10 @@ def __set__(self, inst, value):
     def __get__(self, inst, type_=None):
         return self._value
 
+
 class InterfaceConstrainedProperty(object):
     """A property that may only contain values providing a certain interface.
     """
-
     uses = []
 
     def __init__(self, name, interface):
@@ -77,18 +81,24 @@ def __init__(self, name, interface):
         self._interface = interface
 
     def __set__(self, inst, value):
-        if value != inst.missing_value:
-            if not self._interface.providedBy(value):
-                raise ValueError(u"The property `%s` may only contain objects providing `%s`." %
-                                    (self._name, self._interface.__identifier__,))
+        if (
+            value != inst.missing_value
+            and not self._interface.providedBy(value)
+        ):
+            raise ValueError(
+                u"The property `{0}` may only contain objects "
+                "providing `{1}`.".format(
+                    self._name,
+                    self._interface.__identifier__,
+                )
+            )
         inst.__dict__[self._name] = value
 
+
+@implementer(IPersistentField)
 class PersistentField(Persistent):
     """Base class for persistent field definitions.
     """
-
-    zope.interface.implements(IPersistentField)
-
     # Persistent fields do not have an order
     order = StubbornProperty('order', -1)
 
@@ -100,87 +110,112 @@ class PersistentField(Persistent):
     interfaceName = None
     fieldName = None
 
-class PersistentCollectionField(PersistentField, zope.schema._field.AbstractCollection):
+
+class PersistentCollectionField(
+    PersistentField,
+    zope.schema._field.AbstractCollection
+):
     """Ensure that value_type is a persistent field
     """
-
     value_type = InterfaceConstrainedProperty('value_type', IPersistentField)
 
+
 class Bytes(PersistentField, zope.schema.Bytes):
     pass
 
+
 class BytesLine(PersistentField, zope.schema.BytesLine):
     pass
 
+
 class ASCII(PersistentField, zope.schema.ASCII):
     pass
 
+
 class ASCIILine(PersistentField, zope.schema.ASCIILine):
     pass
 
+
 class Text(PersistentField, zope.schema.Text):
     pass
 
+
 class TextLine(PersistentField, zope.schema.TextLine):
     pass
 
+
 class Bool(PersistentField, zope.schema.Bool):
     pass
 
+
 class Int(PersistentField, zope.schema.Int):
     pass
 
+
 class Float(PersistentField, zope.schema.Float):
     pass
 
+
 class Decimal(PersistentField, zope.schema.Decimal):
     pass
 
+
 class Tuple(PersistentCollectionField, zope.schema.Tuple):
     pass
 
+
 class List(PersistentCollectionField, zope.schema.List):
     pass
 
+
 class Set(PersistentCollectionField, zope.schema.Set):
     pass
 
+
 class FrozenSet(PersistentCollectionField, zope.schema.FrozenSet):
     pass
 
+
 class Password(PersistentField, zope.schema.Password):
     pass
 
+
 class Dict(PersistentField, zope.schema.Dict):
 
     key_type = InterfaceConstrainedProperty('key_type', IPersistentField)
     value_type = InterfaceConstrainedProperty('value_type', IPersistentField)
 
+
 class Datetime(PersistentField, zope.schema.Datetime):
     pass
 
+
 class Date(PersistentField, zope.schema.Date):
     pass
 
+
 class Timedelta(PersistentField, zope.schema.Timedelta):
     pass
 
+
 class SourceText(PersistentField, zope.schema.SourceText):
     pass
 
+
 class URI(PersistentField, zope.schema.URI):
     pass
 
+
 class Id(PersistentField, zope.schema.Id):
     pass
 
+
 class DottedName(PersistentField, zope.schema.DottedName):
     pass
 
-class Choice(PersistentField, zope.schema.Choice):
 
+class Choice(PersistentField, zope.schema.Choice):
     # We can only support string name or primitive=list vocabularies
-
     _values = None
     _vocabulary = None
 
@@ -195,8 +230,10 @@ def __init__(self, values=None, vocabulary=None, source=None, **kw):
                     )
             vocabulary = None
         elif source is not None:
-            raise ValueError("Persistent fields do not support sources, only named "
-                             "vocabularies or vocabularies based on simple value sets.")
+            raise ValueError(
+                "Persistent fields do not support sources, only named "
+                "vocabularies or vocabularies based on simple value sets."
+            )
 
         assert not (values is None and vocabulary is None), (
                "You must specify either values or vocabulary.")
@@ -206,11 +243,11 @@ def __init__(self, values=None, vocabulary=None, source=None, **kw):
         self.vocabularyName = None
 
         if values is not None:
-
             for value in values:
                 if not is_primitive(value):
-                    raise ValueError("Vocabulary values may only contain primitive values.")
-
+                    raise ValueError(
+                        "Vocabulary values may only contain primitive values."
+                    )
             self._values = values
         else:
             self.vocabularyName = vocabulary
@@ -231,7 +268,7 @@ def vocabulary(self):
         if self._vocabulary is not None:
             return self._vocabulary
         if self._values is not None:
-            return zope.schema.vocabulary.SimpleVocabulary.fromValues(self._values)
+            return SimpleVocabulary.fromValues(self._values)
     DisallowedProperty.uses.append('vocabulary')
 
     # override bind to allow us to keep constraints on the 'vocabulary'
@@ -239,7 +276,7 @@ def vocabulary(self):
     def bind(self, object):
         clone = zope.schema.Field.bind(self, object)
         # get registered vocabulary if needed:
-        if zope.schema.interfaces.IContextSourceBinder.providedBy(self.vocabulary):
+        if IContextSourceBinder.providedBy(self.vocabulary):
             clone._vocabulary = self.vocabulary(object)
             assert zope.schema.interfaces.ISource.providedBy(clone.vocabulary)
         elif clone.vocabulary is None and self.vocabularyName is not None:
diff --git a/plone/registry/field.rst b/plone/registry/field.rst
index 532328b..91a0ef8 100644
--- a/plone/registry/field.rst
+++ b/plone/registry/field.rst
@@ -2,23 +2,23 @@
 Persistent fields
 =================
 
-The persistent fields that are found in plone.registry.field are siblings of
-the ones found in zope.schema, with persistence mixed in. To avoid potentially
-breaking the registry with persistent references to symbols that may go away,
-we purposefully limit the number of fields supported. We also disallow some
-properties, and add some additional checks on others.
+The persistent fields that are found in ``plone.registry.field`` are siblings of the ones found in zope.schema,
+with persistence mixed in.
+To avoid potentially breaking the registry with persistent references to symbols that may go away,
+we purposefully limit the number of fields supported.
+We also disallow some properties, and add some additional checks on others.
 
 The standard fields
 ====================
 
 We will show each supported field in turn. For all fields, note that:
 
- * the `order` property will return -1 no matter what
- * setting the `constraint` property is diallowed
- * the `key_type` and `value_type` properties, where applicable, must be set
-   to a persistent field.
- * for `Choice` fields, only named vocabularies and vocabularies based on
-   simple values are supported: sources and IVocabulary objects are not.
+* the ``order`` property will return ``-1`` no matter what setting the ``constraint`` property is diallowed
+* the ``key_type`` and ``value_type`` properties, where applicable, must be set to a persistent field.
+* for ``Choice`` fields, only named vocabularies and vocabularies based on simple values are supported:
+  sources and ``IVocabulary`` objects are not.
+
+Imports needed::
 
     >>> from plone.registry import field
     >>> from zope import schema
@@ -27,7 +27,7 @@ We will show each supported field in turn. For all fields, note that:
 Bytes
 -----
 
-The bytes field describes a string of bytes.
+The bytes field describes a string of bytes::
 
     >>> f = field.Bytes(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.Bytes)
@@ -52,7 +52,7 @@ The bytes field describes a string of bytes.
 BytesLine
 ---------
 
-The bytes field describes a string of bytes, disallowing newlines.
+The bytes field describes a string of bytes, disallowing newlines::
 
     >>> f = field.BytesLine(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.BytesLine)
@@ -77,7 +77,7 @@ The bytes field describes a string of bytes, disallowing newlines.
 ASCII
 -----
 
-The ASCII field describes a string containing only ASCII characters.
+The ASCII field describes a string containing only ASCII characters::
 
     >>> f = field.ASCII(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.ASCII)
@@ -102,8 +102,7 @@ The ASCII field describes a string containing only ASCII characters.
 ASCIILine
 ---------
 
-The ASCII line field describes a string containing only ASCII characters and
-disallowing newlines.
+The ASCII line field describes a string containing only ASCII characters and disallowing newlines::
 
     >>> f = field.ASCIILine(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.ASCIILine)
@@ -128,7 +127,7 @@ disallowing newlines.
 Text
 ----
 
-The text field describes a unicode string.
+The text field describes a unicode string::
 
     >>> f = field.Text(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.Text)
@@ -153,7 +152,7 @@ The text field describes a unicode string.
 TextLine
 --------
 
-The text line field describes a unicode string, disallowing newlines
+The text line field describes a unicode string, disallowing newlines::
 
     >>> f = field.TextLine(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.TextLine)
@@ -178,7 +177,7 @@ The text line field describes a unicode string, disallowing newlines
 Bool
 ----
 
-The bool field describes a boolean.
+The bool field describes a boolean::
 
     >>> f = field.Bool(title=u"Test")
     >>> isinstance(f, schema.Bool)
@@ -203,7 +202,7 @@ The bool field describes a boolean.
 Int
 ---
 
-The int field describes an integer or long.
+The int field describes an integer or long::
 
     >>> f = field.Int(title=u"Test", min=-123, max=1234)
     >>> isinstance(f, schema.Int)
@@ -228,7 +227,7 @@ The int field describes an integer or long.
 Float
 -----
 
-The float field describes a float.
+The float field describes a float::
 
     >>> f = field.Float(title=u"Test", min=-123.0, max=1234.0)
     >>> isinstance(f, schema.Float)
@@ -253,7 +252,7 @@ The float field describes a float.
 Decimal
 -------
 
-The decimal field describes a decimal.
+The decimal field describes a decimal::
 
     >>> import decimal
     >>> f = field.Decimal(title=u"Test", min=decimal.Decimal('-123.0'), max=decimal.Decimal('1234.0'))
@@ -279,7 +278,7 @@ The decimal field describes a decimal.
 Password
 --------
 
-The password field describes a unicode string used for a password.
+The password field describes a unicode string used for a password::
 
     >>> f = field.Password(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.Password)
@@ -304,7 +303,7 @@ The password field describes a unicode string used for a password.
 SourceText
 ----------
 
-The source  text field describes a unicode string with source code.
+The source  text field describes a unicode string with source code::
 
     >>> f = field.SourceText(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.SourceText)
@@ -329,7 +328,7 @@ The source  text field describes a unicode string with source code.
 URI
 ---
 
-The URI field describes a URI string.
+The URI field describes a URI string::
 
     >>> f = field.URI(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.URI)
@@ -354,7 +353,7 @@ The URI field describes a URI string.
 Id
 --
 
-The id field describes a URI string or a dotted name.
+The id field describes a URI string or a dotted name::
 
     >>> f = field.Id(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.Id)
@@ -379,7 +378,7 @@ The id field describes a URI string or a dotted name.
 DottedName
 ----------
 
-The dotted name field describes a dotted name.
+The dotted name field describes a Python dotted name::
 
     >>> f = field.DottedName(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.DottedName)
@@ -404,7 +403,7 @@ The dotted name field describes a dotted name.
 Datetime
 --------
 
-The date/time field describes a Python datetime object.
+The date/time field describes a Python datetime object::
 
     >>> f = field.Datetime(title=u"Test")
     >>> isinstance(f, schema.Datetime)
@@ -430,7 +429,7 @@ The date/time field describes a Python datetime object.
 Date
 ----
 
-The date field describes a Python date object.
+The date field describes a Python date object::
 
     >>> f = field.Date(title=u"Test")
     >>> isinstance(f, schema.Date)
@@ -456,7 +455,7 @@ The date field describes a Python date object.
 Timedelta
 ---------
 
-The time-delta field describes a Python timedelta object.
+The time-delta field describes a Python timedelta object::
 
     >>> f = field.Timedelta(title=u"Test")
     >>> isinstance(f, schema.Timedelta)
@@ -482,7 +481,7 @@ The time-delta field describes a Python timedelta object.
 Tuple
 -----
 
-The tuple field describes a tuple.
+The tuple field describes a tuple::
 
     >>> f = field.Tuple(title=u"Test", min_length=0, max_length=10,
     ...     value_type=field.TextLine(title=u"Value"))
@@ -519,7 +518,7 @@ The tuple field describes a tuple.
 List
 ----
 
-The list field describes a tuple.
+The list field describes a tuple::
 
     >>> f = field.List(title=u"Test", min_length=0, max_length=10,
     ...     value_type=field.TextLine(title=u"Value"))
@@ -556,7 +555,7 @@ The list field describes a tuple.
 Set
 ---
 
-The set field describes a set.
+The set field describes a set::
 
     >>> f = field.Set(title=u"Test", min_length=0, max_length=10,
     ...     value_type=field.TextLine(title=u"Value"))
@@ -593,7 +592,7 @@ The set field describes a set.
 Frozenset
 ---------
 
-The set field describes a frozenset.
+The set field describes a frozenset::
 
     >>> f = field.FrozenSet(title=u"Test", min_length=0, max_length=10,
     ...     value_type=field.TextLine(title=u"Value"))
@@ -630,7 +629,7 @@ The set field describes a frozenset.
 Dict
 ----
 
-The set field describes a dict.
+The set field describes a dict::
 
     >>> f = field.Dict(title=u"Test", min_length=0, max_length=10,
     ...     key_type=field.ASCII(title=u"Key"),
@@ -681,9 +680,9 @@ The set field describes a dict.
 Choice
 ------
 
-A choice field represents a selection from a vocabulary. For persistent
-fields, the vocabulary cannot be a `source` or any kind of object: it must
-either be a list of primitives, or a named vocabulary.
+A choice field represents a selection from a vocabulary.
+For persistent fields, the vocabulary cannot be a ``source`` or any kind of object:
+it must either be a list of primitives, or a named vocabulary::
 
     >>> f = field.Choice(title=u"Test", values=[1,2,3])
     >>> isinstance(f, schema.Choice)
@@ -692,8 +691,8 @@ either be a list of primitives, or a named vocabulary.
     >>> f.order
     -1
 
-With a list of values given, the `vocabulary` property returns a vocabulary
-constructed from the values on the fly, and `vocabularyName` is None.
+With a list of values given, the ``vocabulary`` property returns a vocabulary
+constructed from the values on the fly, and ``vocabularyName`` is ``None``::
 
     >>> f.vocabulary
     <zope.schema.vocabulary.SimpleVocabulary object at ...>
@@ -701,15 +700,14 @@ constructed from the values on the fly, and `vocabularyName` is None.
     >>> f.vocabularyName is None
     True
 
-We will, however, get an error if we use anything other than primitives:
+We will get an error if we use anything other than primitives::
 
     >>> f = field.Choice(title=u"Test", values=[object(), object()])
     Traceback (most recent call last):
     ...
     ValueError: Vocabulary values may only contain primitive values.
 
-If a vocabulary name given, it is stored in `vocabularyName`, and the
-`vocabulary` property returns None.
+If a vocabulary name given, it is stored in ``vocabularyName``, and the ``vocabulary`` property returns ``None``::
 
     >>> f = field.Choice(title=u"Test", vocabulary='my.vocab')
     >>> f.vocabulary is None
@@ -718,21 +716,21 @@ If a vocabulary name given, it is stored in `vocabularyName`, and the
     >>> f.vocabularyName
     'my.vocab'
 
-Other combinations are now allowed, such as specifying no vocabulary:
+Other combinations are now allowed, such as specifying no vocabulary::
 
     >>> field.Choice(title=u"Test")
     Traceback (most recent call last):
     ...
     AssertionError: You must specify either values or vocabulary.
 
-Or specifying both types:
+Or specifying both types::
 
     >>> field.Choice(title=u"Test", values=[1,2,3], vocabulary='my.vocab')
     Traceback (most recent call last):
     ...
     AssertionError: You cannot specify both values and vocabulary.
 
-Or specifying an object source:
+Or specifying an object source::
 
     >>> from zope.schema.vocabulary import SimpleVocabulary
     >>> dummy_vocabulary = SimpleVocabulary.fromValues([1,2,3])
@@ -741,14 +739,14 @@ Or specifying an object source:
     ...
     ValueError: Persistent fields do not support sources, only named vocabularies or vocabularies based on simple value sets.
 
-Or specifying an object vocabulary:
+Or specifying an object vocabulary::
 
     >>> field.Choice(title=u"Test", vocabulary=dummy_vocabulary)
     Traceback (most recent call last):
     ...
     ValueError: Persistent fields only support named vocabularies or vocabularies based on simple value sets.
 
-As with other fields, you also cannot set a constraint:
+As with other fields, you also cannot set a constraint::
 
     >>> field.Choice(title=u"Test", values=[1,2,3], constraint=lambda x: True)
     Traceback (most recent call last):
@@ -763,13 +761,12 @@ As with other fields, you also cannot set a constraint:
     >>> f.constraint('ABC')
     True
 
-IPersistentField adapters
-=========================
+``IPersistentField`` adapters
+=============================
 
-It is possible to adapt any non-persistent field to its related
-IPersistentField using the adapter factories in plone.registry.fieldfactory.
-These are set up in configure.zcml and explicitly registered in the test
-setup in tests.py. Custom adapters are of course also possible.
+It is possible to adapt any non-persistent field to its related ``IPersistentField`` using the adapter factories in ``plone.registry`` fieldfactory.
+These are set up in ``configure.zcml`` and explicitly registered in the test setup in ``tests.py``.
+Custom adapters are of course also possible::
 
     >>> from plone.registry.interfaces import IPersistentField
 
@@ -784,7 +781,7 @@ setup in tests.py. Custom adapters are of course also possible.
     >>> isinstance(p, field.TextLine)
     True
 
-Unsupported field types will not be adaptable by default.
+Unsupported field types will not be adaptable by default::
 
     >>> f = schema.Object(title=u"Object", schema=IPersistentField)
     >>> IPersistentField(f, None) is None
@@ -794,13 +791,14 @@ Unsupported field types will not be adaptable by default.
     >>> IPersistentField(f, None) is None
     True
 
-After adaptation, the rules of persistent fields apply: The `order` attribute
-is perpetually -1, custom constraints are not allowed, and key and value type
-will be adapted to persistent fields as well. If any of these constraints
-cannot be met, the adaptation will fail.
+After adaptation, the rules of persistent fields apply:
+The ``order`` attribute is perpetually ``-1``.
+Custom constraints are not allowed, and key and value type will be adapted to persistent fields as well.
+If any of these constraints can not be met, the adaptation will fail.
+
+For constraints, the non-persistent value is simply ignored and the default method from the class will be used.
 
-For constraints, the non-persistent value is simply ignored and the default
-method from the class will be used.
+::
 
     >>> f = schema.TextLine(title=u"Test", constraint=lambda x: False)
     >>> f.constraint
@@ -810,7 +808,7 @@ method from the class will be used.
     >>> p.constraint
     <bound method TextLine.constraint of <plone.registry.field.TextLine object at ...>>
 
-The order property is similarly ignored:
+The order property is similarly ignored::
 
     >>> f.order > 0
     True
@@ -818,7 +816,7 @@ The order property is similarly ignored:
     >>> p.order
     -1
 
-Key/value types will be adapted if possible.
+Key/value types will be adapted if possible::
 
     >>> f = schema.Dict(title=u"Test",
     ...     key_type=schema.Id(title=u"Id"),
@@ -830,7 +828,7 @@ Key/value types will be adapted if possible.
     >>> p.value_type
     <plone.registry.field.TextLine object at ...>
 
-However, if they cannot be adapted, there will be an error.
+If they cannot be adapted, there will be an error::
 
     >>> f = schema.Dict(title=u"Test",
     ...     key_type=schema.Id(title=u"Id"),
@@ -848,9 +846,10 @@ However, if they cannot be adapted, there will be an error.
     ...
     TypeError: ('Could not adapt', <zope.schema._field.Dict object at ...>, <InterfaceClass plone.registry.interfaces.IPersistentField>)
 
-There is additional validation for choice fields that warrant a custom
-adapter. These ensure that vocabularies are either stored as a list of
-simple values, or as named vocabularies.
+There is additional validation for choice fields that warrant a custom adapter.
+These ensure that vocabularies are either stored as a list of simple values, or as named vocabularies.
+
+::
 
     >>> f = schema.Choice(title=u"Test", values=[1,2,3])
     >>> p = IPersistentField(f)
@@ -870,7 +869,7 @@ simple values, or as named vocabularies.
     >>> p.vocabularyName
     'my.vocab'
 
-Complex vocabularies or sources are not allowed:
+Complex vocabularies or sources are not allowed::
 
     >>> from zope.schema.vocabulary import SimpleVocabulary
     >>> dummy_vocabulary = SimpleVocabulary.fromItems([('a', 1), ('b', 2)])
diff --git a/plone/registry/fieldfactory.py b/plone/registry/fieldfactory.py
index de3a9bb..7089705 100644
--- a/plone/registry/fieldfactory.py
+++ b/plone/registry/fieldfactory.py
@@ -1,19 +1,21 @@
-import zope.interface
-import zope.component
-
-import plone.registry.field
-
-from zope.schema.interfaces import IField, IChoice
-from zope.schema.interfaces import ISource, IContextSourceBinder
-from zope.schema.vocabulary import SimpleVocabulary
-
-from plone.registry.interfaces import IPersistentField
-from plone.registry.field import DisallowedProperty, StubbornProperty, InterfaceConstrainedProperty
+# -*- coding: utf-8 -*-
+from plone.registry.field import DisallowedProperty
+from plone.registry.field import InterfaceConstrainedProperty
 from plone.registry.field import is_primitive
+from plone.registry.field import StubbornProperty
+from plone.registry.interfaces import IPersistentField
+from zope.component import adapter
+from zope.interface import implementer
+from zope.schema.interfaces import IChoice
+from zope.schema.interfaces import IContextSourceBinder
+from zope.schema.interfaces import IField
+from zope.schema.interfaces import ISource
+from zope.schema.vocabulary import SimpleVocabulary
+import plone.registry.field
 
 
-@zope.interface.implementer(IPersistentField)
-@zope.component.adapter(IField)
+@implementer(IPersistentField)
+@adapter(IField)
 def persistentFieldAdapter(context):
     """Turn a non-persistent field into a persistent one
     """
@@ -37,34 +39,38 @@ def persistentFieldAdapter(context):
 
     instance = persistent_class.__new__(persistent_class)
 
-    context_dict = dict([(k,v) for k,v in context.__dict__.items()
-                            if k not in ignored])
-
-    for k,iface in constrained:
-        v = context_dict.get(k, None)
-        if v is not None and v != context.missing_value:
-            v = iface(v, None)
-            if v is None:
-                __traceback_info__ = "The property `%s` cannot be adapted to `%s`." % (k, iface.__identifier__,)
-                return None
-            context_dict[k] = v
+    context_dict = dict(
+        [(k, v) for k, v in context.__dict__.items() if k not in ignored]
+    )
+
+    for key, iface in constrained:
+        value = context_dict.get(key, None)
+        if value is None or value == context.missing_value:
+            continue
+        value = iface(value, None)
+        if value is None:
+            __traceback_info__ = (
+                "The property `{0}` cannot be adapted to "
+                "`{1}`.".format(key, iface.__identifier__,)
+            )
+            return None
+        context_dict[key] = value
 
     instance.__dict__.update(context_dict)
     return instance
 
-@zope.interface.implementer(IPersistentField)
-@zope.component.adapter(IChoice)
+
+@implementer(IPersistentField)
+@adapter(IChoice)
 def choicePersistentFieldAdapter(context):
     """Special handling for Choice fields.
     """
-
     instance = persistentFieldAdapter(context)
     if instance is None:
         return None
 
     if ISource.providedBy(context.vocabulary) or \
             IContextSourceBinder.providedBy(context.vocabulary):
-
         safe = False
 
         # Attempt to reverse engineer a 'values' argument
@@ -81,8 +87,10 @@ def choicePersistentFieldAdapter(context):
                 instance._values = values
 
         if not safe:
-            __traceback_info__ = "Persistent fields only support named vocabularies " + \
-                                    "or vocabularies based on simple value sets."
+            __traceback_info__ = (
+                "Persistent fields only support named vocabularies "
+                "or vocabularies based on simple value sets."
+            )
             return None
 
-    return instance
\ No newline at end of file
+    return instance
diff --git a/plone/registry/fieldref.py b/plone/registry/fieldref.py
index 0df6c72..a4ae488 100644
--- a/plone/registry/fieldref.py
+++ b/plone/registry/fieldref.py
@@ -1,14 +1,14 @@
+# -*- coding: utf-8 -*-
+from plone.registry.interfaces import IFieldRef
 from zope.interface import implementedBy
-from zope.interface import implements
+from zope.interface import implementer
 
-from plone.registry.interfaces import IFieldRef
 
+@implementer(IFieldRef)
 class FieldRef(object):
     """Default field reference.
     """
 
-    implements(IFieldRef)
-
     def __init__(self, name, originalField):
         self.recordName = name
         self.originalField = originalField
diff --git a/plone/registry/record.py b/plone/registry/record.py
index 44b2c3a..2211425 100644
--- a/plone/registry/record.py
+++ b/plone/registry/record.py
@@ -1,18 +1,18 @@
+# -*- coding: utf-8 -*-
 from persistent import Persistent
-
-from zope.interface import implements, alsoProvides
-from zope.event import notify
-
-from zope.dottedname.resolve import resolve
-
+from plone.registry.events import RecordModifiedEvent
+from plone.registry.interfaces import IInterfaceAwareRecord
 from plone.registry.interfaces import IPersistentField
 from plone.registry.interfaces import IRecord
-from plone.registry.interfaces import IInterfaceAwareRecord
-
-from plone.registry.events import RecordModifiedEvent
+from zope.dottedname.resolve import resolve
+from zope.event import notify
+from zope.interface import implementer
+from zope.interface import alsoProvides
 
 _marker = object()
 
+
+@implementer(IRecord)
 class Record(Persistent):
     """A record that is stored in the registry.
 
@@ -24,8 +24,6 @@ class Record(Persistent):
     values may be loaded during automated migration.
     """
 
-    implements(IRecord)
-
     __name__ = u""
     __parent__ = None
 
diff --git a/plone/registry/recordsproxy.py b/plone/registry/recordsproxy.py
index 994c040..ffc53f7 100644
--- a/plone/registry/recordsproxy.py
+++ b/plone/registry/recordsproxy.py
@@ -1,24 +1,25 @@
-from zope.interface import implements, alsoProvides
-from zope.schema import getFieldsInOrder
-from zope.schema.interfaces import RequiredMissing
+# -*- coding: utf-8 -*-
 from plone.registry.interfaces import IRecordsProxy
-
 from UserDict import DictMixin
+from zope.interface import alsoProvides
+from zope.interface import implementer
+from zope.schema import getFieldsInOrder
+from zope.schema.interfaces import RequiredMissing
 import re
 
 _marker = object()
 
+
+@implementer(IRecordsProxy)
 class RecordsProxy(object):
     """A proxy that maps an interface to a number of records
     """
 
-    implements(IRecordsProxy)
-
     def __init__(self, registry, schema, omitted=(), prefix=None):
         if prefix is None:
             prefix = schema.__identifier__ + '.'
         elif not prefix.endswith("."):
-             prefix += '.'
+            prefix += '.'
 
         # skip __setattr__
         self.__dict__['__schema__'] = schema
@@ -46,7 +47,10 @@ def __setattr__(self, name, value):
             self.__dict__[name] = value
 
     def __repr__(self):
-        return "<%s for %s>" % (self.__class__.__name__, self.__schema__.__identifier__)
+        return "<{0} for {1}>".format(
+            self.__class__.__name__,
+            self.__schema__.__identifier__
+        )
 
 
 class RecordsProxyCollection(DictMixin):
@@ -57,12 +61,13 @@ class RecordsProxyCollection(DictMixin):
 
     # ord('.') == ord('/') - 1
 
-    def __init__(self, registry, schema, check=True, omitted=(), prefix=None, factory=None):
+    def __init__(self, registry, schema, check=True, omitted=(), prefix=None,
+                 factory=None):
         if prefix is None:
             prefix = schema.__identifier__
 
         if not prefix.endswith("/"):
-             prefix += '/'
+            prefix += '/'
 
         self.registry = registry
         self.schema = schema
@@ -72,9 +77,15 @@ def __init__(self, registry, schema, check=True, omitted=(), prefix=None, factor
         self.factory = factory
 
     def __getitem__(self, key):
-        if self.has_key(key):
+        if key in self:
             prefix = self.prefix + key
-            proxy = self.registry.forInterface(self.schema, self.check, self.omitted, prefix, self.factory)
+            proxy = self.registry.forInterface(
+                self.schema,
+                self.check,
+                self.omitted,
+                prefix,
+                self.factory
+            )
             return proxy
         raise KeyError(key)
 
@@ -99,7 +110,10 @@ def keys(self):
 
     def _validate(self, key):
         if not isinstance(key, basestring) or not self._validkey(key):
-            raise TypeError('expected a valid key (alphanumeric or underscore, starting with alpha)')
+            raise TypeError(
+                'expected a valid key (alphanumeric or underscore, starting '
+                'with alpha)'
+            )
         return str(key)
 
     def has_key(self, key):
@@ -112,7 +126,12 @@ def add(self, key):
         key = self._validate(key)
         prefix = self.prefix + key
         self.registry.registerInterface(self.schema, self.omitted, prefix)
-        proxy = self.registry.forInterface(self.schema, False, self.omitted, prefix)
+        proxy = self.registry.forInterface(
+            self.schema,
+            False,
+            self.omitted,
+            prefix
+        )
         return proxy
 
     def __setitem__(self, key, value):
@@ -132,7 +151,7 @@ def __setitem__(self, key, value):
             setattr(proxy, name, attr)
 
     def setdefault(self, key, failobj=None):
-        if not self.has_key(key):
+        if key not in self:
             if failobj is None:
                 self.add(key)
             else:
@@ -140,7 +159,7 @@ def setdefault(self, key, failobj=None):
         return self[key]
 
     def __delitem__(self, key):
-        if not self.has_key(key):
+        if key not in self:
             raise KeyError(key)
         prefix = self.prefix + key
         names = list(self.registry.records.keys(prefix+'.', prefix+'/'))
diff --git a/plone/registry/registry.py b/plone/registry/registry.py
index 6776029..2d814e7 100644
--- a/plone/registry/registry.py
+++ b/plone/registry/registry.py
@@ -1,32 +1,31 @@
-import re
-import warnings
-
-from persistent import Persistent
+# -*- coding: utf-8 -*-
 from BTrees.OOBTree import OOBTree
-
-from zope.interface import implements
-from zope.component import queryAdapter
-from zope.event import notify
-
-from zope.schema import getFieldNames, getFieldsInOrder
-
-from zope.schema._field import _isdotted
-
-from plone.registry.interfaces import IRegistry, IRecord, IPersistentField
+from persistent import Persistent
+from plone.registry.events import RecordAddedEvent
+from plone.registry.events import RecordRemovedEvent
+from plone.registry.fieldref import FieldRef
 from plone.registry.interfaces import IFieldRef
 from plone.registry.interfaces import InvalidRegistryKey
+from plone.registry.interfaces import IPersistentField
+from plone.registry.interfaces import IRecord
+from plone.registry.interfaces import IRegistry
 from plone.registry.record import Record
-from plone.registry.fieldref import FieldRef
 from plone.registry.recordsproxy import RecordsProxy
 from plone.registry.recordsproxy import RecordsProxyCollection
-from plone.registry.events import RecordAddedEvent, RecordRemovedEvent
+from zope.component import queryAdapter
+from zope.event import notify
+from zope.interface import implementer
+from zope.schema import getFieldNames
+from zope.schema import getFieldsInOrder
+import re
+import warnings
+
 
+@implementer(IRegistry)
 class Registry(Persistent):
     """The persistent registry
     """
 
-    implements(IRegistry)
-
     def __init__(self):
         self._records = _Records(self)
 
@@ -60,18 +59,24 @@ def records(self):
 
     # Schema interface API
 
-    def forInterface(self, interface, check=True, omit=(), prefix=None, factory=None):
+    def forInterface(self, interface, check=True, omit=(), prefix=None,
+                     factory=None):
         if prefix is None:
             prefix = interface.__identifier__
 
         if not prefix.endswith("."):
-             prefix += '.'
+            prefix += '.'
 
         if check:
             for name in getFieldNames(interface):
                 if name not in omit and prefix + name not in self:
-                    raise KeyError("Interface `%s` defines a field `%s`, "
-                                   "for which there is no record." % (interface.__identifier__, name))
+                    raise KeyError(
+                        "Interface `{0}` defines a field `{1}`, for which "
+                        "there is no record.".format(
+                            interface.__identifier__,
+                            name
+                        )
+                    )
 
         if factory is None:
             factory = RecordsProxy
@@ -83,7 +88,7 @@ def registerInterface(self, interface, omit=(), prefix=None):
             prefix = interface.__identifier__
 
         if not prefix.endswith("."):
-             prefix += '.'
+            prefix += '.'
 
         for name, field in getFieldsInOrder(interface):
             if name in omit or field.readonly:
@@ -91,8 +96,13 @@ def registerInterface(self, interface, omit=(), prefix=None):
             record_name = prefix + name
             persistent_field = queryAdapter(field, IPersistentField)
             if persistent_field is None:
-                raise TypeError("There is no persistent field equivalent for "
-                                "the field `%s` of type `%s`." % (name, field.__class__.__name__))
+                raise TypeError(
+                    "There is no persistent field equivalent for the field "
+                    "`{0}` of type `{1}`.".format(
+                        name,
+                        field.__class__.__name__
+                    )
+                )
 
             persistent_field.interfaceName = interface.__identifier__
             persistent_field.fieldName = name
@@ -109,10 +119,22 @@ def registerInterface(self, interface, omit=(), prefix=None):
                 except:
                     value = persistent_field.default
 
-            self.records[record_name] = Record(persistent_field, value, _validate=False)
-
-    def collectionOfInterface(self, interface, check=True, omit=(), prefix=None, factory=None):
-        return RecordsProxyCollection(self, interface, check, omit, prefix, factory)
+            self.records[record_name] = Record(
+                persistent_field,
+                value,
+                _validate=False
+            )
+
+    def collectionOfInterface(self, interface, check=True, omit=(),
+                              prefix=None, factory=None):
+        return RecordsProxyCollection(
+            self,
+            interface,
+            check,
+            omit,
+            prefix,
+            factory
+        )
 
     # BBB
 
@@ -126,18 +148,21 @@ def _migrateRecords(self):
         if oldData is not None:
             for name, oldRecord in oldData.iteritems():
                 oldRecord._p_activate()
-                if 'field' in oldRecord.__dict__ and 'value' in oldRecord.__dict__:
+                if (
+                    'field' in oldRecord.__dict__
+                    and 'value' in oldRecord.__dict__
+                ):
                     records._fields[name] = oldRecord.__dict__['field']
                     records._values[name] = oldRecord.__dict__['value']
 
         self._records = records
 
+
 class _Records(object):
     """The records stored in the registry. This implements dict-like access
     to records, where as the Registry object implements dict-like read-only
     access to values.
     """
-
     __parent__ = None
 
     # Similar to zope.schema._field._isdotted, but allows up to one '/'
@@ -208,7 +233,7 @@ def __iter__(self):
         return self._values.__iter__()
 
     def has_key(self, name):
-        return self._values.has_key(name)
+        return self._values.__contains__(name)
 
     def __contains__(self, name):
         return self._values.__contains__(name)
@@ -257,12 +282,15 @@ def _setField(self, name, field):
             raise ValueError("The record's field must be an IPersistentField.")
         if IFieldRef.providedBy(field):
             if field.recordName not in self._fields:
-                raise ValueError("Field reference points to non-existent record")
-            self._fields[name] = field.recordName # a pointer, of sorts
+                raise ValueError(
+                    "Field reference points to non-existent record"
+                )
+            self._fields[name] = field.recordName  # a pointer, of sorts
         else:
             field.__name__ = 'value'
             self._fields[name] = field
 
+
 class Records(_Records, Persistent):
     """BBB: This used to be the class for the _records attribute of the
     registry. Having this be a Persistent object was always a bad idea. We
@@ -271,5 +299,9 @@ class Records(_Records, Persistent):
     """
 
     def __init__(self, parent):
-        warnings.warn("The Records persistent class is deprecated and should not be used.", DeprecationWarning)
+        warnings.warn(
+            "The Records persistent class is deprecated and should not be "
+            "used.",
+            DeprecationWarning
+        )
         super(Records, self).__init__(parent)
diff --git a/plone/registry/registry.rst b/plone/registry/registry.rst
index 986d81a..693e11f 100644
--- a/plone/registry/registry.rst
+++ b/plone/registry/registry.rst
@@ -2,17 +2,20 @@
 Using registries
 ================
 
-You can create a new registry simply by instantiating the Registry class. The
-class and its data structures are persistent, so you can store them in the
-ZODB. You may want to provide the registry object as local utility for easy
-access as well, though we won't do that here.
+You can create a new registry simply by instantiating the Registry class.
+The class and its data structures are persistent, so you can store them in the ZODB.
+You may want to provide the registry object as local utility for easy access as well, though we won't do that here.
+
+::
 
     >>> from plone.registry import Registry
     >>> registry = Registry()
 
-The registry starts out empty. To access the registry's records, you can use
-the `records` property. This exposes a dict API where keys are strings and
-values are objects providing `IRecords`.
+The registry starts out empty.
+To access the registry's records, you can use the ``records`` property.
+This exposes a dict API where keys are strings and values are objects providing ``IRecords``.
+
+::
 
     >>> len(registry.records)
     0
@@ -20,37 +23,36 @@ values are objects providing `IRecords`.
 Simple records
 ==============
 
-Let's now create a record. A record must have a name. This should be a dotted
-name, and contain ASCII characters only. By convention, it should be all
-lowercase and start with the name of the package that defines the record.
+Let's now create a record.
+A record must have a name.
+This should be a dotted name, and contain ASCII characters only.
+By convention, it should be all lowercase and start with the name of the package that defines the record.
 
-It is also possible to create a  number of records based on a single schema
-interface - see below - but for now, we will focus on simple records.
+It is also possible to create a  number of records based on a single schema interface - see below.
+For now, we will focus on simple records.
 
 Before we can create the record, we must create the field that describes it.
-Fields are based on the venerable zope.schema package, but plone.registry
-only supports certain fields, and disallows use of a few properties even
-of those. As a rule of thumb, so long as a field stores a Python primitive,
-it is supported; the same goes for attributes of fields.
+Fields are based on the venerable ``zope.schema`` package.
+``plone.registry`` only supports certain fields, and disallows use of a few properties even of those.
+As a rule of thumb, so long as a field stores a Python primitive, it is supported; the same goes for attributes of fields.
 
 Thus:
 
- * Fields like `Object`, `InterfaceField` and so on are not supported
- * A custom `constraint` method is not supported.
- * The `order` attribute will always be set to -1
- * For Choice fields, only named vocabularies are supported: you cannot
-   reference a particular source or source binder
- * The key_type and value_type properties of Dict, List, Tuple, Set and
-   Frozenset may only contain persistent fields.
+* Fields like ``Object``, ``InterfaceField`` and so on are *not* supported.
+* A custom ``constraint`` method is *not* supported.
+* The ``order`` attribute will *always* be set to ``-1``.
+* For Choice fields, *only named vocabularies* are supported:
+  you can *not* reference a particular *source* or *source binder*.
+* The ``key_type`` and ``value_type`` properties of ``Dict``, ``List``, ``Tuple``, ``Set`` and ``Frozenset`` may *only* contain persistent fields.
 
-See field.rst for more details.
+See section "Persistent fields" for more details.
 
 Creating a record
 -----------------
 
-The supported field types are found in the module plone.registry.field. These
-are named the same as the equivalent field in zope.schema, and have the same
-constructors. You must use one of these fields when creating records directly.
+The supported field types are found in the module ``plone.registry.field``.
+These are named the same as the equivalent field in ``zope.schema``, and have the same constructors.
+You must use one of these fields when creating records directly::
 
     >>> from plone.registry import field
     >>> age_field = field.Int(title=u"Age", min=0, default=18)
@@ -58,20 +60,19 @@ constructors. You must use one of these fields when creating records directly.
     >>> from plone.registry import Record
     >>> age_record = Record(age_field)
 
-Note that in this case, we did not supply a value. The value will therefore
-be the field default.
+Note that in this case, we did not supply a value.
+The value will therefore be the field default::
 
     >>> age_record.value
     18
 
-We can set a different value, either in the `Record` constructor or via the
-`value` attribute:
+We can set a different value, either in the ``Record`` constructor or via the ``value`` attribute::
 
     >>> age_record.value = 2
     >>> age_record.value
     2
 
-Note that the value is validated against the field:
+Note that the value is validated against the field::
 
     >>> age_record.value = -1
     Traceback (most recent call last):
@@ -81,14 +82,14 @@ Note that the value is validated against the field:
     >>> age_record.value
     2
 
-We can now add the field to the registry. This is done via the `record`
-dictionary.
+We can now add the field to the registry.
+This is done via the ``record`` dictionary::
 
     >>> 'plone.registry.tests.age' in registry
     False
     >>> registry.records['plone.registry.tests.age'] = age_record
 
-At this point, the record will gain __name__ and __parent__ attributes.
+At this point, the record will gain ``__name__`` and ``__parent__`` attributes::
 
     >>> age_record.__name__
     'plone.registry.tests.age'
@@ -99,14 +100,19 @@ At this point, the record will gain __name__ and __parent__ attributes.
 Creating a record with an initial value
 ---------------------------------------
 
-We can create records more succinctly by creating the field, setting the value
-and assigning it to the registry in one go, like this:
+We can create records more succinctly in *one go* by
+
+1. creating the field,
+2. creating the Record and setting its value as and
+3. assigning it to the registry,
+
+like this::
 
     >>> registry.records['plone.registry.tests.cms'] = \
     ...     Record(field.TextLine(title=u"CMS of choice"), u"Plone")
 
-The record can now be obtained. Note that it has a nice __repr__ to help
-debugging.
+The record can now be obtained.
+Note that it has a nice ``__repr__`` to help debugging.
 
     >>> registry.records['plone.registry.tests.cms']
     <Record plone.registry.tests.cms>
@@ -114,8 +120,8 @@ debugging.
 Accessing and manipulating record values
 ----------------------------------------
 
-Once a record has been created and added to the registry, you can access
-its value through dict-like operations on the registry itself.
+Once a record has been created and added to the registry,
+you can access its value through dict-like operations on the registry itself::
 
     >>> 'plone.registry.tests.cms' in registry
     True
@@ -125,14 +131,14 @@ its value through dict-like operations on the registry itself.
 
     >>> registry['plone.registry.tests.cms'] = u"Plone 3.x"
 
-Again, values are validated:
+Again, values are validated::
 
     >>> registry['plone.registry.tests.cms'] = 'Joomla'
     Traceback (most recent call last):
     ...
     WrongType: ('Joomla', <type 'unicode'>...)
 
-There is also a get() method:
+There is also a ``get()`` method::
 
     >>> registry.get('plone.registry.tests.cms')
     u'Plone 3.x'
@@ -142,7 +148,7 @@ There is also a get() method:
 Deleting records
 ----------------
 
-Records may be deleted from the `records` property:
+Records may be deleted from the ``records`` property::
 
     >>> del registry.records['plone.registry.tests.cms']
     >>> 'plone.registry.tests.cms' in registry.records
@@ -153,16 +159,15 @@ Records may be deleted from the `records` property:
 Creating records from interfaces
 ================================
 
-As an application developer, it is often desirable to define settings as
-traditional interfaces with zope.schema fields. plone.registry includes
-support for creating a set of records from a single interface.
+As an application developer, it is often desirable to define settings as traditional interfaces with ``zope.schema fields``.
+``plone.registry`` includes support for creating a set of records from a single interface.
 
-To test this, we have created an interface, `IMailSettings`, with two fields,
-`sender` and `smtp_host`.
+To test this, we have created an interface, ``IMailSettings``.
+It has two fields: ``sender`` and ``smtp_host``::
 
     >>> from plone.registry.tests import IMailSettings
 
-Note that this contains standard fields.
+Note that this contains standard fields::
 
     >>> IMailSettings['sender']
     <zope.schema._bootstrapfields.TextLine object at ...>
@@ -170,18 +175,17 @@ Note that this contains standard fields.
     >>> IMailSettings['smtp_host']
     <zope.schema._field.URI object at ...>
 
-We can create records from this interface like this:
+We can create records from this interface like this::
 
     >>> registry.registerInterface(IMailSettings)
 
-One record for each field in the interface has now been created. Their names
-are the full dotted names to those fields:
+One record for each field in the interface has now been created.
+Their names are the full dotted names to those fields::
 
     >>> sender_record = registry.records['plone.registry.tests.IMailSettings.sender']
     >>> smtp_host_record = registry.records['plone.registry.tests.IMailSettings.smtp_host']
 
-The fields used in the records will be the equivalent persistent versions of
-the fields from the original interface.
+The fields used in the records will be the equivalent persistent versions of the fields from the original interface::
 
     >>> sender_record.field
     <plone.registry.field.TextLine object at ...>
@@ -189,18 +193,15 @@ the fields from the original interface.
     >>> smtp_host_record.field
     <plone.registry.field.URI object at ...>
 
-This feat is accomplished internally by adapting the field to the
-IPersistentField interface. There is a default adapter factory that works for
-all fields defined in plone.registry.field. You can of course define your own
-adapter if you have a custom field type, but bear in mind the golden rules of
-any persistent field:
+This feat is accomplished internally by adapting the field to the ``IPersistentField`` interface.
+There is a default adapter factory that works for all fields defined in ``plone.registry.field``.
+You can of course define your own adapter if you have a custom field type.
+But bear in mind the golden rules of any persistent field::
 
-  * The field must store only primitives or other persistent fields
-  * It must not reference a function, class, interface or other method that
-    could break if a package is uninstalled.
+* The field must store only primitives or other persistent fields
+* It must not reference a function, class, interface or other method that could break if a package is uninstalled.
 
-If we have a field for which there is no IPersistentField adapter, we will
-get an error:
+If we have a field for which there is no ``IPersistentField`` adapter, we will get an error::
 
     >>> from plone.registry.tests import IMailPreferences
     >>> IMailPreferences['settings']
@@ -211,13 +212,12 @@ get an error:
     ...
     TypeError: There is no persistent field equivalent for the field `settings` of type `Object`.
 
-Whoops! We can, however, tell registerInterface() to ignore one or more
-fields.
+Whoops!
+We can, however, tell ``registerInterface()`` to ignore one or more fields::
 
     >>> registry.registerInterface(IMailPreferences, omit=('settings',))
 
-Once an interface's records have been registered, we can get and set their
-values as normal:
+Once an interface's records have been registered, we can get and set their values as normal::
 
     >>> registry['plone.registry.tests.IMailSettings.sender']
     u'root@localhost'
@@ -226,15 +226,14 @@ values as normal:
     >>> registry['plone.registry.tests.IMailSettings.sender']
     u'webmaster@localhost'
 
-If we sub-sequently re-register the same interface, the value will be retained
-if possible:
+If we sub-sequently re-register the same interface, the value will be retained if possible::
 
     >>> registry.registerInterface(IMailSettings)
     >>> registry['plone.registry.tests.IMailSettings.sender']
     u'webmaster@localhost'
 
-However, if the value is no longer valid, we will revert to the default. To
-test that, let's sneakily modify the field for a while.
+However, if the value is no longer valid, we will revert to the default.
+To test that, let's sneakily modify the field for a while::
 
     >>> old_field = IMailSettings['sender']
     >>> IMailSettings._InterfaceClass__attrs['sender'] = field.Int(title=u"Definitely not a string", default=2)
@@ -244,7 +243,7 @@ test that, let's sneakily modify the field for a while.
     >>> registry['plone.registry.tests.IMailSettings.sender']
     2
 
-But let's put it back the way it was.
+But let's put it back the way it was::
 
     >>> IMailSettings._InterfaceClass__attrs['sender'] = old_field
     >>> if hasattr(IMailSettings, '_v_attrs'):
@@ -253,16 +252,14 @@ But let's put it back the way it was.
     >>> registry['plone.registry.tests.IMailSettings.sender']
     u'root@localhost'
 
-Sometimes, you may want to use an interface as a template for multiple
-instances of a set of fields, rather than defining them all by hand. This is
-especially useful when you want to allow third-party packages to provide
-information. To accomplish this, we can provide a prefix with the
-`registerInterface` call. This will take precedence over the __identifier__
-that is usually used.
+Sometimes, you may want to use an interface as a template for multiple instances of a set of fields, rather than defining them all by hand.
+This is especially useful when you want to allow third-party packages to provide information.
+To accomplish this, we can provide a prefix with the ``registerInterface`` call.
+This will take precedence over the ``__identifier__`` that is usually used.
 
     >>> registry.registerInterface(IMailSettings, prefix="plone.registry.tests.alternativesettings")
 
-These values are now available in the same way as the original settings:
+These values are now available in the same way as the original settings::
 
     >>> sender_record = registry.records['plone.registry.tests.alternativesettings.sender']
     >>> smtp_host_record = registry.records['plone.registry.tests.alternativesettings.smtp_host']
@@ -271,12 +268,12 @@ These values are now available in the same way as the original settings:
 Accessing the original interface
 --------------------------------
 
-Now that we have these records, we can look up the original interface. This
-does not break the golden rules: internally, we only store the name of the
-interface, and resolve it at runtime.
+Now that we have these records, we can look up the original interface.
+This does not break the golden rules:
+internally, we only store the name of the interface, and resolve it at runtime.
 
-Records that know about interfaces are marked with `IInterfaceAwareRecord` and
-have two additional properties: `interface` and `fieldName`.
+Records that know about interfaces are marked with ``IInterfaceAwareRecord`` and have two additional properties:
+``interface`` and ``fieldName``::
 
     >>> from plone.registry.interfaces import IInterfaceAwareRecord
     >>> IInterfaceAwareRecord.providedBy(age_record)
@@ -293,50 +290,46 @@ have two additional properties: `interface` and `fieldName`.
 Using the records proxy
 -----------------------
 
-Once the records for an interface has been created, it is possible to obtain
-a proxy object that provides the given interface, but reads and writes its
-values to the registry. This is useful, for example, to create a form using
-`zope.formlib` or `z3c.form` that is configured with widgets based on the
-interface, or simply as a more convenient API when working with multiple,
-related settings.
+Once the records for an interface has been created, it is possible to obtain a proxy object that provides the given interface, but reads and writes its values to the registry.
+This is useful, for example, to create a form using ``zope.formlib`` or  ``z3c.form`` that is configured with widgets based on the
+interface.
+Or simply as a more convenient API when working with multiple, related settings.
+
+::
 
     >>> proxy = registry.forInterface(IMailSettings)
     >>> proxy
     <RecordsProxy for plone.registry.tests.IMailSettings>
 
-If you use your registry values in code
-which might be encountered on normal HTML rendering
-paths (e.g. in a viewlet) you need to be aware that records
-might not exist or they are invalid. `forInterface()`
-will raise KeyError on this kind of situations::
+If you use your registry values in code which might be encountered on normal HTML rendering paths (e.g. in a viewlet) you need to be aware that records might not exist or they are invalid.
+``forInterface()`` will raise KeyError on this kind of situations::
 
-   try:
-       proxy = registry.forInterface(IMailSettings)
-   except KeyError:
-       # Gracefully handled cases
-       # when GenericSetup installer has not been run or rerun
-       # e.g. by returning or using some default values
-       pass
+    try:
+        proxy = registry.forInterface(IMailSettings)
+    except KeyError:
+        # Gracefully handled cases
+        # when GenericSetup installer has not been run or rerun
+        # e.g. by returning or using some default values
+        pass
 
-The proxy is not a persistent object on its own.
+The proxy is not a persistent object on its own::
 
     >>> from persistent.interfaces import IPersistent
     >>> IPersistent.providedBy(proxy)
     False
 
-It does, however, provide the requisite interface.
+It does, however, provide the requisite interface::
 
     >>> IMailSettings.providedBy(proxy)
     True
 
-You can distinguish between the proxy and a 'norma' object by checking for the
-IRecordsProxy marker interface:
+You can distinguish between the proxy and a 'normal' object by checking for the ``IRecordsProxy`` marker interface::
 
     >>> from plone.registry.interfaces import IRecordsProxy
     >>> IRecordsProxy.providedBy(proxy)
     True
 
-When we set a value, it is stored in the registry:
+When we set a value, it is stored in the registry::
 
     >>> proxy.smtp_host = 'http://mail.server.com'
     >>> registry['plone.registry.tests.IMailSettings.smtp_host']
@@ -346,51 +339,51 @@ When we set a value, it is stored in the registry:
     >>> proxy.smtp_host
     'smtp://mail.server.com'
 
-Values not in the interface will raise an AttributeError:
+Values not in the interface will raise an ``AttributeError``::
 
     >>> proxy.age
     Traceback (most recent call last):
     ...
     AttributeError: age
 
-Note that by default, the forInterface() method will check that the necessary
-records have been registered. For example, we cannot use any old interface:
+Note that by default, the forInterface() method will check that the necessary records have been registered.
+For example, we cannot use any old interface::
 
     >>> registry.forInterface(IInterfaceAwareRecord)
     Traceback (most recent call last):
     ...
     KeyError: 'Interface `plone.registry.interfaces.IInterfaceAwareRecord` defines a field `interface`, for which there is no record.'
 
-By default, we also cannot use an interface for which only some records exist:
+By default, we also cannot use an interface for which only some records exist::
 
     >>> registry.forInterface(IMailPreferences)
     Traceback (most recent call last):
     ...
     KeyError: 'Interface `plone.registry.tests.IMailPreferences` defines a field `settings`, for which there is no record.'
 
-It is possible to disable this check, however. This will be a bit more
-efficient:
+It is possible to disable this check, however.
+This will be a bit more efficient::
 
     >>> registry.forInterface(IMailPreferences, check=False)
     <RecordsProxy for plone.registry.tests.IMailPreferences>
 
-A better way, however, is to explicitly declare that some fields are omitted:
+A better way, however, is to explicitly declare that some fields are omitted::
 
     >>> pref_proxy = registry.forInterface(IMailPreferences, omit=('settings',))
 
-In this case, the omitted fields will default to their 'missing' value:
+In this case, the omitted fields will default to their 'missing' value::
 
     >>> pref_proxy.settings ==  IMailPreferences['settings'].missing_value
     True
 
-However, trying to set the value will result in a AttributeError:
+However, trying to set the value will result in a ``AttributeError``::
 
     >>> pref_proxy.settings = None
     Traceback (most recent call last):
     ...
     AttributeError: settings
 
-To access another instance of the field, supply the prefix:
+To access another instance of the field, supply the prefix::
 
     >>> alt_proxy = registry.forInterface(IMailSettings,
     ...     prefix="plone.registry.tests.alternativesettings")
@@ -400,17 +393,17 @@ To access another instance of the field, supply the prefix:
 Collections of records proxies
 ------------------------------
 
-A collection of record sets may be accessed using `collectionOfInterface`:
+A collection of record sets may be accessed using ``collectionOfInterface``::
 
     >>> collection = registry.collectionOfInterface(IMailSettings)
 
-You can create a new record set:
+You can create a new record set::
 
     >>> proxy = collection.setdefault('example')
     >>> proxy.sender = u'collection@example.org'
     >>> proxy.smtp_host = 'smtp://mail.example.org'
 
-Record sets are stored based under the prefix:
+Record sets are stored based under the prefix::
 
     >>> prefix = IMailSettings.__identifier__
     >>> registry.records.values(prefix+'/', prefix+'0')
@@ -419,7 +412,7 @@ Record sets are stored based under the prefix:
     >>> registry['plone.registry.tests.IMailSettings/example.sender']
     u'collection@example.org'
 
-Records may be set from an existing object:
+Records may be set from an existing object::
 
     >>> class MailSettings:
     ...     sender = u'someone@example.com'
@@ -431,13 +424,13 @@ Records may be set from an existing object:
      <Record plone.registry.tests.IMailSettings/example_com.sender>,
      <Record plone.registry.tests.IMailSettings/example_com.smtp_host>]
 
-The collection may be iterated over:
+The collection may be iterated over::
 
     >>> for name in collection: print name
     example
     example_com
 
-And may be deleted:
+And may be deleted::
 
     >>> del collection['example_com']
     >>> registry.records.values(prefix+'/', prefix+'0')
@@ -447,12 +440,12 @@ And may be deleted:
 Using field references
 ======================
 
-It is possible for one record to refer to another record's field. This can be
-used to provide a simple "override" mechanism, for example, where one record
-defines the field and a default value, whilst another provides an override
-validated against the same field.
+It is possible for one record to refer to another record's field.
+This can be used to provide a simple "override" mechanism,
+for example, where one record defines the field and a default value,
+whilst another provides an override validated against the same field.
 
-Let us first create the base record and set its value:
+Let us first create the base record and set its value::
 
     >>> timeout_field = field.Int(title=u"Timeout", min=0)
     >>> registry.records['plone.registry.tests.timeout'] = Record(timeout_field, 10)
@@ -461,17 +454,17 @@ Let us first create the base record and set its value:
     >>> timeout_record.value
     10
 
-Next, we create a field reference for this record:
+Next, we create a field reference for this record::
 
     >>> from plone.registry import FieldRef
     >>> timeout_override_field = FieldRef(timeout_record.__name__, timeout_record.field)
 
-We can use this to create a new record:
+We can use this to create a new record::
 
     >>> registry.records['plone.registry.tests.timeout.override'] = Record(timeout_override_field, 20)
     >>> timeout_override_record = registry.records['plone.registry.tests.timeout.override']
 
-The two values are separate:
+The two values are separate::
 
     >>> timeout_record.value
     10
@@ -483,21 +476,21 @@ The two values are separate:
     >>> registry['plone.registry.tests.timeout.override']
     20
 
-Validation uses the underlying field:
+Validation uses the underlying field::
 
     >>> registry['plone.registry.tests.timeout.override'] = -1
     Traceback (most recent call last):
     ...
     TooSmall: (-1, 0)
 
-The reference field exposes the standard field properties, e.g.:
+The reference field exposes the standard field properties, e.g.::
 
     >>> timeout_override_record.field.title
     u'Timeout'
     >>> timeout_override_record.field.min
     0
 
-To look up the underlying record name, we can use the ``recordName`` property:
+To look up the underlying record name, we can use the ``recordName`` property::
 
     >>> timeout_override_record.field.recordName
     'plone.registry.tests.timeout'
diff --git a/plone/registry/tests.py b/plone/registry/tests.py
index 1d786f1..5676dc4 100644
--- a/plone/registry/tests.py
+++ b/plone/registry/tests.py
@@ -1,14 +1,15 @@
-import unittest
-import doctest
-
-from zope.testing import doctestunit
-from zope.component import provideAdapter, testing, eventtesting
-
-from plone.registry.fieldfactory import persistentFieldAdapter
+# -*- coding: utf-8 -*-
 from plone.registry.fieldfactory import choicePersistentFieldAdapter
-
-from zope.interface import Interface
+from plone.registry.fieldfactory import persistentFieldAdapter
 from zope import schema
+from zope.component import eventtesting
+from zope.component import provideAdapter
+from zope.component import testing
+from zope.interface import Interface
+from zope.testing import doctestunit
+import doctest
+import unittest
+
 
 class IMailSettings(Interface):
     """Settings for email
@@ -17,12 +18,20 @@ class IMailSettings(Interface):
     sender = schema.TextLine(title=u"Mail sender", default=u"root@localhost")
     smtp_host = schema.URI(title=u"SMTP host server")
 
+
 class IMailPreferences(Interface):
     """Settings for email
     """
+    max_daily = schema.Int(
+        title=u"Maximum number of emails per day",
+        min=0,
+        default=3
+    )
+    settings = schema.Object(
+        title=u"Mail setings to use",
+        schema=IMailSettings
+    )
 
-    max_daily = schema.Int(title=u"Maximum number of emails per day", min=0, default=3)
-    settings = schema.Object(title=u"Mail setings to use", schema=IMailSettings)
 
 def setUp(test=None):
     testing.setUp()
@@ -31,6 +40,7 @@ def setUp(test=None):
     provideAdapter(persistentFieldAdapter)
     provideAdapter(choicePersistentFieldAdapter)
 
+
 class TestBugs(unittest.TestCase):
     """Regression tests for bugs that have been fixed
     """
@@ -74,6 +84,7 @@ def test_fieldref_interfaces(self):
         self.assertTrue(ICollection.providedBy(ref))
         self.assertTrue(IFieldRef.providedBy(ref))
 
+
 class TestMigration(unittest.TestCase):
 
     def setUp(self):
@@ -117,20 +128,30 @@ def test_auto_migration(self):
         self.assertFalse(isinstance(registry._records, Records))
         self.assertTrue(isinstance(registry._records, _Records))
 
+
 def test_suite():
     return unittest.TestSuite([
         doctestunit.DocFileSuite(
-            'registry.rst', package='plone.registry',
-            optionflags = doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,
-            setUp=setUp, tearDown=testing.tearDown),
+            'registry.rst',
+            package='plone.registry',
+            optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,
+            setUp=setUp,
+            tearDown=testing.tearDown
+        ),
         doctestunit.DocFileSuite(
-            'events.rst', package='plone.registry',
-            optionflags = doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,
-            setUp=setUp, tearDown=testing.tearDown),
+            'events.rst',
+            package='plone.registry',
+            optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,
+            setUp=setUp,
+            tearDown=testing.tearDown
+        ),
         doctestunit.DocFileSuite(
-            'field.rst', package='plone.registry',
-            optionflags = doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,
-            setUp=setUp, tearDown=testing.tearDown),
+            'field.rst',
+            package='plone.registry',
+            optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,
+            setUp=setUp,
+            tearDown=testing.tearDown
+        ),
         unittest.makeSuite(TestBugs),
         unittest.makeSuite(TestMigration),
-        ])
+    ])
diff --git a/setup.py b/setup.py
index 75f6909..5b7709a 100644
--- a/setup.py
+++ b/setup.py
@@ -1,5 +1,7 @@
+# -*- coding: utf-8 -*-
+from setuptools import find_packages
+from setuptools import setup
 import os
-from setuptools import setup, find_packages
 
 
 def read(*rnames):
@@ -7,7 +9,7 @@ def read(*rnames):
 
 version = '1.0.3.dev0'
 
-
+description = "Registry for application settings (like debconf/ about:config)"
 long_description = (
     read('README.rst')
     + '\n' +
@@ -21,36 +23,36 @@ def read(*rnames):
     + '\n'
     )
 
-setup(name='plone.registry',
-      version=version,
-      description="A debconf-like (or about:config-like) registry for storing application settings",
-      long_description=long_description,
-      # Get more strings from http://www.python.org/pypi?%3Aaction=list_classifiers
-      classifiers=[
+setup(
+    name='plone.registry',
+    version=version,
+    description=description,
+    long_description=long_description,
+    classifiers=[
         "Framework :: Plone",
         "Programming Language :: Python",
         "Topic :: Software Development :: Libraries :: Python Modules",
-        ],
-      keywords='configuration registry',
-      author='Martin Aspeli, Wichert Akkerman, Hanno Schlichting',
-      author_email='plone-developers@lists.sourceforge.net',
-      url='http://pypi.python.org/pypi/plone.registry',
-      license='GPL',
-      packages=find_packages(exclude=['ez_setup']),
-      namespace_packages=['plone'],
-      include_package_data=True,
-      zip_safe=False,
-      install_requires=[
-          'setuptools',
-          'ZODB3',
-          'zope.schema',
-          'zope.interface',
-          'zope.component',
-          'zope.dottedname',
-          'zope.event',
-          'zope.testing',
-      ],
-      entry_points="""
-      # -*- Entry points: -*-
-      """,
-      )
+    ],
+    keywords='configuration registry',
+    author='Martin Aspeli, Wichert Akkerman, Hanno Schlichting',
+    author_email='plone-developers@lists.sourceforge.net',
+    url='http://pypi.python.org/pypi/plone.registry',
+    license='GPL',
+    packages=find_packages(exclude=['ez_setup']),
+    namespace_packages=['plone'],
+    include_package_data=True,
+    zip_safe=False,
+    install_requires=[
+        'setuptools',
+        'ZODB3',
+        'zope.component',
+        'zope.dottedname',
+        'zope.event',
+        'zope.interface',
+        'zope.schema',
+        'zope.testing',
+    ],
+    entry_points="""
+    # -*- Entry points: -*-
+    """,
+)


Repository: plone.registry


Branch: refs/heads/master
Date: 2015-10-08T13:21:26+02:00
Author: Johannes Raggam (thet) <raggam-nl@adm.at>
Commit: https://github.com/plone/plone.registry/commit/964b65c3a1fe007a2597511bf8f9382942952cb0

Merge pull request #5 from plone/jensens-cleanup

Cleanup: Pep8, utf8 headers, whitespace fixes, readability, ReST-fixes…

Files changed:
M CHANGES.rst
M README.rst
M plone/__init__.py
M plone/registry/__init__.py
M plone/registry/events.py
M plone/registry/events.rst
M plone/registry/field.py
M plone/registry/field.rst
M plone/registry/fieldfactory.py
M plone/registry/fieldref.py
M plone/registry/record.py
M plone/registry/recordsproxy.py
M plone/registry/registry.py
M plone/registry/registry.rst
M plone/registry/tests.py
M setup.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 847f6d6..01968ab 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,7 +4,9 @@ Changelog
 1.0.3 (unreleased)
 ------------------
 
-- Nothing changed yet.
+- Cleanup: Pep8, utf8 headers, whitespace fixes, readability, ReST-fixes,
+  doc-style, etc.
+  [jensens]
 
 
 1.0.2 (2014-09-11)
diff --git a/README.rst b/README.rst
index 52870d5..2b77954 100644
--- a/README.rst
+++ b/README.rst
@@ -9,8 +9,5 @@ well as a ``field`` that describes the record in more detail. At a minimum, the
 field contains information about the type of value allowed, as well as a short
 title describing the record's purpose.
 
-See the following doctests for more details:
+.. contents:: Table of Contents
 
-* ``registry.rst``, which demonstrates how registries and records work
-* ``events.rst``, which shows the events that are fired from the registry
-* ``field.rst``, which describes the behaviour of persistent fields
diff --git a/plone/__init__.py b/plone/__init__.py
index f48ad10..68c04af 100644
--- a/plone/__init__.py
+++ b/plone/__init__.py
@@ -1,6 +1,2 @@
-# See http://peak.telecommunity.com/DevCenter/setuptools#namespace-packages
-try:
-    __import__('pkg_resources').declare_namespace(__name__)
-except ImportError:
-    from pkgutil import extend_path
-    __path__ = extend_path(__path__, __name__)
+# -*- coding: utf-8 -*-
+__import__('pkg_resources').declare_namespace(__name__)
diff --git a/plone/registry/__init__.py b/plone/registry/__init__.py
index 21fdd4a..347516c 100644
--- a/plone/registry/__init__.py
+++ b/plone/registry/__init__.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 from plone.registry.registry import Registry
 from plone.registry.record import Record
-from plone.registry.fieldref import FieldRef
\ No newline at end of file
+from plone.registry.fieldref import FieldRef
diff --git a/plone/registry/events.py b/plone/registry/events.py
index ed9349b..a086c53 100644
--- a/plone/registry/events.py
+++ b/plone/registry/events.py
@@ -1,16 +1,17 @@
-from zope.interface import implements
-from zope.component import subscribers, adapter
-
-from plone.registry.interfaces import IRecordEvent
+# -*- coding: utf-8 -*-
+from plone.registry.interfaces import IInterfaceAwareRecord
 from plone.registry.interfaces import IRecordAddedEvent
-from plone.registry.interfaces import IRecordRemovedEvent
+from plone.registry.interfaces import IRecordEvent
 from plone.registry.interfaces import IRecordModifiedEvent
-from plone.registry.interfaces import IInterfaceAwareRecord
-
+from plone.registry.interfaces import IRecordRemovedEvent
 from plone.registry.recordsproxy import RecordsProxy
+from zope.component import adapter
+from zope.component import subscribers
+from zope.interface import implementer
+
 
+@implementer(IRecordEvent)
 class RecordEvent(object):
-    implements(IRecordEvent)
 
     def __init__(self, record):
         self.record = record
@@ -18,20 +19,26 @@ def __init__(self, record):
     def __repr__(self):
         return "<%s for %s>" % (self.__class__.__name__, self.record.__name__)
 
+
+@implementer(IRecordAddedEvent)
 class RecordAddedEvent(RecordEvent):
-    implements(IRecordAddedEvent)
+    """record added"""
 
+
+@implementer(IRecordRemovedEvent)
 class RecordRemovedEvent(RecordEvent):
-    implements(IRecordRemovedEvent)
+    """record removed"""
+
 
+@implementer(IRecordModifiedEvent)
 class RecordModifiedEvent(RecordEvent):
-    implements(IRecordModifiedEvent)
 
     def __init__(self, record, oldValue, newValue):
         super(RecordModifiedEvent, self).__init__(record)
         self.oldValue = oldValue
         self.newValue = newValue
 
+
 @adapter(IRecordEvent)
 def redispatchInterfaceAwareRecordEvents(event):
     """When an interface-aware record received a record event,
@@ -53,5 +60,5 @@ def redispatchInterfaceAwareRecordEvents(event):
     proxy = RecordsProxy(record.__parent__, schema)
 
     adapters = subscribers((proxy, event), None)
-    for adapter in adapters:
-        pass # getting them does the work
\ No newline at end of file
+    for ad in adapters:
+        pass  # getting them does the work
diff --git a/plone/registry/events.rst b/plone/registry/events.rst
index 452031a..a0df49c 100644
--- a/plone/registry/events.rst
+++ b/plone/registry/events.rst
@@ -4,21 +4,21 @@ Registry events
 
 The registry fires certain events. These are:
 
- * `plone.registry.interfaces.IRecordAddedEvent`, when a record has been
-    added to the registry.
+``plone.registry.interfaces.IRecordAddedEvent``
+    when a record has been added to the registry.
 
- * `plone.registry.interfaces.IRecordRemovedEvent`, when a record has been
-    removed from the registry.
+``plone.registry.interfaces.IRecordRemovedEvent``
+    when a record has been removed from the registry.
 
- * `plone.registry.interfaces.IRecordModifiedEvent`, when a record's value is
-    modified.
+``plone.registry.interfaces.IRecordModifiedEvent``,
+    when a record's value is modified.
 
-To test these events, we will create, modify and remove a few records:
+To test these events, we will create, modify and remove a few records::
 
     >>> from plone.registry import Registry, Record, field
     >>> registry = Registry()
 
-Adding a new record to the registry should fire IRecordAddedEvents:
+Adding a new record to the registry should fire ``IRecordAddedEvents``::
 
     >>> registry.records['plone.registry.tests.age'] = \
     ...     Record(field.Int(title=u"Age", min=0, default=18))
@@ -26,22 +26,21 @@ Adding a new record to the registry should fire IRecordAddedEvents:
     >>> registry.records['plone.registry.tests.cms'] = \
     ...     Record(field.TextLine(title=u"Preferred CMS"), value=u"Plone")
 
-When creating records from an interface, one event is fired for each field
-in the interface.
+When creating records from an interface, one event is fired for each field in the interface::
 
     >>> from plone.registry.tests import IMailSettings
     >>> registry.registerInterface(IMailSettings)
 
-Deleting a record should fire an IRecordRemovedEvent:
+Deleting a record should fire an ``IRecordRemovedEvent``::
 
     >>> del registry.records['plone.registry.tests.cms']
 
-Changing a record should fire an IRecordModifiedEvent:
+Changing a record should fire an ``IRecordModifiedEvent``::
 
     >>> registry['plone.registry.tests.age'] = 25
     >>> registry.records['plone.registry.tests.age'].value = 24
 
-Let's take a look at the events that were just fired:
+Let's take a look at the events that were just fired::
 
     >>> from plone.registry.interfaces import IRecordEvent
     >>> from zope.component.eventtesting import getEvents
@@ -54,8 +53,7 @@ Let's take a look at the events that were just fired:
      <RecordModifiedEvent for plone.registry.tests.age>,
      <RecordModifiedEvent for plone.registry.tests.age>]
 
-For the modified events, we can also check the value before and after the
-change.
+For the modified events, we can also check the value before and after the change::
 
     >>> from plone.registry.interfaces import IRecordModifiedEvent
     >>> [(repr(e), e.oldValue, e.newValue,) for e in getEvents(IRecordModifiedEvent)]
@@ -65,12 +63,13 @@ change.
 IObjectEvent-style redispatchers
 ================================
 
-There is a special event handler which takes care of re-dispatching registry
-events based on the schema interface prescribed by the record.
+There is a special event handler.
+It takes care of re-dispatching registry events based on the schema interface prescribed by the record.
 
-Let's re-set the event testing framework and register the re-dispatching event
-subscriber. Normally, this would happen automatically by including this
-package's ZCML.
+Let's re-set the event testing framework and register the re-dispatching event subscriber.
+Normally, this would happen automatically by including this package's ZCML.
+
+::
 
     >>> from zope.component.eventtesting import clearEvents
     >>> from zope.component import provideHandler
@@ -78,16 +77,14 @@ package's ZCML.
     >>> clearEvents()
     >>> provideHandler(redispatchInterfaceAwareRecordEvents)
 
-We'll then register a schema interface.
+We'll then register a schema interface::
 
     >>> from plone.registry.tests import IMailSettings
     >>> registry.registerInterface(IMailSettings)
 
-We could now register an event handler to print any record event occurring on
-an IMailSettings record. More specialised event handlers for e.g.
-IRecordModifiedEvent or IRecordRemovedEvent are of course also possible.
-Note that it is not possible to re-dispatch IRecordAddedEvents, so these are
-never caught.
+We could now register an event handler to print any record event occurring on an ``IMailSettings`` record.
+More specialised event handlers for e.g. ``IRecordModifiedEvent`` or ``IRecordRemovedEvent`` are of course also possible.
+Note that it is not possible to re-dispatch ``IRecordAddedEvents``, so these are never caught.
 
     >>> from zope.component import adapter
     >>> @adapter(IMailSettings, IRecordEvent)
@@ -95,23 +92,23 @@ never caught.
     ...     print "Got", event, "for", proxy
     >>> provideHandler(print_mail_settings_events)
 
-Let's now modify one of the records for this interface. The event handler
-should react immediately.
+Let's now modify one of the records for this interface.
+The event handler should react immediately::
 
     >>> registry['plone.registry.tests.IMailSettings.sender'] = u"Some sender"
     Got <RecordModifiedEvent for plone.registry.tests.IMailSettings.sender> for <RecordsProxy for plone.registry.tests.IMailSettings>
 
-Let's also modify a non-interface-aware record, for comparison's sake. Here,
-there is nothing printed.
+Let's also modify a non-interface-aware record, for comparison's sake.
+Here, there is nothing printed::
 
     >>> registry['plone.registry.tests.age'] = 3
 
-We can try a record-removed event as well:
+We can try a record-removed event as well::
 
     >>> del registry.records['plone.registry.tests.IMailSettings.sender']
     Got <RecordRemovedEvent for plone.registry.tests.IMailSettings.sender> for <RecordsProxy for plone.registry.tests.IMailSettings>
 
-The basic events that have been dispatched are:
+The basic events that have been dispatched are::
 
     >>> getEvents(IRecordEvent)
     [<RecordAddedEvent for plone.registry.tests.IMailSettings.sender>,
diff --git a/plone/registry/field.py b/plone/registry/field.py
index 0a27051..2150d31 100644
--- a/plone/registry/field.py
+++ b/plone/registry/field.py
@@ -1,3 +1,4 @@
+# -*- coding: utf-8 -*-
 """This module defines persistent versions of various fields.
 
 The idea is that when a record is created, we copy relevant field properties
@@ -5,30 +6,30 @@
 persistent field. Not all field types are supported, but the common types
 are.
 """
-
-import zope.interface
-
-import zope.schema
-import zope.schema._field
-import zope.schema.vocabulary
-import zope.schema.interfaces
-
 from persistent import Persistent
-
 from plone.registry.interfaces import IPersistentField
+from zope.interface import implementer
+from zope.schema.interfaces import IContextSourceBinder
+from zope.schema.vocabulary import SimpleVocabulary
+import zope.schema
+import zope.schema._field
 
 _missing_value_marker = object()
 
+
 def is_primitive(value):
     return value is None or \
-            isinstance(value, (int, long, bool, str, unicode, tuple, list,
-                                set, frozenset, dict, float))
+            isinstance(
+                value,
+                (int, long, bool, str, unicode, tuple,
+                 list, set, frozenset, dict, float)
+            )
+
 
 class DisallowedProperty(object):
     """A property that may not be set on an instance. It may still be set
     defined in a base class.
     """
-
     uses = []
 
     def __init__(self, name):
@@ -46,12 +47,15 @@ def __get__(self, inst, type_=None):
         raise AttributeError(self._name)
 
     def __set__(self, inst, value):
-        raise ValueError(u"Persistent fields does not support setting the `%s` property" % self._name)
+        raise ValueError(
+            u"Persistent fields does not support setting the `{0}` "
+            u"property".format(self._name)
+        )
+
 
 class StubbornProperty(object):
     """A property that stays stubbornly at a single, pre-defined value.
     """
-
     uses = []
 
     def __init__(self, name, value):
@@ -65,10 +69,10 @@ def __set__(self, inst, value):
     def __get__(self, inst, type_=None):
         return self._value
 
+
 class InterfaceConstrainedProperty(object):
     """A property that may only contain values providing a certain interface.
     """
-
     uses = []
 
     def __init__(self, name, interface):
@@ -77,18 +81,24 @@ def __init__(self, name, interface):
         self._interface = interface
 
     def __set__(self, inst, value):
-        if value != inst.missing_value:
-            if not self._interface.providedBy(value):
-                raise ValueError(u"The property `%s` may only contain objects providing `%s`." %
-                                    (self._name, self._interface.__identifier__,))
+        if (
+            value != inst.missing_value
+            and not self._interface.providedBy(value)
+        ):
+            raise ValueError(
+                u"The property `{0}` may only contain objects "
+                "providing `{1}`.".format(
+                    self._name,
+                    self._interface.__identifier__,
+                )
+            )
         inst.__dict__[self._name] = value
 
+
+@implementer(IPersistentField)
 class PersistentField(Persistent):
     """Base class for persistent field definitions.
     """
-
-    zope.interface.implements(IPersistentField)
-
     # Persistent fields do not have an order
     order = StubbornProperty('order', -1)
 
@@ -100,87 +110,112 @@ class PersistentField(Persistent):
     interfaceName = None
     fieldName = None
 
-class PersistentCollectionField(PersistentField, zope.schema._field.AbstractCollection):
+
+class PersistentCollectionField(
+    PersistentField,
+    zope.schema._field.AbstractCollection
+):
     """Ensure that value_type is a persistent field
     """
-
     value_type = InterfaceConstrainedProperty('value_type', IPersistentField)
 
+
 class Bytes(PersistentField, zope.schema.Bytes):
     pass
 
+
 class BytesLine(PersistentField, zope.schema.BytesLine):
     pass
 
+
 class ASCII(PersistentField, zope.schema.ASCII):
     pass
 
+
 class ASCIILine(PersistentField, zope.schema.ASCIILine):
     pass
 
+
 class Text(PersistentField, zope.schema.Text):
     pass
 
+
 class TextLine(PersistentField, zope.schema.TextLine):
     pass
 
+
 class Bool(PersistentField, zope.schema.Bool):
     pass
 
+
 class Int(PersistentField, zope.schema.Int):
     pass
 
+
 class Float(PersistentField, zope.schema.Float):
     pass
 
+
 class Decimal(PersistentField, zope.schema.Decimal):
     pass
 
+
 class Tuple(PersistentCollectionField, zope.schema.Tuple):
     pass
 
+
 class List(PersistentCollectionField, zope.schema.List):
     pass
 
+
 class Set(PersistentCollectionField, zope.schema.Set):
     pass
 
+
 class FrozenSet(PersistentCollectionField, zope.schema.FrozenSet):
     pass
 
+
 class Password(PersistentField, zope.schema.Password):
     pass
 
+
 class Dict(PersistentField, zope.schema.Dict):
 
     key_type = InterfaceConstrainedProperty('key_type', IPersistentField)
     value_type = InterfaceConstrainedProperty('value_type', IPersistentField)
 
+
 class Datetime(PersistentField, zope.schema.Datetime):
     pass
 
+
 class Date(PersistentField, zope.schema.Date):
     pass
 
+
 class Timedelta(PersistentField, zope.schema.Timedelta):
     pass
 
+
 class SourceText(PersistentField, zope.schema.SourceText):
     pass
 
+
 class URI(PersistentField, zope.schema.URI):
     pass
 
+
 class Id(PersistentField, zope.schema.Id):
     pass
 
+
 class DottedName(PersistentField, zope.schema.DottedName):
     pass
 
-class Choice(PersistentField, zope.schema.Choice):
 
+class Choice(PersistentField, zope.schema.Choice):
     # We can only support string name or primitive=list vocabularies
-
     _values = None
     _vocabulary = None
 
@@ -195,8 +230,10 @@ def __init__(self, values=None, vocabulary=None, source=None, **kw):
                     )
             vocabulary = None
         elif source is not None:
-            raise ValueError("Persistent fields do not support sources, only named "
-                             "vocabularies or vocabularies based on simple value sets.")
+            raise ValueError(
+                "Persistent fields do not support sources, only named "
+                "vocabularies or vocabularies based on simple value sets."
+            )
 
         assert not (values is None and vocabulary is None), (
                "You must specify either values or vocabulary.")
@@ -206,11 +243,11 @@ def __init__(self, values=None, vocabulary=None, source=None, **kw):
         self.vocabularyName = None
 
         if values is not None:
-
             for value in values:
                 if not is_primitive(value):
-                    raise ValueError("Vocabulary values may only contain primitive values.")
-
+                    raise ValueError(
+                        "Vocabulary values may only contain primitive values."
+                    )
             self._values = values
         else:
             self.vocabularyName = vocabulary
@@ -231,7 +268,7 @@ def vocabulary(self):
         if self._vocabulary is not None:
             return self._vocabulary
         if self._values is not None:
-            return zope.schema.vocabulary.SimpleVocabulary.fromValues(self._values)
+            return SimpleVocabulary.fromValues(self._values)
     DisallowedProperty.uses.append('vocabulary')
 
     # override bind to allow us to keep constraints on the 'vocabulary'
@@ -239,7 +276,7 @@ def vocabulary(self):
     def bind(self, object):
         clone = zope.schema.Field.bind(self, object)
         # get registered vocabulary if needed:
-        if zope.schema.interfaces.IContextSourceBinder.providedBy(self.vocabulary):
+        if IContextSourceBinder.providedBy(self.vocabulary):
             clone._vocabulary = self.vocabulary(object)
             assert zope.schema.interfaces.ISource.providedBy(clone.vocabulary)
         elif clone.vocabulary is None and self.vocabularyName is not None:
diff --git a/plone/registry/field.rst b/plone/registry/field.rst
index 532328b..91a0ef8 100644
--- a/plone/registry/field.rst
+++ b/plone/registry/field.rst
@@ -2,23 +2,23 @@
 Persistent fields
 =================
 
-The persistent fields that are found in plone.registry.field are siblings of
-the ones found in zope.schema, with persistence mixed in. To avoid potentially
-breaking the registry with persistent references to symbols that may go away,
-we purposefully limit the number of fields supported. We also disallow some
-properties, and add some additional checks on others.
+The persistent fields that are found in ``plone.registry.field`` are siblings of the ones found in zope.schema,
+with persistence mixed in.
+To avoid potentially breaking the registry with persistent references to symbols that may go away,
+we purposefully limit the number of fields supported.
+We also disallow some properties, and add some additional checks on others.
 
 The standard fields
 ====================
 
 We will show each supported field in turn. For all fields, note that:
 
- * the `order` property will return -1 no matter what
- * setting the `constraint` property is diallowed
- * the `key_type` and `value_type` properties, where applicable, must be set
-   to a persistent field.
- * for `Choice` fields, only named vocabularies and vocabularies based on
-   simple values are supported: sources and IVocabulary objects are not.
+* the ``order`` property will return ``-1`` no matter what setting the ``constraint`` property is diallowed
+* the ``key_type`` and ``value_type`` properties, where applicable, must be set to a persistent field.
+* for ``Choice`` fields, only named vocabularies and vocabularies based on simple values are supported:
+  sources and ``IVocabulary`` objects are not.
+
+Imports needed::
 
     >>> from plone.registry import field
     >>> from zope import schema
@@ -27,7 +27,7 @@ We will show each supported field in turn. For all fields, note that:
 Bytes
 -----
 
-The bytes field describes a string of bytes.
+The bytes field describes a string of bytes::
 
     >>> f = field.Bytes(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.Bytes)
@@ -52,7 +52,7 @@ The bytes field describes a string of bytes.
 BytesLine
 ---------
 
-The bytes field describes a string of bytes, disallowing newlines.
+The bytes field describes a string of bytes, disallowing newlines::
 
     >>> f = field.BytesLine(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.BytesLine)
@@ -77,7 +77,7 @@ The bytes field describes a string of bytes, disallowing newlines.
 ASCII
 -----
 
-The ASCII field describes a string containing only ASCII characters.
+The ASCII field describes a string containing only ASCII characters::
 
     >>> f = field.ASCII(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.ASCII)
@@ -102,8 +102,7 @@ The ASCII field describes a string containing only ASCII characters.
 ASCIILine
 ---------
 
-The ASCII line field describes a string containing only ASCII characters and
-disallowing newlines.
+The ASCII line field describes a string containing only ASCII characters and disallowing newlines::
 
     >>> f = field.ASCIILine(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.ASCIILine)
@@ -128,7 +127,7 @@ disallowing newlines.
 Text
 ----
 
-The text field describes a unicode string.
+The text field describes a unicode string::
 
     >>> f = field.Text(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.Text)
@@ -153,7 +152,7 @@ The text field describes a unicode string.
 TextLine
 --------
 
-The text line field describes a unicode string, disallowing newlines
+The text line field describes a unicode string, disallowing newlines::
 
     >>> f = field.TextLine(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.TextLine)
@@ -178,7 +177,7 @@ The text line field describes a unicode string, disallowing newlines
 Bool
 ----
 
-The bool field describes a boolean.
+The bool field describes a boolean::
 
     >>> f = field.Bool(title=u"Test")
     >>> isinstance(f, schema.Bool)
@@ -203,7 +202,7 @@ The bool field describes a boolean.
 Int
 ---
 
-The int field describes an integer or long.
+The int field describes an integer or long::
 
     >>> f = field.Int(title=u"Test", min=-123, max=1234)
     >>> isinstance(f, schema.Int)
@@ -228,7 +227,7 @@ The int field describes an integer or long.
 Float
 -----
 
-The float field describes a float.
+The float field describes a float::
 
     >>> f = field.Float(title=u"Test", min=-123.0, max=1234.0)
     >>> isinstance(f, schema.Float)
@@ -253,7 +252,7 @@ The float field describes a float.
 Decimal
 -------
 
-The decimal field describes a decimal.
+The decimal field describes a decimal::
 
     >>> import decimal
     >>> f = field.Decimal(title=u"Test", min=decimal.Decimal('-123.0'), max=decimal.Decimal('1234.0'))
@@ -279,7 +278,7 @@ The decimal field describes a decimal.
 Password
 --------
 
-The password field describes a unicode string used for a password.
+The password field describes a unicode string used for a password::
 
     >>> f = field.Password(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.Password)
@@ -304,7 +303,7 @@ The password field describes a unicode string used for a password.
 SourceText
 ----------
 
-The source  text field describes a unicode string with source code.
+The source  text field describes a unicode string with source code::
 
     >>> f = field.SourceText(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.SourceText)
@@ -329,7 +328,7 @@ The source  text field describes a unicode string with source code.
 URI
 ---
 
-The URI field describes a URI string.
+The URI field describes a URI string::
 
     >>> f = field.URI(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.URI)
@@ -354,7 +353,7 @@ The URI field describes a URI string.
 Id
 --
 
-The id field describes a URI string or a dotted name.
+The id field describes a URI string or a dotted name::
 
     >>> f = field.Id(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.Id)
@@ -379,7 +378,7 @@ The id field describes a URI string or a dotted name.
 DottedName
 ----------
 
-The dotted name field describes a dotted name.
+The dotted name field describes a Python dotted name::
 
     >>> f = field.DottedName(title=u"Test", min_length=0, max_length=10)
     >>> isinstance(f, schema.DottedName)
@@ -404,7 +403,7 @@ The dotted name field describes a dotted name.
 Datetime
 --------
 
-The date/time field describes a Python datetime object.
+The date/time field describes a Python datetime object::
 
     >>> f = field.Datetime(title=u"Test")
     >>> isinstance(f, schema.Datetime)
@@ -430,7 +429,7 @@ The date/time field describes a Python datetime object.
 Date
 ----
 
-The date field describes a Python date object.
+The date field describes a Python date object::
 
     >>> f = field.Date(title=u"Test")
     >>> isinstance(f, schema.Date)
@@ -456,7 +455,7 @@ The date field describes a Python date object.
 Timedelta
 ---------
 
-The time-delta field describes a Python timedelta object.
+The time-delta field describes a Python timedelta object::
 
     >>> f = field.Timedelta(title=u"Test")
     >>> isinstance(f, schema.Timedelta)
@@ -482,7 +481,7 @@ The time-delta field describes a Python timedelta object.
 Tuple
 -----
 
-The tuple field describes a tuple.
+The tuple field describes a tuple::
 
     >>> f = field.Tuple(title=u"Test", min_length=0, max_length=10,
     ...     value_type=field.TextLine(title=u"Value"))
@@ -519,7 +518,7 @@ The tuple field describes a tuple.
 List
 ----
 
-The list field describes a tuple.
+The list field describes a tuple::
 
     >>> f = field.List(title=u"Test", min_length=0, max_length=10,
     ...     value_type=field.TextLine(title=u"Value"))
@@ -556,7 +555,7 @@ The list field describes a tuple.
 Set
 ---
 
-The set field describes a set.
+The set field describes a set::
 
     >>> f = field.Set(title=u"Test", min_length=0, max_length=10,
     ...     value_type=field.TextLine(title=u"Value"))
@@ -593,7 +592,7 @@ The set field describes a set.
 Frozenset
 ---------
 
-The set field describes a frozenset.
+The set field describes a frozenset::
 
     >>> f = field.FrozenSet(title=u"Test", min_length=0, max_length=10,
     ...     value_type=field.TextLine(title=u"Value"))
@@ -630,7 +629,7 @@ The set field describes a frozenset.
 Dict
 ----
 
-The set field describes a dict.
+The set field describes a dict::
 
     >>> f = field.Dict(title=u"Test", min_length=0, max_length=10,
     ...     key_type=field.ASCII(title=u"Key"),
@@ -681,9 +680,9 @@ The set field describes a dict.
 Choice
 ------
 
-A choice field represents a selection from a vocabulary. For persistent
-fields, the vocabulary cannot be a `source` or any kind of object: it must
-either be a list of primitives, or a named vocabulary.
+A choice field represents a selection from a vocabulary.
+For persistent fields, the vocabulary cannot be a ``source`` or any kind of object:
+it must either be a list of primitives, or a named vocabulary::
 
     >>> f = field.Choice(title=u"Test", values=[1,2,3])
     >>> isinstance(f, schema.Choice)
@@ -692,8 +691,8 @@ either be a list of primitives, or a named vocabulary.
     >>> f.order
     -1
 
-With a list of values given, the `vocabulary` property returns a vocabulary
-constructed from the values on the fly, and `vocabularyName` is None.
+With a list of values given, the ``vocabulary`` property returns a vocabulary
+constructed from the values on the fly, and ``vocabularyName`` is ``None``::
 
     >>> f.vocabulary
     <zope.schema.vocabulary.SimpleVocabulary object at ...>
@@ -701,15 +700,14 @@ constructed from the values on the fly, and `vocabularyName` is None.
     >>> f.vocabularyName is None
     True
 
-We will, however, get an error if we use anything other than primitives:
+We will get an error if we use anything other than primitives::
 
     >>> f = field.Choice(title=u"Test", values=[object(), object()])
     Traceback (most recent call last):
     ...
     ValueError: Vocabulary values may only contain primitive values.
 
-If a vocabulary name given, it is stored in `vocabularyName`, and the
-`vocabulary` property returns None.
+If a vocabulary name given, it is stored in ``vocabularyName``, and the ``vocabulary`` property returns ``None``::
 
     >>> f = field.Choice(title=u"Test", vocabulary='my.vocab')
     >>> f.vocabulary is None
@@ -718,21 +716,21 @@ If a vocabulary name given, it is stored in `vocabularyName`, and the
     >>> f.vocabularyName
     'my.vocab'
 
-Other combinations are now allowed, such as specifying no vocabulary:
+Other combinations are now allowed, such as specifying no vocabulary::
 
     >>> field.Choice(title=u"Test")
     Traceback (most recent call last):
     ...
     AssertionError: You must specify either values or vocabulary.
 
-Or specifying both types:
+Or specifying both types::
 
     >>> field.Choice(title=u"Test", values=[1,2,3], vocabulary='my.vocab')
     Traceback (most recent call last):
     ...
     AssertionError: You cannot specify both values and vocabulary.
 
-Or specifying an object source:
+Or specifying an object source::
 
     >>> from zope.schema.vocabulary import SimpleVocabulary
     >>> dummy_vocabulary = SimpleVocabulary.fromValues([1,2,3])
@@ -741,14 +739,14 @@ Or specifying an object source:
     ...
     ValueError: Persistent fields do not support sources, only named vocabularies or vocabularies based on simple value sets.
 
-Or specifying an object vocabulary:
+Or specifying an object vocabulary::
 
     >>> field.Choice(title=u"Test", vocabulary=dummy_vocabulary)
     Traceback (most recent call last):
     ...
     ValueError: Persistent fields only support named vocabularies or vocabularies based on simple value sets.
 
-As with other fields, you also cannot set a constraint:
+As with other fields, you also cannot set a constraint::
 
     >>> field.Choice(title=u"Test", values=[1,2,3], constraint=lambda x: True)
     Traceback (most recent call last):
@@ -763,13 +761,12 @@ As with other fields, you also cannot set a constraint:
     >>> f.constraint('ABC')
     True
 
-IPersistentField adapters
-=========================
+``IPersistentField`` adapters
+=============================
 
-It is possible to adapt any non-persistent field to its related
-IPersistentField using the adapter factories in plone.registry.fieldfactory.
-These are set up in configure.zcml and explicitly registered in the test
-setup in tests.py. Custom adapters are of course also possible.
+It is possible to adapt any non-persistent field to its related ``IPersistentField`` using the adapter factories in ``plone.registry`` fieldfactory.
+These are set up in ``configure.zcml`` and explicitly registered in the test setup in ``tests.py``.
+Custom adapters are of course also possible::
 
     >>> from plone.registry.interfaces import IPersistentField
 
@@ -784,7 +781,7 @@ setup in tests.py. Custom adapters are of course also possible.
     >>> isinstance(p, field.TextLine)
     True
 
-Unsupported field types will not be adaptable by default.
+Unsupported field types will not be adaptable by default::
 
     >>> f = schema.Object(title=u"Object", schema=IPersistentField)
     >>> IPersistentField(f, None) is None
@@ -794,13 +791,14 @@ Unsupported field types will not be adaptable by default.
     >>> IPersistentField(f, None) is None
     True
 
-After adaptation, the rules of persistent fields apply: The `order` attribute
-is perpetually -1, custom constraints are not allowed, and key and value type
-will be adapted to persistent fields as well. If any of these constraints
-cannot be met, the adaptation will fail.
+After adaptation, the rules of persistent fields apply:
+The ``order`` attribute is perpetually ``-1``.
+Custom constraints are not allowed, and key and value type will be adapted to persistent fields as well.
+If any of these constraints can not be met, the adaptation will fail.
+
+For constraints, the non-persistent value is simply ignored and the default method from the class will be used.
 
-For constraints, the non-persistent value is simply ignored and the default
-method from the class will be used.
+::
 
     >>> f = schema.TextLine(title=u"Test", constraint=lambda x: False)
     >>> f.constraint
@@ -810,7 +808,7 @@ method from the class will be used.
     >>> p.constraint
     <bound method TextLine.constraint of <plone.registry.field.TextLine object at ...>>
 
-The order property is similarly ignored:
+The order property is similarly ignored::
 
     >>> f.order > 0
     True
@@ -818,7 +816,7 @@ The order property is similarly ignored:
     >>> p.order
     -1
 
-Key/value types will be adapted if possible.
+Key/value types will be adapted if possible::
 
     >>> f = schema.Dict(title=u"Test",
     ...     key_type=schema.Id(title=u"Id"),
@@ -830,7 +828,7 @@ Key/value types will be adapted if possible.
     >>> p.value_type
     <plone.registry.field.TextLine object at ...>
 
-However, if they cannot be adapted, there will be an error.
+If they cannot be adapted, there will be an error::
 
     >>> f = schema.Dict(title=u"Test",
     ...     key_type=schema.Id(title=u"Id"),
@@ -848,9 +846,10 @@ However, if they cannot be adapted, there will be an error.
     ...
     TypeError: ('Could not adapt', <zope.schema._field.Dict object at ...>, <InterfaceClass plone.registry.interfaces.IPersistentField>)
 
-There is additional validation for choice fields that warrant a custom
-adapter. These ensure that vocabularies are either stored as a list of
-simple values, or as named vocabularies.
+There is additional validation for choice fields that warrant a custom adapter.
+These ensure that vocabularies are either stored as a list of simple values, or as named vocabularies.
+
+::
 
     >>> f = schema.Choice(title=u"Test", values=[1,2,3])
     >>> p = IPersistentField(f)
@@ -870,7 +869,7 @@ simple values, or as named vocabularies.
     >>> p.vocabularyName
     'my.vocab'
 
-Complex vocabularies or sources are not allowed:
+Complex vocabularies or sources are not allowed::
 
     >>> from zope.schema.vocabulary import SimpleVocabulary
     >>> dummy_vocabulary = SimpleVocabulary.fromItems([('a', 1), ('b', 2)])
diff --git a/plone/registry/fieldfactory.py b/plone/registry/fieldfactory.py
index de3a9bb..7089705 100644
--- a/plone/registry/fieldfactory.py
+++ b/plone/registry/fieldfactory.py
@@ -1,19 +1,21 @@
-import zope.interface
-import zope.component
-
-import plone.registry.field
-
-from zope.schema.interfaces import IField, IChoice
-from zope.schema.interfaces import ISource, IContextSourceBinder
-from zope.schema.vocabulary import SimpleVocabulary
-
-from plone.registry.interfaces import IPersistentField
-from plone.registry.field import DisallowedProperty, StubbornProperty, InterfaceConstrainedProperty
+# -*- coding: utf-8 -*-
+from plone.registry.field import DisallowedProperty
+from plone.registry.field import InterfaceConstrainedProperty
 from plone.registry.field import is_primitive
+from plone.registry.field import StubbornProperty
+from plone.registry.interfaces import IPersistentField
+from zope.component import adapter
+from zope.interface import implementer
+from zope.schema.interfaces import IChoice
+from zope.schema.interfaces import IContextSourceBinder
+from zope.schema.interfaces import IField
+from zope.schema.interfaces import ISource
+from zope.schema.vocabulary import SimpleVocabulary
+import plone.registry.field
 
 
-@zope.interface.implementer(IPersistentField)
-@zope.component.adapter(IField)
+@implementer(IPersistentField)
+@adapter(IField)
 def persistentFieldAdapter(context):
     """Turn a non-persistent field into a persistent one
     """
@@ -37,34 +39,38 @@ def persistentFieldAdapter(context):
 
     instance = persistent_class.__new__(persistent_class)
 
-    context_dict = dict([(k,v) for k,v in context.__dict__.items()
-                            if k not in ignored])
-
-    for k,iface in constrained:
-        v = context_dict.get(k, None)
-        if v is not None and v != context.missing_value:
-            v = iface(v, None)
-            if v is None:
-                __traceback_info__ = "The property `%s` cannot be adapted to `%s`." % (k, iface.__identifier__,)
-                return None
-            context_dict[k] = v
+    context_dict = dict(
+        [(k, v) for k, v in context.__dict__.items() if k not in ignored]
+    )
+
+    for key, iface in constrained:
+        value = context_dict.get(key, None)
+        if value is None or value == context.missing_value:
+            continue
+        value = iface(value, None)
+        if value is None:
+            __traceback_info__ = (
+                "The property `{0}` cannot be adapted to "
+                "`{1}`.".format(key, iface.__identifier__,)
+            )
+            return None
+        context_dict[key] = value
 
     instance.__dict__.update(context_dict)
     return instance
 
-@zope.interface.implementer(IPersistentField)
-@zope.component.adapter(IChoice)
+
+@implementer(IPersistentField)
+@adapter(IChoice)
 def choicePersistentFieldAdapter(context):
     """Special handling for Choice fields.
     """
-
     instance = persistentFieldAdapter(context)
     if instance is None:
         return None
 
     if ISource.providedBy(context.vocabulary) or \
             IContextSourceBinder.providedBy(context.vocabulary):
-
         safe = False
 
         # Attempt to reverse engineer a 'values' argument
@@ -81,8 +87,10 @@ def choicePersistentFieldAdapter(context):
                 instance._values = values
 
         if not safe:
-            __traceback_info__ = "Persistent fields only support named vocabularies " + \
-                                    "or vocabularies based on simple value sets."
+            __traceback_info__ = (
+                "Persistent fields only support named vocabularies "
+                "or vocabularies based on simple value sets."
+            )
             return None
 
-    return instance
\ No newline at end of file
+    return instance
diff --git a/plone/registry/fieldref.py b/plone/registry/fieldref.py
index 0df6c72..a4ae488 100644
--- a/plone/registry/fieldref.py
+++ b/plone/registry/fieldref.py
@@ -1,14 +1,14 @@
+# -*- coding: utf-8 -*-
+from plone.registry.interfaces import IFieldRef
 from zope.interface import implementedBy
-from zope.interface import implements
+from zope.interface import implementer
 
-from plone.registry.interfaces import IFieldRef
 
+@implementer(IFieldRef)
 class FieldRef(object):
     """Default field reference.
     """
 
-    implements(IFieldRef)
-
     def __init__(self, name, originalField):
         self.recordName = name
         self.originalField = originalField
diff --git a/plone/registry/record.py b/plone/registry/record.py
index 44b2c3a..2211425 100644
--- a/plone/registry/record.py
+++ b/plone/registry/record.py
@@ -1,18 +1,18 @@
+# -*- coding: utf-8 -*-
 from persistent import Persistent
-
-from zope.interface import implements, alsoProvides
-from zope.event import notify
-
-from zope.dottedname.resolve import resolve
-
+from plone.registry.events import RecordModifiedEvent
+from plone.registry.interfaces import IInterfaceAwareRecord
 from plone.registry.interfaces import IPersistentField
 from plone.registry.interfaces import IRecord
-from plone.registry.interfaces import IInterfaceAwareRecord
-
-from plone.registry.events import RecordModifiedEvent
+from zope.dottedname.resolve import resolve
+from zope.event import notify
+from zope.interface import implementer
+from zope.interface import alsoProvides
 
 _marker = object()
 
+
+@implementer(IRecord)
 class Record(Persistent):
     """A record that is stored in the registry.
 
@@ -24,8 +24,6 @@ class Record(Persistent):
     values may be loaded during automated migration.
     """
 
-    implements(IRecord)
-
     __name__ = u""
     __parent__ = None
 
diff --git a/plone/registry/recordsproxy.py b/plone/registry/recordsproxy.py
index 994c040..ffc53f7 100644
--- a/plone/registry/recordsproxy.py
+++ b/plone/registry/recordsproxy.py
@@ -1,24 +1,25 @@
-from zope.interface import implements, alsoProvides
-from zope.schema import getFieldsInOrder
-from zope.schema.interfaces import RequiredMissing
+# -*- coding: utf-8 -*-
 from plone.registry.interfaces import IRecordsProxy
-
 from UserDict import DictMixin
+from zope.interface import alsoProvides
+from zope.interface import implementer
+from zope.schema import getFieldsInOrder
+from zope.schema.interfaces import RequiredMissing
 import re
 
 _marker = object()
 
+
+@implementer(IRecordsProxy)
 class RecordsProxy(object):
     """A proxy that maps an interface to a number of records
     """
 
-    implements(IRecordsProxy)
-
     def __init__(self, registry, schema, omitted=(), prefix=None):
         if prefix is None:
             prefix = schema.__identifier__ + '.'
         elif not prefix.endswith("."):
-             prefix += '.'
+            prefix += '.'
 
         # skip __setattr__
         self.__dict__['__schema__'] = schema
@@ -46,7 +47,10 @@ def __setattr__(self, name, value):
             self.__dict__[name] = value
 
     def __repr__(self):
-        return "<%s for %s>" % (self.__class__.__name__, self.__schema__.__identifier__)
+        return "<{0} for {1}>".format(
+            self.__class__.__name__,
+            self.__schema__.__identifier__
+        )
 
 
 class RecordsProxyCollection(DictMixin):
@@ -57,12 +61,13 @@ class RecordsProxyCollection(DictMixin):
 
     # ord('.') == ord('/') - 1
 
-    def __init__(self, registry, schema, check=True, omitted=(), prefix=None, factory=None):
+    def __init__(self, registry, schema, check=True, omitted=(), prefix=None,
+                 factory=None):
         if prefix is None:
             prefix = schema.__identifier__
 
         if not prefix.endswith("/"):
-             prefix += '/'
+            prefix += '/'
 
         self.registry = registry
         self.schema = schema
@@ -72,9 +77,15 @@ def __init__(self, registry, schema, check=True, omitted=(), prefix=None, factor
         self.factory = factory
 
     def __getitem__(self, key):
-        if self.has_key(key):
+        if key in self:
             prefix = self.prefix + key
-            proxy = self.registry.forInterface(self.schema, self.check, self.omitted, prefix, self.factory)
+            proxy = self.registry.forInterface(
+                self.schema,
+                self.check,
+                self.omitted,
+                prefix,
+                self.factory
+            )
             return proxy
         raise KeyError(key)
 
@@ -99,7 +110,10 @@ def keys(self):
 
     def _validate(self, key):
         if not isinstance(key, basestring) or not self._validkey(key):
-            raise TypeError('expected a valid key (alphanumeric or underscore, starting with alpha)')
+            raise TypeError(
+                'expected a valid key (alphanumeric or underscore, starting '
+                'with alpha)'
+            )
         return str(key)
 
     def has_key(self, key):
@@ -112,7 +126,12 @@ def add(self, key):
         key = self._validate(key)
         prefix = self.prefix + key
         self.registry.registerInterface(self.schema, self.omitted, prefix)
-        proxy = self.registry.forInterface(self.schema, False, self.omitted, prefix)
+        proxy = self.registry.forInterface(
+            self.schema,
+            False,
+            self.omitted,
+            prefix
+        )
         return proxy
 
     def __setitem__(self, key, value):
@@ -132,7 +151,7 @@ def __setitem__(self, key, value):
             setattr(proxy, name, attr)
 
     def setdefault(self, key, failobj=None):
-        if not self.has_key(key):
+        if key not in self:
             if failobj is None:
                 self.add(key)
             else:
@@ -140,7 +159,7 @@ def setdefault(self, key, failobj=None):
         return self[key]
 
     def __delitem__(self, key):
-        if not self.has_key(key):
+        if key not in self:
             raise KeyError(key)
         prefix = self.prefix + key
         names = list(self.registry.records.keys(prefix+'.', prefix+'/'))
diff --git a/plone/registry/registry.py b/plone/registry/registry.py
index 6776029..2d814e7 100644
--- a/plone/registry/registry.py
+++ b/plone/registry/registry.py
@@ -1,32 +1,31 @@
-import re
-import warnings
-
-from persistent import Persistent
+# -*- coding: utf-8 -*-
 from BTrees.OOBTree import OOBTree
-
-from zope.interface import implements
-from zope.component import queryAdapter
-from zope.event import notify
-
-from zope.schema import getFieldNames, getFieldsInOrder
-
-from zope.schema._field import _isdotted
-
-from plone.registry.interfaces import IRegistry, IRecord, IPersistentField
+from persistent import Persistent
+from plone.registry.events import RecordAddedEvent
+from plone.registry.events import RecordRemovedEvent
+from plone.registry.fieldref import FieldRef
 from plone.registry.interfaces import IFieldRef
 from plone.registry.interfaces import InvalidRegistryKey
+from plone.registry.interfaces import IPersistentField
+from plone.registry.interfaces import IRecord
+from plone.registry.interfaces import IRegistry
 from plone.registry.record import Record
-from plone.registry.fieldref import FieldRef
 from plone.registry.recordsproxy import RecordsProxy
 from plone.registry.recordsproxy import RecordsProxyCollection
-from plone.registry.events import RecordAddedEvent, RecordRemovedEvent
+from zope.component import queryAdapter
+from zope.event import notify
+from zope.interface import implementer
+from zope.schema import getFieldNames
+from zope.schema import getFieldsInOrder
+import re
+import warnings
+
 
+@implementer(IRegistry)
 class Registry(Persistent):
     """The persistent registry
     """
 
-    implements(IRegistry)
-
     def __init__(self):
         self._records = _Records(self)
 
@@ -60,18 +59,24 @@ def records(self):
 
     # Schema interface API
 
-    def forInterface(self, interface, check=True, omit=(), prefix=None, factory=None):
+    def forInterface(self, interface, check=True, omit=(), prefix=None,
+                     factory=None):
         if prefix is None:
             prefix = interface.__identifier__
 
         if not prefix.endswith("."):
-             prefix += '.'
+            prefix += '.'
 
         if check:
             for name in getFieldNames(interface):
                 if name not in omit and prefix + name not in self:
-                    raise KeyError("Interface `%s` defines a field `%s`, "
-                                   "for which there is no record." % (interface.__identifier__, name))
+                    raise KeyError(
+                        "Interface `{0}` defines a field `{1}`, for which "
+                        "there is no record.".format(
+                            interface.__identifier__,
+                            name
+                        )
+                    )
 
         if factory is None:
             factory = RecordsProxy
@@ -83,7 +88,7 @@ def registerInterface(self, interface, omit=(), prefix=None):
             prefix = interface.__identifier__
 
         if not prefix.endswith("."):
-             prefix += '.'
+            prefix += '.'
 
         for name, field in getFieldsInOrder(interface):
             if name in omit or field.readonly:
@@ -91,8 +96,13 @@ def registerInterface(self, interface, omit=(), prefix=None):
             record_name = prefix + name
             persistent_field = queryAdapter(field, IPersistentField)
             if persistent_field is None:
-                raise TypeError("There is no persistent field equivalent for "
-                                "the field `%s` of type `%s`." % (name, field.__class__.__name__))
+                raise TypeError(
+                    "There is no persistent field equivalent for the field "
+                    "`{0}` of type `{1}`.".format(
+                        name,
+                        field.__class__.__name__
+                    )
+                )
 
             persistent_field.interfaceName = interface.__identifier__
             persistent_field.fieldName = name
@@ -109,10 +119,22 @@ def registerInterface(self, interface, omit=(), prefix=None):
                 except:
                     value = persistent_field.default
 
-            self.records[record_name] = Record(persistent_field, value, _validate=False)
-
-    def collectionOfInterface(self, interface, check=True, omit=(), prefix=None, factory=None):
-        return RecordsProxyCollection(self, interface, check, omit, prefix, factory)
+            self.records[record_name] = Record(
+                persistent_field,
+                value,
+                _validate=False
+            )
+
+    def collectionOfInterface(self, interface, check=True, omit=(),
+                              prefix=None, factory=None):
+        return RecordsProxyCollection(
+            self,
+            interface,
+            check,
+            omit,
+            prefix,
+            factory
+        )
 
     # BBB
 
@@ -126,18 +148,21 @@ def _migrateRecords(self):
         if oldData is not None:
             for name, oldRecord in oldData.iteritems():
                 oldRecord._p_activate()
-                if 'field' in oldRecord.__dict__ and 'value' in oldRecord.__dict__:
+                if (
+                    'field' in oldRecord.__dict__
+                    and 'value' in oldRecord.__dict__
+                ):
                     records._fields[name] = oldRecord.__dict__['field']
                     records._values[name] = oldRecord.__dict__['value']
 
         self._records = records
 
+
 class _Records(object):
     """The records stored in the registry. This implements dict-like access
     to records, where as the Registry object implements dict-like read-only
     access to values.
     """
-
     __parent__ = None
 
     # Similar to zope.schema._field._isdotted, but allows up to one '/'
@@ -208,7 +233,7 @@ def __iter__(self):
         return self._values.__iter__()
 
     def has_key(self, name):
-        return self._values.has_key(name)
+        return self._values.__contains__(name)
 
     def __contains__(self, name):
         return self._values.__contains__(name)
@@ -257,12 +282,15 @@ def _setField(self, name, field):
             raise ValueError("The record's field must be an IPersistentField.")
         if IFieldRef.providedBy(field):
             if field.recordName not in self._fields:
-                raise ValueError("Field reference points to non-existent record")
-            self._fields[name] = field.recordName # a pointer, of sorts
+                raise ValueError(
+                    "Field reference points to non-existent record"
+                )
+            self._fields[name] = field.recordName  # a pointer, of sorts
         else:
             field.__name__ = 'value'
             self._fields[name] = field
 
+
 class Records(_Records, Persistent):
     """BBB: This used to be the class for the _records attribute of the
     registry. Having this be a Persistent object was always a bad idea. We
@@ -271,5 +299,9 @@ class Records(_Records, Persistent):
     """
 
     def __init__(self, parent):
-        warnings.warn("The Records persistent class is deprecated and should not be used.", DeprecationWarning)
+        warnings.warn(
+            "The Records persistent class is deprecated and should not be "
+            "used.",
+            DeprecationWarning
+        )
         super(Records, self).__init__(parent)
diff --git a/plone/registry/registry.rst b/plone/registry/registry.rst
index 986d81a..693e11f 100644
--- a/plone/registry/registry.rst
+++ b/plone/registry/registry.rst
@@ -2,17 +2,20 @@
 Using registries
 ================
 
-You can create a new registry simply by instantiating the Registry class. The
-class and its data structures are persistent, so you can store them in the
-ZODB. You may want to provide the registry object as local utility for easy
-access as well, though we won't do that here.
+You can create a new registry simply by instantiating the Registry class.
+The class and its data structures are persistent, so you can store them in the ZODB.
+You may want to provide the registry object as local utility for easy access as well, though we won't do that here.
+
+::
 
     >>> from plone.registry import Registry
     >>> registry = Registry()
 
-The registry starts out empty. To access the registry's records, you can use
-the `records` property. This exposes a dict API where keys are strings and
-values are objects providing `IRecords`.
+The registry starts out empty.
+To access the registry's records, you can use the ``records`` property.
+This exposes a dict API where keys are strings and values are objects providing ``IRecords``.
+
+::
 
     >>> len(registry.records)
     0
@@ -20,37 +23,36 @@ values are objects providing `IRecords`.
 Simple records
 ==============
 
-Let's now create a record. A record must have a name. This should be a dotted
-name, and contain ASCII characters only. By convention, it should be all
-lowercase and start with the name of the package that defines the record.
+Let's now create a record.
+A record must have a name.
+This should be a dotted name, and contain ASCII characters only.
+By convention, it should be all lowercase and start with the name of the package that defines the record.
 
-It is also possible to create a  number of records based on a single schema
-interface - see below - but for now, we will focus on simple records.
+It is also possible to create a  number of records based on a single schema interface - see below.
+For now, we will focus on simple records.
 
 Before we can create the record, we must create the field that describes it.
-Fields are based on the venerable zope.schema package, but plone.registry
-only supports certain fields, and disallows use of a few properties even
-of those. As a rule of thumb, so long as a field stores a Python primitive,
-it is supported; the same goes for attributes of fields.
+Fields are based on the venerable ``zope.schema`` package.
+``plone.registry`` only supports certain fields, and disallows use of a few properties even of those.
+As a rule of thumb, so long as a field stores a Python primitive, it is supported; the same goes for attributes of fields.
 
 Thus:
 
- * Fields like `Object`, `InterfaceField` and so on are not supported
- * A custom `constraint` method is not supported.
- * The `order` attribute will always be set to -1
- * For Choice fields, only named vocabularies are supported: you cannot
-   reference a particular source or source binder
- * The key_type and value_type properties of Dict, List, Tuple, Set and
-   Frozenset may only contain persistent fields.
+* Fields like ``Object``, ``InterfaceField`` and so on are *not* supported.
+* A custom ``constraint`` method is *not* supported.
+* The ``order`` attribute will *always* be set to ``-1``.
+* For Choice fields, *only named vocabularies* are supported:
+  you can *not* reference a particular *source* or *source binder*.
+* The ``key_type`` and ``value_type`` properties of ``Dict``, ``List``, ``Tuple``, ``Set`` and ``Frozenset`` may *only* contain persistent fields.
 
-See field.rst for more details.
+See section "Persistent fields" for more details.
 
 Creating a record
 -----------------
 
-The supported field types are found in the module plone.registry.field. These
-are named the same as the equivalent field in zope.schema, and have the same
-constructors. You must use one of these fields when creating records directly.
+The supported field types are found in the module ``plone.registry.field``.
+These are named the same as the equivalent field in ``zope.schema``, and have the same constructors.
+You must use one of these fields when creating records directly::
 
     >>> from plone.registry import field
     >>> age_field = field.Int(title=u"Age", min=0, default=18)
@@ -58,20 +60,19 @@ constructors. You must use one of these fields when creating records directly.
     >>> from plone.registry import Record
     >>> age_record = Record(age_field)
 
-Note that in this case, we did not supply a value. The value will therefore
-be the field default.
+Note that in this case, we did not supply a value.
+The value will therefore be the field default::
 
     >>> age_record.value
     18
 
-We can set a different value, either in the `Record` constructor or via the
-`value` attribute:
+We can set a different value, either in the ``Record`` constructor or via the ``value`` attribute::
 
     >>> age_record.value = 2
     >>> age_record.value
     2
 
-Note that the value is validated against the field:
+Note that the value is validated against the field::
 
     >>> age_record.value = -1
     Traceback (most recent call last):
@@ -81,14 +82,14 @@ Note that the value is validated against the field:
     >>> age_record.value
     2
 
-We can now add the field to the registry. This is done via the `record`
-dictionary.
+We can now add the field to the registry.
+This is done via the ``record`` dictionary::
 
     >>> 'plone.registry.tests.age' in registry
     False
     >>> registry.records['plone.registry.tests.age'] = age_record
 
-At this point, the record will gain __name__ and __parent__ attributes.
+At this point, the record will gain ``__name__`` and ``__parent__`` attributes::
 
     >>> age_record.__name__
     'plone.registry.tests.age'
@@ -99,14 +100,19 @@ At this point, the record will gain __name__ and __parent__ attributes.
 Creating a record with an initial value
 ---------------------------------------
 
-We can create records more succinctly by creating the field, setting the value
-and assigning it to the registry in one go, like this:
+We can create records more succinctly in *one go* by
+
+1. creating the field,
+2. creating the Record and setting its value as and
+3. assigning it to the registry,
+
+like this::
 
     >>> registry.records['plone.registry.tests.cms'] = \
     ...     Record(field.TextLine(title=u"CMS of choice"), u"Plone")
 
-The record can now be obtained. Note that it has a nice __repr__ to help
-debugging.
+The record can now be obtained.
+Note that it has a nice ``__repr__`` to help debugging.
 
     >>> registry.records['plone.registry.tests.cms']
     <Record plone.registry.tests.cms>
@@ -114,8 +120,8 @@ debugging.
 Accessing and manipulating record values
 ----------------------------------------
 
-Once a record has been created and added to the registry, you can access
-its value through dict-like operations on the registry itself.
+Once a record has been created and added to the registry,
+you can access its value through dict-like operations on the registry itself::
 
     >>> 'plone.registry.tests.cms' in registry
     True
@@ -125,14 +131,14 @@ its value through dict-like operations on the registry itself.
 
     >>> registry['plone.registry.tests.cms'] = u"Plone 3.x"
 
-Again, values are validated:
+Again, values are validated::
 
     >>> registry['plone.registry.tests.cms'] = 'Joomla'
     Traceback (most recent call last):
     ...
     WrongType: ('Joomla', <type 'unicode'>...)
 
-There is also a get() method:
+There is also a ``get()`` method::
 
     >>> registry.get('plone.registry.tests.cms')
     u'Plone 3.x'
@@ -142,7 +148,7 @@ There is also a get() method:
 Deleting records
 ----------------
 
-Records may be deleted from the `records` property:
+Records may be deleted from the ``records`` property::
 
     >>> del registry.records['plone.registry.tests.cms']
     >>> 'plone.registry.tests.cms' in registry.records
@@ -153,16 +159,15 @@ Records may be deleted from the `records` property:
 Creating records from interfaces
 ================================
 
-As an application developer, it is often desirable to define settings as
-traditional interfaces with zope.schema fields. plone.registry includes
-support for creating a set of records from a single interface.
+As an application developer, it is often desirable to define settings as traditional interfaces with ``zope.schema fields``.
+``plone.registry`` includes support for creating a set of records from a single interface.
 
-To test this, we have created an interface, `IMailSettings`, with two fields,
-`sender` and `smtp_host`.
+To test this, we have created an interface, ``IMailSettings``.
+It has two fields: ``sender`` and ``smtp_host``::
 
     >>> from plone.registry.tests import IMailSettings
 
-Note that this contains standard fields.
+Note that this contains standard fields::
 
     >>> IMailSettings['sender']
     <zope.schema._bootstrapfields.TextLine object at ...>
@@ -170,18 +175,17 @@ Note that this contains standard fields.
     >>> IMailSettings['smtp_host']
     <zope.schema._field.URI object at ...>
 
-We can create records from this interface like this:
+We can create records from this interface like this::
 
     >>> registry.registerInterface(IMailSettings)
 
-One record for each field in the interface has now been created. Their names
-are the full dotted names to those fields:
+One record for each field in the interface has now been created.
+Their names are the full dotted names to those fields::
 
     >>> sender_record = registry.records['plone.registry.tests.IMailSettings.sender']
     >>> smtp_host_record = registry.records['plone.registry.tests.IMailSettings.smtp_host']
 
-The fields used in the records will be the equivalent persistent versions of
-the fields from the original interface.
+The fields used in the records will be the equivalent persistent versions of the fields from the original interface::
 
     >>> sender_record.field
     <plone.registry.field.TextLine object at ...>
@@ -189,18 +193,15 @@ the fields from the original interface.
     >>> smtp_host_record.field
     <plone.registry.field.URI object at ...>
 
-This feat is accomplished internally by adapting the field to the
-IPersistentField interface. There is a default adapter factory that works for
-all fields defined in plone.registry.field. You can of course define your own
-adapter if you have a custom field type, but bear in mind the golden rules of
-any persistent field:
+This feat is accomplished internally by adapting the field to the ``IPersistentField`` interface.
+There is a default adapter factory that works for all fields defined in ``plone.registry.field``.
+You can of course define your own adapter if you have a custom field type.
+But bear in mind the golden rules of any persistent field::
 
-  * The field must store only primitives or other persistent fields
-  * It must not reference a function, class, interface or other method that
-    could break if a package is uninstalled.
+* The field must store only primitives or other persistent fields
+* It must not reference a function, class, interface or other method that could break if a package is uninstalled.
 
-If we have a field for which there is no IPersistentField adapter, we will
-get an error:
+If we have a field for which there is no ``IPersistentField`` adapter, we will get an error::
 
     >>> from plone.registry.tests import IMailPreferences
     >>> IMailPreferences['settings']
@@ -211,13 +212,12 @@ get an error:
     ...
     TypeError: There is no persistent field equivalent for the field `settings` of type `Object`.
 
-Whoops! We can, however, tell registerInterface() to ignore one or more
-fields.
+Whoops!
+We can, however, tell ``registerInterface()`` to ignore one or more fields::
 
     >>> registry.registerInterface(IMailPreferences, omit=('settings',))
 
-Once an interface's records have been registered, we can get and set their
-values as normal:
+Once an interface's records have been registered, we can get and set their values as normal::
 
     >>> registry['plone.registry.tests.IMailSettings.sender']
     u'root@localhost'
@@ -226,15 +226,14 @@ values as normal:
     >>> registry['plone.registry.tests.IMailSettings.sender']
     u'webmaster@localhost'
 
-If we sub-sequently re-register the same interface, the value will be retained
-if possible:
+If we sub-sequently re-register the same interface, the value will be retained if possible::
 
     >>> registry.registerInterface(IMailSettings)
     >>> registry['plone.registry.tests.IMailSettings.sender']
     u'webmaster@localhost'
 
-However, if the value is no longer valid, we will revert to the default. To
-test that, let's sneakily modify the field for a while.
+However, if the value is no longer valid, we will revert to the default.
+To test that, let's sneakily modify the field for a while::
 
     >>> old_field = IMailSettings['sender']
     >>> IMailSettings._InterfaceClass__attrs['sender'] = field.Int(title=u"Definitely not a string", default=2)
@@ -244,7 +243,7 @@ test that, let's sneakily modify the field for a while.
     >>> registry['plone.registry.tests.IMailSettings.sender']
     2
 
-But let's put it back the way it was.
+But let's put it back the way it was::
 
     >>> IMailSettings._InterfaceClass__attrs['sender'] = old_field
     >>> if hasattr(IMailSettings, '_v_attrs'):
@@ -253,16 +252,14 @@ But let's put it back the way it was.
     >>> registry['plone.registry.tests.IMailSettings.sender']
     u'root@localhost'
 
-Sometimes, you may want to use an interface as a template for multiple
-instances of a set of fields, rather than defining them all by hand. This is
-especially useful when you want to allow third-party packages to provide
-information. To accomplish this, we can provide a prefix with the
-`registerInterface` call. This will take precedence over the __identifier__
-that is usually used.
+Sometimes, you may want to use an interface as a template for multiple instances of a set of fields, rather than defining them all by hand.
+This is especially useful when you want to allow third-party packages to provide information.
+To accomplish this, we can provide a prefix with the ``registerInterface`` call.
+This will take precedence over the ``__identifier__`` that is usually used.
 
     >>> registry.registerInterface(IMailSettings, prefix="plone.registry.tests.alternativesettings")
 
-These values are now available in the same way as the original settings:
+These values are now available in the same way as the original settings::
 
     >>> sender_record = registry.records['plone.registry.tests.alternativesettings.sender']
     >>> smtp_host_record = registry.records['plone.registry.tests.alternativesettings.smtp_host']
@@ -271,12 +268,12 @@ These values are now available in the same way as the original settings:
 Accessing the original interface
 --------------------------------
 
-Now that we have these records, we can look up the original interface. This
-does not break the golden rules: internally, we only store the name of the
-interface, and resolve it at runtime.
+Now that we have these records, we can look up the original interface.
+This does not break the golden rules:
+internally, we only store the name of the interface, and resolve it at runtime.
 
-Records that know about interfaces are marked with `IInterfaceAwareRecord` and
-have two additional properties: `interface` and `fieldName`.
+Records that know about interfaces are marked with ``IInterfaceAwareRecord`` and have two additional properties:
+``interface`` and ``fieldName``::
 
     >>> from plone.registry.interfaces import IInterfaceAwareRecord
     >>> IInterfaceAwareRecord.providedBy(age_record)
@@ -293,50 +290,46 @@ have two additional properties: `interface` and `fieldName`.
 Using the records proxy
 -----------------------
 
-Once the records for an interface has been created, it is possible to obtain
-a proxy object that provides the given interface, but reads and writes its
-values to the registry. This is useful, for example, to create a form using
-`zope.formlib` or `z3c.form` that is configured with widgets based on the
-interface, or simply as a more convenient API when working with multiple,
-related settings.
+Once the records for an interface has been created, it is possible to obtain a proxy object that provides the given interface, but reads and writes its values to the registry.
+This is useful, for example, to create a form using ``zope.formlib`` or  ``z3c.form`` that is configured with widgets based on the
+interface.
+Or simply as a more convenient API when working with multiple, related settings.
+
+::
 
     >>> proxy = registry.forInterface(IMailSettings)
     >>> proxy
     <RecordsProxy for plone.registry.tests.IMailSettings>
 
-If you use your registry values in code
-which might be encountered on normal HTML rendering
-paths (e.g. in a viewlet) you need to be aware that records
-might not exist or they are invalid. `forInterface()`
-will raise KeyError on this kind of situations::
+If you use your registry values in code which might be encountered on normal HTML rendering paths (e.g. in a viewlet) you need to be aware that records might not exist or they are invalid.
+``forInterface()`` will raise KeyError on this kind of situations::
 
-   try:
-       proxy = registry.forInterface(IMailSettings)
-   except KeyError:
-       # Gracefully handled cases
-       # when GenericSetup installer has not been run or rerun
-       # e.g. by returning or using some default values
-       pass
+    try:
+        proxy = registry.forInterface(IMailSettings)
+    except KeyError:
+        # Gracefully handled cases
+        # when GenericSetup installer has not been run or rerun
+        # e.g. by returning or using some default values
+        pass
 
-The proxy is not a persistent object on its own.
+The proxy is not a persistent object on its own::
 
     >>> from persistent.interfaces import IPersistent
     >>> IPersistent.providedBy(proxy)
     False
 
-It does, however, provide the requisite interface.
+It does, however, provide the requisite interface::
 
     >>> IMailSettings.providedBy(proxy)
     True
 
-You can distinguish between the proxy and a 'norma' object by checking for the
-IRecordsProxy marker interface:
+You can distinguish between the proxy and a 'normal' object by checking for the ``IRecordsProxy`` marker interface::
 
     >>> from plone.registry.interfaces import IRecordsProxy
     >>> IRecordsProxy.providedBy(proxy)
     True
 
-When we set a value, it is stored in the registry:
+When we set a value, it is stored in the registry::
 
     >>> proxy.smtp_host = 'http://mail.server.com'
     >>> registry['plone.registry.tests.IMailSettings.smtp_host']
@@ -346,51 +339,51 @@ When we set a value, it is stored in the registry:
     >>> proxy.smtp_host
     'smtp://mail.server.com'
 
-Values not in the interface will raise an AttributeError:
+Values not in the interface will raise an ``AttributeError``::
 
     >>> proxy.age
     Traceback (most recent call last):
     ...
     AttributeError: age
 
-Note that by default, the forInterface() method will check that the necessary
-records have been registered. For example, we cannot use any old interface:
+Note that by default, the forInterface() method will check that the necessary records have been registered.
+For example, we cannot use any old interface::
 
     >>> registry.forInterface(IInterfaceAwareRecord)
     Traceback (most recent call last):
     ...
     KeyError: 'Interface `plone.registry.interfaces.IInterfaceAwareRecord` defines a field `interface`, for which there is no record.'
 
-By default, we also cannot use an interface for which only some records exist:
+By default, we also cannot use an interface for which only some records exist::
 
     >>> registry.forInterface(IMailPreferences)
     Traceback (most recent call last):
     ...
     KeyError: 'Interface `plone.registry.tests.IMailPreferences` defines a field `settings`, for which there is no record.'
 
-It is possible to disable this check, however. This will be a bit more
-efficient:
+It is possible to disable this check, however.
+This will be a bit more efficient::
 
     >>> registry.forInterface(IMailPreferences, check=False)
     <RecordsProxy for plone.registry.tests.IMailPreferences>
 
-A better way, however, is to explicitly declare that some fields are omitted:
+A better way, however, is to explicitly declare that some fields are omitted::
 
     >>> pref_proxy = registry.forInterface(IMailPreferences, omit=('settings',))
 
-In this case, the omitted fields will default to their 'missing' value:
+In this case, the omitted fields will default to their 'missing' value::
 
     >>> pref_proxy.settings ==  IMailPreferences['settings'].missing_value
     True
 
-However, trying to set the value will result in a AttributeError:
+However, trying to set the value will result in a ``AttributeError``::
 
     >>> pref_proxy.settings = None
     Traceback (most recent call last):
     ...
     AttributeError: settings
 
-To access another instance of the field, supply the prefix:
+To access another instance of the field, supply the prefix::
 
     >>> alt_proxy = registry.forInterface(IMailSettings,
     ...     prefix="plone.registry.tests.alternativesettings")
@@ -400,17 +393,17 @@ To access another instance of the field, supply the prefix:
 Collections of records proxies
 ------------------------------
 
-A collection of record sets may be accessed using `collectionOfInterface`:
+A collection of record sets may be accessed using ``collectionOfInterface``::
 
     >>> collection = registry.collectionOfInterface(IMailSettings)
 
-You can create a new record set:
+You can create a new record set::
 
     >>> proxy = collection.setdefault('example')
     >>> proxy.sender = u'collection@example.org'
     >>> proxy.smtp_host = 'smtp://mail.example.org'
 
-Record sets are stored based under the prefix:
+Record sets are stored based under the prefix::
 
     >>> prefix = IMailSettings.__identifier__
     >>> registry.records.values(prefix+'/', prefix+'0')
@@ -419,7 +412,7 @@ Record sets are stored based under the prefix:
     >>> registry['plone.registry.tests.IMailSettings/example.sender']
     u'collection@example.org'
 
-Records may be set from an existing object:
+Records may be set from an existing object::
 
     >>> class MailSettings:
     ...     sender = u'someone@example.com'
@@ -431,13 +424,13 @@ Records may be set from an existing object:
      <Record plone.registry.tests.IMailSettings/example_com.sender>,
      <Record plone.registry.tests.IMailSettings/example_com.smtp_host>]
 
-The collection may be iterated over:
+The collection may be iterated over::
 
     >>> for name in collection: print name
     example
     example_com
 
-And may be deleted:
+And may be deleted::
 
     >>> del collection['example_com']
     >>> registry.records.values(prefix+'/', prefix+'0')
@@ -447,12 +440,12 @@ And may be deleted:
 Using field references
 ======================
 
-It is possible for one record to refer to another record's field. This can be
-used to provide a simple "override" mechanism, for example, where one record
-defines the field and a default value, whilst another provides an override
-validated against the same field.
+It is possible for one record to refer to another record's field.
+This can be used to provide a simple "override" mechanism,
+for example, where one record defines the field and a default value,
+whilst another provides an override validated against the same field.
 
-Let us first create the base record and set its value:
+Let us first create the base record and set its value::
 
     >>> timeout_field = field.Int(title=u"Timeout", min=0)
     >>> registry.records['plone.registry.tests.timeout'] = Record(timeout_field, 10)
@@ -461,17 +454,17 @@ Let us first create the base record and set its value:
     >>> timeout_record.value
     10
 
-Next, we create a field reference for this record:
+Next, we create a field reference for this record::
 
     >>> from plone.registry import FieldRef
     >>> timeout_override_field = FieldRef(timeout_record.__name__, timeout_record.field)
 
-We can use this to create a new record:
+We can use this to create a new record::
 
     >>> registry.records['plone.registry.tests.timeout.override'] = Record(timeout_override_field, 20)
     >>> timeout_override_record = registry.records['plone.registry.tests.timeout.override']
 
-The two values are separate:
+The two values are separate::
 
     >>> timeout_record.value
     10
@@ -483,21 +476,21 @@ The two values are separate:
     >>> registry['plone.registry.tests.timeout.override']
     20
 
-Validation uses the underlying field:
+Validation uses the underlying field::
 
     >>> registry['plone.registry.tests.timeout.override'] = -1
     Traceback (most recent call last):
     ...
     TooSmall: (-1, 0)
 
-The reference field exposes the standard field properties, e.g.:
+The reference field exposes the standard field properties, e.g.::
 
     >>> timeout_override_record.field.title
     u'Timeout'
     >>> timeout_override_record.field.min
     0
 
-To look up the underlying record name, we can use the ``recordName`` property:
+To look up the underlying record name, we can use the ``recordName`` property::
 
     >>> timeout_override_record.field.recordName
     'plone.registry.tests.timeout'
diff --git a/plone/registry/tests.py b/plone/registry/tests.py
index 1d786f1..5676dc4 100644
--- a/plone/registry/tests.py
+++ b/plone/registry/tests.py
@@ -1,14 +1,15 @@
-import unittest
-import doctest
-
-from zope.testing import doctestunit
-from zope.component import provideAdapter, testing, eventtesting
-
-from plone.registry.fieldfactory import persistentFieldAdapter
+# -*- coding: utf-8 -*-
 from plone.registry.fieldfactory import choicePersistentFieldAdapter
-
-from zope.interface import Interface
+from plone.registry.fieldfactory import persistentFieldAdapter
 from zope import schema
+from zope.component import eventtesting
+from zope.component import provideAdapter
+from zope.component import testing
+from zope.interface import Interface
+from zope.testing import doctestunit
+import doctest
+import unittest
+
 
 class IMailSettings(Interface):
     """Settings for email
@@ -17,12 +18,20 @@ class IMailSettings(Interface):
     sender = schema.TextLine(title=u"Mail sender", default=u"root@localhost")
     smtp_host = schema.URI(title=u"SMTP host server")
 
+
 class IMailPreferences(Interface):
     """Settings for email
     """
+    max_daily = schema.Int(
+        title=u"Maximum number of emails per day",
+        min=0,
+        default=3
+    )
+    settings = schema.Object(
+        title=u"Mail setings to use",
+        schema=IMailSettings
+    )
 
-    max_daily = schema.Int(title=u"Maximum number of emails per day", min=0, default=3)
-    settings = schema.Object(title=u"Mail setings to use", schema=IMailSettings)
 
 def setUp(test=None):
     testing.setUp()
@@ -31,6 +40,7 @@ def setUp(test=None):
     provideAdapter(persistentFieldAdapter)
     provideAdapter(choicePersistentFieldAdapter)
 
+
 class TestBugs(unittest.TestCase):
     """Regression tests for bugs that have been fixed
     """
@@ -74,6 +84,7 @@ def test_fieldref_interfaces(self):
         self.assertTrue(ICollection.providedBy(ref))
         self.assertTrue(IFieldRef.providedBy(ref))
 
+
 class TestMigration(unittest.TestCase):
 
     def setUp(self):
@@ -117,20 +128,30 @@ def test_auto_migration(self):
         self.assertFalse(isinstance(registry._records, Records))
         self.assertTrue(isinstance(registry._records, _Records))
 
+
 def test_suite():
     return unittest.TestSuite([
         doctestunit.DocFileSuite(
-            'registry.rst', package='plone.registry',
-            optionflags = doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,
-            setUp=setUp, tearDown=testing.tearDown),
+            'registry.rst',
+            package='plone.registry',
+            optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,
+            setUp=setUp,
+            tearDown=testing.tearDown
+        ),
         doctestunit.DocFileSuite(
-            'events.rst', package='plone.registry',
-            optionflags = doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,
-            setUp=setUp, tearDown=testing.tearDown),
+            'events.rst',
+            package='plone.registry',
+            optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,
+            setUp=setUp,
+            tearDown=testing.tearDown
+        ),
         doctestunit.DocFileSuite(
-            'field.rst', package='plone.registry',
-            optionflags = doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,
-            setUp=setUp, tearDown=testing.tearDown),
+            'field.rst',
+            package='plone.registry',
+            optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS,
+            setUp=setUp,
+            tearDown=testing.tearDown
+        ),
         unittest.makeSuite(TestBugs),
         unittest.makeSuite(TestMigration),
-        ])
+    ])
diff --git a/setup.py b/setup.py
index 75f6909..5b7709a 100644
--- a/setup.py
+++ b/setup.py
@@ -1,5 +1,7 @@
+# -*- coding: utf-8 -*-
+from setuptools import find_packages
+from setuptools import setup
 import os
-from setuptools import setup, find_packages
 
 
 def read(*rnames):
@@ -7,7 +9,7 @@ def read(*rnames):
 
 version = '1.0.3.dev0'
 
-
+description = "Registry for application settings (like debconf/ about:config)"
 long_description = (
     read('README.rst')
     + '\n' +
@@ -21,36 +23,36 @@ def read(*rnames):
     + '\n'
     )
 
-setup(name='plone.registry',
-      version=version,
-      description="A debconf-like (or about:config-like) registry for storing application settings",
-      long_description=long_description,
-      # Get more strings from http://www.python.org/pypi?%3Aaction=list_classifiers
-      classifiers=[
+setup(
+    name='plone.registry',
+    version=version,
+    description=description,
+    long_description=long_description,
+    classifiers=[
         "Framework :: Plone",
         "Programming Language :: Python",
         "Topic :: Software Development :: Libraries :: Python Modules",
-        ],
-      keywords='configuration registry',
-      author='Martin Aspeli, Wichert Akkerman, Hanno Schlichting',
-      author_email='plone-developers@lists.sourceforge.net',
-      url='http://pypi.python.org/pypi/plone.registry',
-      license='GPL',
-      packages=find_packages(exclude=['ez_setup']),
-      namespace_packages=['plone'],
-      include_package_data=True,
-      zip_safe=False,
-      install_requires=[
-          'setuptools',
-          'ZODB3',
-          'zope.schema',
-          'zope.interface',
-          'zope.component',
-          'zope.dottedname',
-          'zope.event',
-          'zope.testing',
-      ],
-      entry_points="""
-      # -*- Entry points: -*-
-      """,
-      )
+    ],
+    keywords='configuration registry',
+    author='Martin Aspeli, Wichert Akkerman, Hanno Schlichting',
+    author_email='plone-developers@lists.sourceforge.net',
+    url='http://pypi.python.org/pypi/plone.registry',
+    license='GPL',
+    packages=find_packages(exclude=['ez_setup']),
+    namespace_packages=['plone'],
+    include_package_data=True,
+    zip_safe=False,
+    install_requires=[
+        'setuptools',
+        'ZODB3',
+        'zope.component',
+        'zope.dottedname',
+        'zope.event',
+        'zope.interface',
+        'zope.schema',
+        'zope.testing',
+    ],
+    entry_points="""
+    # -*- Entry points: -*-
+    """,
+)


