Repository: mockup


Branch: refs/heads/master
Date: 2015-09-09T01:30:03+02:00
Author: Johannes Raggam (thet) <raggam-nl@adm.at>
Commit: https://github.com/plone/mockup/commit/68c950b7707d8f436c8e34464e619f1764623987

fix inline-tinymce to work together with textareamimetypeselectorgs

Files changed:
M CHANGES.rst
M mockup/patterns/textareamimetypeselector/pattern.js
M mockup/patterns/tinymce/pattern.js
M mockup/tests/pattern-textareamimetypeselector-test.js

diff --git a/CHANGES.rst b/CHANGES.rst
index 894b042..0e8a653 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -4,7 +4,8 @@ Changelog
 2.0.9 (Unreleased)
 ------------------
 
-- No changes yet.
+- Fix inline TinyMCE to work together with ``pat-textareamimetypeselector``.
+  [thet]
 
 
 2.0.8 (2015-09-08)
@@ -17,8 +18,9 @@ Changelog
   [obct537]
 
 - Add option to use tinyMCE inline on a contenteditable div. The pattern
-  creates the contenteditable div from the textarea, copies it's content to it
-  and handles saving changed data back to the textarea on form submit.
+  creates a contenteditable div from the textarea, copies the textarea's
+  content to it and handles copying changed text back to the textarea on form
+  submit.
   [thet]
 
 
diff --git a/mockup/patterns/textareamimetypeselector/pattern.js b/mockup/patterns/textareamimetypeselector/pattern.js
index 9be19b1..97d0925 100644
--- a/mockup/patterns/textareamimetypeselector/pattern.js
+++ b/mockup/patterns/textareamimetypeselector/pattern.js
@@ -26,8 +26,11 @@
  *
  *   {{ example-1 }}
  *
- * Example: example-1
+ *   # Mimetype selection on textarea with inline TinyMCE editor.
  *
+ *   {{ example-2 }}
+ *
+  * Example: example-1
  *    <textarea name="text">
  *      <h1>hello world</h1>
  *    </textarea>
@@ -54,6 +57,34 @@
  *      <option value="text/plain" selected="selected">text/plain</option>
  *    </select>
  *
+ * Example: example-2
+ *    <textarea name="text2">
+ *      <h1>hello world</h1>
+ *    </textarea>
+ *    <select
+ *        name="text.mimeType"
+ *        class="pat-textareamimetypeselector"
+ *        data-pat-textareamimetypeselector='{
+ *          "textareaName": "text2",
+ *          "widgets": {
+ *            "text/html": {
+ *              "pattern": "tinymce",
+ *              "patternOptions": {
+ *                "tiny": {
+ *                  "plugins": [],
+ *                  "menubar": "edit format tools",
+ *                  "toolbar": " ",
+ *                  "inline": true
+ *                }
+ *              }
+ *            }
+ *          }
+ *        }'
+ *      >
+ *      <option value="text/html">text/html</option>
+ *      <option value="text/plain" selected="selected">text/plain</option>
+ *    </select>
+ *
  */
 
 define([
diff --git a/mockup/patterns/tinymce/pattern.js b/mockup/patterns/tinymce/pattern.js
index 8f10c1d..9dadf7a 100644
--- a/mockup/patterns/tinymce/pattern.js
+++ b/mockup/patterns/tinymce/pattern.js
@@ -345,8 +345,8 @@ define([
       // tiny needs an id in order to initialize. Creat it if not set.
       var id = utils.setId(self.$el);
       var tinyOptions = self.options.tiny;
-      var tinyId = tinyOptions.inline ? id + '-editable' : id;  // when displaying tinyMCE inline, a separate div is created.
-      tinyOptions.selector = '#' + tinyId;
+      self.tinyId = tinyOptions.inline ? id + '-editable' : id;  // when displaying TinyMCE inline, a separate div is created.
+      tinyOptions.selector = '#' + self.tinyId;
       tinyOptions.addLinkClicked = function() {
         self.addLinkClicked.apply(self, []);
       };
@@ -387,14 +387,14 @@ define([
         }
 
         if (tinyOptions.inline === true) {
-          // create a div, which will be made content-editable by tinyMCE and
+          // create a div, which will be made content-editable by TinyMCE and
           // copy contents from textarea to it. Then hide textarea.
-          self.$el.after('<div id="' + tinyId + '">' + self.$el.val() + '</div>');
+          self.$el.after('<div id="' + self.tinyId + '">' + self.$el.val() + '</div>');
           self.$el.hide();
         }
 
         tinymce.init(tinyOptions);
-        self.tiny = tinymce.get(tinyId);
+        self.tiny = tinymce.get(self.tinyId);
 
         /* tiny really should be doing this by default
          * but this fixes overlays not saving data */
@@ -411,7 +411,16 @@ define([
       });
     },
     destroy: function() {
-      this.tiny.destroy();
+      if (this.tiny) {
+        if (this.options.tiny.inline === true) {
+          // destroy also inline editable
+          this.$el.val(this.tiny.getContent());
+          $('#' + this.tinyId).remove();
+          this.$el.show();
+        }
+        this.tiny.destroy();
+        this.tiny = undefined;
+      }
     }
   });
 
diff --git a/mockup/tests/pattern-textareamimetypeselector-test.js b/mockup/tests/pattern-textareamimetypeselector-test.js
index 585da9c..0b92d5f 100644
--- a/mockup/tests/pattern-textareamimetypeselector-test.js
+++ b/mockup/tests/pattern-textareamimetypeselector-test.js
@@ -77,6 +77,71 @@ define([
 
     });
 
+    it('Switching changes widget with inline TinyMCE', function() {
+
+      var dom_structure =
+        '<textarea name="text">hello world</textarea>' +
+        '<select' +
+        '    name="text.mimeType"' +
+        '    class="pat-textareamimetypeselector"' +
+        '    data-pat-textareamimetypeselector=\'{' +
+        '      "textareaName": "text",' +
+        '      "widgets": {' +
+        '        "text/html": {' +
+        '          "pattern": "tinymce",' +
+        '          "patternOptions": {' +
+        '            "tiny": {' +
+        '              "plugins": [],' +
+        '              "menubar": "edit format tools",' +
+        '              "toolbar": " ",' +
+        '              "inline": true' +
+        '            }' +
+        '          }' +
+        '        }' +
+        '      }' +
+        '    }\'' +
+        '  >' +
+        '  <option value="text/html">text/html</option>' +
+        '  <option value="text/plain" selected="selected">text/plain</option>' +
+        '</select>';
+
+      var $doc = $(dom_structure).appendTo('body');
+      registry.scan($doc);
+
+      var $el = $("[name='text.mimeType']");
+      var $textarea = $("[name='text']");
+
+      // Initially, text/plain is selected and textarea should be visible.
+      expect($textarea.is(":visible")).to.be.ok();
+      // But TinyMCE shouldn't be there
+      expect($(".mce-content-body[contenteditable='true']").length).to.be(0);
+      // Value should be at it's initial state
+      expect($textarea.val()).to.be.equal("hello world");
+
+      // change the textarea's value
+      $textarea.val("hello mellow");
+
+      // Now, select text/html
+      $el.val("text/html").change();
+
+      // Textarea should be hidden
+      expect($textarea.is(":hidden")).to.be.ok();
+      // And TinyMCE should be shown
+      expect($(".mce-content-body[contenteditable='true']").is(":visible")).to.be.ok();
+
+      // Switching back to text/plain should destroy TinyMCE
+      $el.val("text/plain").change();
+      expect($textarea.is(":visible")).to.be.ok();
+      expect($(".mce-content-body[contenteditable='true']").length).to.be(0);
+      // Unfortunately, TinyMCE changes the value just by loading TinyMCE.
+      expect($textarea.val()).to.be.equal("<p>hello mellow</p>");
+
+      // switching back to TinyMCE loads it again
+      $el.val("text/html").change();
+      expect($textarea.is(":hidden")).to.be.ok();
+      expect($(".mce-content-body[contenteditable='true']").is(":visible")).to.be.ok();
+
+    });
+
   });
 });
-


